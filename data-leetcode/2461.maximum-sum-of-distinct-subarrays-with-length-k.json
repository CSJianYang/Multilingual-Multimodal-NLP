[
    {
        "title": "Maximum Sum of Distinct Subarrays With Length K",
        "question_content": "You are given an integer array nums and an integer k. Find the maximum subarray sum of all the subarrays of nums that meet the following conditions:\n\n\tThe length of the subarray is k, and\n\tAll the elements of the subarray are distinct.\n\nReturn the maximum subarray sum of all the subarrays that meet the conditions. If no subarray meets the conditions, return 0.\nA subarray is a contiguous non-empty sequence of elements within an array.\n&nbsp;\nExample 1:\n\nInput: nums = [1,5,4,2,9,9,9], k = 3\nOutput: 15\nExplanation: The subarrays of nums with length 3 are:\n- [1,5,4] which meets the requirements and has a sum of 10.\n- [5,4,2] which meets the requirements and has a sum of 11.\n- [4,2,9] which meets the requirements and has a sum of 15.\n- [2,9,9] which does not meet the requirements because the element 9 is repeated.\n- [9,9,9] which does not meet the requirements because the element 9 is repeated.\nWe return 15 because it is the maximum subarray sum of all the subarrays that meet the conditions\n\nExample 2:\n\nInput: nums = [4,4,4], k = 3\nOutput: 0\nExplanation: The subarrays of nums with length 3 are:\n- [4,4,4] which does not meet the requirements because the element 4 is repeated.\nWe return 0 because no subarrays meet the conditions.\n\n&nbsp;\nConstraints:\n\n\t1 <= k <= nums.length <= 105\n\t1 <= nums[i] <= 105",
        "solutions": [
            {
                "id": 2783127,
                "title": "c-solution-using-map-very-simple-and-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n\\n/*\\nApproach is to store the elements in a map and using sliding window technique\\ncheck if the size of map is equal to k on each window. The window which has map size equal to k\\nis having distict elements.\\n\\n1. Store first k elements in the map.\\n2. Then keep traversing through the array and adding the new one to the map and \\nremoving the old one(i-k th) element form the map if its count is zero.\\n3. Do same for the total sum, add ith value and remove i-k th value.\\n4. Maximize ans by taking max sum value. \\n*/\\n\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        int i = 0;\\n        while(i < k  && i < nums.size()){ // store first k elements in the map\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n            i++;\\n        }\\n        if(mp.size() == k) ans = sum; // if all distinct, then ans = sum \\n        while(i < nums.size()){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]] == 0) mp.erase(nums[i-k]);\\n            \\n            sum += nums[i];\\n            sum -= nums[i-k];\\n            if(mp.size() == k) ans = max(ans, sum);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n/*\\nApproach is to store the elements in a map and using sliding window technique\\ncheck if the size of map is equal to k on each window. The window which has map size equal to k\\nis having distict elements.\\n\\n1. Store first k elements in the map.\\n2. Then keep traversing through the array and adding the new one to the map and \\nremoving the old one(i-k th) element form the map if its count is zero.\\n3. Do same for the total sum, add ith value and remove i-k th value.\\n4. Maximize ans by taking max sum value. \\n*/\\n\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        int i = 0;\\n        while(i < k  && i < nums.size()){ // store first k elements in the map\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n            i++;\\n        }\\n        if(mp.size() == k) ans = sum; // if all distinct, then ans = sum \\n        while(i < nums.size()){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]] == 0) mp.erase(nums[i-k]);\\n            \\n            sum += nums[i];\\n            sum -= nums[i-k];\\n            if(mp.size() == k) ans = max(ans, sum);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783077,
                "title": "python-c-java-rust-running-sum-keep-track-of-positions-and-duplicates-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs linear scan to keep track of positions of duplicate numbers, while computing running sum. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Python.**\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        res, cur, pos, dup = 0, 0, [-1] * 100001, -1\\n        \\n        for i in range(0,len(nums)):\\n            cur += nums[i]                      # compute running sum for\\n            if i >= k: cur -= nums[i-k]         # the window of length k\\n            \\n            dup = max(dup, pos[nums[i]])        # update LAST seen duplicate\\n            \\n            if i - dup >= k:                    # if no duplicates were found\\n                res = max(res, cur)             # update max window sum\\n\\n            pos[nums[i]] = i\\n\\n        return res\\n```\\n\\nThis solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/JMiDaCHT/shared\" frameBorder=\"0\" width=\"800\" height=\"430\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        res, cur, pos, dup = 0, 0, [-1] * 100001, -1\\n        \\n        for i in range(0,len(nums)):\\n            cur += nums[i]                      # compute running sum for\\n            if i >= k: cur -= nums[i-k]         # the window of length k\\n            \\n            dup = max(dup, pos[nums[i]])        # update LAST seen duplicate\\n            \\n            if i - dup >= k:                    # if no duplicates were found\\n                res = max(res, cur)             # update max window sum\\n\\n            pos[nums[i]] = i\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783175,
                "title": "sliding-window-using-hashmap-c-java",
                "content": "- Just Slide the window and for duplicates we will use hashmap instead of a hashset.\\n- We will discard any element if its count becomes zero in a window.\\n\\n# Why we use a hashmap instead of hashset??\\nWhen we encounter a subarray of size k, having all duplicate elements, then if we simply discard it from set, that single will be removed and our set size will become zero and we will loose access to all previous elements.\\n\\nSo for that we will use a hashmap and while moving forward we will remove a key only if its count becomes 0, else we will keep moving by decreasing that element count in hashmap.\\n\\n**Time** - O(N)\\n**Space** - O(N)\\n# C++   \\n    long long maximumSubarraySum(vector<int>& A, int k) {\\n        unordered_map<int, int> mp;\\n        long mx = 0, sum = 0;\\n        for (int i = 0; i < size(A); i++){\\n            sum += A[i];\\n            mp[A[i]]++;\\n\\n            if (i >= k - 1){\\n                if (mp.size() == k) mx = max(mx, sum);\\n                sum -= A[i - k + 1];\\n                if (--mp[A[i - k + 1]] == 0) mp.erase(A[i - k + 1]);\\n            }\\n        }\\n        return mx;\\n    }\\n\\n# Java\\n    public long maximumSubarraySum(int[] A, int k) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        long mx = 0, sum = 0;\\n        for (int i = 0; i < A.length; i++){\\n            sum +=A[i];\\n            mp.put(A[i], mp.getOrDefault(A[i],0) + 1);\\n\\n            if (i >= k - 1){\\n                if (mp.size() == k) mx = Math.max(mx, sum);\\n                sum -= A[i - k + 1];\\n                mp.put(A[i - k + 1], mp.get(A[i - k + 1]) - 1);\\n                if (mp.get(A[i - k + 1]) == 0) mp.remove(A[i - k + 1]);\\n            }\\n        }\\n        return mx;\\n    }",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "- Just Slide the window and for duplicates we will use hashmap instead of a hashset.\\n- We will discard any element if its count becomes zero in a window.\\n\\n# Why we use a hashmap instead of hashset??\\nWhen we encounter a subarray of size k, having all duplicate elements, then if we simply discard it from set, that single will be removed and our set size will become zero and we will loose access to all previous elements.\\n\\nSo for that we will use a hashmap and while moving forward we will remove a key only if its count becomes 0, else we will keep moving by decreasing that element count in hashmap.\\n\\n**Time** - O(N)\\n**Space** - O(N)\\n# C++   \\n    long long maximumSubarraySum(vector<int>& A, int k) {\\n        unordered_map<int, int> mp;\\n        long mx = 0, sum = 0;\\n        for (int i = 0; i < size(A); i++){\\n            sum += A[i];\\n            mp[A[i]]++;\\n\\n            if (i >= k - 1){\\n                if (mp.size() == k) mx = max(mx, sum);\\n                sum -= A[i - k + 1];\\n                if (--mp[A[i - k + 1]] == 0) mp.erase(A[i - k + 1]);\\n            }\\n        }\\n        return mx;\\n    }\\n\\n# Java\\n    public long maximumSubarraySum(int[] A, int k) {\\n        HashMap<Integer, Integer> mp = new HashMap<>();\\n        long mx = 0, sum = 0;\\n        for (int i = 0; i < A.length; i++){\\n            sum +=A[i];\\n            mp.put(A[i], mp.getOrDefault(A[i],0) + 1);\\n\\n            if (i >= k - 1){\\n                if (mp.size() == k) mx = Math.max(mx, sum);\\n                sum -= A[i - k + 1];\\n                mp.put(A[i - k + 1], mp.get(A[i - k + 1]) - 1);\\n                if (mp.get(A[i - k + 1]) == 0) mp.remove(A[i - k + 1]);\\n            }\\n        }\\n        return mx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2783796,
                "title": "c-carry-forward-dictionary-sliding-window-detailed-explanation-set-vs-map",
                "content": "Upvote if it helps.\\n\\n**Intuition**\\nIn the question sub array of specific window is already specified\\n\\n**Condition:**\\n* SubArray should be of Window Size K.\\n* Each element in the sub-array should be unique.\\n\\n**O/P:** We have to return the max sum of only that sub-array in which all the elements are distinct.\\n\\n**Question is how we can know if the elements are distinct:**\\n\\n**There are two ways to check if there is repitition -**\\n* \\tSet (HashSet) - Does not work here.\\n* \\tMap(HashMap/Dictionary).\\n\\n**Why Set can\\'t be used:**\\n\\nWe can not use HashSet here as in the array there might be a sub-array in which the elements are repeating.\\n\\nLet\\'s see why?\\n\\nSuppose arr[] = [4,4,5,2,9,9,9] and k = 3\\n\\nBelow is all the sub-arrays of window size k:\\n\\n[4,4,5] -> Sum = 13 ***(Answer will be discaded as 4 is repeating)***\\nWhen we will move from above window size to below window size we have to remove the first element from above sub-array and from the sum.\\nBut if we\\'ve used Set here this will fail as removing the 1st occurence of 4 we will also remove its next occurence from the set.\\nDue to which Map(HashMap/Dictionary) will be used here.\\n[4,5,2] -> Sum = 11\\n[5,2,9] -> Sum = 16 \\n[2,9,9] -> Sum = 20 ***(Answer will be discaded as 9 is repeating)***\\n[9,9,9] -> Sum = 27 ***(Answer will be discaded as 9 is repeating)***\\n\\n**What Map will do for us:**\\n\\nSuppose arr[] = [4,4,5,2,9,9,9] and k = 3\\n\\nBelow is all the sub-arrays of window size k:\\n\\n[4,4,5] -> Sum = 13 ***(Answer will be discaded as 4 is repeating)***\\nWhen we will move from above window size to below window size we have to remove the first element from above sub-array and from the sum.\\nNow we can easily reduce the frequency of 4.\\n[4,5,2] -> Sum = 11\\n[5,2,9] -> Sum = 16 \\n[2,9,9] -> Sum = 20 ***(Answer will be discaded as 9 is repeating)***\\n[9,9,9] -> Sum = 27 ***(Answer will be discaded as 9 is repeating)***\\n\\n```\\npublic class Solution {\\n    public long MaximumSubarraySum(int[] A, int k) {\\n        var map = new Dictionary<int,int>(); /* Map/HashMap/Dictionary */\\n        int len = A.Count();\\n        long sum = 0, ans = 0;\\n        int i = 0, j = 0;\\n        /* Sliding Window */\\n        while(j < len)\\n        {\\n          sum += A[j];\\n\\t\\t  /* Add the element in map with frequency 1, If map doesn\\'t already contains the element  */\\n          if(!map.ContainsKey( A[j] ))\\n            map.Add(A[j], 1);\\n\\t\\t  /* If element already exists increase the frequency */\\n          else\\n            map[A[j]]++;\\n\\t\\t  /* Only update the answer if size of map == k  with all distinct element*/\\n          if(map.Count == k)\\n          {\\n            ans = Math.Max(sum, ans);\\n          }\\n          if(j - i + 1 == k)\\n          {\\n            sum -= A[i]; // Subtract the previous value from the sum as we\\'re changing the window.\\n            map[A[i]]--; // Also reduce the frequency of the previous element.\\n            if(map[A[i]] == 0) map.Remove(A[i]); // If frequency of the previous element is 0 remove the key from map\\n            i++;\\n          }\\n          j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\npublic class Solution {\\n    public long MaximumSubarraySum(int[] A, int k) {\\n        var map = new Dictionary<int,int>(); /* Map/HashMap/Dictionary */\\n        int len = A.Count();\\n        long sum = 0, ans = 0;\\n        int i = 0, j = 0;\\n        /* Sliding Window */\\n        while(j < len)\\n        {\\n          sum += A[j];\\n\\t\\t  /* Add the element in map with frequency 1, If map doesn\\'t already contains the element  */\\n          if(!map.ContainsKey( A[j] ))\\n            map.Add(A[j], 1);\\n\\t\\t  /* If element already exists increase the frequency */\\n          else\\n            map[A[j]]++;\\n\\t\\t  /* Only update the answer if size of map == k  with all distinct element*/\\n          if(map.Count == k)\\n          {\\n            ans = Math.Max(sum, ans);\\n          }\\n          if(j - i + 1 == k)\\n          {\\n            sum -= A[i]; // Subtract the previous value from the sum as we\\'re changing the window.\\n            map[A[i]]--; // Also reduce the frequency of the previous element.\\n            if(map[A[i]] == 0) map.Remove(A[i]); // If frequency of the previous element is 0 remove the key from map\\n            i++;\\n          }\\n          j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783082,
                "title": "short-concise-fixed-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int ,int> m;\\n        long long ans = 0, s = 0, i = 0;\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            m[nums[j]]++;\\n            s += nums[j];\\n            if(k == j - i + 1) {\\n                if(m.size() == k) ans = max(ans, s);\\n                s -= nums[i];\\n                m[nums[i]]--;\\n                if(!m[nums[i]]) m.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int ,int> m;\\n        long long ans = 0, s = 0, i = 0;\\n        \\n        for(int j=0; j<nums.size(); j++) {\\n            m[nums[j]]++;\\n            s += nums[j];\\n            if(k == j - i + 1) {\\n                if(m.size() == k) ans = max(ans, s);\\n                s -= nums[i];\\n                m[nums[i]]--;\\n                if(!m[nums[i]]) m.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783231,
                "title": "c-java-sliding-window-using-hashmap-neat-code",
                "content": "The idea is simple we maintain a hashtable\\nthe idea of hashtable is to see if the current element is a duplicate or not\\nIf it is present we keep removing elements from the start of window else we include it in window\\nif the size of sub array becomes k then we update the max value\\n\\n<hr>\\n\\n##### Solution \\n\\n```c++\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0 , sum = 0;\\n        unordered_set<int> ht;\\n        int n = nums.size();\\n        int j = 0 , i = 0;\\n        while(i < n - k + 1){\\n            if(j - i  == k){\\n                ans = max(ans, sum);\\n                sum -= nums[i];\\n                ht.erase(nums[i++]);\\n            }\\n            else if (ht.find(nums[j]) == ht.end()){\\n                sum += nums[j];\\n                ht.insert(nums[j++]);\\n            }else{\\n                sum -= nums[i];\\n                ht.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n<hr>\\nJava Solution \\n\\n```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLong sum = 0l, max = 0l;\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\twhile (end < n) {\\n\\t\\t\\tint val = nums[end];\\n\\t\\t\\twhile (set.contains(val) || (end - start + 1 > k) && start < end) {\\n\\t\\t\\t\\tsum -= nums[start];\\n\\t\\t\\t\\tset.remove(nums[start++]);\\n\\t\\t\\t}\\n\\t\\t\\tsum += val;\\n\\t\\t\\tset.add(val);\\n\\t\\t\\tif (end - start + 1 == k)\\n\\t\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```\\n##### time complexity O(n) space complexity O(n)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0 , sum = 0;\\n        unordered_set<int> ht;\\n        int n = nums.size();\\n        int j = 0 , i = 0;\\n        while(i < n - k + 1){\\n            if(j - i  == k){\\n                ans = max(ans, sum);\\n                sum -= nums[i];\\n                ht.erase(nums[i++]);\\n            }\\n            else if (ht.find(nums[j]) == ht.end()){\\n                sum += nums[j];\\n                ht.insert(nums[j++]);\\n            }else{\\n                sum -= nums[i];\\n                ht.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n\\t\\tint start = 0, end = 0;\\n\\t\\tLong sum = 0l, max = 0l;\\n\\t\\tSet<Integer> set = new HashSet<>();\\n\\t\\twhile (end < n) {\\n\\t\\t\\tint val = nums[end];\\n\\t\\t\\twhile (set.contains(val) || (end - start + 1 > k) && start < end) {\\n\\t\\t\\t\\tsum -= nums[start];\\n\\t\\t\\t\\tset.remove(nums[start++]);\\n\\t\\t\\t}\\n\\t\\t\\tsum += val;\\n\\t\\t\\tset.add(val);\\n\\t\\t\\tif (end - start + 1 == k)\\n\\t\\t\\t\\tmax = Math.max(max, sum);\\n\\t\\t\\tend++;\\n\\t\\t}\\n\\t\\treturn max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783141,
                "title": "line-by-line-commented-sliding-window-o-n",
                "content": "**INTUITION**\\n**1. Keep storing the frequency of elements in a map.\\n2. If both the window size and the map size are K, that means window has K unique elements, so store the sum. \\n3.  Slide the window to the right to check for all windows.\\n4.  To do this, remove calculations of left pointer of window, and increase by 1.**\\n\\n\\n##### [WRONG] Solution 1 : Using HashSet \\n*This solution will not work for [1, 3, 1, 4, 2]\\nThanks to [@uilnauyisDP](https://leetcode.com/uilnauyis_DP/) for pointing out the mistake.*\\n\\n```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] arr, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint i = 0, j = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tlong maxSum = 0;\\n\\t\\t\\n\\t\\twhile (j < arr.length) {\\n\\t\\t\\tif (!set.contains(arr[j])) {               // no duplicate element in window\\n                set.add(arr[j]);                       // add it to set\\n                sum += arr[j];                         // add to local sum\\n                if (j-i+1 == k) {                      // if window length == K\\n\\t\\t\\t\\t\\tmaxSum = Math.max(maxSum, sum);                // take the max sum\\n\\t\\t\\t\\t\\tsum -= arr[i];                                 // remove calculation of arr[i]\\n\\t\\t\\t\\t\\tset.remove(arr[i]);                            // remove arr[i] from set\\n\\t\\t\\t\\t\\ti++;                                           // shift the window to the right \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {                                                 // duplicate element encountered in window, reset everything\\n\\t\\t\\t\\ti = j;                                             // start window from j\\n\\t\\t\\t\\tsum = arr[i];                                      // add first element to window\\n\\t\\t\\t\\tset = new HashSet<>();                             // create a new set or clear the previous one\\n\\t\\t\\t\\tset.add(arr[j]);                                   // add current element to set\\n\\t\\t\\t}\\n\\t\\t\\tj++;                                                   // expand the window\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxSum;\\n    }\\n}\\n```\\n\\n\\n##### [CORRECT] Solution 2: Using HashMap\\n```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\t\\tint i = 0, j = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tlong maxSum = 0;\\n\\n\\t\\twhile (j < arr.length) {\\n\\t\\t\\tmap.put(arr[j], map.getOrDefault(arr[j], 0) + 1);          // add it to map\\n\\t\\t\\tsum += arr[j];                                             // add to local sum\\n\\t\\t\\tif (j - i + 1 == k) {                                      // if window length == K\\n\\t\\t\\t\\tif (map.size() == k) {                                 // if size of map is k, that means there are k unique elements\\n\\t\\t\\t\\t\\tmaxSum = Math.max(maxSum, sum);                    // take the max sum\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsum -= arr[i];                                         // remove calculation of arr[i]\\n\\t\\t\\t\\tmap.put(arr[i], map.get(arr[i])-1);                    // remove arr[i] from map. If arr[i] is duplicate in window, decrease the freq by 1\\n\\t\\t\\t\\tif (map.get(arr[i]) == 0) map.remove(arr[i]);\\n\\t\\t\\t\\ti++;                                                   // shift the window to the right\\n\\t\\t\\t}\\n\\t\\t\\tj++;                                                       // expand the window\\n\\t\\t}\\n\\n\\t\\treturn maxSum;\\n    }\\n}\\n```\\n\\n***Time complexity : O(N)\\nSpace Complexity : O(N)***",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] arr, int k) {\\n        HashSet<Integer> set = new HashSet<>();\\n\\t\\tint i = 0, j = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tlong maxSum = 0;\\n\\t\\t\\n\\t\\twhile (j < arr.length) {\\n\\t\\t\\tif (!set.contains(arr[j])) {               // no duplicate element in window\\n                set.add(arr[j]);                       // add it to set\\n                sum += arr[j];                         // add to local sum\\n                if (j-i+1 == k) {                      // if window length == K\\n\\t\\t\\t\\t\\tmaxSum = Math.max(maxSum, sum);                // take the max sum\\n\\t\\t\\t\\t\\tsum -= arr[i];                                 // remove calculation of arr[i]\\n\\t\\t\\t\\t\\tset.remove(arr[i]);                            // remove arr[i] from set\\n\\t\\t\\t\\t\\ti++;                                           // shift the window to the right \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\telse {                                                 // duplicate element encountered in window, reset everything\\n\\t\\t\\t\\ti = j;                                             // start window from j\\n\\t\\t\\t\\tsum = arr[i];                                      // add first element to window\\n\\t\\t\\t\\tset = new HashSet<>();                             // create a new set or clear the previous one\\n\\t\\t\\t\\tset.add(arr[j]);                                   // add current element to set\\n\\t\\t\\t}\\n\\t\\t\\tj++;                                                   // expand the window\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn maxSum;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public long maximumSubarraySum(int[] arr, int k) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\t\\tint i = 0, j = 0;\\n\\t\\tlong sum = 0;\\n\\t\\tlong maxSum = 0;\\n\\n\\t\\twhile (j < arr.length) {\\n\\t\\t\\tmap.put(arr[j], map.getOrDefault(arr[j], 0) + 1);          // add it to map\\n\\t\\t\\tsum += arr[j];                                             // add to local sum\\n\\t\\t\\tif (j - i + 1 == k) {                                      // if window length == K\\n\\t\\t\\t\\tif (map.size() == k) {                                 // if size of map is k, that means there are k unique elements\\n\\t\\t\\t\\t\\tmaxSum = Math.max(maxSum, sum);                    // take the max sum\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsum -= arr[i];                                         // remove calculation of arr[i]\\n\\t\\t\\t\\tmap.put(arr[i], map.get(arr[i])-1);                    // remove arr[i] from map. If arr[i] is duplicate in window, decrease the freq by 1\\n\\t\\t\\t\\tif (map.get(arr[i]) == 0) map.remove(arr[i]);\\n\\t\\t\\t\\ti++;                                                   // shift the window to the right\\n\\t\\t\\t}\\n\\t\\t\\tj++;                                                       // expand the window\\n\\t\\t}\\n\\n\\t\\treturn maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145738,
                "title": "sliding-window-technique-and-hashmap-c",
                "content": "# Intuition\\nTo solve this problem, we need to have knowledge about unordered map and counting frequency of elements and sliding window.\\n\\n# Approach\\nThe step by step approach is:\\n1. Firstly we need to traverse the vector k times and count the frequency of each element ans store them in `unordered map` and along with them also calculate the sum.\\n2. Check the condition if unordered map size is ``equal to k``or not. If it is equal then update the `result`with sum.\\n3. Now traverse the vector starting from k upto the size of vector and update the sum by adding `nums[i]` and subtract `nums[i-k]` from sum. Along with them, also increase the frequency of `nums[i]` in map and decrease the frequency of `nums[i-k]`.\\n4. Now after subtracting the frequency of `nums[i-k]` becomes zero then `erase` that particular number  from map.\\n5. compare if the ``size of map`` is equal to `k` then update the result with maximum of sum and `result`. finally return the `result`. \\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where n is  the size of vector.\\n\\n- Space complexity:\\n$$O(k)$$ where k is the length of the subarrays. \\n\\n\\n**Please upvote this solution.**\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long sum=0;\\n        long long res=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            sum+=nums[i];\\n            m[nums[i]]++; // counting the frequency of each first k elements\\n        }\\n        if(m.size()==k)\\n            res=sum;\\n        for(int i=k; i<nums.size(); i++)\\n        {\\n// sliding the window one by one and updating the sum accordingly\\n            sum+=nums[i]; \\n            sum-=nums[i-k];\\n            m[nums[i]]++;\\n            m[nums[i-k]]--;\\n// if frequency of elements becomes zero, remove the elements from map\\n            if(m[nums[i-k]]==0)\\n                m.erase(nums[i-k]);\\n// update the result with maximum of result and sum only when map size is equal to length of subarrays\\n            if(m.size()==k)\\n                res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long sum=0;\\n        long long res=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            sum+=nums[i];\\n            m[nums[i]]++; // counting the frequency of each first k elements\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2783276,
                "title": "o-n-solution-easy-memorize-last-appearing-element-prefix-sum-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrefix sum & unique elements subarray\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(2*n)   \\n# Code\\n```\\nlong long sum[100005];\\nint last[100005];\\n\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        memset(last, -1 , sizeof(last));\\n        \\n        int left=-1;\\n        long long mx=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int len ;\\n            left = max(left, last[nums[i]]); /// updating left index because unique element we need\\n          \\n            last[nums[i]]=i; /// storing lastest index of this element\\n            len = i - left;  /// max unique elements subarray length\\n            sum[i+1] = sum[i]+nums[i]; /// prefix sum\\n            if(len >= k) mx = max(mx , sum[i+1]-sum[i+1-k]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nlong long sum[100005];\\nint last[100005];\\n\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        memset(last, -1 , sizeof(last));\\n        \\n        int left=-1;\\n        long long mx=0;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            int len ;\\n            left = max(left, last[nums[i]]); /// updating left index because unique element we need\\n          \\n            last[nums[i]]=i; /// storing lastest index of this element\\n            len = i - left;  /// max unique elements subarray length\\n            sum[i+1] = sum[i]+nums[i]; /// prefix sum\\n            if(len >= k) mx = max(mx , sum[i+1]-sum[i+1-k]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783099,
                "title": "map-sliding-window-w-dry-run",
                "content": "**Upvotes are appreciated!!**\\n\\n**Dry-run:**\\nPlease take my apology for the bad handwriting.\\n\\n![image](https://assets.leetcode.com/users/images/c5cdf468-5c17-4328-a4a0-6a602b7647e2_1667709193.9824271.jpeg)\\n\\nTherefore, max out of all of them is `15`.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, max = 0;\\n        int n  = nums.length;\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n            sum += nums[i];\\n\\t\\t\\t\\n            if(i>=k){\\n                map.put(nums[i-k],map.get(nums[i-k]) - 1);\\n                sum -= nums[i-k];\\n                \\n                if(map.get(nums[i-k]) == 0)\\n                    map.remove(nums[i-k]);\\n            }\\n\\t\\t\\t\\n            if(map.size() == k)\\n                max = Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```\\n\\n\\nI hope you got the idea. Just in case, there are still some doubts left in your mind, feel free to ask them in comments, Peace.",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, max = 0;\\n        int n  = nums.length;\\n        \\n        Map<Integer,Integer> map = new HashMap();\\n        if(n == 1)\\n            return nums[0];\\n        \\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n            sum += nums[i];\\n\\t\\t\\t\\n            if(i>=k){\\n                map.put(nums[i-k],map.get(nums[i-k]) - 1);\\n                sum -= nums[i-k];\\n                \\n                if(map.get(nums[i-k]) == 0)\\n                    map.remove(nums[i-k]);\\n            }\\n\\t\\t\\t\\n            if(map.size() == k)\\n                max = Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3398049,
                "title": "sliding-window-hashing-easy-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        map<int,int> mp;\\n        int i=0,j=0;\\n\\n        // this will store the answer.\\n        long long mx=0;\\n        long long sum=0;\\n\\n        while(j<nums.size())\\n        {\\n            // insert it into the map.\\n            mp[nums[j]]++;\\n            sum+=nums[j];\\n\\n\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k)\\n            {\\n                // if size of window is matched and all elements are different.\\n                if(mp.size()==k) \\n                {\\n                    mx=max(mx,sum);\\n                }\\n\\n                // remove the count of nums[i]\\n                mp[nums[i]]--;\\n\\n                // if count becomes zero, then remove it from map.\\n                if(mp[nums[i]]==0) mp.erase(nums[i]);\\n                sum-=nums[i];\\n\\n                // to slide the window.\\n                i++,j++;\\n            }\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        map<int,int> mp;\\n        int i=0,j=0;\\n\\n        // this will store the answer.\\n        long long mx=0;\\n        long long sum=0;\\n\\n        while(j<nums.size())\\n        {\\n            // insert it into the map.\\n            mp[nums[j]]++;\\n            sum+=nums[j];\\n\\n\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k)\\n            {\\n                // if size of window is matched and all elements are different.\\n                if(mp.size()==k) \\n                {\\n                    mx=max(mx,sum);\\n                }\\n\\n                // remove the count of nums[i]\\n                mp[nums[i]]--;\\n\\n                // if count becomes zero, then remove it from map.\\n                if(mp[nums[i]]==0) mp.erase(nums[i]);\\n                sum-=nums[i];\\n\\n                // to slide the window.\\n                i++,j++;\\n            }\\n        }\\n        return mx;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783646,
                "title": "python-easy-solution-using-libraries",
                "content": "**Kindly upvote it if you Like it\\uD83D\\uDE07!**\\n**Thank You\\uD83D\\uDE0A!!!**\\n\\n\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        seen = collections.Counter(nums[:k]) #from collections import Counter (elements and their respective count are stored as a dictionary)\\n        summ = sum(nums[:k])\\n        \\n        \\n        res = 0\\n        if len(seen) == k:\\n            res = summ\\n            \\n            \\n        for i in range(k, len(nums)):\\n            summ += nums[i] - nums[i-k]\\n            seen[nums[i]] += 1\\n            seen[nums[i-k]] -= 1\\n            \\n            if seen[nums[i-k]] == 0:\\n                del seen[nums[i-k]]\\n                \\n            if len(seen) == k:\\n                res = max(res, summ) \\n                \\n        return res\\n                \\n        \\n```\\n\\n\\n*Python makes life easier due to it\\'s super cool extensive support libraries* \\u2764\\uFE0F\\uD83D\\uDC96 *but at the same time it\\'s very time consuming language(if you haven\\'t mastered in it\\'s data structures and libraries) and also it has a low execution speed* \\uD83D\\uDE15",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        seen = collections.Counter(nums[:k]) #from collections import Counter (elements and their respective count are stored as a dictionary)\\n        summ = sum(nums[:k])\\n        \\n        \\n        res = 0\\n        if len(seen) == k:\\n            res = summ\\n            \\n            \\n        for i in range(k, len(nums)):\\n            summ += nums[i] - nums[i-k]\\n            seen[nums[i]] += 1\\n            seen[nums[i-k]] -= 1\\n            \\n            if seen[nums[i-k]] == 0:\\n                del seen[nums[i-k]]\\n                \\n            if len(seen) == k:\\n                res = max(res, summ) \\n                \\n        return res\\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783132,
                "title": "sliding-window-o-n-c",
                "content": "<h5>Main Idea</h5>\\nFor every subarray of size \\'k\\' we need to keep track of the sum and number of distinct element of the subarray. We can maintain the sum using a variable. To maintain the number of distinct element you can use a hashmap or an array to count number of occurance and update the number of distinct element as necessary(See code for better understanding). We update our answer with the maximum sum whenever number of distinct element is equal to k.<br><br>\\n<b>Time Complexity: O(n) </b><br><br>\\n<h5>Sample Code</h5>\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& a, int k) {\\n        long long ans = 0;\\n        int n = a.size();\\n        int distinct = 0;\\n        int occurance[100005]={};\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=1ll*a[i];\\n            occurance[a[i]]++;\\n            if(occurance[a[i]]==1)distinct++;\\n            else if(occurance[a[i]]==2)distinct--;\\n            if(i>k-1){\\n                sum-=1ll*a[i-k];\\n                occurance[a[i-k]]--;\\n                if(occurance[a[i-k]]==0)distinct--;\\n                if(occurance[a[i-k]]==1)distinct++;\\n            }  \\n            if(distinct==k){\\n                    ans = max(ans,sum);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>P.S</b> Please upvote if you find the solution useful.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& a, int k) {\\n        long long ans = 0;\\n        int n = a.size();\\n        int distinct = 0;\\n        int occurance[100005]={};\\n        long long sum = 0;\\n        for(int i=0;i<n;i++){\\n            sum+=1ll*a[i];\\n            occurance[a[i]]++;\\n            if(occurance[a[i]]==1)distinct++;\\n            else if(occurance[a[i]]==2)distinct--;\\n            if(i>k-1){\\n                sum-=1ll*a[i-k];\\n                occurance[a[i-k]]--;\\n                if(occurance[a[i-k]]==0)distinct--;\\n                if(occurance[a[i-k]]==1)distinct++;\\n            }  \\n            if(distinct==k){\\n                    ans = max(ans,sum);\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792908,
                "title": "java-easy-solution-using-hashmap-faster-than-95-simple-and-easy-with-comments",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k){\\n        long maxSum = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0 , i = 0;\\n        long currSum = 0;\\n        \\n        while( j < nums.length){\\n            map.put(nums[j] , map.getOrDefault(nums[j], 0) + 1); //putting element to map\\n            currSum += nums[j];         //updating currsum\\n            if(j - i + 1 == k){         //Checking in every 3 pairs\\n                if(map.size() == k){\\n                    maxSum = Math.max(currSum , maxSum);        //updating maxsum\\n                }\\n                currSum -= nums[i];         //deducting first element of the triplet as we move forward\\n                map.put(nums[i], map.get(nums[i])-1);                  \\n\\t\\t\\t\\tif (map.get(nums[i]) == 0) map.remove(nums[i]);  //updating map\\n\\t\\t\\t\\ti++;\\n            }\\n            j++;\\n        }\\n        \\n        \\n        return maxSum;\\n    }\\n}\\n```\\n**Upvote please**",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k){\\n        long maxSum = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int j = 0 , i = 0;\\n        long currSum = 0;\\n        \\n        while( j < nums.length){\\n            map.put(nums[j] , map.getOrDefault(nums[j], 0) + 1); //putting element to map\\n            currSum += nums[j];         //updating currsum\\n            if(j - i + 1 == k){         //Checking in every 3 pairs\\n                if(map.size() == k){\\n                    maxSum = Math.max(currSum , maxSum);        //updating maxsum\\n                }\\n                currSum -= nums[i];         //deducting first element of the triplet as we move forward\\n                map.put(nums[i], map.get(nums[i])-1);                  \\n\\t\\t\\t\\tif (map.get(nums[i]) == 0) map.remove(nums[i]);  //updating map\\n\\t\\t\\t\\ti++;\\n            }\\n            j++;\\n        }\\n        \\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783269,
                "title": "sliding-window-map-solution-with-intuition-and-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever we need to find something in subarray of size k, we think of sliding window as one of the approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe maintain a window size of k and keep track of distinct elements in map and for every window size we update maximum sum if all number is distinct in that subarray of size k.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        long long sum=0, mxm=0;\\n        \\n        for(int i=0;i<k;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n        \\n        if(mp.size()==k)\\n            mxm=max(mxm,sum);\\n        \\n        for(int i=k;i<n;i++){  \\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0)\\n                mp.erase(nums[i-k]);\\n            sum-=nums[i-k];\\n            \\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n            \\n            if(mp.size()==k){\\n                mxm=max(mxm,sum);\\n            }\\n        }\\n        \\n        return mxm;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        unordered_map<int,int> mp;\\n        \\n        long long sum=0, mxm=0;\\n        \\n        for(int i=0;i<k;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n        \\n        if(mp.size()==k)\\n            mxm=max(mxm,sum);\\n        \\n        for(int i=k;i<n;i++){  \\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0)\\n                mp.erase(nums[i-k]);\\n            sum-=nums[i-k];\\n            \\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n            \\n            if(mp.size()==k){\\n                mxm=max(mxm,sum);\\n            }\\n        }\\n        \\n        return mxm;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783180,
                "title": "sliding-window-c-easy-understanding-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        //for checking distinct element\\n        unordered_map<int, int> mp;\\n        \\n        int i=0, j=0;\\n        int n = nums.size();\\n        unsigned long long int ans = 0;\\n        unsigned long long int sum = 0;\\n        \\n        //sliding window\\n        while(j<n){\\n            //Till we hit the window size K\\n            if(j-i+1 < k){\\n                mp[nums[j]]++;\\n                sum+=nums[j];\\n                j++;\\n            }else if(j-i+1 == k){\\n                mp[nums[j]]++;\\n                sum+=nums[j];\\n                //checking if K distinct elements are present\\n                if(mp.size()==k){\\n                    if(ans<sum){\\n                        ans=sum;\\n                    }\\n                }\\n                //removing the element thats is no longer in the window\\n                if(mp[nums[i]] > 1){\\n                    mp[nums[i]]--;\\n                }else{\\n                    mp.erase(nums[i]);\\n                }\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        //for checking distinct element\\n        unordered_map<int, int> mp;\\n        \\n        int i=0, j=0;\\n        int n = nums.size();\\n        unsigned long long int ans = 0;\\n        unsigned long long int sum = 0;\\n        \\n        //sliding window\\n        while(j<n){\\n            //Till we hit the window size K\\n            if(j-i+1 < k){\\n                mp[nums[j]]++;\\n                sum+=nums[j];\\n                j++;\\n            }else if(j-i+1 == k){\\n                mp[nums[j]]++;\\n                sum+=nums[j];\\n                //checking if K distinct elements are present\\n                if(mp.size()==k){\\n                    if(ans<sum){\\n                        ans=sum;\\n                    }\\n                }\\n                //removing the element thats is no longer in the window\\n                if(mp[nums[i]] > 1){\\n                    mp[nums[i]]--;\\n                }else{\\n                    mp.erase(nums[i]);\\n                }\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814624,
                "title": "sliding-window",
                "content": "**C++**\\n```cpp\\nint cnt[100001] = {};\\nlong long maximumSubarraySum(vector<int>& n, int k) {\\n    long long sum = 0, res = 0, unique = 0;\\n    for (int i = 0; i < n.size(); ++i) {\\n        sum += n[i];\\n        int reps = ++cnt[n[i]];\\n        unique += reps == 1 ? 1 : reps == 2 ? -1 : 0;\\n        if (i >= k) {\\n            sum -= n[i - k];\\n            int reps = --cnt[n[i - k]];\\n            unique += reps == 1 ? 1 : reps == 0 ? -1 : 0;\\n        }\\n        if (unique == k)\\n            res = max(res, sum);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint cnt[100001] = {};\\nlong long maximumSubarraySum(vector<int>& n, int k) {\\n    long long sum = 0, res = 0, unique = 0;\\n    for (int i = 0; i < n.size(); ++i) {\\n        sum += n[i];\\n        int reps = ++cnt[n[i]];\\n        unique += reps == 1 ? 1 : reps == 2 ? -1 : 0;\\n        if (i >= k) {\\n            sum -= n[i - k];\\n            int reps = --cnt[n[i - k]];\\n            unique += reps == 1 ? 1 : reps == 0 ? -1 : 0;\\n        }\\n        if (unique == k)\\n            res = max(res, sum);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2786087,
                "title": "python-3-sliding-window-w-explanation-t-m-852-ms-30-1-mb",
                "content": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        sm, c = sum(nums[:k]), Counter(nums[:k])        #        sm : running sum of the [i:i+k]     \\n        multiples = {n for n in c.keys() if c[n] > 1}   #         c : counter for digits in [i:i+k]\\n        ans = sm if not multiples else 0                # multiples : list of repeated digits in [i:i+k]\\n                                                        #       ans : max sum for distinct [i:i+k]\\n        for i in range(len(nums) - k):\\n            old, new = nums[i], nums[i+k]               # <-- sliding window [i:i+k] \\n\\n            if old == new: continue                     # <-- no change to sm, multiples, or ans if \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    #     old == new for new window\\n\\n            c[old]-= 1                                  # <-- update c and sm for new window\\n            c[new]+= 1                                  #\\n            sm+= new - old                              #\\n\\n            if c[old] == 1: multiples.remove(old)       # <-- counter for new window\\n            if c[new] >  1: multiples.add(new)          #\\n\\n            if not multiples: ans = max(ans, sm)        # <-- if elements of the new window are \\n\\t\\t\\t                                            #     distinct, update ans as necessary\\n\\n        return ans\\n```\\n[https://leetcode.com/submissions/detail/838189096/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*).\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        sm, c = sum(nums[:k]), Counter(nums[:k])        #        sm : running sum of the [i:i+k]     \\n        multiples = {n for n in c.keys() if c[n] > 1}   #         c : counter for digits in [i:i+k]\\n        ans = sm if not multiples else 0                # multiples : list of repeated digits in [i:i+k]\\n                                                        #       ans : max sum for distinct [i:i+k]\\n        for i in range(len(nums) - k):\\n            old, new = nums[i], nums[i+k]               # <-- sliding window [i:i+k] \\n\\n            if old == new: continue                     # <-- no change to sm, multiples, or ans if \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t    #     old == new for new window\\n\\n            c[old]-= 1                                  # <-- update c and sm for new window\\n            c[new]+= 1                                  #\\n            sm+= new - old                              #\\n\\n            if c[old] == 1: multiples.remove(old)       # <-- counter for new window\\n            if c[new] >  1: multiples.add(new)          #\\n\\n            if not multiples: ans = max(ans, sm)        # <-- if elements of the new window are \\n\\t\\t\\t                                            #     distinct, update ans as necessary\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783409,
                "title": "c-easy-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> s;\\n        long long curr = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++){\\n            s[nums[i]]++;\\n            curr+=nums[i];\\n        }\\n        long long maxi = 0;\\n        if(s.size()==k){\\n            maxi = max(maxi, curr);\\n        }\\n        for(int i=k;i<n;i++){\\n            s[nums[i-k]]--;\\n            curr-=nums[i-k];\\n            curr+=nums[i];\\n            s[nums[i]]++;\\n            if(s[nums[i-k]]==0){\\n                s.erase(nums[i-k]);\\n            }\\n            if(s.size()==k){\\n                maxi=max(maxi,curr);\\n            }\\n        }\\n        return\\xA0maxi;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> s;\\n        long long curr = 0;\\n        int n = nums.size();\\n        for(int i=0;i<k;i++){\\n            s[nums[i]]++;\\n            curr+=nums[i];\\n        }\\n        long long maxi = 0;\\n        if(s.size()==k){\\n            maxi = max(maxi, curr);\\n        }\\n        for(int i=k;i<n;i++){\\n            s[nums[i-k]]--;\\n            curr-=nums[i-k];\\n            curr+=nums[i];\\n            s[nums[i]]++;\\n            if(s[nums[i-k]]==0){\\n                s.erase(nums[i-k]);\\n            }\\n            if(s.size()==k){\\n                maxi=max(maxi,curr);\\n            }\\n        }\\n        return\\xA0maxi;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783072,
                "title": "c-use-hashmap-efficient-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        if(n<k) return 0; //when required subarray size is greater than nums size. \\n        \\n        unordered_map<int, int> mp; //store frequency of element\\n        int i, cnt=0, low=0; //cnt stores current size of subarray, low shows starting index of subarray\\n        long long sum=0, maxi=0;\\n        \\n        for(i=0; i<n; i++)\\n        {\\n            if(mp[nums[i]]>0)  //if current element is repeated we erase first occurrence of it\\n            {\\n                while(mp[nums[i]]  > 0 ) \\n                {\\n                    mp[nums[low]]--;  //decrease frequency of all elements which arrived before the first occurrences of repeated element \\n                    sum -= nums[low]; //substract elements which arrived before the first occurrences of repeated element \\n                    cnt--; //decrease subarray size\\n                    low++; set starting index of subarray\\n                }\\n            }\\n            \\n\\t\\t\\t//add current elements in sum, increase cnt by 1, and store frequency in mp\\n            sum += nums[i];\\n            cnt++;\\n            mp[nums[i]]++;\\n            \\n            if(cnt==k) //when subarray size (cnt) equals to k\\n            {\\n                maxi = max(maxi, sum);\\n                mp[nums[low]]--;\\n                sum -= nums[low];\\n                cnt--;\\n                low++;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n=nums.size();\\n        if(n<k) return 0; //when required subarray size is greater than nums size. \\n        \\n        unordered_map<int, int> mp; //store frequency of element\\n        int i, cnt=0, low=0; //cnt stores current size of subarray, low shows starting index of subarray\\n        long long sum=0, maxi=0;\\n        \\n        for(i=0; i<n; i++)\\n        {\\n            if(mp[nums[i]]>0)  //if current element is repeated we erase first occurrence of it\\n            {\\n                while(mp[nums[i]]  > 0 ) \\n                {\\n                    mp[nums[low]]--;  //decrease frequency of all elements which arrived before the first occurrences of repeated element \\n                    sum -= nums[low]; //substract elements which arrived before the first occurrences of repeated element \\n                    cnt--; //decrease subarray size\\n                    low++; set starting index of subarray\\n                }\\n            }\\n            \\n\\t\\t\\t//add current elements in sum, increase cnt by 1, and store frequency in mp\\n            sum += nums[i];\\n            cnt++;\\n            mp[nums[i]]++;\\n            \\n            if(cnt==k) //when subarray size (cnt) equals to k\\n            {\\n                maxi = max(maxi, sum);\\n                mp[nums[low]]--;\\n                sum -= nums[low];\\n                cnt--;\\n                low++;\\n            }\\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802392,
                "title": "using-sliding-window-maximum-sum-of-distinct-subarrays-with-length-k",
                "content": "\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       unordered_map<int, int>mp;\\n        int n=nums.size();\\n       long long i=0,j=0,ans=0,sum=0;;\\n        while(j<n){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n               \\n                if(mp.size()==k){\\n                    ans=max(ans,sum);\\n                }\\n               if(mp[nums[i]] > 1){\\n                 mp[nums[i]]--;\\n                }\\n              else{\\n                 mp.erase(nums[i]);\\n                }\\n\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n                \\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       unordered_map<int, int>mp;\\n        int n=nums.size();\\n       long long i=0,j=0,ans=0,sum=0;;\\n        while(j<n){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            if(j-i+1<k){\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2788473,
                "title": "sliding-window-solution-in-js-explained-o-n-time",
                "content": "## Sliding window solution in JS explained\\n**TC: O(n), SD: O(n)**\\n```\\nfunction maximumSubarraySum(nums, k){\\n    const eleFreq = new Map(); // Used to store the frequency of an element within the window k\\n    let currSum = 0, maxSum = 0; // local and global sum\\n    let i = 0;\\n\\t// Loop over the elements untill you have your first window\\n\\t// record the currSum and keep adding the num[i] to your map\\n    while(i < k){\\n        currSum += nums[i];\\n        eleFreq.set(nums[i], (eleFreq.get(nums[i]) || 0) + 1);\\n        i++;\\n    }\\n\\t// Check if the all the elements in your window is unique\\n    if(eleFreq.size === k){\\n        maxSum = Math.max(maxSum, currSum);\\n    }\\n    while(i < nums.length){\\n\\t// Since we already have k elements in the window, remove the first element in the window. Subtract the sum and frequency of first element to reflect the removal \\n        currSum -= nums[i - k];\\n        eleFreq.set(nums[i - k], (eleFreq.get(nums[i - k]) || 0) - 1);\\n\\t\\t// If freq is zero, then just remove it from the map so that we have a count of unique elements in the window\\n        if(eleFreq.get(nums[i - k]) === 0)\\n            eleFreq.delete(nums[i - k]) \\n        currSum += nums[i];\\n        eleFreq.set(nums[i], (eleFreq.get(nums[i]) || 0) + 1);\\n\\t\\t// Everytime you add nums[i] in your map, check if there are k unique elements, if yes then calcualte maxSum again\\n        if(eleFreq.size === k){\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        i++;\\n    }\\n    return maxSum;\\n}\\n```\\nYou can use this a template to solve many such *fixed window* based sliding window questions",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nfunction maximumSubarraySum(nums, k){\\n    const eleFreq = new Map(); // Used to store the frequency of an element within the window k\\n    let currSum = 0, maxSum = 0; // local and global sum\\n    let i = 0;\\n\\t// Loop over the elements untill you have your first window\\n\\t// record the currSum and keep adding the num[i] to your map\\n    while(i < k){\\n        currSum += nums[i];\\n        eleFreq.set(nums[i], (eleFreq.get(nums[i]) || 0) + 1);\\n        i++;\\n    }\\n\\t// Check if the all the elements in your window is unique\\n    if(eleFreq.size === k){\\n        maxSum = Math.max(maxSum, currSum);\\n    }\\n    while(i < nums.length){\\n\\t// Since we already have k elements in the window, remove the first element in the window. Subtract the sum and frequency of first element to reflect the removal \\n        currSum -= nums[i - k];\\n        eleFreq.set(nums[i - k], (eleFreq.get(nums[i - k]) || 0) - 1);\\n\\t\\t// If freq is zero, then just remove it from the map so that we have a count of unique elements in the window\\n        if(eleFreq.get(nums[i - k]) === 0)\\n            eleFreq.delete(nums[i - k]) \\n        currSum += nums[i];\\n        eleFreq.set(nums[i], (eleFreq.get(nums[i]) || 0) + 1);\\n\\t\\t// Everytime you add nums[i] in your map, check if there are k unique elements, if yes then calcualte maxSum again\\n        if(eleFreq.size === k){\\n            maxSum = Math.max(maxSum, currSum);\\n        }\\n        i++;\\n    }\\n    return maxSum;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783196,
                "title": "full-explanation-sliding-window-easy-approach",
                "content": "#As we want to consider \"SUBARRAY OF LENGTH K\", take it as a \"WINDOW OF LENGTH K\"\\n#**Validity condition of window ==> All elements of window should be distinct.**\\n\\n#We can keep a track of **sum of window** by\\n=>removing the (i - k)th element from the totalSum\\n=>adding the (i)th element to the totalSum\\n\\n#Now point is that -> How to check the validity of window in O(1) rather than O(N)\\n#For all the elements to be distinct, there should be no duplicate element in the window\\n#**So we just need to keep a track of \"NUMBER OF DUPLICATE ELEMENTS IN WINDOW\"**\\n#For tracking duplicates in window do the following ===>\\n\\n**1. Initial Step [index = 0] to [index = k - 1]**\\n#Create a hashmap for keeping a track of freq of elements\\n#Iterate the first k elements, if that element is already in map increase \"duplicateCount\" by 1\\n\\n**2. Iterate elements from [index = k]  to [index = n - 1]**\\n* #Remove the element at index = (currIndex - k) from map and decrease it\\'s freq in map\\n#After removing if newFreq of that element becomes 1 which means that it earlier contributed  to \"duplicateCount\" and now it is no longer duplicate.\\n =>**if freq moves from (freq > 1) to (freq = 1) ==> \"decrease duplicateCount by 1\"**\\n\\n* #Add the element at currIndex in map and increase it\\'s freq in map\\n#After adding if newFreq of that element becomes > 1, which means that it earlier wasn\\'t duplicate\\n but now it has become duplicated. \\n =>**if freq moves from (freq = 1) to (freq > 1) ==> so \"increase duplicateCount by 1\"**\\n \\n\\n#Now for each valid window record the sum and there you GOT YOU ANSWER :))\\n\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        long long sum = 0;\\n        long long mxSum = 0;\\n        map<int, int>mp;\\n        int duplicateCount = 0; //keeping a track of number of duplicate elements in a window\\n        //======================================================\\n        for (int i = 0; i < k; i++)  //initial window of size k\\n        {\\n            if (mp[nums[i]] == 1) duplicateCount++; //increase duplicateCount only when freq moves from 1(initial) to 2\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n        }\\n        if (duplicateCount == 0) mxSum = max(mxSum, sum); //record window sum\\n        //========================================================\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            mp[nums[i - k]]--; //decrease freq of (i - k)th element\\n            if (mp[nums[i - k]] == 1) duplicateCount--; //if freq moves from (freq > 1) to (freq = 1)\\n            sum = sum - (nums[i - k]); \\n            \\n            mp[nums[i]]++; //increase freq of (i)th element\\n            if (mp[nums[i]] != 1) duplicateCount++; //if freq moves from (freq == 1) to (freq > 1)\\n            sum = sum + (nums[i]);\\n            \\n            if (duplicateCount == 0) mxSum = max(mxSum, sum); //record window sum\\n        }\\n        //======================================================\\n        return mxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        long long sum = 0;\\n        long long mxSum = 0;\\n        map<int, int>mp;\\n        int duplicateCount = 0; //keeping a track of number of duplicate elements in a window\\n        //======================================================\\n        for (int i = 0; i < k; i++)  //initial window of size k\\n        {\\n            if (mp[nums[i]] == 1) duplicateCount++; //increase duplicateCount only when freq moves from 1(initial) to 2\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n        }\\n        if (duplicateCount == 0) mxSum = max(mxSum, sum); //record window sum\\n        //========================================================\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            mp[nums[i - k]]--; //decrease freq of (i - k)th element\\n            if (mp[nums[i - k]] == 1) duplicateCount--; //if freq moves from (freq > 1) to (freq = 1)\\n            sum = sum - (nums[i - k]); \\n            \\n            mp[nums[i]]++; //increase freq of (i)th element\\n            if (mp[nums[i]] != 1) duplicateCount++; //if freq moves from (freq == 1) to (freq > 1)\\n            sum = sum + (nums[i]);\\n            \\n            if (duplicateCount == 0) mxSum = max(mxSum, sum); //record window sum\\n        }\\n        //======================================================\\n        return mxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783129,
                "title": "full-explanation-sliding-window-easy-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0;\\n        long long presum=0;\\n        // Creates an empty hashmap hm\\n        unordered_map<int, int> hm;\\n        long long dist_count=0; \\n        int n=nums.size();\\n          // initialize distinct element count for current window\\n        //we will count presum also and will count presum and distinct element also\\n        for(int i=0;i<k;i++){\\n            presum+=nums[i];\\n          if (hm[nums[i]] == 0) {\\n            dist_count++;\\n        }\\n        hm[nums[i]]+=1;\\n        }\\n        if(dist_count==k)\\n            ans=max(presum,ans);\\n        // Traverse through the remaining array\\n        for(int i=k;i<n;i++){\\n            //will do presum here and after that update the answer\\n            presum=presum+nums[i]-nums[i-k];\\n           // Remove first element of previous window\\n        // If there was only one occurrence, then reduce distinct count.\\n        if (hm[nums[i-k]] == 1) {\\n            dist_count--;\\n        }\\n        // reduce count of the removed element\\n        hm[nums[i-k]] -= 1;\\n \\n        // Add new element of current window\\n        // If this element appears first time,\\n        // increment distinct element count\\n        if (hm[nums[i]] == 0) {\\n            dist_count++;\\n        }\\n        hm[nums[i]] += 1;\\n            //if distinct element is equall to count we will update answer\\n           if(dist_count==k)\\n            ans=max(presum,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0;\\n        long long presum=0;\\n        // Creates an empty hashmap hm\\n        unordered_map<int, int> hm;\\n        long long dist_count=0; \\n        int n=nums.size();\\n          // initialize distinct element count for current window\\n        //we will count presum also and will count presum and distinct element also\\n        for(int i=0;i<k;i++){\\n            presum+=nums[i];\\n          if (hm[nums[i]] == 0) {\\n            dist_count++;\\n        }\\n        hm[nums[i]]+=1;\\n        }\\n        if(dist_count==k)\\n            ans=max(presum,ans);\\n        // Traverse through the remaining array\\n        for(int i=k;i<n;i++){\\n            //will do presum here and after that update the answer\\n            presum=presum+nums[i]-nums[i-k];\\n           // Remove first element of previous window\\n        // If there was only one occurrence, then reduce distinct count.\\n        if (hm[nums[i-k]] == 1) {\\n            dist_count--;\\n        }\\n        // reduce count of the removed element\\n        hm[nums[i-k]] -= 1;\\n \\n        // Add new element of current window\\n        // If this element appears first time,\\n        // increment distinct element count\\n        if (hm[nums[i]] == 0) {\\n            dist_count++;\\n        }\\n        hm[nums[i]] += 1;\\n            //if distinct element is equall to count we will update answer\\n           if(dist_count==k)\\n            ans=max(presum,ans);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555206,
                "title": "using-map-element-count-c",
                "content": "get sum of each unique element of each window \\nall element\\'s are unique so in map all element are unique and map size equal to k.\\nif map size equal to k than try to maximize our ans\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long int ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mp.count(nums[i])==0){//get sum of each window unique element\\n                sum += nums[i];\\n            }\\n            mp[nums[i]]++;\\n            if(mp.size()==k){//if in map all element are unique than get maximum ans\\n                ans = max(ans,sum);\\n            }\\n            if(i-k+1>=0){\\n                mp[nums[i+1-k]]--;\\n                if(mp[nums[i+1-k]]==0){\\n                    sum -= nums[i+1-k];\\n                    mp.erase(nums[i+1-k]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        long long int ans = 0, sum = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(mp.count(nums[i])==0){//get sum of each window unique element\\n                sum += nums[i];\\n            }\\n            mp[nums[i]]++;\\n            if(mp.size()==k){//if in map all element are unique than get maximum ans\\n                ans = max(ans,sum);\\n            }\\n            if(i-k+1>=0){\\n                mp[nums[i+1-k]]--;\\n                if(mp[nums[i+1-k]]==0){\\n                    sum -= nums[i+1-k];\\n                    mp.erase(nums[i+1-k]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795179,
                "title": "fixed-size-sliding-window-explained-with-comments-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n- $O(n)$ :- Just one iteration\\n\\n- Space complexity:\\n $O(n)$ :- for using map\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        //fixed sized sliding window\\n        int i=0,j=0;\\n        int n = nums.size();\\n       long long int max_sum=0;\\n       long long int sum=0;\\n        map<int,int>freq;\\n        \\n        while(j<n){\\n            \\n            //reaching window size \\n            sum+=nums[j]; freq[nums[j]]++;\\n            if(j-i+1<k){   \\n                j++;\\n            }\\n            \\n            \\n            //window size reach , find max_sum if freq size is equal to k \\n          else  if(j-i+1 == k){\\n                //see max_sum only if all distinct element in window\\n                if(freq.size()==k){\\n                max_sum=max(max_sum,sum);\\n                  \\n                }\\n                \\n                //now, move to next window by removing the calculation for i\\n                freq[nums[i]]--; \\n                sum-=nums[i]; //remove calculation of i from sum as well\\n                if(freq[nums[i]]==0){\\n                     //erase it from freq\\n                    freq.erase(nums[i]);\\n                }\\n                //going to next window\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```\\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        //fixed sized sliding window\\n        int i=0,j=0;\\n        int n = nums.size();\\n       long long int max_sum=0;\\n       long long int sum=0;\\n        map<int,int>freq;\\n        \\n        while(j<n){\\n            \\n            //reaching window size \\n            sum+=nums[j]; freq[nums[j]]++;\\n            if(j-i+1<k){   \\n                j++;\\n            }\\n            \\n            \\n            //window size reach , find max_sum if freq size is equal to k \\n          else  if(j-i+1 == k){\\n                //see max_sum only if all distinct element in window\\n                if(freq.size()==k){\\n                max_sum=max(max_sum,sum);\\n                  \\n                }\\n                \\n                //now, move to next window by removing the calculation for i\\n                freq[nums[i]]--; \\n                sum-=nums[i]; //remove calculation of i from sum as well\\n                if(freq[nums[i]]==0){\\n                     //erase it from freq\\n                    freq.erase(nums[i]);\\n                }\\n                //going to next window\\n                i++;\\n                j++;\\n            }\\n            \\n            \\n        }\\n        \\n        return max_sum;\\n    }\\n};\\n```\n```\\nIf you find this solutions to be helpful do upvote..It keeps me motivated :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788474,
                "title": "python-sliding-window-deque-time-complexity-o-n",
                "content": "```\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        q=deque()\\n        i=0\\n        maxsum,add=0,0\\n        s=set()\\n        \\n        while i<len(nums):\\n            q.append(nums[i])\\n            s.add(nums[i])\\n            add+=nums[i]\\n            if len(q)==k:\\n                if len(q)==len(s):\\n                    maxsum=max(add,maxsum)\\n                    a=q.popleft()\\n                    s.remove(a)\\n                    add-=a\\n                    i+=1\\n                else:\\n                    q=deque()\\n                    s=set()\\n                    add=0\\n            else:\\n                i += 1\\n                    \\n        return maxsum\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        q=deque()\\n        i=0\\n        maxsum,add=0,0\\n        s=set()\\n        \\n        while i<len(nums):\\n            q.append(nums[i])\\n            s.add(nums[i])\\n            add+=nums[i]\\n            if len(q)==k:\\n                if len(q)==len(s):\\n                    maxsum=max(add,maxsum)\\n                    a=q.popleft()\\n                    s.remove(a)\\n                    add-=a\\n                    i+=1\\n                else:\\n                    q=deque()\\n                    s=set()\\n                    add=0\\n            else:\\n                i += 1\\n                    \\n        return maxsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785339,
                "title": "python-two-pointers-or-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nsliding window length = j + 1- i\\ni is left pointer and j is right pointer\\nloop over right pointer and check/remove duplicated num and update i\\nif window length is k, update max sum \\n\\n# Code\\n```\\nclass Solution(object):\\n    def maximumSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        #sliding window\\n        n = len(nums)\\n        seen  = set()\\n        i = ans = cur = 0\\n        for j in range(n):\\n            cur += nums[j]\\n            while nums[j] in seen or j+1-i > k:\\n                seen.remove(nums[i])\\n                cur -= nums[i]\\n                i +=1\\n            seen.add(nums[j])\\n            if j+1-i == k:\\n                ans = max(ans, cur)\\n        return ans or 0\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumSubarraySum(self, nums, k):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        #sliding window\\n        n = len(nums)\\n        seen  = set()\\n        i = ans = cur = 0\\n        for j in range(n):\\n            cur += nums[j]\\n            while nums[j] in seen or j+1-i > k:\\n                seen.remove(nums[i])\\n                cur -= nums[i]\\n                i +=1\\n            seen.add(nums[j])\\n            if j+1-i == k:\\n                ans = max(ans, cur)\\n        return ans or 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785010,
                "title": "java-maximum-sum-of-distinct-subarrays-with-length-k",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        long max=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n             if(i>=k-1){\\n                 if(map.size()==k)max=Math.max(max,sum);\\n                 \\n                 sum-=nums[i-k+1];\\n                 map.put(nums[i-k+1],map.get(nums[i-k+1])-1);\\n                 \\n                 if(map.get(nums[i-k+1])==0)map.remove(nums[i-k+1]); \\n             }\\n            \\n        }\\n        \\n      \\n        return max;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        long max=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n             if(i>=k-1){\\n                 if(map.size()==k)max=Math.max(max,sum);\\n                 \\n                 sum-=nums[i-k+1];\\n                 map.put(nums[i-k+1],map.get(nums[i-k+1])-1);\\n                 \\n                 if(map.get(nums[i-k+1])==0)map.remove(nums[i-k+1]); \\n             }\\n            \\n        }\\n        \\n      \\n        return max;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784871,
                "title": "sliding-window-hashmap-c",
                "content": "# Approach\\nTraverse the array until you hit the window of k size, alongside also store the frequency of elements, if window contains duplicate elements, then ignore the window and move forward.\\n\\nIf you hit a window which do not contain duplicate element, then check if the sum of elements is greater than the sum previously calculated, and update your sum if found greater. \\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)log(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maxSum = INT_MIN;\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0, j = 0,n = nums.size();\\n        unordered_map<int, int> mp;\\n        long long sum = 0;\\n        while(j<n){\\n            sum+= nums[j];\\n            mp[nums[j]]++;\\n            if (j - i + 1 == k){\\n                if (mp.size()==k){\\n                    maxSum = max(maxSum, sum);\\n                }\\n                sum -= nums[i];\\n                mp[nums[i]]--; \\n                if (mp[nums[i]]==0){mp.erase(nums[i]);}\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return maxSum==INT_MIN?0:maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maxSum = INT_MIN;\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0, j = 0,n = nums.size();\\n        unordered_map<int, int> mp;\\n        long long sum = 0;\\n        while(j<n){\\n            sum+= nums[j];\\n            mp[nums[j]]++;\\n            if (j - i + 1 == k){\\n                if (mp.size()==k){\\n                    maxSum = max(maxSum, sum);\\n                }\\n                sum -= nums[i];\\n                mp[nums[i]]--; \\n                if (mp[nums[i]]==0){mp.erase(nums[i]);}\\n                i++;\\n            }\\n            j++;\\n        }\\n        \\n        return maxSum==INT_MIN?0:maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784234,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n            if(i >= k - 1) {\\n                if(mp.size() == k) ans = max(ans, sum);\\n                sum -= nums[i-k+1];\\n                mp[nums[i-k+1]]--;\\n                if(mp[nums[i-k+1]] == 0) mp.erase(nums[i-k+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        for(int i = 0; i < nums.size(); i++) {\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n            if(i >= k - 1) {\\n                if(mp.size() == k) ans = max(ans, sum);\\n                sum -= nums[i-k+1];\\n                mp[nums[i-k+1]]--;\\n                if(mp[nums[i-k+1]] == 0) mp.erase(nums[i-k+1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783537,
                "title": "java-100-faster-easy-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, max = 0;\\n        int n  = nums.length;\\n        Map<Integer,Integer> map = new HashMap();\\n        if(n == 1)\\n            return nums[0];\\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n            sum += nums[i];\\n\\t\\t\\t\\n            if(i>=k){\\n                map.put(nums[i-k],map.get(nums[i-k]) - 1);\\n                sum -= nums[i-k];\\n                \\n                if(map.get(nums[i-k]) == 0)\\n                    map.remove(nums[i-k]);\\n            }\\n\\t\\t\\t\\n            if(map.size() == k)\\n                max = Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, max = 0;\\n        int n  = nums.length;\\n        Map<Integer,Integer> map = new HashMap();\\n        if(n == 1)\\n            return nums[0];\\n        for(int i=0; i<n; i++){\\n\\t\\t\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n            sum += nums[i];\\n\\t\\t\\t\\n            if(i>=k){\\n                map.put(nums[i-k],map.get(nums[i-k]) - 1);\\n                sum -= nums[i-k];\\n                \\n                if(map.get(nums[i-k]) == 0)\\n                    map.remove(nums[i-k]);\\n            }\\n\\t\\t\\t\\n            if(map.size() == k)\\n                max = Math.max(sum,max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783081,
                "title": "python-simple-sliding-window-solution",
                "content": "# Intuition\\nWhenever you see a problem that is looking for a subarray within an array there is a good chance that the sliding window technique is a possible solution\\n\\n# Approach\\nThe idea here is to use a dictionary, Counter, to ensure our window (l to r) only ever contains unique elements and is never larger than k. if a duplicate is ever found, we increment l until all the elements in the window are unique again. We also use the variable \"curr\" that maintains the sum of all the elements within the window. If our window is of size k after doing the maintenance described above, we know all the elements are unique so we can check to see if we have found a new maximum subarray sum. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        ctr = Counter()\\n        curr = 0\\n        max_sum = -math.inf\\n        \\n        for r in range(len(nums)):\\n            ctr[nums[r]] += 1\\n            curr += nums[r]\\n            \\n            while ctr[nums[r]] > 1 or (r - l + 1) > k:\\n                curr -= nums[l]\\n                ctr[nums[l]] -= 1\\n                l += 1\\n            \\n            if (r - l + 1) == k:\\n                max_sum = max(max_sum, curr)\\n            \\n        return max_sum if max_sum != -math.inf else 0             \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        l = 0\\n        ctr = Counter()\\n        curr = 0\\n        max_sum = -math.inf\\n        \\n        for r in range(len(nums)):\\n            ctr[nums[r]] += 1\\n            curr += nums[r]\\n            \\n            while ctr[nums[r]] > 1 or (r - l + 1) > k:\\n                curr -= nums[l]\\n                ctr[nums[l]] -= 1\\n                l += 1\\n            \\n            if (r - l + 1) == k:\\n                max_sum = max(max_sum, curr)\\n            \\n        return max_sum if max_sum != -math.inf else 0             \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783071,
                "title": "sliding-window-with-hashmap-to-count-distinct",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        s = 0\\n        res = 0\\n        ctr = Counter()\\n        l = 0\\n        for i in range(n):\\n            s += nums[i]\\n            if ctr[nums[i]] == 0:\\n                l += 1\\n            ctr[nums[i]] += 1\\n            if i >= k:\\n                s -= nums[i - k]\\n                ctr[nums[i - k]] -= 1\\n                if ctr[nums[i - k]] == 0:\\n                    l -= 1\\n            if i >= k - 1:\\n                if l == k:\\n                    res = max(res, s)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        n = len(nums)\\n        s = 0\\n        res = 0\\n        ctr = Counter()\\n        l = 0\\n        for i in range(n):\\n            s += nums[i]\\n            if ctr[nums[i]] == 0:\\n                l += 1\\n            ctr[nums[i]] += 1\\n            if i >= k:\\n                s -= nums[i - k]\\n                ctr[nums[i - k]] -= 1\\n                if ctr[nums[i - k]] == 0:\\n                    l -= 1\\n            if i >= k - 1:\\n                if l == k:\\n                    res = max(res, s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762314,
                "title": "c-using-map-sliding-window-t-c-o-n-s-c-o-k",
                "content": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N)\\n\\t\\tSpace Complexity : O(K)\\n\\t*/\\n\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long res = 0, currSum = 0;\\n        map<int, int> m1;\\n        \\n        for(int i=0; i<k; i++){\\n            m1[nums[i]]++;\\n            currSum += nums[i];\\n        }\\n        \\n        if(m1.size()==k && currSum > res){\\n            res = currSum;\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            int addIdx = i;\\n            int rmvIdx = i-k;\\n            \\n            // Updating the current sum\\n            currSum += nums[addIdx];\\n            currSum -= nums[rmvIdx];\\n            \\n            // Updating map\\n            if(m1[nums[rmvIdx]] == 1){\\n                m1.erase(nums[rmvIdx]);\\n            }else{\\n                m1[nums[rmvIdx]]--;\\n            }\\n            \\n            m1[nums[addIdx]]++;\\n            \\n            if(m1.size()==k && currSum > res){\\n                res = currSum;\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n\\t/*\\n\\t\\tTime Complexity : O(N)\\n\\t\\tSpace Complexity : O(K)\\n\\t*/\\n\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long res = 0, currSum = 0;\\n        map<int, int> m1;\\n        \\n        for(int i=0; i<k; i++){\\n            m1[nums[i]]++;\\n            currSum += nums[i];\\n        }\\n        \\n        if(m1.size()==k && currSum > res){\\n            res = currSum;\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            int addIdx = i;\\n            int rmvIdx = i-k;\\n            \\n            // Updating the current sum\\n            currSum += nums[addIdx];\\n            currSum -= nums[rmvIdx];\\n            \\n            // Updating map\\n            if(m1[nums[rmvIdx]] == 1){\\n                m1.erase(nums[rmvIdx]);\\n            }else{\\n                m1[nums[rmvIdx]]--;\\n            }\\n            \\n            m1[nums[addIdx]]++;\\n            \\n            if(m1.size()==k && currSum > res){\\n                res = currSum;\\n            }\\n        }\\n        \\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735114,
                "title": "c-easy-solution-map-sliding-window-explained",
                "content": "# Intuition\\nJust use sliding window approach with unique subaarray elements condition.\\n\\n# Approach\\nFollow sliding window approach with unique elements present in subarray condition. We can use unordered map to store freq of elements.\\nIf element occurs more than once in window, just move window forward.\\nElse keep storing its count and increase the sum.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum = 0, maxSum = 0;\\n        unordered_map<int,int> freq;\\n        int i=0, j=0;\\n        // Sliding Window Approach\\n        while(j < nums.size()){\\n            //Increase the freq count\\n            freq[nums[j]]++;\\n            // Add to sum\\n            sum += nums[j];\\n            if(j-i+1 == k){\\n                //No duplicates present\\n                if(freq.size() == k) maxSum = max(sum,maxSum);\\n                sum -= nums[i];\\n                freq[nums[i]]--;\\n                if(freq[nums[i]] == 0) freq.erase(nums[i]);\\n                //Slide Window Forward\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum = 0, maxSum = 0;\\n        unordered_map<int,int> freq;\\n        int i=0, j=0;\\n        // Sliding Window Approach\\n        while(j < nums.size()){\\n            //Increase the freq count\\n            freq[nums[j]]++;\\n            // Add to sum\\n            sum += nums[j];\\n            if(j-i+1 == k){\\n                //No duplicates present\\n                if(freq.size() == k) maxSum = max(sum,maxSum);\\n                sum -= nums[i];\\n                freq[nums[i]]--;\\n                if(freq[nums[i]] == 0) freq.erase(nums[i]);\\n                //Slide Window Forward\\n                i++;\\n            }\\n            j++;\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3708117,
                "title": "simple-easy-to-understand-c-code-explanation-sliding-window-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window + Map\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach used in the code is a sliding window approach combined with a map data structure.\\n\\nHere\\'s the step-by-step breakdown of the approach:\\n\\n1. Initialize two pointers i and j to track the left and right boundaries of the window, respectively. Set n to the size of the nums vector.\\n2. Create a map s to store the count of each element in the current window.\\n3. Initialize mx to 0, which will store the maximum subarray sum encountered.\\n4. Initialize sm to 0, which will keep track of the current sum of the elements in the window.\\n5. Iterate through the nums vector using the right pointer j:\\n- Add the current element nums[j] to the current sum sm.\\n- Increment the count of nums[j] in the map s.\\n- Check if the window size (j - i + 1) is equal to k. If so, we have a valid window.\\n- Check if the count of distinct elements in the window (s.size()) is equal to k. If so, update mx with the maximum of mx and sm.\\n- Move the left pointer i by one step:\\n    - Subtract the element at i from the current sum sm.\\n    - Decrement the count of the element at i in the map s.\\n    - If the count becomes 0, remove the element from the map s.\\n6. Repeat steps 5 and 6 until the right pointer j reaches the end of the nums vector.\\n7. Return the maximum subarray sum mx.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0,j=0,n=nums.size();\\n        map<int,int> s;\\n        long long mx=0;\\n        long long sm=0;\\n        while(j<n){\\n            sm+=nums[j];\\n            s[nums[j]]++;\\n            if(j-i+1==k){\\n                if(s.size()==k){\\n                    mx=max(mx,sm);\\n                }\\n                sm-=nums[i];\\n                s[nums[i]]--;\\n                if(s[nums[i]]==0)\\n                s.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mx;\\n    }\\n};\\n```\\n\\nPlease upvote if it was helpful.",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0,j=0,n=nums.size();\\n        map<int,int> s;\\n        long long mx=0;\\n        long long sm=0;\\n        while(j<n){\\n            sm+=nums[j];\\n            s[nums[j]]++;\\n            if(j-i+1==k){\\n                if(s.size()==k){\\n                    mx=max(mx,sm);\\n                }\\n                sm-=nums[i];\\n                s[nums[i]]--;\\n                if(s[nums[i]]==0)\\n                s.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374008,
                "title": "java-sliding-window-set-o-n-time",
                "content": "# Approach\\nExplained in the comments\\n\\n# Complexity\\n- Time complexity: $$O(N + N) = O(2N) = O(N)$$\\n    - The outer loop processes the elements in the array once.\\n    - The inner loop responsible for sliding the elements are goes through each element only one.\\n\\n- Space complexity: $$O(K)$$\\n    - $$K$$ - number of distinct elements in the input array, equal to array length $$N$$ in worst-case.\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long returnSum = 0;   // Initialize return sum to 0\\n        long currentSum = 0;    // Current sum of window\\n        int windowStart = 0;    // Start of window\\n\\n        Set<Integer> numberSet = new HashSet<>();   // Set to store the distinct elements in the window\\n        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n            int current = nums[windowEnd];  //  Getting hold of current element\\n            currentSum += current;  //  Adding it to the sum\\n\\n            //  If the addition of the element fails, we slide the window forward until we are able to add, remove the element from the set\\n            //  and reduce it\\'s value from the current sum \\n            while (!numberSet.add(current)) {  \\n                int start = nums[windowStart];\\n                currentSum -= start;\\n                numberSet.remove(start);\\n                windowStart++;\\n            }\\n\\n            // We update the returnSum if and only if the window size if equal to the limit specified\\n            // The window is also slid forward and operations repeated as specified above \\n            if (windowEnd - windowStart == k - 1) {\\n                returnSum = Math.max(returnSum, currentSum);\\n\\n                int start = nums[windowStart];\\n                currentSum -= start;\\n                numberSet.remove(start);\\n                windowStart++;\\n            }\\n        }\\n\\n        return returnSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long returnSum = 0;   // Initialize return sum to 0\\n        long currentSum = 0;    // Current sum of window\\n        int windowStart = 0;    // Start of window\\n\\n        Set<Integer> numberSet = new HashSet<>();   // Set to store the distinct elements in the window\\n        for (int windowEnd = 0; windowEnd < nums.length; windowEnd++) {\\n            int current = nums[windowEnd];  //  Getting hold of current element\\n            currentSum += current;  //  Adding it to the sum\\n\\n            //  If the addition of the element fails, we slide the window forward until we are able to add, remove the element from the set\\n            //  and reduce it\\'s value from the current sum \\n            while (!numberSet.add(current)) {  \\n                int start = nums[windowStart];\\n                currentSum -= start;\\n                numberSet.remove(start);\\n                windowStart++;\\n            }\\n\\n            // We update the returnSum if and only if the window size if equal to the limit specified\\n            // The window is also slid forward and operations repeated as specified above \\n            if (windowEnd - windowStart == k - 1) {\\n                returnSum = Math.max(returnSum, currentSum);\\n\\n                int start = nums[windowStart];\\n                currentSum -= start;\\n                numberSet.remove(start);\\n                windowStart++;\\n            }\\n        }\\n\\n        return returnSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335205,
                "title": "most-easiest-ever-o-n",
                "content": "# \\uD83D\\uDE09Please upvote it motivates me\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: O(N) `traversal`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K) `map`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# \\uD83D\\uDE09Please upvote it motivates me\\uD83D\\uDE09\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        long long i=0,j=0,ans=0,sum=0;\\n\\n        //SLIDING WINDOW STARTS HERE:\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n            sum += nums[j];\\n\\n            //if win_size == k\\n            if(j-i+1 == k)\\n            {\\n\\n        //if map_size == k the it means that map contains unique elements\\n                if(mp.size() == k)\\n                    ans = max(ans, sum);\\n\\n        //Now we\\'re moving win by 1 step so reduce 1st element from sum.\\n                sum = sum - nums[i];\\n        \\n        //decrement count of that first element from map.\\n                mp[nums[i]]--;\\n\\n        //If count of that element is 0 then no use of keeping it.\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        <!-- \\u2705Well before returning \"ans\" don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int n = nums.size();\\n        long long i=0,j=0,ans=0,sum=0;\\n\\n        //SLIDING WINDOW STARTS HERE:\\n        while(j<n)\\n        {\\n            mp[nums[j]]++;\\n            sum += nums[j];\\n\\n            //if win_size == k\\n            if(j-i+1 == k)\\n            {\\n\\n        //if map_size == k the it means that map contains unique elements\\n                if(mp.size() == k)\\n                    ans = max(ans, sum);\\n\\n        //Now we\\'re moving win by 1 step so reduce 1st element from sum.\\n                sum = sum - nums[i];\\n        \\n        //decrement count of that first element from map.\\n                mp[nums[i]]--;\\n\\n        //If count of that element is 0 then no use of keeping it.\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        <!-- \\u2705Well before returning \"ans\" don\\'t forget to UPVOTE.\\u2705 -->\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306657,
                "title": "best-possible-solution-beat-100-java-easy-solution-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0,j=0;\\n        int n = nums.length;\\n        long sum=0, maxSum=0;\\n        HashSet set = new HashSet<>();\\n\\n        while(j<n){\\n            //adding val at j index only if it is not present in the set \\n            //if it is present first remove all i index values till the current j index duplicate value is removed\\n            while(set.contains(nums[j])){\\n                set.remove(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            set.add(nums[j]);\\n            sum+=nums[j];\\n\\n            if(j-i+1<k){      //when less than windows size\\n                j++;\\n            }else{      //when equals to window size\\n                maxSum= Math.max(maxSum, sum);\\n                set.remove(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0,j=0;\\n        int n = nums.length;\\n        long sum=0, maxSum=0;\\n        HashSet set = new HashSet<>();\\n\\n        while(j<n){\\n            //adding val at j index only if it is not present in the set \\n            //if it is present first remove all i index values till the current j index duplicate value is removed\\n            while(set.contains(nums[j])){\\n                set.remove(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            set.add(nums[j]);\\n            sum+=nums[j];\\n\\n            if(j-i+1<k){      //when less than windows size\\n                j++;\\n            }else{      //when equals to window size\\n                maxSum= Math.max(maxSum, sum);\\n                set.remove(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3093351,
                "title": "java-simple-easy-hashmap-tc-o-n-sc-o-n",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        long max=0;\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n            if(i>=k-1){\\n                if(hm.size()==k)    max=Math.max(max,sum);\\n                sum-=nums[i-k+1];\\n                hm.put(nums[i-k+1],hm.get(nums[i-k+1])-1);\\n                if(hm.get(nums[i-k+1])==0)  hm.remove(nums[i-k+1]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        long max=0;\\n        HashMap<Integer,Integer>hm=new HashMap<>();\\n        for(int i=0;i<nums.length;i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n            if(i>=k-1){\\n                if(hm.size()==k)    max=Math.max(max,sum);\\n                sum-=nums[i-k+1];\\n                hm.put(nums[i-k+1],hm.get(nums[i-k+1])-1);\\n                if(hm.get(nums[i-k+1])==0)  hm.remove(nums[i-k+1]);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039460,
                "title": "c-rust-6-lines-only-set-sliding-window-o-n",
                "content": "**C++**\\n```c++\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k, \\n                                 long long res = 0, long long countingSum = 0) {\\n        unordered_set<long long> bag; \\n        for (int i = 0, j = 0; i < nums.size(); i++) {\\n            auto curr = nums[i];\\n            while (bag.count(curr) || bag.size() == k) {\\n                auto toErase = nums[j++];\\n                bag.erase(toErase), countingSum -= toErase;\\n            }\\n            bag.insert(curr), countingSum += curr;\\n            if (bag.size() == k) res = max(res, countingSum);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Rust**\\n```rust\\nimpl Solution {\\n    pub fn maximum_subarray_sum(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut bag = std::collections::HashSet::new();\\n        let (mut res, mut j) = (0, 0);\\n        let mut counting_sum: i64 = 0;\\n        for i in 0..nums.len() {\\n            let curr = nums[i];\\n            while bag.contains(&curr) || bag.len() == k as usize {\\n                let to_erase = nums[j];\\n                j += 1;\\n                bag.remove(&to_erase);\\n                counting_sum -= to_erase as i64;\\n            }\\n            bag.insert(curr);\\n            counting_sum += curr as i64;\\n            if bag.len() == k as usize {\\n                res = std::cmp::max(res, counting_sum);\\n            }\\n        }\\n        res as i64\\n    }\\n}\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k, \\n                                 long long res = 0, long long countingSum = 0) {\\n        unordered_set<long long> bag; \\n        for (int i = 0, j = 0; i < nums.size(); i++) {\\n            auto curr = nums[i];\\n            while (bag.count(curr) || bag.size() == k) {\\n                auto toErase = nums[j++];\\n                bag.erase(toErase), countingSum -= toErase;\\n            }\\n            bag.insert(curr), countingSum += curr;\\n            if (bag.size() == k) res = max(res, countingSum);\\n        }\\n        return res;\\n    }\\n};\\n```\n```rust\\nimpl Solution {\\n    pub fn maximum_subarray_sum(nums: Vec<i32>, k: i32) -> i64 {\\n        let mut bag = std::collections::HashSet::new();\\n        let (mut res, mut j) = (0, 0);\\n        let mut counting_sum: i64 = 0;\\n        for i in 0..nums.len() {\\n            let curr = nums[i];\\n            while bag.contains(&curr) || bag.len() == k as usize {\\n                let to_erase = nums[j];\\n                j += 1;\\n                bag.remove(&to_erase);\\n                counting_sum -= to_erase as i64;\\n            }\\n            bag.insert(curr);\\n            counting_sum += curr as i64;\\n            if bag.len() == k as usize {\\n                res = std::cmp::max(res, counting_sum);\\n            }\\n        }\\n        res as i64\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2793885,
                "title": "easy-solution-using-map-and-sliding-window",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans =0;\\n        long currsum =0;\\n        int n = nums.length;\\n// using HashMap to check the count\\n        Map<Integer,Integer> map = new HashMap<>();\\n//         pahli baar hit hoga condition toh\\n        for(int i=0;i<k;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            currsum += (long)nums[i];\\n        }\\n    \\n    \\n        if(map.size()==k){\\n        ans = currsum;\\n    }\\n    \\n    \\n//     after moving sliding window\\n    \\n    int l=0;\\n    for(int i=k;i<n;i++){\\n        currsum -=(long)nums[l];\\n        currsum +=(long)nums[i];\\n        \\n        map.put(nums[l],map.get(nums[l])-1);\\n        if(map.get(nums[l])==0){\\n            map.remove(nums[l]);\\n        }\\n        map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        l++;\\n        if(map.size()==k){\\n            ans = Math.max(currsum,ans);\\n        }\\n       \\n    }\\n         return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans =0;\\n        long currsum =0;\\n        int n = nums.length;\\n// using HashMap to check the count\\n        Map<Integer,Integer> map = new HashMap<>();\\n//         pahli baar hit hoga condition toh\\n        for(int i=0;i<k;i++){\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            currsum += (long)nums[i];\\n        }\\n    \\n    \\n        if(map.size()==k){\\n        ans = currsum;\\n    }\\n    \\n    \\n//     after moving sliding window\\n    \\n    int l=0;\\n    for(int i=k;i<n;i++){\\n        currsum -=(long)nums[l];\\n        currsum +=(long)nums[i];\\n        \\n        map.put(nums[l],map.get(nums[l])-1);\\n        if(map.get(nums[l])==0){\\n            map.remove(nums[l]);\\n        }\\n        map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n        l++;\\n        if(map.size()==k){\\n            ans = Math.max(currsum,ans);\\n        }\\n       \\n    }\\n         return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792538,
                "title": "java-solution-using-hashmap-efficient-and-faster-sliding-window",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long max=-1;\\n        long curr=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<k;i++){\\n            curr+=nums[i];\\n            if(map.containsKey(nums[i])){\\n                max=0;\\n            }\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            \\n        }\\n        max=max==0?0:curr;\\n        for(int i=k;i<nums.length;i++){\\n            curr=curr-nums[i-k];\\n\\t        map.put(nums[i-k],map.get(nums[i-k])-1);\\n            if(map.get(nums[i-k])==0){\\n                map.remove(nums[i-k]);\\n            }\\n                curr+=nums[i];\\n                if(!map.containsKey(nums[i])){\\n                    map.put(nums[i],1);\\n                    if(map.size()==k){\\n                        max=Math.max(curr,max); \\n                    }\\n                    \\n                }\\n                else{\\n                    map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n                }\\n               \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long max=-1;\\n        long curr=0;\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int i=0;i<k;i++){\\n            curr+=nums[i];\\n            if(map.containsKey(nums[i])){\\n                max=0;\\n            }\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            \\n        }\\n        max=max==0?0:curr;\\n        for(int i=k;i<nums.length;i++){\\n            curr=curr-nums[i-k];\\n\\t        map.put(nums[i-k],map.get(nums[i-k])-1);\\n            if(map.get(nums[i-k])==0){\\n                map.remove(nums[i-k]);\\n            }\\n                curr+=nums[i];\\n                if(!map.containsKey(nums[i])){\\n                    map.put(nums[i],1);\\n                    if(map.size()==k){\\n                        max=Math.max(curr,max); \\n                    }\\n                    \\n                }\\n                else{\\n                    map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n                }\\n               \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785389,
                "title": "c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are multiple solutions available for this problem.\\nOne of the approach is using Sliding Window\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Calculate the sum for first \\'k\\' elements and insert those elements into a map.\\n- Check if the size of the map is equal to \\'k\\' then assign sum to the answer.\\n- Then iterate the rest of the elements one by one.\\n- While iterating add the current element to the sum and subtract the \\'i-k\\' the element from sum.\\n- Insert the current element into the map and subtract the \\'i-k\\' th element from the map.\\n- Check if the size of the map is equal to \\'k\\' then take the max of \\'ans\\' and \\'sum\\'.\\n- \\'ans\\' will be the result.\\n# Complexity\\n- Time complexity:$$O(n)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        long long s = 0, ans = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n            s += nums[i];\\n        }\\n        \\n        if(mp.size() == k)\\n            ans = max(ans, s);\\n\\n        for(int i = k; i < nums.size(); i++){\\n            s += nums[i];\\n            s -= nums[i - k];\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            \\n            if(mp[nums[i-k]] == 0)  mp.erase(nums[i-k]);\\n            \\n            if(mp.size() == k)\\n                ans = max(ans, s);\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        long long s = 0, ans = 0;\\n        \\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n            s += nums[i];\\n        }\\n        \\n        if(mp.size() == k)\\n            ans = max(ans, s);\\n\\n        for(int i = k; i < nums.size(); i++){\\n            s += nums[i];\\n            s -= nums[i - k];\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            \\n            if(mp[nums[i-k]] == 0)  mp.erase(nums[i-k]);\\n            \\n            if(mp.size() == k)\\n                ans = max(ans, s);\\n        }\\n        \\n        return ans;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785145,
                "title": "easy-understanding-c-solution-fixed-sliding-window-hashmap",
                "content": "\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long i=0;\\n        long long j=k-1;\\n        \\n        unordered_map< long long, long long> map;\\n         long long sum=0;\\n         long long ans=0;\\n        for( long long z=i;z<=j;z++){\\n            sum+=nums[z];\\n            map[nums[z]]++;\\n        }\\n        if(map.size()==k) ans=sum;\\n        \\n        while(j<nums.size()){\\n            map[nums[i]]--;\\n            if(map[nums[i]]==0){\\n                map.erase(nums[i]);\\n            }\\n            sum=sum-nums[i];\\n            i++;\\n            j++;\\n            if(j>=nums.size()) break;\\n            map[nums[j]]++;\\n            sum=sum+nums[j];\\n            if(map.size()==k) ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long i=0;\\n        long long j=k-1;\\n        \\n        unordered_map< long long, long long> map;\\n         long long sum=0;\\n         long long ans=0;\\n        for( long long z=i;z<=j;z++){\\n            sum+=nums[z];\\n            map[nums[z]]++;\\n        }\\n        if(map.size()==k) ans=sum;\\n        \\n        while(j<nums.size()){\\n            map[nums[i]]--;\\n            if(map[nums[i]]==0){\\n                map.erase(nums[i]);\\n            }\\n            sum=sum-nums[i];\\n            i++;\\n            j++;\\n            if(j>=nums.size()) break;\\n            map[nums[j]]++;\\n            sum=sum+nums[j];\\n            if(map.size()==k) ans=max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785094,
                "title": "sliding-window-and-hashmap-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor validity check use HashMap\\n                First choose k elements\\n                Use sliding window techq everytime remove elements from left and add from right\\n                if frequency becomes 0 then remove it from map\\n\\n# Approach\\nSliding Window\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans = 0;\\n        long currSum = 0;\\n        int n = nums.length;\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        //add first k elements\\n        for(int i = 0 ; i < k ; i++) {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            currSum += (long) nums[i];\\n        }\\n        //if map size is k\\n        if(map.size() == k) ans = currSum;\\n        int left = 0; //which element to be removed\\n        for(int i = k ; i < n ; i++) {\\n            //remove from left and add from right\\n            currSum -= (long)nums[left];\\n            currSum += (long) nums[i];\\n            //remove freq of left\\n            map.put(nums[left],map.get(nums[left])-1);\\n            //if freq of left becomes 0 then remove from map\\n            if(map.get(nums[left]) == 0) map.remove(nums[left]);\\n            //add the current element in map(right)\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            left++;\\n            if(map.size() == k) ans = Math.max(ans,currSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans = 0;\\n        long currSum = 0;\\n        int n = nums.length;\\n        HashMap<Integer,Integer>map = new HashMap<>();\\n        //add first k elements\\n        for(int i = 0 ; i < k ; i++) {\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            currSum += (long) nums[i];\\n        }\\n        //if map size is k\\n        if(map.size() == k) ans = currSum;\\n        int left = 0; //which element to be removed\\n        for(int i = k ; i < n ; i++) {\\n            //remove from left and add from right\\n            currSum -= (long)nums[left];\\n            currSum += (long) nums[i];\\n            //remove freq of left\\n            map.put(nums[left],map.get(nums[left])-1);\\n            //if freq of left becomes 0 then remove from map\\n            if(map.get(nums[left]) == 0) map.remove(nums[left]);\\n            //add the current element in map(right)\\n            map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n            left++;\\n            if(map.size() == k) ans = Math.max(ans,currSum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784356,
                "title": "c-sliding-window-2-pointer-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWhenever a subaaray question comes, try to think about sliding window. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake a map to get the last index of a number. Increment j and if nums[j] is there in the map then update running sum upto a point where nums[j] is not there. If j-i+1 == k which is window size then update ans and then increment i to be ready for next iteration. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long runningSum=0;\\n        long long ans=0; \\n        unordered_map<int,int>mp;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        \\n        while(j<n)\\n        {\\n            if(mp.find(nums[j])!=mp.end())\\n            {\\n                int idx=mp[nums[j]];\\n                while(i<=idx)\\n                {\\n                    runningSum-=nums[i];\\n                    mp.erase(nums[i]);\\n                    i++;\\n                }\\n            }\\n            runningSum+=nums[j];\\n            mp[nums[j]]=j;            \\n            if(j-i+1==k)\\n            {\\n                ans=max(ans,runningSum);\\n                runningSum-=nums[i];\\n                mp.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long runningSum=0;\\n        long long ans=0; \\n        unordered_map<int,int>mp;\\n        int i=0,j=0;\\n        int n=nums.size();\\n        \\n        while(j<n)\\n        {\\n            if(mp.find(nums[j])!=mp.end())\\n            {\\n                int idx=mp[nums[j]];\\n                while(i<=idx)\\n                {\\n                    runningSum-=nums[i];\\n                    mp.erase(nums[i]);\\n                    i++;\\n                }\\n            }\\n            runningSum+=nums[j];\\n            mp[nums[j]]=j;            \\n            if(j-i+1==k)\\n            {\\n                ans=max(ans,runningSum);\\n                runningSum-=nums[i];\\n                mp.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784351,
                "title": "java-4-solutions-map-set-array-sliding-window",
                "content": "### **Please Upvote** :D\\n##### 1. My Brainstorm solution (Using HashMap):\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            if (!map.containsKey(nums[j])) {\\n                map.put(nums[j], j);\\n            }\\n\\n            else {\\n                int a = map.get(nums[j]) + 1;\\n\\n                while (i < a) {\\n                    sum -= nums[i];\\n                    map.remove(nums[i]);\\n                    i++;\\n                }\\n\\n                map.put(nums[j], j);\\n            }\\n\\n            if (j - i + 1 > k) {\\n                sum -= nums[i];\\n                map.remove(nums[i]);\\n                i++;\\n            }\\n\\n            if (map.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\\n***We can see that inside the*** **`else`** ***and*** **`if (j - i + 1 > k)`** ***conditions, the same work is being performed. So we can get rid of this repetition in the following way:***\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            while (map.containsKey(nums[j]) || j - i + 1 > k) {\\n                sum -= nums[i];\\n                map.remove(nums[i]);\\n                i++;\\n            }\\n\\n            map.put(nums[j], j);\\n\\n            if (map.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\\n***The following two solutions incorporates the same algorithm like the solution just above but using other data structures.***\\n##### 2: Using HashSet:\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        int i = 0, j = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n            while (i < j && (set.contains(nums[j]) || set.size() >= k)) {\\n                set.remove(nums[i]);\\n                sum -= nums[i++];\\n            }\\n\\n            set.add(nums[j]);\\n\\n            if (set.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\\n##### 3. Using boolean array for duplicacy check:\\n***This is the fastest solution.***\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        boolean[] freq = new boolean[100001];\\n\\n        long sum  = 0, maxSum = 0;\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            while(freq[nums[j]] || j - i + 1 > k){\\n                freq[nums[i]] = false;\\n                sum -= nums[i];\\n                i++;\\n            }\\n\\n            freq[nums[j]] = true;\\n\\n            if (j - i + 1 == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            if (!map.containsKey(nums[j])) {\\n                map.put(nums[j], j);\\n            }\\n\\n            else {\\n                int a = map.get(nums[j]) + 1;\\n\\n                while (i < a) {\\n                    sum -= nums[i];\\n                    map.remove(nums[i]);\\n                    i++;\\n                }\\n\\n                map.put(nums[j], j);\\n            }\\n\\n            if (j - i + 1 > k) {\\n                sum -= nums[i];\\n                map.remove(nums[i]);\\n                i++;\\n            }\\n\\n            if (map.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            while (map.containsKey(nums[j]) || j - i + 1 > k) {\\n                sum -= nums[i];\\n                map.remove(nums[i]);\\n                i++;\\n            }\\n\\n            map.put(nums[j], j);\\n\\n            if (map.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0, sum = 0;\\n        int i = 0, j = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n            while (i < j && (set.contains(nums[j]) || set.size() >= k)) {\\n                set.remove(nums[i]);\\n                sum -= nums[i++];\\n            }\\n\\n            set.add(nums[j]);\\n\\n            if (set.size() == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(k)\\n```\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        boolean[] freq = new boolean[100001];\\n\\n        long sum  = 0, maxSum = 0;\\n        int i = 0, j = 0;\\n\\n        while (j < nums.length) {\\n            sum += nums[j];\\n\\n            while(freq[nums[j]] || j - i + 1 > k){\\n                freq[nums[i]] = false;\\n                sum -= nums[i];\\n                i++;\\n            }\\n\\n            freq[nums[j]] = true;\\n\\n            if (j - i + 1 == k) maxSum = Math.max(maxSum, sum);\\n            j++;\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784123,
                "title": "c-easy-sliding-window-map",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int i = 0, j = 0;\\n        long long maxi = 0, sum = 0;\\n\\n        while(j < nums.size()){\\n            mp[nums[j]]++;\\n            sum += nums[j];\\n            while(mp.size() > k || mp.size() < j - i + 1){\\n                mp[nums[i]]--;\\n                sum -= nums[i];\\n                if(mp[nums[i]] == 0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            if(mp.size() == j - i + 1 && j - i + 1 == k){\\n                maxi = max(maxi, sum);\\n            }\\n            j++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> mp;\\n        int i = 0, j = 0;\\n        long long maxi = 0, sum = 0;\\n\\n        while(j < nums.size()){\\n            mp[nums[j]]++;\\n            sum += nums[j];\\n            while(mp.size() > k || mp.size() < j - i + 1){\\n                mp[nums[i]]--;\\n                sum -= nums[i];\\n                if(mp[nums[i]] == 0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n            if(mp.size() == j - i + 1 && j - i + 1 == k){\\n                maxi = max(maxi, sum);\\n            }\\n            j++;\\n        }\\n\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784085,
                "title": "best-solution-in-c-hashmap",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum=0,maxi=0;\\n        int i=0,j=0,n=nums.size();\\n        unordered_map<int,int> mp;\\n        while(j<k){\\n            mp[nums[j]]++;\\n            sum+=nums[j++];\\n        }\\n        if(mp.size()==k)\\n            maxi=max(maxi,sum);\\n        while(j<n){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            sum-=nums[i];\\n            mp[nums[i]]--;\\n            if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n            i++;\\n            if(j-i+1==mp.size())\\n                maxi=max(maxi,sum);\\n            j++;\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum=0,maxi=0;\\n        int i=0,j=0,n=nums.size();\\n        unordered_map<int,int> mp;\\n        while(j<k){\\n            mp[nums[j]]++;\\n            sum+=nums[j++];\\n        }\\n        if(mp.size()==k)\\n            maxi=max(maxi,sum);\\n        while(j<n){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            sum-=nums[i];\\n            mp[nums[i]]--;\\n            if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n            i++;\\n            if(j-i+1==mp.size())\\n                maxi=max(maxi,sum);\\n            j++;\\n            \\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783815,
                "title": "python-3-hashmap-sliding-window-o-n",
                "content": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        hm = defaultdict(int) #to store the elements of the sliding window.\\n        \\n        total = 0\\n\\t\\tres = 0 \\n        for i in range(k):\\n            hm[nums[i]] += 1\\n            total += nums[i]\\n        \\n\\t\\t# if all keys of the hashmap(elements of window) are distinct, then store their sum in res.\\n        if len(hm) == k:\\n            res = total\\n            \\n        for i in range(k, len(nums)):\\n\\t\\t\\tadd = nums[i] #element to add in the window.\\n            remo = nums[i - k] #element to remove from window.\\n            \\n\\t\\t\\thm[add] += 1\\n            hm[remo] -= 1\\n            if hm[remo] == 0:\\n                hm.pop(remo)\\n                \\n\\t\\t\\ttotal += add\\n            total -= remo\\n            \\n\\t\\t\\t# if all keys of the hashmap(elements of window) are distinct,\\n\\t\\t\\t# then take max of res and total(sum of current window)\\n            if len(hm) == k:\\n                res = max(res, total)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        hm = defaultdict(int) #to store the elements of the sliding window.\\n        \\n        total = 0\\n\\t\\tres = 0 \\n        for i in range(k):\\n            hm[nums[i]] += 1\\n            total += nums[i]\\n        \\n\\t\\t# if all keys of the hashmap(elements of window) are distinct, then store their sum in res.\\n        if len(hm) == k:\\n            res = total\\n            \\n        for i in range(k, len(nums)):\\n\\t\\t\\tadd = nums[i] #element to add in the window.\\n            remo = nums[i - k] #element to remove from window.\\n            \\n\\t\\t\\thm[add] += 1\\n            hm[remo] -= 1\\n            if hm[remo] == 0:\\n                hm.pop(remo)\\n                \\n\\t\\t\\ttotal += add\\n            total -= remo\\n            \\n\\t\\t\\t# if all keys of the hashmap(elements of window) are distinct,\\n\\t\\t\\t# then take max of res and total(sum of current window)\\n            if len(hm) == k:\\n                res = max(res, total)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783725,
                "title": "optimal-sliding-window",
                "content": "# Intuition\\nTalking about subarray with conditon we can apply sliding windows.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo keep track of the distinct numbers we create a map `pre` to mark the presence or absence of a number.\\nThen we apply simple Sliding Window checking for the condition of removal as `pre[nums[l]] || l - r == k`.\\nAnd updating the `global` ansere when the size condition is satified.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`* \\n\\n>`pre` array has a constant sapce as it\\'s size if fixed `1e5 + 1`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long global, local;\\n        global = local = 0;\\n        \\n        bool pre[(int)(1e5 + 1)] = {false};\\n        \\n        int l, r, n = nums.size();\\n\\n        for(l = r = 0; l < n; l++) {\\n            local += nums[l];\\n            while(pre[nums[l]] || l - r == k) {\\n                local -= nums[r];\\n                pre[nums[r++]] = false;\\n            }\\n            pre[nums[l]] = true;\\n\\n            if(l - r + 1 == k)\\n                global = max(global, local);\\n        }\\n        \\n        return global;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long global, local;\\n        global = local = 0;\\n        \\n        bool pre[(int)(1e5 + 1)] = {false};\\n        \\n        int l, r, n = nums.size();\\n\\n        for(l = r = 0; l < n; l++) {\\n            local += nums[l];\\n            while(pre[nums[l]] || l - r == k) {\\n                local -= nums[r];\\n                pre[nums[r++]] = false;\\n            }\\n            pre[nums[l]] = true;\\n\\n            if(l - r + 1 == k)\\n                global = max(global, local);\\n        }\\n        \\n        return global;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783609,
                "title": "prefix-sum-hashmap-java",
                "content": "# Intuition\\nWe need to find subarrays of lenth k and it should not have duplicates. So we can maintain Hashmap to find the index that is causing the duplicates, and those duplicates would be an issue only when they are in the window we are currently considering.  \\n\\n# Approach\\nNeed to maintain Hashmap to know the duplicates and the index at which duplicates are occured. Maintain left and right pointers to find the window and Update left pointer whenever we find the dupicate within the window. Also update left when window size is more than k. Once we know there is no duplicate in the window and size of window is k we need to find the sum. We can find this sum using the prefix sum array.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] sf = new long[n];\\n        sf[0] = nums[0]; //Storing prefix sum\\n        for(int i =1; i<n; i++){\\n            sf[i] = sf[i-1] + nums[i];\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int left = 0;\\n        int right = 0;\\n        long res = 0;  \\n        while(right < n){\\n\\n//If left is behind duplicate element, move past duplicate element.\\n            if(map.containsKey(nums[right]) && left <= map.get(nums[right]) ){\\n                left = map.get(nums[right]) + 1;\\n            }\\n\\n//If window size greater than k, move left by 1.\\n            if(right - left >= k){\\n                left++;    \\n            }\\n\\n//If window size equal to k, compare with result and update it.  \\n            if(right - left == k-1){\\n                if(left != 0)\\n                res = Math.max(sf[right] - sf[left - 1], res);\\n                else{\\n                    res = Math.max(sf[right], res);\\n                }\\n            }\\n            \\n\\n            \\n            map.put(nums[right], right);\\n            right++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        long[] sf = new long[n];\\n        sf[0] = nums[0]; //Storing prefix sum\\n        for(int i =1; i<n; i++){\\n            sf[i] = sf[i-1] + nums[i];\\n        }\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        \\n        int left = 0;\\n        int right = 0;\\n        long res = 0;  \\n        while(right < n){\\n\\n//If left is behind duplicate element, move past duplicate element.\\n            if(map.containsKey(nums[right]) && left <= map.get(nums[right]) ){\\n                left = map.get(nums[right]) + 1;\\n            }\\n\\n//If window size greater than k, move left by 1.\\n            if(right - left >= k){\\n                left++;    \\n            }\\n\\n//If window size equal to k, compare with result and update it.  \\n            if(right - left == k-1){\\n                if(left != 0)\\n                res = Math.max(sf[right] - sf[left - 1], res);\\n                else{\\n                    res = Math.max(sf[right], res);\\n                }\\n            }\\n            \\n\\n            \\n            map.put(nums[right], right);\\n            right++;\\n        }\\n        \\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783582,
                "title": "c-solution-using-map-easy-to-understand",
                "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        // <length of the sub is equals to k\\n     unordered_set<int> s;\\n    long long l = 0, res = 0, sum = 0;\\n    for(int r = 0; r<nums.size(); r++)\\n    {\\n        while(l < r && (s.count(nums[r]) || s.size() >= k))\\n        {\\n            sum -= nums[l];\\n            s.erase(nums[l]);\\n            l++;\\n        }\\n        sum +=nums[r];\\n        s.insert(nums[r]);\\n            \\n        if (s.size() == k)\\n            res = max(res, sum);\\n    }\\n     return res;\\n    }\\n};\\nGuys if you have any query so comment below and if you like the solution so plz Up Vote !!",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        // <length of the sub is equals to k\\n     unordered_set<int> s;\\n    long long l = 0, res = 0, sum = 0;\\n    for(int r = 0; r<nums.size(); r++)\\n    {\\n        while(l < r && (s.count(nums[r]) || s.size() >= k))\\n        {\\n            sum -= nums[l];\\n            s.erase(nums[l]);\\n            l++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2783507,
                "title": "c-time-o-n-easy-map-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,sum=0;\\n        map<int,int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i]; \\n            s[nums[i]]++;\\n            if(i+1>=k)\\n            {\\n                if(s.size()==k)\\n                {\\n                   ans=max(sum,ans); \\n                }\\n                sum-=nums[i-k+1];\\n                if(s[nums[i-k+1]]>1)\\n                    s[nums[i-k+1]]--;\\n                else\\n                    s.erase(nums[i-k+1]);\\n            }                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,sum=0;\\n        map<int,int> s;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i]; \\n            s[nums[i]]++;\\n            if(i+1>=k)\\n            {\\n                if(s.size()==k)\\n                {\\n                   ans=max(sum,ans); \\n                }\\n                sum-=nums[i-k+1];\\n                if(s[nums[i-k+1]]>1)\\n                    s[nums[i-k+1]]--;\\n                else\\n                    s.erase(nums[i-k+1]);\\n            }                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783468,
                "title": "sliding-window-with-updates-100-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo have a sliding window and keep tracking of running sum and the context of the window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe update the `max_total` under the criteria of:\\n* The window has unique values (size == k)\\n* Current running sum greater than current `max_total`\\n\\n### Why introduce a \"size\"\\nBecause the operation of check the windows lenght will take up to `O(k)` in each iteration. If we using `size` to track that. The update would be done within `O(1)`\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(k)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        window = Counter(nums[:k])\\n        size = len(window)\\n        n = len(nums)\\n        running = sum(nums[:k])\\n        max_total = running if size == k else 0\\n\\n        for i in range(k, n):\\n            out, v = nums[i-k], nums[i]\\n            window[out] -= 1\\n            if window[out] == 0:\\n                window.pop(out)\\n                size -= 1\\n            \\n            if v in window:\\n                window[v] += 1\\n            else:\\n                window[v] = 1\\n                size += 1\\n            \\n            running = running + v - out\\n            #print(f\"{i}: {nums[i]}; {running} | {window}\")\\n            if size == k and running > max_total:\\n                max_total = running\\n\\n        return max_total\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        window = Counter(nums[:k])\\n        size = len(window)\\n        n = len(nums)\\n        running = sum(nums[:k])\\n        max_total = running if size == k else 0\\n\\n        for i in range(k, n):\\n            out, v = nums[i-k], nums[i]\\n            window[out] -= 1\\n            if window[out] == 0:\\n                window.pop(out)\\n                size -= 1\\n            \\n            if v in window:\\n                window[v] += 1\\n            else:\\n                window[v] = 1\\n                size += 1\\n            \\n            running = running + v - out\\n            #print(f\"{i}: {nums[i]}; {running} | {window}\")\\n            if size == k and running > max_total:\\n                max_total = running\\n\\n        return max_total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783463,
                "title": "java-solution-using-set-sliding-window",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, maxSum = 0;\\n        int i = 0, j = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        while(j < nums.length){\\n            if(j - i < k && hs.size() < k){\\n                while(hs.size()>0 && hs.contains(nums[j])){\\n                    sum -= nums[i];\\n                    hs.remove(nums[i++]);\\n                }\\n                sum+=nums[j];\\n                hs.add(nums[j]);\\n                j++;\\n            }else{\\n                if(j - i == k && hs.size() == k){\\n                    maxSum = Math.max(maxSum , sum);\\n                    \\n                }\\n                sum-=nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            \\n        }\\n        \\n        if(j - i == k && hs.size() == k){\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        \\n        return maxSum;\\n            \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, maxSum = 0;\\n        int i = 0, j = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        while(j < nums.length){\\n            if(j - i < k && hs.size() < k){\\n                while(hs.size()>0 && hs.contains(nums[j])){\\n                    sum -= nums[i];\\n                    hs.remove(nums[i++]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2783313,
                "title": "2461-maximum-sum-of-distinct-subarrays-with-length-k",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long maximumSubarraySum(vector<int>& s, int k) {\\n\\n\\t\\t\\t\\tmap<int, int> mp;\\n\\n\\t\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\t\\tlong long int maxi = 0, sum = 0;\\n\\n\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\twhile(j < s.size()) {\\n\\n\\t\\t\\t\\t\\tmp[s[j]]++;\\n\\t\\t\\t\\t\\tsum += s[j];\\n\\n\\t\\t\\t\\tif(mp[s[j]] == 1) cnt++;\\n\\n\\t\\t\\t\\tif(j - i + 1 == k) {\\n\\t\\t\\t\\t\\tif(cnt == j - i + 1) {\\n\\t\\t\\t\\t\\t\\tmaxi = max(maxi, sum);\\n\\t\\t\\t\\t\\t\\tmp[s[i]]--;\\n\\t\\t\\t\\t\\t\\tif(mp[s[i]] == 0) cnt--;\\n\\t\\t\\t\\t\\t\\tsum -= s[i];\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\t\\tcout << sum << \" \";\\n\\t\\t\\t\\t\\t\\tmp[s[i]]--;\\n\\t\\t\\t\\t\\t\\tif(mp[s[i]] == 0) cnt--;\\n\\t\\t\\t\\t\\t\\tsum -= s[i];\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Array",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tlong long maximumSubarraySum(vector<int>& s, int k) {\\n\\n\\t\\t\\t\\tmap<int, int> mp;\\n\\n\\t\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\t\\tlong long int maxi = 0, sum = 0;\\n\\n\\t\\t\\t\\tint cnt = 0;\\n\\n\\t\\t\\t\\twhile(j < s.size()) {\\n\\n\\t\\t\\t\\t\\tmp[s[j]]++;\\n\\t\\t\\t\\t\\tsum += s[j];\\n\\n\\t\\t\\t\\tif(mp[s[j]] == 1) cnt++;\\n\\n\\t\\t\\t\\tif(j - i + 1 == k) {\\n\\t\\t\\t\\t\\tif(cnt == j - i + 1) {\\n\\t\\t\\t\\t\\t\\tmaxi = max(maxi, sum);\\n\\t\\t\\t\\t\\t\\tmp[s[i]]--;\\n\\t\\t\\t\\t\\t\\tif(mp[s[i]] == 0) cnt--;\\n\\t\\t\\t\\t\\t\\tsum -= s[i];\\n\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2783188,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n < k) {\\n            return 0;\\n        }\\n        long res = 0;\\n        long sum = 0;\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int right = 0, left = 0; right < n; right++) {\\n            int curr = nums[right];\\n            while (seen.contains(curr) || seen.size() == k) {\\n                seen.remove(nums[left]);\\n                sum -= nums[left];\\n                left++;\\n            }\\n            seen.add(curr);\\n            sum += curr;\\n            if (seen.size() == k && sum > res) {\\n                res = sum;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int n = nums.length;\\n        if (n < k) {\\n            return 0;\\n        }\\n        long res = 0;\\n        long sum = 0;\\n        HashSet<Integer> seen = new HashSet<>();\\n        for (int right = 0, left = 0; right < n; right++) {\\n            int curr = nums[right];\\n            while (seen.contains(curr) || seen.size() == k) {\\n                seen.remove(nums[left]);\\n                sum -= nums[left];\\n                left++;\\n            }\\n            seen.add(curr);\\n            sum += curr;\\n            if (seen.size() == k && sum > res) {\\n                res = sum;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783162,
                "title": "c-sliding-window-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,sum=0;\\n        int i=0,j=0;\\n        set<int> st;\\n        while(i<nums.size()){\\n            if(i-j<k && st.size()<k){\\n                while(st.size()>0 && st.count(nums[i])>0){\\n                    sum -= nums[j];\\n                    st.erase(nums[j++]);\\n                }\\n                sum += nums[i];\\n                st.insert(nums[i++]);\\n            }else{\\n                if(i-j==k && st.size()==k){\\n                    ans=max(ans,sum);\\n                }\\n                sum -= nums[j];\\n                st.erase(nums[j++]);\\n            }\\n        }\\n        if(i-j==k && st.size()==k)\\n        ans = max(ans,sum);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,sum=0;\\n        int i=0,j=0;\\n        set<int> st;\\n        while(i<nums.size()){\\n            if(i-j<k && st.size()<k){\\n                while(st.size()>0 && st.count(nums[i])>0){\\n                    sum -= nums[j];\\n                    st.erase(nums[j++]);\\n                }\\n                sum += nums[i];\\n                st.insert(nums[i++]);\\n            }else{\\n                if(i-j==k && st.size()==k){\\n                    ans=max(ans,sum);\\n                }\\n                sum -= nums[j];\\n                st.erase(nums[j++]);\\n            }\\n        }\\n        if(i-j==k && st.size()==k)\\n        ans = max(ans,sum);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783142,
                "title": "java-sliding-window-hashmap-with-explanation",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long sum=0;\\n        long max=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        while(j<nums.length){\\n            sum+=nums[j]; /*Keep on doing the sum*/\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1); /*Keep on adding to hashmap and keep\\n\\t\\t\\t                                               on counting it\\'s frequency*/\\n            if(j-i+1<k)\\n                j++; //Keep on going forward if it has not hit the window size k\\n            else if(j-i+1==k){\\n                if(hm.size()==k)  /*If we hit the window size then we will check if there is \\n\\t\\t\\t                    \\tdistinct element exactly k times. If we have then we will find\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthe max of sums of every window that has exactly k distinct \\n\\t\\t\\t\\t\\t\\t\\t\\t\\telements in the subarray.*/\\n                    max=Math.max(max,sum);\\n                sum-=nums[i]; /*Then after the window size is k and after computing the max \\n\\t\\t\\t\\t                that has distinct k elements, we delete it from front by removing \\n\\t\\t\\t\\t\\t\\t\\t\\tthat element from the sum and also decreasing it\\'s frequency by 1 \\n\\t\\t\\t\\t\\t\\t\\t\\tfrom the hashmap. If any element\\'s frequency comes out to be 0 then we \\n\\t\\t\\t\\t\\t\\t\\t\\tremove it from hashmap as it doesnt exist anymore in the window */\\n                hm.put(nums[i],hm.get(nums[i])-1);\\n                if(hm.get(nums[i])==0)\\n                    hm.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```\\n**UPVOTE IF YOU LIKED THE APPROACH \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long sum=0;\\n        long max=0;\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        while(j<nums.length){\\n            sum+=nums[j]; /*Keep on doing the sum*/\\n            hm.put(nums[j],hm.getOrDefault(nums[j],0)+1); /*Keep on adding to hashmap and keep\\n\\t\\t\\t                                               on counting it\\'s frequency*/\\n            if(j-i+1<k)\\n                j++; //Keep on going forward if it has not hit the window size k\\n            else if(j-i+1==k){\\n                if(hm.size()==k)  /*If we hit the window size then we will check if there is \\n\\t\\t\\t                    \\tdistinct element exactly k times. If we have then we will find\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tthe max of sums of every window that has exactly k distinct \\n\\t\\t\\t\\t\\t\\t\\t\\t\\telements in the subarray.*/\\n                    max=Math.max(max,sum);\\n                sum-=nums[i]; /*Then after the window size is k and after computing the max \\n\\t\\t\\t\\t                that has distinct k elements, we delete it from front by removing \\n\\t\\t\\t\\t\\t\\t\\t\\tthat element from the sum and also decreasing it\\'s frequency by 1 \\n\\t\\t\\t\\t\\t\\t\\t\\tfrom the hashmap. If any element\\'s frequency comes out to be 0 then we \\n\\t\\t\\t\\t\\t\\t\\t\\tremove it from hashmap as it doesnt exist anymore in the window */\\n                hm.put(nums[i],hm.get(nums[i])-1);\\n                if(hm.get(nums[i])==0)\\n                    hm.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n            \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783125,
                "title": "easy-and-best-solution-in-c-using-set",
                "content": "Please UpVotes\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUsing Setset\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        int j = 0;\\n        int cnt = 0;\\n        long long ans = 0;\\n        set<int>st;\\n        for(int i = 0;i<nums.size();i++){\\n            sum+=nums[i];\\n            cout<<sum<<\" \";\\n            if(st.find(nums[i])!=st.end()){\\n                sum = nums[i];\\n                j = i;\\n                cnt=1;\\n                st.clear();\\n                st.insert(nums[i]);\\n            }else{\\n                st.insert(nums[i]);\\n                cnt++;\\n            }\\n            if(cnt == k){\\n                ans = max(sum,ans);\\n                cnt--;\\n                st.erase(nums[j]);\\n                sum-=nums[j];\\n                j++;\\n                \\n            }\\n        }\\n        // ans = max(sum,ans);\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long sum = 0;\\n        int j = 0;\\n        int cnt = 0;\\n        long long ans = 0;\\n        set<int>st;\\n        for(int i = 0;i<nums.size();i++){\\n            sum+=nums[i];\\n            cout<<sum<<\" \";\\n            if(st.find(nums[i])!=st.end()){\\n                sum = nums[i];\\n                j = i;\\n                cnt=1;\\n                st.clear();\\n                st.insert(nums[i]);\\n            }else{\\n                st.insert(nums[i]);\\n                cnt++;\\n            }\\n            if(cnt == k){\\n                ans = max(sum,ans);\\n                cnt--;\\n                st.erase(nums[j]);\\n                sum-=nums[j];\\n                j++;\\n                \\n            }\\n        }\\n        // ans = max(sum,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2783114,
                "title": "easy-c-solution-using-sliding-window-and-unordered-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n       long long maximumSubarraySum(vector<int> &nums, int k)\\n       {\\n              unordered_map<int, int> mapping;\\n\\n              long long currentSum = 0;\\n              long long maximumSum = 0;\\n\\n              for (int i = 0; i < k; i++)\\n              {\\n                     currentSum += nums[i];\\n                     mapping[nums[i]]++;\\n              }\\n\\n              if (mapping.size() == k)\\n              {\\n                     maximumSum = currentSum;\\n              }\\n\\n              for (int i = k; i < nums.size(); i++)\\n              {\\n                     currentSum -= nums[i - k];\\n                     currentSum += nums[i];\\n\\n                     mapping[nums[i - k]]--;\\n\\n                     if (mapping[nums[i - k]] == 0)\\n                     {\\n                            mapping.erase(nums[i - k]);\\n                     }\\n\\n                     mapping[nums[i]]++;\\n\\n                     if (mapping.size() == k)\\n                     {\\n                            maximumSum = max(currentSum, maximumSum);\\n                     }\\n              }\\n\\n              return maximumSum;\\n       }\\n};\\n```\\n\\n**Please upvote if you found this helpful!!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n       long long maximumSubarraySum(vector<int> &nums, int k)\\n       {\\n              unordered_map<int, int> mapping;\\n\\n              long long currentSum = 0;\\n              long long maximumSum = 0;\\n\\n              for (int i = 0; i < k; i++)\\n              {\\n                     currentSum += nums[i];\\n                     mapping[nums[i]]++;\\n              }\\n\\n              if (mapping.size() == k)\\n              {\\n                     maximumSum = currentSum;\\n              }\\n\\n              for (int i = k; i < nums.size(); i++)\\n              {\\n                     currentSum -= nums[i - k];\\n                     currentSum += nums[i];\\n\\n                     mapping[nums[i - k]]--;\\n\\n                     if (mapping[nums[i - k]] == 0)\\n                     {\\n                            mapping.erase(nums[i - k]);\\n                     }\\n\\n                     mapping[nums[i]]++;\\n\\n                     if (mapping.size() == k)\\n                     {\\n                            maximumSum = max(currentSum, maximumSum);\\n                     }\\n              }\\n\\n              return maximumSum;\\n       }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981815,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAdded print statements to follow trail, feel free to remove!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    extend window\\n    if we see duplicate, reset window\\n    if at max length, check for new maximum sum and reset window\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        curr= 0\\n        res=set()\\n\\n        for i in range(len(nums)):\\n            if nums[i] not in res:\\n                if len(res)<k:\\n                    res.add(nums[i])\\n                    # print(res)\\n                    curr+=nums[i]\\n                    # print(\"ans =\", curr)\\n                if len(res)==k:\\n                    ans= max(ans, curr)\\n                    curr-= nums[i-k+1]\\n                    res.remove(nums[i-k+1])\\n                    # print(res)\\n            else:\\n                res = {nums[i-1], nums[i]}\\n                # print(res)\\n                curr = sum(res)\\n                # print(\"ans =\", curr)\\n        return ans\\n\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        curr= 0\\n        res=set()\\n\\n        for i in range(len(nums)):\\n            if nums[i] not in res:\\n                if len(res)<k:\\n                    res.add(nums[i])\\n                    # print(res)\\n                    curr+=nums[i]\\n                    # print(\"ans =\", curr)\\n                if len(res)==k:\\n                    ans= max(ans, curr)\\n                    curr-= nums[i-k+1]\\n                    res.remove(nums[i-k+1])\\n                    # print(res)\\n            else:\\n                res = {nums[i-1], nums[i]}\\n                # print(res)\\n                curr = sum(res)\\n                # print(\"ans =\", curr)\\n        return ans\\n\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968827,
                "title": "simple-easy-solution-with-comments",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0 , j = 0 , n = nums.size();\\n        long long ans = 0 , sum = 0;\\n        unordered_map<int,int> m;\\n\\n        while(j < n){\\n            m[nums[j]]++;\\n            sum+=nums[j];\\n\\n            if((j-i+1) < k){\\n                j++;\\n            }\\n            else{\\n                // if size == k means all elements are unique\\n                if(m.size() == k){\\n                    ans = max(ans,sum);\\n                }\\n\\n                sum-=nums[i];\\n                m[nums[i]]--;\\n\\n                // if ith element frequency is 0 then erase that element otherwise it will be counted in m.size()\\n                if(m[nums[i]] == 0){\\n                    m.erase(nums[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0 , j = 0 , n = nums.size();\\n        long long ans = 0 , sum = 0;\\n        unordered_map<int,int> m;\\n\\n        while(j < n){\\n            m[nums[j]]++;\\n            sum+=nums[j];\\n\\n            if((j-i+1) < k){\\n                j++;\\n            }\\n            else{\\n                // if size == k means all elements are unique\\n                if(m.size() == k){\\n                    ans = max(ans,sum);\\n                }\\n\\n                sum-=nums[i];\\n                m[nums[i]]--;\\n\\n                // if ith element frequency is 0 then erase that element otherwise it will be counted in m.size()\\n                if(m[nums[i]] == 0){\\n                    m.erase(nums[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920443,
                "title": "using-stl-map-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought : Another sliding window problem. Could be improvised with sets. Thinking the solution, realising set won\\'t be enough for multiple occurence. Shift to maps for improvising sliding window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nImplement sliding window and use maps to check the distinct element condition. \\n\\nSteps: \\n1. Find the sum of first subArray.\\n2. Check if all the elements were distinct. \\n3. Maintain two flags to keep record of current subarray and prev subarray distinct element condition.\\n4. If current subarray has all the distinct elements, compare the current sum with ans.\\n5. If prev subarray was not having distinct elements, run a loop to check the map in current iteration. \\n6. If map has any value greater than 1, set status to false.\\n7. Update the prevFlag and currentFlag in each loop.\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        bool prevFlag = true, flag = true;\\n        long long ans = 0, subSum = 0;\\n\\n        unordered_map<int, int> mp;\\n\\n        for (int i = 0; i < k; ++i)\\n        {\\n            if (mp[nums[i]]++) flag = false;\\n            subSum += nums[i];\\n        }\\n        \\n        if (flag) ans = max(ans, subSum);\\n\\n        prevFlag = flag;\\n        flag = true;\\n\\n        for (int i = k; i < n; ++i)\\n        {\\n            subSum += (nums[i] - nums[i-k]);\\n\\n            // Check Distinct Element\\n            mp[nums[i-k]]--;\\n            if (mp[nums[i]]++) flag = false;\\n            if (!prevFlag && flag) {\\n                for(auto &it: mp) {\\n                    if (it.second > 1) \\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (flag) ans = max(ans, subSum);\\n\\n            prevFlag = flag;\\n            flag = true;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\nCode is pretty much self explanatory, but if you still need help, comment your doubts. \\n\\nHope we learn something here.",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n\\n        bool prevFlag = true, flag = true;\\n        long long ans = 0, subSum = 0;\\n\\n        unordered_map<int, int> mp;\\n\\n        for (int i = 0; i < k; ++i)\\n        {\\n            if (mp[nums[i]]++) flag = false;\\n            subSum += nums[i];\\n        }\\n        \\n        if (flag) ans = max(ans, subSum);\\n\\n        prevFlag = flag;\\n        flag = true;\\n\\n        for (int i = k; i < n; ++i)\\n        {\\n            subSum += (nums[i] - nums[i-k]);\\n\\n            // Check Distinct Element\\n            mp[nums[i-k]]--;\\n            if (mp[nums[i]]++) flag = false;\\n            if (!prevFlag && flag) {\\n                for(auto &it: mp) {\\n                    if (it.second > 1) \\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if (flag) ans = max(ans, subSum);\\n\\n            prevFlag = flag;\\n            flag = true;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648838,
                "title": "unique-solution-using-java",
                "content": "# UPVOTE THIS IF U FIND IT IS HELPFUL\\n\\nThis question is based on fixed **slide window **based question:\\n\\n* **Concept** - To have uniquess best concept is of map so here is use of **hashmap** + **sliding window concept``**\\n\\n### *same template is used in every slide fixed window*\\n\\nwhile(j<n){\\n//calculations//\\nif(j-i+1<k)\\nj++;\\nelse\\n{\\n// calculations\\n// remove calculations of ith index\\n// slide window using\\ni++;\\nj++;\\n}\\n\\n\\n\\n### Code based on above template\\n\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n         int i=0,j=0,n=nums.length,p=0;\\n        long ans=0,s=0;\\n\\n        \\n        while(j<n){\\n            map.merge(nums[j],1,(o,v)->o+v);\\n            \\n            s=s+(long)nums[j];\\n            if(j-i+1<k)\\n                j++;\\n            else\\n            {\\n              //  System.out.println(map);\\n                if(map.size()==k)\\n                    ans=Math.max(s,ans);\\n                \\n                int val=map.get(nums[i]);\\n                val--;\\n                if(val==0)\\n                    map.remove(nums[i]);\\n                else\\n                map.put(nums[i],val);\\n                \\n                s=s-(long)nums[i];\\n                \\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n         int i=0,j=0,n=nums.length,p=0;\\n        long ans=0,s=0;\\n\\n        \\n        while(j<n){\\n            map.merge(nums[j],1,(o,v)->o+v);\\n            \\n            s=s+(long)nums[j];\\n            if(j-i+1<k)\\n                j++;\\n            else\\n            {\\n              //  System.out.println(map);\\n                if(map.size()==k)\\n                    ans=Math.max(s,ans);\\n                \\n                int val=map.get(nums[i]);\\n                val--;\\n                if(val==0)\\n                    map.remove(nums[i]);\\n                else\\n                map.put(nums[i],val);\\n                \\n                s=s-(long)nums[i];\\n                \\n                \\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3584847,
                "title": "easy-solution-using-hash-map-and-sliding-window-concept",
                "content": "```\\n\\n```\\'\\'\\'\\nlong long n=nums.size(),i=0,j=0;\\n        if(k==0 || n<k)  // base condition\\n            return 0;\\n        unordered_map<long long,long long> mp;\\n        long long sum=0,maxi=0;     // maxi needs to be initialized with zero and not INT_MIN. (acc. to ques)\\n        while(j<n){  \\n            if(j-i+1>k){         // if window size exceeds k\\n                sum-=nums[i];    //  remove leftmost element\\n                mp[nums[i]]--; \\n                i++;\\n            }\\n            if(mp[nums[j]]==0){  // distinct element upcoming\\n                \\n                if(j-i+1<k){     // if window size less then k\\n                   sum+=nums[j]; \\n                }\\n                else if(j-i+1==k){   // max window size reached\\n                    sum+=nums[j];\\n                    maxi=max(maxi,sum);  // store sum in max\\n                }\\n                mp[nums[j]]++;       // increment the count of this element in map\\n            }\\n            else{\\n                mp[nums[j]]++;  // if not unique, include it in map and iterate till it is unique in subaray\\n                \\n                while(mp[nums[j]]!=1){  // till the element not becomes unique\\n                    sum-=nums[i];   // remove all frontier elements\\n                    mp[nums[i]]--;\\n                    i++;\\n                }\\n                sum+=nums[j];      // after it becomes unique, add it in the sum and move further\\n            } \\n            j++;\\n        }\\n        return maxi;\\n\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579426,
                "title": "sliding-window-easy-code-in-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nApproach is simple apply sliding window and keep counts of unique elements in each window by using a map.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& arr, int k) {\\n        long long ans = 0,sum = 0;\\n        int n = arr.size();\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<k;i++)\\n        {\\n           sum+=arr[i];\\n           mp[arr[i]]++;\\n        }\\n        if(mp.size()==k) ans = max(ans,sum);\\n        for(int i = k;i<n;i++)\\n        {\\n            mp[arr[i-k]]--;\\n            mp[arr[i]]++;\\n            sum-=arr[i-k];\\n            sum+=arr[i];\\n            if(mp[arr[i-k]]==0) mp.erase(arr[i-k]);\\n            if(mp.size()==k) ans = max(sum,ans);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& arr, int k) {\\n        long long ans = 0,sum = 0;\\n        int n = arr.size();\\n        unordered_map<int,int> mp;\\n        for(int i = 0;i<k;i++)\\n        {\\n           sum+=arr[i];\\n           mp[arr[i]]++;\\n        }\\n        if(mp.size()==k) ans = max(ans,sum);\\n        for(int i = k;i<n;i++)\\n        {\\n            mp[arr[i-k]]--;\\n            mp[arr[i]]++;\\n            sum-=arr[i-k];\\n            sum+=arr[i];\\n            if(mp[arr[i-k]]==0) mp.erase(arr[i-k]);\\n            if(mp.size()==k) ans = max(sum,ans);\\n        }\\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543719,
                "title": "sliding-window-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse a map to store the frequency and apply sliding window to move further.every time we strike window size=k,we check our map and update.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif map size==k implies all elements are unique for j-i+1==k,else if it is less than k implies there must be duplicate. for efficiency we shift  from left till we get all unique elements in the map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(k)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<long long,long long >mp;\\n        long long i=0,j=0;\\n        long long  sum=0,temp=0;\\n\\n\\n        while(j<nums.size())\\n        {\\n           temp+=nums[j];\\n           mp[nums[j]]++;\\n           if(j-i+1!=k)\\n           j++;\\n\\n           else if(j-i+1==k)\\n           {\\n               if(mp.size()==k)\\n               {\\n                   sum=max(temp,sum);\\n                   mp[nums[i]]--;\\n                   if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                   temp-=nums[i];\\n                   i++;\\n               }\\n               else\\n               {\\n                   while(mp.size()!=j-i+1)\\n                   {\\n                       mp[nums[i]]--;\\n                       if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                        temp-=nums[i];\\n                        i++;\\n                   }\\n               }\\n               j++;\\n\\n           }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<long long,long long >mp;\\n        long long i=0,j=0;\\n        long long  sum=0,temp=0;\\n\\n\\n        while(j<nums.size())\\n        {\\n           temp+=nums[j];\\n           mp[nums[j]]++;\\n           if(j-i+1!=k)\\n           j++;\\n\\n           else if(j-i+1==k)\\n           {\\n               if(mp.size()==k)\\n               {\\n                   sum=max(temp,sum);\\n                   mp[nums[i]]--;\\n                   if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                   temp-=nums[i];\\n                   i++;\\n               }\\n               else\\n               {\\n                   while(mp.size()!=j-i+1)\\n                   {\\n                       mp[nums[i]]--;\\n                       if(mp[nums[i]]==0)\\n                        mp.erase(nums[i]);\\n                        temp-=nums[i];\\n                        i++;\\n                   }\\n               }\\n               j++;\\n\\n           }\\n            \\n        }\\n\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505862,
                "title": "java-hashmap",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans = 0;\\n        int i = 0, j = 0, n = nums.length;\\n        long temp = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        while(j < n){\\n            int num  = nums[j];\\n            temp+=num;\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n                \\n            if( j -i+1<k){\\n                j++;\\n            }\\n            else{\\n                if(hm.size()==k){\\n                    ans = Math.max(temp, ans);\\n                }    \\n                temp-=nums[i];\\n                hm.put(nums[i], hm.get(nums[i])-1);\\n                if(hm.get(nums[i]) ==0 )\\n                    hm.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long ans = 0;\\n        int i = 0, j = 0, n = nums.length;\\n        long temp = 0;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        while(j < n){\\n            int num  = nums[j];\\n            temp+=num;\\n            hm.put(num, hm.getOrDefault(num,0)+1);\\n                \\n            if( j -i+1<k){\\n                j++;\\n            }\\n            else{\\n                if(hm.size()==k){\\n                    ans = Math.max(temp, ans);\\n                }    \\n                temp-=nums[i];\\n                hm.put(nums[i], hm.get(nums[i])-1);\\n                if(hm.get(nums[i]) ==0 )\\n                    hm.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482557,
                "title": "map-slidingwindow",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        long int ans=0,currsum=0;;\\n        unordered_map<int,int> mp;\\n\\n        for(j=0;j<nums.size();j++){\\n           \\n           mp[nums[j]]++;\\n           currsum=currsum+nums[j];\\n            // handle duplicates\\n            while(mp[nums[j]]>1){\\n                    if(mp[nums[i]]==1){\\n                        mp.erase(nums[i]);\\n                    } else {\\n                        mp[nums[i]]--;\\n                    }\\n                    currsum=currsum-nums[i];\\n                    i++;\\n            }\\n\\n            // find ans for windowsize k\\n            if(mp.size()==k){\\n                ans=max(ans,currsum);\\n                currsum=currsum-nums[i];\\n                mp.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0,j=0;\\n        long int ans=0,currsum=0;;\\n        unordered_map<int,int> mp;\\n\\n        for(j=0;j<nums.size();j++){\\n           \\n           mp[nums[j]]++;\\n           currsum=currsum+nums[j];\\n            // handle duplicates\\n            while(mp[nums[j]]>1){\\n                    if(mp[nums[i]]==1){\\n                        mp.erase(nums[i]);\\n                    } else {\\n                        mp[nums[i]]--;\\n                    }\\n                    currsum=currsum-nums[i];\\n                    i++;\\n            }\\n\\n            // find ans for windowsize k\\n            if(mp.size()==k){\\n                ans=max(ans,currsum);\\n                currsum=currsum-nums[i];\\n                mp.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343537,
                "title": "c-simple-solution-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int windowStart=0;\\n        long long maxSum=0;\\n        unordered_map<int,int> numFreq;\\n        long long windowSum = 0;\\n        for(int windowEnd =0;windowEnd<nums.size();windowEnd++){\\n            int rightNum = nums[windowEnd];\\n            numFreq[rightNum]++;\\n            windowSum+=rightNum;\\n            // shrink the window\\n            if(windowEnd-windowStart+1>=k){\\n                int leftNum = nums[windowStart++];\\n                // store the value when all elements are distinct\\n                if(k==numFreq.size()){\\n                    maxSum = max(maxSum,windowSum);\\n                }\\n                windowSum-=leftNum;\\n                numFreq[leftNum]--;\\n                if(numFreq[leftNum]==0){\\n                    numFreq.erase(leftNum);\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int windowStart=0;\\n        long long maxSum=0;\\n        unordered_map<int,int> numFreq;\\n        long long windowSum = 0;\\n        for(int windowEnd =0;windowEnd<nums.size();windowEnd++){\\n            int rightNum = nums[windowEnd];\\n            numFreq[rightNum]++;\\n            windowSum+=rightNum;\\n            // shrink the window\\n            if(windowEnd-windowStart+1>=k){\\n                int leftNum = nums[windowStart++];\\n                // store the value when all elements are distinct\\n                if(k==numFreq.size()){\\n                    maxSum = max(maxSum,windowSum);\\n                }\\n                windowSum-=leftNum;\\n                numFreq[leftNum]--;\\n                if(numFreq[leftNum]==0){\\n                    numFreq.erase(leftNum);\\n                }\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194180,
                "title": "javascript-concise-solution",
                "content": "```\\nconst maximumSubarraySum = (n, k) => {\\n  if (new Set(n).size < k) return 0;\\n\\n  let [max, cur, freq] = [0, 0, new Map()];\\n  for (let i = 0; i < n.length; i++) {\\n    const r = n[i];\\n    cur += r;\\n    freq.set(r, (freq.get(r) || 0) + 1);\\n\\n    if (i < k - 1) continue;\\n    if (freq.size == k) max = Math.max(max, cur);\\n\\n    const l = n[i - k + 1];\\n    cur -= l;\\n    freq.set(l, (freq.get(l) || 0) - 1);\\n    if (freq.get(l) === 0) freq.delete(l);\\n  }\\n  return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst maximumSubarraySum = (n, k) => {\\n  if (new Set(n).size < k) return 0;\\n\\n  let [max, cur, freq] = [0, 0, new Map()];\\n  for (let i = 0; i < n.length; i++) {\\n    const r = n[i];\\n    cur += r;\\n    freq.set(r, (freq.get(r) || 0) + 1);\\n\\n    if (i < k - 1) continue;\\n    if (freq.size == k) max = Math.max(max, cur);\\n\\n    const l = n[i - k + 1];\\n    cur -= l;\\n    freq.set(l, (freq.get(l) || 0) - 1);\\n    if (freq.get(l) === 0) freq.delete(l);\\n  }\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171863,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long sum=0;\\n        long long res=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            sum+=nums[i];\\n            m[nums[i]]++; \\n        }\\n        if(m.size()==k)\\n            res=sum;\\n        for(int i=k; i<nums.size(); i++)\\n        {\\n            sum+=nums[i]; \\n            sum-=nums[i-k];\\n            m[nums[i]]++;\\n            m[nums[i-k]]--;\\n            if(m[nums[i-k]]==0)\\n                m.erase(nums[i-k]);\\n            if(m.size()==k)\\n                res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int>m;\\n        long long sum=0;\\n        long long res=0;\\n        for(int i=0; i<k; i++)\\n        {\\n            sum+=nums[i];\\n            m[nums[i]]++; \\n        }\\n        if(m.size()==k)\\n            res=sum;\\n        for(int i=k; i<nums.size(); i++)\\n        {\\n            sum+=nums[i]; \\n            sum-=nums[i-k];\\n            m[nums[i]]++;\\n            m[nums[i-k]]--;\\n            if(m[nums[i-k]]==0)\\n                m.erase(nums[i-k]);\\n            if(m.size()==k)\\n                res=max(res,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046429,
                "title": "crisp-n-clear-o-n-javascript-memory-94-72-meaningful-vars",
                "content": "# Intuition\\nIt has to be solved with O(N) time complexity.\\nstore tempSum\\nfinal sum into maxSum\\n\\n# Approach\\nstore the elements found at what indexes(initConfig)\\nif an element has already been found earlier and met again, then remove array till next meeting point,\\nalso keep storing the total items collected(arraySize). if item collected is equal to K, them refresh the maxSum\\nif array size has exceeded then remove the very first element from the array\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar maximumSubarraySum = function (nums, k) {\\n    let maxSum = 0;\\n    let tempSum = 0;\\n    const initConfig = {};\\n    let childIndex = 0;\\n    let arraySize = 0;\\n    for (let index = 0; index < nums.length; index++) {\\n        if (initConfig[nums[index]] !== undefined) {\\n            const whereItFound = initConfig[nums[index]];\\n            childIndex = index - arraySize;\\n            while (childIndex <= whereItFound) {\\n                initConfig[nums[childIndex]] = undefined;\\n                tempSum -= nums[childIndex++];\\n                arraySize -= 1;\\n            }\\n        }\\n        initConfig[nums[index]] = index;\\n        arraySize += 1;\\n        tempSum += nums[index];\\n        if (arraySize > k) {\\n            initConfig[nums[index - k]] = undefined;\\n            tempSum -= nums[index - k];\\n            arraySize -= 1;\\n        }\\n        if (arraySize === k && maxSum < tempSum) {\\n            maxSum = tempSum;\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumSubarraySum = function (nums, k) {\\n    let maxSum = 0;\\n    let tempSum = 0;\\n    const initConfig = {};\\n    let childIndex = 0;\\n    let arraySize = 0;\\n    for (let index = 0; index < nums.length; index++) {\\n        if (initConfig[nums[index]] !== undefined) {\\n            const whereItFound = initConfig[nums[index]];\\n            childIndex = index - arraySize;\\n            while (childIndex <= whereItFound) {\\n                initConfig[nums[childIndex]] = undefined;\\n                tempSum -= nums[childIndex++];\\n                arraySize -= 1;\\n            }\\n        }\\n        initConfig[nums[index]] = index;\\n        arraySize += 1;\\n        tempSum += nums[index];\\n        if (arraySize > k) {\\n            initConfig[nums[index - k]] = undefined;\\n            tempSum -= nums[index - k];\\n            arraySize -= 1;\\n        }\\n        if (arraySize === k && maxSum < tempSum) {\\n            maxSum = tempSum;\\n        }\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939249,
                "title": "c-map-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake the sum of first k-1 element means sum of the subarray with length 1 less than the subarray length required. Now we continue loop from the k the element and run till the size of the array .\\nWe need to keep the sum of the k-1 elemnts and the frequency of all the k-1 element . Next when we check from the kth element if we sum the kth element in the subarray sum and mark it\\'s frequency along with this if found after this that the freq map length is equal to the the subarray means no duplicate is present then we store the sum in the maxi integer to find the maximum of all. At the same time if the frequency of the starting element of the subarray of length k is 1 then we need to just erase it\\'s frequency and move forward else if the frequency is greater than k then we just decrese the frequnecy continuously. And finally for all the conditional statement we need to erase the starting element from the sum so as to move forward and check for the maximum.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        map<int,int> freq ;\\n        int n=nums.size();\\n        long long int sum=0;\\n        long long int maxi =0;\\n        for(int i=0;i<k-1;i++){\\n           sum=sum+nums[i];\\n           freq[nums[i]]++ ;\\n        }\\n        for(int i=k-1;i<n;i++){\\n            sum+=nums[i];\\n            freq[nums[i]]++ ;\\n            if(freq.size()==k){\\n                maxi = max(maxi , sum);\\n            }\\n            if(freq[nums[i-k+1]]==1){\\n                freq.erase(nums[i-k+1]);\\n            }\\n            else{\\n                freq[nums[i-k+1]]-- ;\\n            }\\n            sum-= nums[i-k+1];\\n        }\\n        return maxi ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        map<int,int> freq ;\\n        int n=nums.size();\\n        long long int sum=0;\\n        long long int maxi =0;\\n        for(int i=0;i<k-1;i++){\\n           sum=sum+nums[i];\\n           freq[nums[i]]++ ;\\n        }\\n        for(int i=k-1;i<n;i++){\\n            sum+=nums[i];\\n            freq[nums[i]]++ ;\\n            if(freq.size()==k){\\n                maxi = max(maxi , sum);\\n            }\\n            if(freq[nums[i-k+1]]==1){\\n                freq.erase(nums[i-k+1]);\\n            }\\n            else{\\n                freq[nums[i-k+1]]-- ;\\n            }\\n            sum-= nums[i-k+1];\\n        }\\n        return maxi ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842431,
                "title": "o-n-solution-using-sliding-window-hashset",
                "content": "# Intuition\\nSliding window standard question(given window size)\\n\\n# Approach\\nUsing hashset because we need distinct elements\\n-> If set contains element remove all the previous elements\\n-> take long because of the given constraint\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i = 0, j = 0, len = nums.length;\\n        long maxSum = 0;\\n        long local = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(j < len) {\\n            //calculations\\n            int curr = nums[j];\\n            local += curr;\\n           \\n            if(set.contains(curr)) {   // if set contains element, remove till we get that element\\n                while(i < j && set.contains(curr)) {\\n                   int first = nums[i++];\\n                   local -= first;\\n                   set.remove(first);\\n                }\\n            } \\n        \\n            if (j - i + 1 < k) {  // smaller than window\\n                set.add(curr);\\n                j++;\\n            } else if (j - i + 1 == k) { // if hit window size\\n                maxSum = Math.max(maxSum, local); // checking max\\n\\n                int first = nums[i];  // removing first adding last\\n                local -= first;\\n                set.remove(first);\\n                set.add(curr);\\n                j++;\\n                i++;\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i = 0, j = 0, len = nums.length;\\n        long maxSum = 0;\\n        long local = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n\\n        while(j < len) {\\n            //calculations\\n            int curr = nums[j];\\n            local += curr;\\n           \\n            if(set.contains(curr)) {   // if set contains element, remove till we get that element\\n                while(i < j && set.contains(curr)) {\\n                   int first = nums[i++];\\n                   local -= first;\\n                   set.remove(first);\\n                }\\n            } \\n        \\n            if (j - i + 1 < k) {  // smaller than window\\n                set.add(curr);\\n                j++;\\n            } else if (j - i + 1 == k) { // if hit window size\\n                maxSum = Math.max(maxSum, local); // checking max\\n\\n                int first = nums[i];  // removing first adding last\\n                local -= first;\\n                set.remove(first);\\n                set.add(curr);\\n                j++;\\n                i++;\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832776,
                "title": "c-frequency-map-sliding-window-100-time-106ms-100-space-64-8mb",
                "content": "Typical sliding window problem like many on LC, with the added twist of avoiding duplicates. But we can conveniently manage it with a frequency map, so let\\'s get cracking \\uD83D\\uDCAA \\n\\nFirst of all, the usual support variables:\\n* `seen` is going to be our frequency map - a simple array of `100001` slots all initially set to `0` (much cheaper than a hashmap for larger inputs, where performance matters);\\n* `len` is the length of `nums`;\\n* `res` is going to be our maximum allowed total;\\n* `tot` is our ongoing total, the sum all the values in our window, initially set to be `0`;\\n* `dupes` is an unordered set used to store all the duplicated values we will find.\\n\\nNow, time to get our variables populated with the first `k` elements, parsing them with `i` and:\\n* setting `n` to be `nums[i]`;\\n* increasing `tot` by `n`;\\n* increasing its frequency `seen[n]` by `1`;\\n* if the frequency is now `2`, it means we just found a new duplicate, so we insert `n` in `dupes`.\\n\\nAt this point, we have to initialise `res` and will do so to be `tot` if we did not find any duplicates or `0` otherwise.\\n\\nNow, time to parse all the other possible windows and we will do so with `i` going from `k` to the last element and `j` going from `0` onwards; at each iteration, we will be:\\n* setting `n` to be `nums[i]`;\\n* setting `m` to be `nums[j]`;\\n* increasing `tot` by `n`;\\n* decreasing `tot` by `m`;\\n* increasing `n` frequency `seen[n]` by `1`;\\n* if the frequency is now `2`, it means we just found a new duplicate, so we insert `n` in `dupes`;\\n* decreasing `m` frequency `seen[m]` by `1`;\\n* if the frequency is now back to `1`, it means we just removed a previously duplicated value, so we erase `m` from `dupes`;\\n* if there are no duplicates, then we will set `res` to be the larger between its current value and `tot`.\\n\\nFinally, we can just `return` `res` :)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        // support variables\\n        int seen[100001] = {}, len = nums.size();\\n        long long res = 0, tot = 0;\\n        unordered_set<int> dupes;\\n        // first k elements\\n        for (int i = 0, n; i < k; i++) {\\n            n = nums[i];\\n            tot += n;\\n            // recording n as seen and checking for duplicates\\n            seen[n]++;\\n            if (seen[n] == 2) dupes.insert(n);\\n        }\\n        // checking if the first k are valid and in case updating res\\n        res = dupes.size() ? 0 : tot;\\n        // all the others elements\\n        for (int i = k, j = 0, n, m; i < len; i++, j++) {\\n            n = nums[i], m = nums[j];\\n            tot += n - m;\\n            // recording n as seen and checking for duplicates\\n            seen[n]++;\\n            if (seen[n] == 2) dupes.insert(n);\\n            // removing m as seen and possibly as a duplicate\\n            seen[m]--;\\n            if (seen[m] == 1) dupes.erase(m);\\n            if (!dupes.size()) res = max(res, tot);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThe brag:\\n![image.png](https://assets.leetcode.com/users/images/321ea802-14b5-4e27-9fee-2115b92d042a_1668935678.3560514.png)\\n",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        // support variables\\n        int seen[100001] = {}, len = nums.size();\\n        long long res = 0, tot = 0;\\n        unordered_set<int> dupes;\\n        // first k elements\\n        for (int i = 0, n; i < k; i++) {\\n            n = nums[i];\\n            tot += n;\\n            // recording n as seen and checking for duplicates\\n            seen[n]++;\\n            if (seen[n] == 2) dupes.insert(n);\\n        }\\n        // checking if the first k are valid and in case updating res\\n        res = dupes.size() ? 0 : tot;\\n        // all the others elements\\n        for (int i = k, j = 0, n, m; i < len; i++, j++) {\\n            n = nums[i], m = nums[j];\\n            tot += n - m;\\n            // recording n as seen and checking for duplicates\\n            seen[n]++;\\n            if (seen[n] == 2) dupes.insert(n);\\n            // removing m as seen and possibly as a duplicate\\n            seen[m]--;\\n            if (seen[m] == 1) dupes.erase(m);\\n            if (!dupes.size()) res = max(res, tot);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2821586,
                "title": "python-easy-to-read-and-understand-set",
                "content": "```\\nn = len(nums)\\n        seen  = set()\\n        i = ans = cur = 0\\n        for j in range(n):\\n            cur += nums[j]\\n            while nums[j] in seen or j+1-i > k:\\n                seen.remove(nums[i])\\n                cur -= nums[i]\\n                i +=1\\n            seen.add(nums[j])\\n            if j+1-i == k:\\n                ans = max(ans, cur)\\n        return ans or 0",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nn = len(nums)\\n        seen  = set()\\n        i = ans = cur = 0\\n        for j in range(n):\\n            cur += nums[j]\\n            while nums[j] in seen or j+1-i > k:\\n                seen.remove(nums[i])\\n                cur -= nums[i]\\n                i +=1\\n            seen.add(nums[j])\\n            if j+1-i == k:\\n                ans = max(ans, cur)\\n        return ans or 0",
                "codeTag": "Unknown"
            },
            {
                "id": 2811515,
                "title": "javascript-map-solution-sliding-window",
                "content": "```\\nvar maximumSubarraySum = function(nums, k) {\\n    \\n    let j = 0;\\n    let map = new Map();\\n    let sum = 0;\\n    let maxSum = 0;\\n    nums.forEach((value, i) => {\\n        // current sum\\n        sum += value;\\n        //currnet map values\\n        if(map.has(value)) {\\n            map.set(value, map.get(value) + 1);\\n        }\\n        else{\\n            map.set(value, 1);\\n        }\\n        \\n        //if subarray length becomes > k remove front element from previous window\\n        if(i - j >= k) {\\n            sum -= nums[j];\\n            if(map.get(nums[j]) > 1) map.set(nums[j], map.get(nums[j])-1);\\n            else map.delete(nums[j]);\\n            j++;\\n        }\\n        \\n        if(i - j + 1 ===  k) {\\n            if(map.size === k) {\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n       \\n    });\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar maximumSubarraySum = function(nums, k) {\\n    \\n    let j = 0;\\n    let map = new Map();\\n    let sum = 0;\\n    let maxSum = 0;\\n    nums.forEach((value, i) => {\\n        // current sum\\n        sum += value;\\n        //currnet map values\\n        if(map.has(value)) {\\n            map.set(value, map.get(value) + 1);\\n        }\\n        else{\\n            map.set(value, 1);\\n        }\\n        \\n        //if subarray length becomes > k remove front element from previous window\\n        if(i - j >= k) {\\n            sum -= nums[j];\\n            if(map.get(nums[j]) > 1) map.set(nums[j], map.get(nums[j])-1);\\n            else map.delete(nums[j]);\\n            j++;\\n        }\\n        \\n        if(i - j + 1 ===  k) {\\n            if(map.size === k) {\\n                maxSum = Math.max(maxSum, sum);\\n            }\\n        }\\n       \\n    });\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808088,
                "title": "easy-c-heap-ka-template-lo-heap-hatao-map-dalo-hogaya-ans",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans =0; long long sum = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<k; i++){\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n        }\\n        if(mp.size() == k) ans += sum;//all the elements are unique\\n        \\n        for(int i=k; i<nums.size(); i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            //erase if the occurance is equal to zero\\n            if(mp[nums[i-k]] == 0) mp.erase(nums[i-k]);\\n            \\n            sum += nums[i];\\n            sum -= nums[i-k];\\n            \\n            if(mp.size() == k) ans = max(ans, sum);\\n            \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans =0; long long sum = 0;\\n        unordered_map<int, int> mp;\\n        \\n        for(int i=0; i<k; i++){\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2792820,
                "title": "python-java-solution-hashmap-sliding-window",
                "content": "**JAVA**\\n\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> d = new HashMap<>();\\n        int left = 0 , right = 0 ,N = nums.length ;\\n        long best = 0, cur = 0;\\n        while( right < N ){\\n            cur += nums[right];\\n            d.put( nums[right] , d.getOrDefault( nums[right] , 0 ) + 1 );\\n            // System.out.println(right + \" -> \" + d);\\n            if( right - left + 1 == k ){            // Needed Window Achieved\\n                if( d.size() == k )\\n                    best = Math.max(best,cur);\\n                cur -= nums[left];\\n                d.put( nums[left] , d.get(nums[left]) -1 );\\n                if( d.get(nums[left]) == 0 )\\n                    d.remove(nums[left]);\\n                left++;\\n            }\\n            right++;\\n        }\\n        return best;\\n    }\\n}\\n```\\n\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        best = 0\\n        N = len(nums)\\n        if N < k:\\n            return 0\\n        cur = 0\\n        left, right = 0 ,0 \\n        d = Counter()\\n        \\n        while right < N:\\n            cur += nums[right]\\n            d[nums[right]] += 1\\n            if right - left + 1 == k:\\n                if len(d) == k:\\n                    best = max(best,cur)\\n                cur -= nums[left]\\n                d[nums[left]] -= 1\\n                if d[nums[left]] == 0:\\n                    del d[nums[left]]\\n                left += 1\\n            right += 1\\n        \\n        return best\\n        \\n        \\n# BRUTE-FORCE -- TLE\\n#         for i in range(N-k+1):\\n#             tmp = nums[i:i+k]\\n#             if len(tmp) == len(set(tmp)):\\n#                 best = max(best,sum(tmp))\\n#         return best\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> d = new HashMap<>();\\n        int left = 0 , right = 0 ,N = nums.length ;\\n        long best = 0, cur = 0;\\n        while( right < N ){\\n            cur += nums[right];\\n            d.put( nums[right] , d.getOrDefault( nums[right] , 0 ) + 1 );\\n            // System.out.println(right + \" -> \" + d);\\n            if( right - left + 1 == k ){            // Needed Window Achieved\\n                if( d.size() == k )\\n                    best = Math.max(best,cur);\\n                cur -= nums[left];\\n                d.put( nums[left] , d.get(nums[left]) -1 );\\n                if( d.get(nums[left]) == 0 )\\n                    d.remove(nums[left]);\\n                left++;\\n            }\\n            right++;\\n        }\\n        return best;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        best = 0\\n        N = len(nums)\\n        if N < k:\\n            return 0\\n        cur = 0\\n        left, right = 0 ,0 \\n        d = Counter()\\n        \\n        while right < N:\\n            cur += nums[right]\\n            d[nums[right]] += 1\\n            if right - left + 1 == k:\\n                if len(d) == k:\\n                    best = max(best,cur)\\n                cur -= nums[left]\\n                d[nums[left]] -= 1\\n                if d[nums[left]] == 0:\\n                    del d[nums[left]]\\n                left += 1\\n            right += 1\\n        \\n        return best\\n        \\n        \\n# BRUTE-FORCE -- TLE\\n#         for i in range(N-k+1):\\n#             tmp = nums[i:i+k]\\n#             if len(tmp) == len(set(tmp)):\\n#                 best = max(best,sum(tmp))\\n#         return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791493,
                "title": "98-time-ans-space-beats-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        int i = 0;\\n        while(i < k  && i < nums.size()){ // store first k elements in the map\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n            i++;\\n        }\\n        if(mp.size() == k) ans = sum; // if all distinct, then ans = sum \\n        while(i < nums.size()){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]] == 0) mp.erase(nums[i-k]);\\n            \\n            sum += nums[i];\\n            sum -= nums[i-k];\\n            if(mp.size() == k) ans = max(ans, sum);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        int i = 0;\\n        while(i < k  && i < nums.size()){ // store first k elements in the map\\n            mp[nums[i]]++;\\n            sum += nums[i];\\n            i++;\\n        }\\n        if(mp.size() == k) ans = sum; // if all distinct, then ans = sum \\n        while(i < nums.size()){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]] == 0) mp.erase(nums[i-k]);\\n            \\n            sum += nums[i];\\n            sum -= nums[i-k];\\n            if(mp.size() == k) ans = max(ans, sum);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788880,
                "title": "c-simple-as-f-k",
                "content": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        ll sum =0;\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<k; i++)\\n        {\\n            mp[nums[i]]++;\\n            sum += (ll)nums[i];\\n        }\\n        ll ans = 0;\\n        if(mp.size()==k) ans = max(ans,sum);\\n        int l = 0;\\n        for(int r=k; r<nums.size(); r++)\\n        {\\n            sum += nums[r] - nums[l];\\n            mp[nums[l]]--;\\n            if(mp[nums[l]]<=0)\\n            {\\n               mp.erase(nums[l]); \\n            }\\n            l++;\\n            mp[nums[r]]++;\\n            if(mp.size()==k) ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n#define ll long long\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        ll sum =0;\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<k; i++)\\n        {\\n            mp[nums[i]]++;\\n            sum += (ll)nums[i];\\n        }\\n        ll ans = 0;\\n        if(mp.size()==k) ans = max(ans,sum);\\n        int l = 0;\\n        for(int r=k; r<nums.size(); r++)\\n        {\\n            sum += nums[r] - nums[l];\\n            mp[nums[l]]--;\\n            if(mp[nums[l]]<=0)\\n            {\\n               mp.erase(nums[l]); \\n            }\\n            l++;\\n            mp[nums[r]]++;\\n            if(mp.size()==k) ans = max(ans,sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787770,
                "title": "python-sliding-window-o-n-easy-approach-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. keep extend window\\n2. if find duplicate, open a new window\\n3. if window length reach k, update the max sum and moving the window\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        res = 0\\n        curr = 0\\n        for i in range(len(nums)):\\n            if nums[i] not in seen:\\n                if len(seen) < k:\\n                    seen.add(nums[i])\\n                    curr += nums[i]\\n                if len(seen) == k:\\n                    res = max(res, curr)\\n                    curr -= nums[i-k+1]\\n                    seen.remove(nums[i-k+1])\\n            else:\\n                seen = {nums[i]}\\n                curr = nums[i]\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        res = 0\\n        curr = 0\\n        for i in range(len(nums)):\\n            if nums[i] not in seen:\\n                if len(seen) < k:\\n                    seen.add(nums[i])\\n                    curr += nums[i]\\n                if len(seen) == k:\\n                    res = max(res, curr)\\n                    curr -= nums[i-k+1]\\n                    seen.remove(nums[i-k+1])\\n            else:\\n                seen = {nums[i]}\\n                curr = nums[i]\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2785059,
                "title": "c-easy-solution",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        ll res = 0, sum = 0;;\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        unordered_map<int, int> map;\\n        while (j < n) {\\n            map[nums[j]]++;\\n            sum += nums[j];\\n            if (j - i + 1 == k) {\\n                bool flag = false;\\n                while (i < j && (j - i + 1 != map.size())) {\\n                    map[nums[i]]--;\\n                    if (map[nums[i]] == 0) map.erase(nums[i]);\\n                    sum -= nums[i];\\n                    i++;\\n                    flag = true;\\n                }\\n                if (map.size() == k) res = max(res, sum);\\n                if (!flag) {\\n                    map[nums[i]]--;\\n                    if (map[nums[i]] == 0) map.erase(nums[i]);\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        ll res = 0, sum = 0;;\\n        int n = nums.size();\\n        int i = 0, j = 0;\\n        unordered_map<int, int> map;\\n        while (j < n) {\\n            map[nums[j]]++;\\n            sum += nums[j];\\n            if (j - i + 1 == k) {\\n                bool flag = false;\\n                while (i < j && (j - i + 1 != map.size())) {\\n                    map[nums[i]]--;\\n                    if (map[nums[i]] == 0) map.erase(nums[i]);\\n                    sum -= nums[i];\\n                    i++;\\n                    flag = true;\\n                }\\n                if (map.size() == k) res = max(res, sum);\\n                if (!flag) {\\n                    map[nums[i]]--;\\n                    if (map[nums[i]] == 0) map.erase(nums[i]);\\n                    sum -= nums[i];\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784822,
                "title": "java-easy-2-solutions-hashmap-set",
                "content": "```\\n// HashMap solution\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashMap <Integer,Integer>hm=new HashMap<>();\\n        int prev=-1;\\n        long ans=0;\\n        long tsum=0;\\n        for(int i=0;i<nums.length;i++){\\n            tsum+=nums[i];\\n            \\n            if(hm.containsKey(nums[i]) && hm.get(nums[i])>prev){\\n                for(int j=prev+1;j<=hm.get(nums[i]);j++){\\n                    tsum-=nums[j];\\n                }\\n                prev=hm.get(nums[i]);\\n            }\\n     \\n           \\n         if(i-prev==k){\\n                ans=Math.max(ans,tsum);\\n                prev++;\\n                tsum-=nums[prev];\\n            }\\n            \\n            hm.put(nums[i],i);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// set solution\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Set <Integer>hm=new HashSet<>();\\n        int prev=-1;\\n        long ans=0;\\n        long tsum=0;\\n        for(int i=0;i<nums.length;i++){\\n            tsum+=nums[i];\\n            \\n            while(hm.contains(nums[i])){\\n                prev++;\\n                tsum-=nums[prev];\\n                hm.remove(nums[prev]);\\n                \\n                \\n            }\\n     \\n           \\n         if(i-prev==k){\\n                ans=Math.max(ans,tsum);\\n                prev++;\\n                tsum-=nums[prev];\\n                hm.remove(nums[prev]);\\n            }\\n            \\n            hm.add(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// HashMap solution\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashMap <Integer,Integer>hm=new HashMap<>();\\n        int prev=-1;\\n        long ans=0;\\n        long tsum=0;\\n        for(int i=0;i<nums.length;i++){\\n            tsum+=nums[i];\\n            \\n            if(hm.containsKey(nums[i]) && hm.get(nums[i])>prev){\\n                for(int j=prev+1;j<=hm.get(nums[i]);j++){\\n                    tsum-=nums[j];\\n                }\\n                prev=hm.get(nums[i]);\\n            }\\n     \\n           \\n         if(i-prev==k){\\n                ans=Math.max(ans,tsum);\\n                prev++;\\n                tsum-=nums[prev];\\n            }\\n            \\n            hm.put(nums[i],i);\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n// set solution\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Set <Integer>hm=new HashSet<>();\\n        int prev=-1;\\n        long ans=0;\\n        long tsum=0;\\n        for(int i=0;i<nums.length;i++){\\n            tsum+=nums[i];\\n            \\n            while(hm.contains(nums[i])){\\n                prev++;\\n                tsum-=nums[prev];\\n                hm.remove(nums[prev]);\\n                \\n                \\n            }\\n     \\n           \\n         if(i-prev==k){\\n                ans=Math.max(ans,tsum);\\n                prev++;\\n                tsum-=nums[prev];\\n                hm.remove(nums[prev]);\\n            }\\n            \\n            hm.add(nums[i]);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784611,
                "title": "beats-100-java-sliding-window-with-hashmap",
                "content": "*Here most crucial part is to know wether elements are* **unique or not in window** \\nto resolve this we use hashmap , we will store key with value as frequency of element \\n\\nafter that we would keep adding new elements and delete i-k element \\n\\nIf hashmap size is same of that k(window) then all elements are unique we would also calculate sum at the same time \\n\\nand we would check if it is max sum or not :\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n\\n**Code :**\\n\\n```\\n  public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0l ; \\n        long max = Long.MIN_VALUE;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < k ; i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n            if(hm.size()==k)  max = Math.max(sum,max);\\n        }\\n        \\n        for(int i = k ; i < nums.length ; i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            if(hm.get(nums[i-k])==1) hm.remove(nums[i-k]);\\n            else hm.put(nums[i-k],hm.get(nums[i-k])-1);\\n            sum+=nums[i];\\n            sum-=nums[i-k];\\n            if(hm.size()==k) max = Math.max(sum,max);\\n        }\\n        if(max == Long.MIN_VALUE) return 0;\\n        return max;\\n    }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n  public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0l ; \\n        long max = Long.MIN_VALUE;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        for(int i = 0 ; i < k ; i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            sum+=nums[i];\\n            if(hm.size()==k)  max = Math.max(sum,max);\\n        }\\n        \\n        for(int i = k ; i < nums.length ; i++){\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            if(hm.get(nums[i-k])==1) hm.remove(nums[i-k]);\\n            else hm.put(nums[i-k],hm.get(nums[i-k])-1);\\n            sum+=nums[i];\\n            sum-=nums[i-k];\\n            if(hm.size()==k) max = Math.max(sum,max);\\n        }\\n        if(max == Long.MIN_VALUE) return 0;\\n        return max;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2784440,
                "title": "simple-java-solution-sliding-window-tc-o-n-sc-o-n",
                "content": "# \\n\\n# Approach\\nUsing hashmap with sliding window.Taking k as window size as well as distinct character count.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\n- O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long answer=0;\\n        long sum=0;\\n        HashMap<Integer,Integer>mp=new HashMap<>();\\n        int release=0;\\n        int distinct=0; \\n        for(int i=0;i<k;i++){\\n            if(mp.containsKey(nums[i])){\\n                sum+=nums[i];\\n                mp.put(nums[i],mp.get(nums[i])+1);\\n            }else{\\n                mp.put(nums[i],1);\\n                distinct++;\\n                sum+=nums[i];\\n            }\\n        }\\n        if(distinct==k){\\n            answer=Math.max(answer,sum);\\n        }\\n        for(int acquire=k;acquire<nums.length;acquire++){\\n            \\n            sum-=nums[release];\\n            mp.put(nums[release],mp.get(nums[release])-1);\\n            if(mp.get(nums[release])==0){\\n                mp.remove(nums[release]);\\n                distinct--;\\n            }\\n            release++;\\n            \\n            \\n            \\n            if(mp.containsKey(nums[acquire])){\\n                sum+=nums[acquire];\\n                mp.put(nums[acquire],mp.get(nums[acquire])+1);\\n            }else{\\n                 mp.put(nums[acquire],1);\\n                distinct++;\\n                sum+=nums[acquire];\\n            }\\n            \\n            if(distinct==k)answer=Math.max(answer,sum);\\n            \\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long answer=0;\\n        long sum=0;\\n        HashMap<Integer,Integer>mp=new HashMap<>();\\n        int release=0;\\n        int distinct=0; \\n        for(int i=0;i<k;i++){\\n            if(mp.containsKey(nums[i])){\\n                sum+=nums[i];\\n                mp.put(nums[i],mp.get(nums[i])+1);\\n            }else{\\n                mp.put(nums[i],1);\\n                distinct++;\\n                sum+=nums[i];\\n            }\\n        }\\n        if(distinct==k){\\n            answer=Math.max(answer,sum);\\n        }\\n        for(int acquire=k;acquire<nums.length;acquire++){\\n            \\n            sum-=nums[release];\\n            mp.put(nums[release],mp.get(nums[release])-1);\\n            if(mp.get(nums[release])==0){\\n                mp.remove(nums[release]);\\n                distinct--;\\n            }\\n            release++;\\n            \\n            \\n            \\n            if(mp.containsKey(nums[acquire])){\\n                sum+=nums[acquire];\\n                mp.put(nums[acquire],mp.get(nums[acquire])+1);\\n            }else{\\n                 mp.put(nums[acquire],1);\\n                distinct++;\\n                sum+=nums[acquire];\\n            }\\n            \\n            if(distinct==k)answer=Math.max(answer,sum);\\n            \\n            \\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783976,
                "title": "python-sliding-widow-100-faster",
                "content": "```\\n        i=0\\n        d={}\\n\\t\\ttot=0    #current sum\\n        maxTot=0   #max sum\\n        \\n        # step1 add first k nums to dict and keep track of the sum ie. tot\\n        while i<k and i<len(nums):            \\n            d[nums[i]]=1+d.get(nums[i],0)\\n            tot+=nums[i]\\n            i+=1\\n        \\n        if len(d)==k:   # if first k are distinct then assign it as the maxSum \\n            maxTot=max(maxTot,tot)\\n        \\n        # sliding window\\n        while i<len(nums):\\n            \\n            d[nums[i]]=1+d.get(nums[i],0)   #add count of nums to dict\\n            d[nums[i-k]]-=1                 #remove the count of left most element dict\\n            \\n            # if count of the removed num becomes 0 remove the key from dict\\n            if d[nums[i-k]]==0:\\n                del d[nums[i-k]]\\n            \\n            # keeping track of sum of k element in the sliding window \\n            tot+=nums[i]\\n            tot-=nums[i-k]\\n            \\n            # if the k elements are distinct then check if the current sum if greater the maxSum\\n            if len(d)==k:\\n                maxTot=max(maxTot,tot)\\n                \\n            i+=1\\n            \\n        return maxTot\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        i=0\\n        d={}\\n\\t\\ttot=0    #current sum\\n        maxTot=0   #max sum\\n        \\n        # step1 add first k nums to dict and keep track of the sum ie. tot\\n        while i<k and i<len(nums):            \\n            d[nums[i]]=1+d.get(nums[i],0)\\n            tot+=nums[i]\\n            i+=1\\n        \\n        if len(d)==k:   # if first k are distinct then assign it as the maxSum \\n            maxTot=max(maxTot,tot)\\n        \\n        # sliding window\\n        while i<len(nums):\\n            \\n            d[nums[i]]=1+d.get(nums[i],0)   #add count of nums to dict\\n            d[nums[i-k]]-=1                 #remove the count of left most element dict\\n            \\n            # if count of the removed num becomes 0 remove the key from dict\\n            if d[nums[i-k]]==0:\\n                del d[nums[i-k]]\\n            \\n            # keeping track of sum of k element in the sliding window \\n            tot+=nums[i]\\n            tot-=nums[i-k]\\n            \\n            # if the k elements are distinct then check if the current sum if greater the maxSum\\n            if len(d)==k:\\n                maxTot=max(maxTot,tot)\\n                \\n            i+=1\\n            \\n        return maxTot\\n\\t\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783951,
                "title": "c-using-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,curr=0;\\n        unordered_set<int>s;\\n        queue<int>q;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            q.push(nums[i]);\\n            curr+=nums[i];\\n            while(s.find(nums[i])!=s.end()){\\n                curr-=q.front();\\n                s.erase(q.front());\\n                q.pop();\\n            }\\n            s.insert(nums[i]);\\n            while(q.size()>k){\\n                curr-=q.front();\\n                s.erase(q.front());\\n                q.pop();\\n            }\\n            if(q.size()==k) ans=max(ans,curr);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0,curr=0;\\n        unordered_set<int>s;\\n        queue<int>q;\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++){\\n            q.push(nums[i]);\\n            curr+=nums[i];\\n            while(s.find(nums[i])!=s.end()){\\n                curr-=q.front();\\n                s.erase(q.front());\\n                q.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2783917,
                "title": "python-hashmap-time-o-n-space-o-n",
                "content": "```\\ndef maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        hash=defaultdict(int)\\n        sm=0\\n        ans=0\\n        for i in range(len(nums)):\\n            sm+=nums[i]\\n            hash[nums[i]]+=1\\n            if i>=k:\\n                hash[nums[i-k]]-=1\\n                sm-=nums[i-k]\\n                if hash[nums[i-k]]==0:\\n                    del hash[nums[i-k]]\\n            if len(hash)==k:\\n                ans=max(ans,sm)\\n        return ans\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\ndef maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        hash=defaultdict(int)\\n        sm=0\\n        ans=0\\n        for i in range(len(nums)):\\n            sm+=nums[i]\\n            hash[nums[i]]+=1\\n            if i>=k:\\n                hash[nums[i-k]]-=1\\n                sm-=nums[i-k]\\n                if hash[nums[i-k]]==0:\\n                    del hash[nums[i-k]]\\n            if len(hash)==k:\\n                ans=max(ans,sm)\\n        return ans\\n                    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2783909,
                "title": "hashmap",
                "content": "```\\n int n=nums.size();\\n        long long sum=0;\\n        map<int,int>mp;\\n        long long ans=0;\\n        for(int i=0;i<k;i++){\\n            mp[nums[i]]++;\\n            sum+=nums[i];\\n        }\\n        if(mp.size()==k){\\n            ans=max(ans,sum);\\n        }\\n        for(int i=k;i<n;i++){\\n            if(mp[nums[i-k]]==1){\\n                mp.erase(nums[i-k]);\\n                sum-=nums[i-k];\\n            }\\n            else{\\n                mp[nums[i-k]]--;\\n                sum-=nums[i-k];\\n            }\\n            mp[nums[i]]++;\\n            sum+=nums[i];\\n            if(mp.size()==k){\\n               \\n                ans=max(ans,sum);\\n            }\\n           // cout<<sum<<\" \";\\n        }\\n        return ans;",
                "solutionTags": [],
                "code": "```\\n int n=nums.size();\\n        long long sum=0;\\n        map<int,int>mp;\\n        long long ans=0;\\n        for(int i=0;i<k;i++){\\n            mp[nums[i]]++;\\n            sum+=nums[i];\\n        }\\n        if(mp.size()==k){\\n            ans=max(ans,sum);\\n        }\\n        for(int i=k;i<n;i++){\\n            if(mp[nums[i-k]]==1){\\n                mp.erase(nums[i-k]);\\n                sum-=nums[i-k];\\n            }\\n            else{\\n                mp[nums[i-k]]--;\\n                sum-=nums[i-k];\\n            }\\n            mp[nums[i]]++;\\n            sum+=nums[i];\\n            if(mp.size()==k){\\n               \\n                ans=max(ans,sum);\\n            }\\n           // cout<<sum<<\" \";\\n        }\\n        return ans;",
                "codeTag": "C++"
            },
            {
                "id": 2783900,
                "title": "java-2-solutions-slide-window-hashmap",
                "content": "# 2.prefix sum + hashmap\\n```\\n   //2.prefix sum\\n    //Runtime: 80 ms, faster than 80.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Memory Usage: 105.6 MB, less than 20.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Time: O(N); Space: O(N)\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long res = 0;\\n        long[] preSum = new long[nums.length + 1];\\n        for (int i = 1; i <= nums.length; i++) preSum[i] = preSum[i - 1] + nums[i - 1];\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int left = 0;\\n        for (int idx = 0; idx < nums.length; idx++) {\\n            left = Math.max(left, map.getOrDefault(nums[idx], -2) + 1);\\n            if (idx - left >= k - 1)\\n                res = Math.max(res, preSum[idx + 1] - preSum[idx + 1 - k]);\\n            map.put(nums[idx], idx);\\n        }\\n        return res;\\n    }\\n```\\n# 1.Slide window\\n```\\n    //1.Slide window\\n    //Runtime: 105 ms, faster than 80.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Memory Usage: 105.9 MB, less than 20.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Time: O(N); Space: O(1)\\n    public long maximumSubarraySum_1(int[] nums, int k) {\\n        long res = 0, sum = 0;\\n        int left = 0, right = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        while (right < nums.length) {\\n            while (left < right && (set.contains(nums[right]) || set.size() >= k)) {\\n                set.remove(nums[left]);\\n                sum -= nums[left++];\\n            }\\n            set.add(nums[right]);\\n            sum += nums[right++];\\n            if (set.size() == k) res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n   //2.prefix sum\\n    //Runtime: 80 ms, faster than 80.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Memory Usage: 105.6 MB, less than 20.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Time: O(N); Space: O(N)\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long res = 0;\\n        long[] preSum = new long[nums.length + 1];\\n        for (int i = 1; i <= nums.length; i++) preSum[i] = preSum[i - 1] + nums[i - 1];\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int left = 0;\\n        for (int idx = 0; idx < nums.length; idx++) {\\n            left = Math.max(left, map.getOrDefault(nums[idx], -2) + 1);\\n            if (idx - left >= k - 1)\\n                res = Math.max(res, preSum[idx + 1] - preSum[idx + 1 - k]);\\n            map.put(nums[idx], idx);\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.Slide window\\n    //Runtime: 105 ms, faster than 80.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Memory Usage: 105.9 MB, less than 20.00% of Java online submissions for Maximum Sum of Distinct Subarrays With Length K.\\n    //Time: O(N); Space: O(1)\\n    public long maximumSubarraySum_1(int[] nums, int k) {\\n        long res = 0, sum = 0;\\n        int left = 0, right = 0;\\n\\n        Set<Integer> set = new HashSet<>();\\n        while (right < nums.length) {\\n            while (left < right && (set.contains(nums[right]) || set.size() >= k)) {\\n                set.remove(nums[left]);\\n                sum -= nums[left++];\\n            }\\n            set.add(nums[right]);\\n            sum += nums[right++];\\n            if (set.size() == k) res = Math.max(res, sum);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783875,
                "title": "python3-sliding-window-with-no-duplicates",
                "content": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        mx = 0\\n        n = len(nums)\\n        d = {}\\n        prev,curr,s = 0,0,0\\n        \\n        while curr<n:\\n            \\n            if curr-prev<k:\\n                if d.get(nums[curr],0)==0:\\n                    d[nums[curr]] = 1\\n                    s += nums[curr]\\n                else:\\n                    d = {nums[curr]:1}\\n                    prev = curr\\n                    s = nums[curr]\\n            else:\\n                del d[nums[prev]]\\n                mx = max(mx,s)\\n                if d.get(nums[curr],0)==0:\\n                    d[nums[curr]] = 1\\n                    s += nums[curr]\\n                    s -= nums[prev]\\n                    prev += 1\\n                else:\\n                    d = {nums[curr]:1}\\n                    prev = curr\\n                    s = nums[curr]\\n                mx = max(mx,s)\\n            curr += 1\\n            \\n        if len(d.keys())==k:\\n            mx = max(mx,s)\\n            \\n        return mx\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        mx = 0\\n        n = len(nums)\\n        d = {}\\n        prev,curr,s = 0,0,0\\n        \\n        while curr<n:\\n            \\n            if curr-prev<k:\\n                if d.get(nums[curr],0)==0:\\n                    d[nums[curr]] = 1\\n                    s += nums[curr]\\n                else:\\n                    d = {nums[curr]:1}\\n                    prev = curr\\n                    s = nums[curr]\\n            else:\\n                del d[nums[prev]]\\n                mx = max(mx,s)\\n                if d.get(nums[curr],0)==0:\\n                    d[nums[curr]] = 1\\n                    s += nums[curr]\\n                    s -= nums[prev]\\n                    prev += 1\\n                else:\\n                    d = {nums[curr]:1}\\n                    prev = curr\\n                    s = nums[curr]\\n                mx = max(mx,s)\\n            curr += 1\\n            \\n        if len(d.keys())==k:\\n            mx = max(mx,s)\\n            \\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783813,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\n\\t\\tlong long maximumSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tif(k>nums.size()){return 0;}\\n\\t\\t\\tlong long int cnt=0, maxi=0;\\n\\t\\t\\tunordered_map<long long int, long long int>m;\\n\\t\\t\\tfor(int i=0; i<k; i++){\\n\\t\\t\\t\\tcnt+=nums[i];\\n\\t\\t\\t\\tm[nums[i]]++;\\n\\t\\t\\t\\t//cout<<maxi<<\" \"<<cnt<<endl;\\n\\t\\t\\t\\tif(m.size()==k){maxi=max(maxi, cnt);}\\n\\t\\t\\t}\\n\\t\\t\\tif(k==nums.size()){return maxi;}\\n\\t\\t\\tint j=k-1, i=0;\\n\\t\\t\\twhile(j<nums.size()){\\n\\t\\t\\t\\tm[nums[i]]--;\\n\\t\\t\\t\\tif(m[nums[i]]==0){\\n\\t\\t\\t\\t\\tm.erase(nums[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(j==nums.size()-1){break;}\\n\\t\\t\\t\\tcnt-=nums[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t\\tm[nums[j]]++;\\n\\t\\t\\t\\tcnt+=nums[j];\\n\\t\\t\\t\\tif(m.size()==k){maxi=max(maxi, cnt);}\\n\\t\\t\\t\\t//cout<<maxi<<\" \"<<cnt<<endl;\\n\\t\\t\\t}\\n\\t\\t\\treturn maxi;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\n\\t\\tlong long maximumSubarraySum(vector<int>& nums, int k) {\\n\\t\\t\\tif(k>nums.size()){return 0;}",
                "codeTag": "Java"
            },
            {
                "id": 2783591,
                "title": "sliding-window-like-problem-with-hashset-to-keep-unique-elems",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // sliding window\\n        unordered_set<int> s;\\n        int l = 0, r = 0;\\n        \\n        long long ans = 0;\\n        long long window = 0;\\n        \\n        while(r < n) {\\n            // move window left until there is no duplicate nums[r]\\n            while(l < r && s.count(nums[r])) {\\n                s.erase(nums[l]);\\n                window -= nums[l];\\n                l++;\\n            }\\n\\n            // expand window\\n            s.insert(nums[r]);\\n            window += nums[r];\\n            \\n            // shrink window to keep window size == k\\n            while(r - l + 1 > k) {\\n                s.erase(nums[l]);\\n                window -= nums[l];\\n                l++;\\n            }\\n\\n            // subarray is k-size and k unique number\\n            if (s.size() == k) {\\n                ans = max(ans, window);\\n            }\\n            \\n            // expand window\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        \\n        // sliding window\\n        unordered_set<int> s;\\n        int l = 0, r = 0;\\n        \\n        long long ans = 0;\\n        long long window = 0;\\n        \\n        while(r < n) {\\n            // move window left until there is no duplicate nums[r]\\n            while(l < r && s.count(nums[r])) {\\n                s.erase(nums[l]);\\n                window -= nums[l];\\n                l++;\\n            }\\n\\n            // expand window\\n            s.insert(nums[r]);\\n            window += nums[r];\\n            \\n            // shrink window to keep window size == k\\n            while(r - l + 1 > k) {\\n                s.erase(nums[l]);\\n                window -= nums[l];\\n                l++;\\n            }\\n\\n            // subarray is k-size and k unique number\\n            if (s.size() == k) {\\n                ans = max(ans, window);\\n            }\\n            \\n            // expand window\\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783576,
                "title": "c-solution-with-comments-sliding-window-hashmap",
                "content": "Comment down if you have any doubts. **Please** **upvote** if you liked the solution :)\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, currSum = 0;\\n        int n = nums.size(), currSize = 0, start = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < n; i++){\\n\\t\\t//if the element already exists in our subarray we\\'ll eliminate it\\'s first occurence by eliminating all elements from the start of our current subarray window\\n            if(mp[nums[i]]){ \\n                while(mp[nums[i]] != 0){\\n                    currSum -= nums[start];\\n                    mp[nums[start++]]--;\\n                    currSize--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//adding current element to our subarray\\n            currSum += nums[i];\\n            currSize++;\\n            mp[nums[i]]++;\\n\\t\\t\\t\\n\\t\\t\\t//when current window size becomes \\'k\\' store the ans(if it\\'s max)\\t\\n            if(currSize == k){\\n                ans = max(ans, currSum);\\n\\t\\t\\t\\t//eliminating first element of window to check for any further subarrays with max sum in other iterations\\n                currSum -= nums[start];\\n                mp[nums[start++]]--;\\n                currSize--;\\n            }\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans = 0, currSum = 0;\\n        int n = nums.size(), currSize = 0, start = 0;\\n        unordered_map<int,int>mp;\\n        \\n        for(int i = 0; i < n; i++){\\n\\t\\t//if the element already exists in our subarray we\\'ll eliminate it\\'s first occurence by eliminating all elements from the start of our current subarray window\\n            if(mp[nums[i]]){ \\n                while(mp[nums[i]] != 0){\\n                    currSum -= nums[start];\\n                    mp[nums[start++]]--;\\n                    currSize--;\\n                }\\n            }\\n\\t\\t\\t\\n\\t\\t\\t//adding current element to our subarray\\n            currSum += nums[i];\\n            currSize++;\\n            mp[nums[i]]++;\\n\\t\\t\\t\\n\\t\\t\\t//when current window size becomes \\'k\\' store the ans(if it\\'s max)\\t\\n            if(currSize == k){\\n                ans = max(ans, currSum);\\n\\t\\t\\t\\t//eliminating first element of window to check for any further subarrays with max sum in other iterations\\n                currSum -= nums[start];\\n                mp[nums[start++]]--;\\n                currSize--;\\n            }\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783572,
                "title": "python-o-n-by-prefix-sum-sliding-window-w-hint",
                "content": "**Hint**\\n\\nThis is a combination of [**Leetcode #303 Range Sum Query**](https://leetcode.com/problems/range-sum-query-immutable/) and [**Leetcode #3 Longest substring without repetition**](https://leetcode.com/problems/longest-substring-without-repeating-characters/) in numerical version.\\n\\nWhen it comes to **range sum operation in array**, think of **prefix sum**.\\n\\nWhen it comes to **specific goal function optimization of substring / subarray**, think of **sliding window**.\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        # Build prefix sum table to help us calculate range sum in O(1)\\n        prefixS = [ nums[0] ]\\n        for i in range( 1, len(nums) ):\\n            prefixS.append( prefixS[-1] + nums[i] )\\n            \\n        \\n        \\n        best = 0            # maximum subarray sum\\n        start = 0           # left index of sliding window\\n        summation = 0       # current subarray sum\\n        \\n        \\n        ## dictionary\\n        # key: number\\n        # value: latest index of number on the left hand side\\n        lastIndexOf = defaultdict( lambda : -1)\\n        \\n        \\n        # Sliding windows bounded in [start, end] inclusively\\n        for end, number in enumerate(nums):\\n                        \\n            if lastIndexOf[number] >= start:\\n                # current number has shown up before\\n                summation = prefixS[end] - prefixS[ lastIndexOf[number] ]\\n                start = lastIndexOf[number] + 1\\n                \\n            elif start + k == end:\\n                # current number is unique, but we are forced to discard the leftmost element to keep window size k\\n                summation = prefixS[end] - prefixS[start]\\n                start += 1\\n                \\n            else:\\n                # current number is unique, just adding it to summation\\n                summation += nums[end]\\n            \\n            \\n            if (end - start + 1) == k:\\n                # Update subarray sum only when window size is k\\n                best = max(best, summation)\\n            \\n            # update lasest index of number\\n            lastIndexOf[ number ] = end\\n            \\n        return best\\n    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        \\n        # Build prefix sum table to help us calculate range sum in O(1)\\n        prefixS = [ nums[0] ]\\n        for i in range( 1, len(nums) ):\\n            prefixS.append( prefixS[-1] + nums[i] )\\n            \\n        \\n        \\n        best = 0            # maximum subarray sum\\n        start = 0           # left index of sliding window\\n        summation = 0       # current subarray sum\\n        \\n        \\n        ## dictionary\\n        # key: number\\n        # value: latest index of number on the left hand side\\n        lastIndexOf = defaultdict( lambda : -1)\\n        \\n        \\n        # Sliding windows bounded in [start, end] inclusively\\n        for end, number in enumerate(nums):\\n                        \\n            if lastIndexOf[number] >= start:\\n                # current number has shown up before\\n                summation = prefixS[end] - prefixS[ lastIndexOf[number] ]\\n                start = lastIndexOf[number] + 1\\n                \\n            elif start + k == end:\\n                # current number is unique, but we are forced to discard the leftmost element to keep window size k\\n                summation = prefixS[end] - prefixS[start]\\n                start += 1\\n                \\n            else:\\n                # current number is unique, just adding it to summation\\n                summation += nums[end]\\n            \\n            \\n            if (end - start + 1) == k:\\n                # Update subarray sum only when window size is k\\n                best = max(best, summation)\\n            \\n            # update lasest index of number\\n            lastIndexOf[ number ] = end\\n            \\n        return best\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783519,
                "title": "c-easy-and-precise-well-commented-beginner-friendly",
                "content": "Let\\'s try to understand question first. It\\'s asking for distinct and contiguous elements. \\'k\\' denotes size but what type of size. It\\'s giving hint for window size. Yes, it\\'s sliding window problem and we are gonna use unordered_map to keep track of frequency of each element within \\'k\\' window size. Why we are not using set here? It\\'s because it doesn\\'t keep track of frequency and it only stores distinct elements.\\nLet\\'s jump to the solution \\n\\n``` \\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp; //declared unordered_map to keep track of elements\\n        long long ans=0, tmp=0; //ans will store the maximum sum and tmp will store the sum of current window size\\n        int i=0; // initialized one variable to iterate through nums array\\n        while(i<k && i<n){ //this loop will run till k only and store first k elements with their frequency in map\\n            mp[nums[i]]++;  //element with its frequency\\n            tmp+=nums[i];  //current sum\\n            i++;\\n        }\\n        if(mp.size()==k) ans = tmp; //if map size equals \\'k\\' that means k distinct elements\\n        while(i<n){\\n            mp[nums[i]]++; //increasing frequency by 1\\n            mp[nums[i-k]]--; //decreasing frequency by 1\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]); //if frequency zero then erase it\\n            tmp+=nums[i];\\n            tmp-=nums[i-k];\\n            if(mp.size()==k) ans = max(ans,tmp);\\n            i++;\\n        }\\n        return ans; // return final answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp; //declared unordered_map to keep track of elements\\n        long long ans=0, tmp=0; //ans will store the maximum sum and tmp will store the sum of current window size\\n        int i=0; // initialized one variable to iterate through nums array\\n        while(i<k && i<n){ //this loop will run till k only and store first k elements with their frequency in map\\n            mp[nums[i]]++;  //element with its frequency\\n            tmp+=nums[i];  //current sum\\n            i++;\\n        }\\n        if(mp.size()==k) ans = tmp; //if map size equals \\'k\\' that means k distinct elements\\n        while(i<n){\\n            mp[nums[i]]++; //increasing frequency by 1\\n            mp[nums[i-k]]--; //decreasing frequency by 1\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]); //if frequency zero then erase it\\n            tmp+=nums[i];\\n            tmp-=nums[i-k];\\n            if(mp.size()==k) ans = max(ans,tmp);\\n            i++;\\n        }\\n        return ans; // return final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783452,
                "title": "simple-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long mx = 0,sum = 0,ln = 0;\\n        unordered_map <int,int> ump;\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(j < n){\\n            while(ump[nums[j]] > 0 || ln >= k)\\n                ump[nums[i]]--,sum -= nums[i],i++,ln--;\\n            sum += nums[j];\\n            ump[nums[j]]++;\\n            ln++;\\n            if(ln == k)  \\n                mx = max(mx,sum);   \\n            j++;    \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long mx = 0,sum = 0,ln = 0;\\n        unordered_map <int,int> ump;\\n        int n=nums.size();\\n        int i=0,j=0;\\n        while(j < n){\\n            while(ump[nums[j]] > 0 || ln >= k)\\n                ump[nums[i]]--,sum -= nums[i],i++,ln--;\\n            sum += nums[j];\\n            ump[nums[j]]++;\\n            ln++;\\n            if(ln == k)  \\n                mx = max(mx,sum);   \\n            j++;    \\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783444,
                "title": "sliding-window-using-hashmap-c",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<ll int,ll int>mp;\\n        ll int sum = 0, j = 0;\\n        for(int i = 0; i < k; i++){\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n        }\\n        ll int ans = 0;\\n        if(mp.size() == k){\\n            ans = max(ans, sum);\\n        }\\n        for(int i = k; i < nums.size(); i++){\\n            sum -= nums[j];\\n            mp[nums[j]]--;\\n            if(mp[nums[j]] == 0) mp.erase(nums[j]);\\n            j++;\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n            if(mp.size() == k){\\n                ans = max(ans, sum);\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<ll int,ll int>mp;\\n        ll int sum = 0, j = 0;\\n        for(int i = 0; i < k; i++){\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n        }\\n        ll int ans = 0;\\n        if(mp.size() == k){\\n            ans = max(ans, sum);\\n        }\\n        for(int i = k; i < nums.size(); i++){\\n            sum -= nums[j];\\n            mp[nums[j]]--;\\n            if(mp[nums[j]] == 0) mp.erase(nums[j]);\\n            j++;\\n            sum += nums[i];\\n            mp[nums[i]]++;\\n            if(mp.size() == k){\\n                ans = max(ans, sum);\\n            }    \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783402,
                "title": "sliding-window-hashmap-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n         int n=nums.length;      \\n             HashMap<Integer,Integer> hmap=new HashMap<>();\\n             int i=0,j=0;\\n             long res=0,curr=0;\\n             for( i=0;i<n;i++)\\n             {                \\n              while(j<i && (hmap.containsKey(nums[i]) || hmap.size()>=k))\\n              {\\n                 curr=curr-nums[j];\\n                 hmap.remove(nums[j++]);\\n            \\n        }\\n        curr+=nums[i];\\n        if(!hmap.containsKey(nums[i]))\\n        hmap.put(nums[i],1);\\n        else\\n        hmap.put(nums[i],hmap.get(nums[i])+1);\\n            \\n        if (hmap.size()== k)\\n            res = Math.max(res, curr);\\n    }\\n    return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n         int n=nums.length;      \\n             HashMap<Integer,Integer> hmap=new HashMap<>();\\n             int i=0,j=0;\\n             long res=0,curr=0;\\n             for( i=0;i<n;i++)\\n             {                \\n              while(j<i && (hmap.containsKey(nums[i]) || hmap.size()>=k))\\n              {\\n                 curr=curr-nums[j];\\n                 hmap.remove(nums[j++]);\\n            \\n        }\\n        curr+=nums[i];\\n        if(!hmap.containsKey(nums[i]))\\n        hmap.put(nums[i],1);\\n        else\\n        hmap.put(nums[i],hmap.get(nums[i])+1);\\n            \\n        if (hmap.size()== k)\\n            res = Math.max(res, curr);\\n    }\\n    return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783321,
                "title": "c-easy-sliding-window",
                "content": "\\n\\n# Approach\\nEasy Sliding Window\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        unordered_map<int,int> map;\\n        long long res = 0;\\n        long long sum = 0;\\n        for(int i = 0; i < k; i++)\\n        {\\n            sum += nums[i];\\n            map[nums[i]]++;\\n        }\\n        if(map.size() == k)res = max(res,sum);\\n        int j = 0;\\n        for(int i = k; i < n; i++)\\n        {\\n            map[nums[j]]--;\\n            if(map[nums[j]] == 0)map.erase(nums[j]);\\n            sum -= nums[j];\\n            j++;\\n            map[nums[i]]++;\\n            sum += nums[i];\\n            if(map.size() == k)\\n            {\\n                res = max(res,sum);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) \\n    {\\n        int n = nums.size();\\n        unordered_map<int,int> map;\\n        long long res = 0;\\n        long long sum = 0;\\n        for(int i = 0; i < k; i++)\\n        {\\n            sum += nums[i];\\n            map[nums[i]]++;\\n        }\\n        if(map.size() == k)res = max(res,sum);\\n        int j = 0;\\n        for(int i = k; i < n; i++)\\n        {\\n            map[nums[j]]--;\\n            if(map[nums[j]] == 0)map.erase(nums[j]);\\n            sum -= nums[j];\\n            j++;\\n            map[nums[i]]++;\\n            sum += nums[i];\\n            if(map.size() == k)\\n            {\\n                res = max(res,sum);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783279,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        curr=0\\n        hm={}\\n        for i in range(len(nums)):\\n            curr+=nums[i]\\n            if nums[i] in hm:\\n                hm[nums[i]]+=1\\n            else:\\n                hm[nums[i]]=1\\n            if i>=k:\\n                hm[nums[i-k]]-=1\\n                curr-=nums[i-k]\\n            if nums[i-k] in hm:\\n                if hm[nums[i-k]]==0:\\n                    hm.pop(nums[i-k])\\n            if len(hm)==k:\\n                ans=max(ans,curr)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        ans=0\\n        curr=0\\n        hm={}\\n        for i in range(len(nums)):\\n            curr+=nums[i]\\n            if nums[i] in hm:\\n                hm[nums[i]]+=1\\n            else:\\n                hm[nums[i]]=1\\n            if i>=k:\\n                hm[nums[i-k]]-=1\\n                curr-=nums[i-k]\\n            if nums[i-k] in hm:\\n                if hm[nums[i-k]]==0:\\n                    hm.pop(nums[i-k])\\n            if len(hm)==k:\\n                ans=max(ans,curr)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783267,
                "title": "easy-java-greedy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is a sliding window problem\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.) Add Elements in the array untill size of window is k\\n2.) If we find a duplicate element in window then remove all elements in the window uptill the duplicate elements and continue the above process.\\n3.) If size of wwindow greater than k remove elements from window\\n4.) If size of window is equal to k then find update the ans and shift the left and right pointer of window by 1\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        int i=0;\\n        int j=0;\\n        sum=nums[i];\\n        long ans=0;\\n        HashSet<Integer> set1=new HashSet<Integer>();\\n        for(int num:nums){\\n            set1.add(num);\\n        }\\n        if(set1.size()==1 && k>1){\\n            return 0;\\n        }\\n        else if(set1.size()==1 && k==1){\\n            return nums[0];\\n        }\\n        HashMap<Integer,Integer> set=new HashMap<Integer,Integer>();\\n        set.put(nums[i],i);\\n        while(j<nums.length && i<=j){\\n            System.out.println((j-i+1)+\" \"+((j-i+1)==k));\\n            if((j-i+1)==k){\\n                if(set.size()==k){\\n                    ans=Math.max(ans,sum);   \\n                }\\n                set.remove(nums[i]);\\n                sum-=nums[i++];\\n                if(j+1<nums.length){\\n                    if(set.containsKey(nums[j+1])){\\n                        int val=set.get(nums[j+1]);\\n                        for(int a=i;a<=val;a++){\\n                            set.remove(nums[a]);\\n                            sum-=nums[a];\\n                        }\\n                        i=val+1;\\n                    }\\n                    sum+=nums[++j];   \\n                    set.put(nums[j],j);\\n                }\\n                else{\\n                    ++j;   \\n                }\\n            }\\n            else if((j-i+1)<k){\\n                if(j+1<nums.length){\\n                    if(set.containsKey(nums[j+1])){\\n                        int val=set.get(nums[j+1]);\\n                        for(int a=i;a<=val;a++){\\n                            set.remove(nums[a]);\\n                            sum-=nums[a];\\n                        }\\n                        i=val+1;\\n                    }\\n                    sum+=nums[++j];   \\n                    set.put(nums[j],j);\\n                }\\n                else{\\n                    ++j;   \\n                }\\n            }\\n            else{\\n                set.remove(nums[i]);\\n                sum-=nums[i++];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum=0;\\n        int i=0;\\n        int j=0;\\n        sum=nums[i];\\n        long ans=0;\\n        HashSet<Integer> set1=new HashSet<Integer>();\\n        for(int num:nums){\\n            set1.add(num);\\n        }\\n        if(set1.size()==1 && k>1){\\n            return 0;\\n        }\\n        else if(set1.size()==1 && k==1){\\n            return nums[0];\\n        }\\n        HashMap<Integer,Integer> set=new HashMap<Integer,Integer>();\\n        set.put(nums[i],i);\\n        while(j<nums.length && i<=j){\\n            System.out.println((j-i+1)+\" \"+((j-i+1)==k));\\n            if((j-i+1)==k){\\n                if(set.size()==k){\\n                    ans=Math.max(ans,sum);   \\n                }\\n                set.remove(nums[i]);\\n                sum-=nums[i++];\\n                if(j+1<nums.length){\\n                    if(set.containsKey(nums[j+1])){\\n                        int val=set.get(nums[j+1]);\\n                        for(int a=i;a<=val;a++){\\n                            set.remove(nums[a]);\\n                            sum-=nums[a];\\n                        }\\n                        i=val+1;\\n                    }\\n                    sum+=nums[++j];   \\n                    set.put(nums[j],j);\\n                }\\n                else{\\n                    ++j;   \\n                }\\n            }\\n            else if((j-i+1)<k){\\n                if(j+1<nums.length){\\n                    if(set.containsKey(nums[j+1])){\\n                        int val=set.get(nums[j+1]);\\n                        for(int a=i;a<=val;a++){\\n                            set.remove(nums[a]);\\n                            sum-=nums[a];\\n                        }\\n                        i=val+1;\\n                    }\\n                    sum+=nums[++j];   \\n                    set.put(nums[j],j);\\n                }\\n                else{\\n                    ++j;   \\n                }\\n            }\\n            else{\\n                set.remove(nums[i]);\\n                sum-=nums[i++];\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783230,
                "title": "python-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = collections.defaultdict(int)\\n        s = 0\\n        res = 0\\n        for i in range(k):\\n            s += nums[i]\\n            seen[nums[i]] += 1\\n        if len(seen) == k:\\n            res = s\\n        for i in range(k, len(nums)):\\n            s -= nums[i - k]\\n            s += nums[i]\\n            seen[nums[i - k]] -= 1\\n            if seen[nums[i - k]] == 0:\\n                del seen[nums[i - k]]\\n            seen[nums[i]] += 1\\n            if len(seen) == k:\\n                res = max(res, s)\\n        return res\\n\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        long s = 0;\\n        long res = 0;\\n        for (int i = 0; i < k; i ++) {\\n            s += (long)nums[i];\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n        }\\n        if (seen.size() == k) {\\n            res = s;\\n        }\\n        for (int i = k; i < nums.length; i ++) {\\n            s -= nums[i - k];\\n            s += nums[i];\\n            seen.put(nums[i - k], seen.get(nums[i - k]) - 1);\\n            if (seen.get(nums[i - k]) == 0) {\\n                seen.remove(nums[i - k]);\\n            }\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n            if (seen.size() == k) {\\n                res = Math.max(res, s);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = collections.defaultdict(int)\\n        s = 0\\n        res = 0\\n        for i in range(k):\\n            s += nums[i]\\n            seen[nums[i]] += 1\\n        if len(seen) == k:\\n            res = s\\n        for i in range(k, len(nums)):\\n            s -= nums[i - k]\\n            s += nums[i]\\n            seen[nums[i - k]] -= 1\\n            if seen[nums[i - k]] == 0:\\n                del seen[nums[i - k]]\\n            seen[nums[i]] += 1\\n            if len(seen) == k:\\n                res = max(res, s)\\n        return res\\n\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer, Integer> seen = new HashMap<>();\\n        long s = 0;\\n        long res = 0;\\n        for (int i = 0; i < k; i ++) {\\n            s += (long)nums[i];\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n        }\\n        if (seen.size() == k) {\\n            res = s;\\n        }\\n        for (int i = k; i < nums.length; i ++) {\\n            s -= nums[i - k];\\n            s += nums[i];\\n            seen.put(nums[i - k], seen.get(nums[i - k]) - 1);\\n            if (seen.get(nums[i - k]) == 0) {\\n                seen.remove(nums[i - k]);\\n            }\\n            seen.put(nums[i], seen.getOrDefault(nums[i], 0) + 1);\\n            if (seen.size() == k) {\\n                res = Math.max(res, s);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783224,
                "title": "hashmap-sliding-window-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans  = 0,temp = 0;\\n        map<int,int> mp;\\n        for(int i =0;i<k;i++){\\n            mp[nums[i]]++;\\n            temp+=nums[i];\\n        };\\n        if(mp.size() == k){\\n            ans = max(ans,temp);\\n        };\\n        for(int i = k;i<nums.size();i++){\\n              temp-=nums[i-k];\\n             if(--mp[nums[i-k]] == 0){\\n                 mp.erase(nums[i-k]);\\n             };\\n             temp+=nums[i];\\n             mp[nums[i]]++;\\n            if(mp.size() == k){\\n                ans = max(ans,temp);\\n            }\\n        };\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans  = 0,temp = 0;\\n        map<int,int> mp;\\n        for(int i =0;i<k;i++){\\n            mp[nums[i]]++;\\n            temp+=nums[i];\\n        };\\n        if(mp.size() == k){\\n            ans = max(ans,temp);\\n        };\\n        for(int i = k;i<nums.size();i++){\\n              temp-=nums[i-k];\\n             if(--mp[nums[i-k]] == 0){\\n                 mp.erase(nums[i-k]);\\n             };\\n             temp+=nums[i];\\n             mp[nums[i]]++;\\n            if(mp.size() == k){\\n                ans = max(ans,temp);\\n            }\\n        };\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783221,
                "title": "easy-java-solution-sliding-window",
                "content": "```\\npublic long maximumSubarraySum(int[] nums, int k) {\\n        Set<Integer> set= new HashSet<>();\\n        long res=0,sum=0;\\n        int s=0;\\n        for(int e=0;e<nums.length;e++){\\n            sum+=nums[e];\\n            if(set.contains(nums[e])){\\n                s=e;\\n                sum=nums[e];\\n                set.clear();\\n            }\\n            if((e-s+1)==k){\\n                res=Math.max(sum,res);\\n                set.remove(nums[s]);\\n                sum-=nums[s++];\\n            }\\n            set.add(nums[e]);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic long maximumSubarraySum(int[] nums, int k) {\\n        Set<Integer> set= new HashSet<>();\\n        long res=0,sum=0;\\n        int s=0;\\n        for(int e=0;e<nums.length;e++){\\n            sum+=nums[e];\\n            if(set.contains(nums[e])){\\n                s=e;\\n                sum=nums[e];\\n                set.clear();\\n            }\\n            if((e-s+1)==k){\\n                res=Math.max(sum,res);\\n                set.remove(nums[s]);\\n                sum-=nums[s++];\\n            }\\n            set.add(nums[e]);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2783167,
                "title": "using-sliding-window-with-one-variable",
                "content": "**Approach :-**\\n\\t* We have taken a set to consider `k` no of items from `nums`. \\n\\t* Our `set` maintains the list of non-repeating elements in the subarray (set is acting as subarray) and `tempSum` is the temporary sum of the elements present in `set`.\\n\\t* When ever we are removing one element from the beggining from the set, then only we are removeing that from the `tempSum` as well.\\n\\t* Lastly, checking for max of `ans` and `tempSum` when the size of set is equal to `k` and returning the answer after the loop ends.\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>(); long ans = 0, tempSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(set.size() == k && i-k >= 0) { set.remove(nums[i-k]); tempSum -= nums[i-k]; }\\n            if(set.contains(nums[i])) { set.clear(); set.add(nums[i]); tempSum = 0 + nums[i]; }\\n            else {\\n                tempSum += nums[i];\\n                set.add(nums[i]);\\n            }\\n            if(i == k-1 || i >= k) { if(set.size() == k) { ans = Math.max(ans, tempSum); } }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```\\n\\nTime Complexity:- O(n)\\nSpace Complexity:- O(n)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashSet<Integer> set = new HashSet<>(); long ans = 0, tempSum = 0;\\n        \\n        for(int i = 0; i < nums.length; i++){\\n            if(set.size() == k && i-k >= 0) { set.remove(nums[i-k]); tempSum -= nums[i-k]; }\\n            if(set.contains(nums[i])) { set.clear(); set.add(nums[i]); tempSum = 0 + nums[i]; }\\n            else {\\n                tempSum += nums[i];\\n                set.add(nums[i]);\\n            }\\n            if(i == k-1 || i >= k) { if(set.size() == k) { ans = Math.max(ans, tempSum); } }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783143,
                "title": "c-map-sliding-window",
                "content": "```\\nlong long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long maxSum = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        for (int i=0; i<k; i++) {\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n        \\n        if (mp.size()==k) {\\n            maxSum = max(sum, maxSum);\\n        }\\n        \\n        for (int i=k; i<n; i++) {\\n            sum+=nums[i];\\n            sum-=nums[i-k];\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if (mp[nums[i-k]]==0) {\\n                mp.erase(nums[i-k]);\\n            }\\n            if (mp.size()==k) {\\n                maxSum = max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }",
                "solutionTags": [],
                "code": "```\\nlong long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        long long maxSum = 0, sum = 0;\\n        unordered_map<int, int> mp;\\n        for (int i=0; i<k; i++) {\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n        \\n        if (mp.size()==k) {\\n            maxSum = max(sum, maxSum);\\n        }\\n        \\n        for (int i=k; i<n; i++) {\\n            sum+=nums[i];\\n            sum-=nums[i-k];\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;\\n            if (mp[nums[i-k]]==0) {\\n                mp.erase(nums[i-k]);\\n            }\\n            if (mp.size()==k) {\\n                maxSum = max(sum, maxSum);\\n            }\\n        }\\n        return maxSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2783101,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll curSum = 0, counter = 0, ans = 0;\\n        unordered_map<int, int> map;\\n        int i = 0, j = 0;\\n        while(j < k - 1) {\\n            curSum += nums[j];\\n            if(map[nums[j]] == 0)\\n                counter++;\\n            map[nums[j]] = map[nums[j]] + 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            curSum += nums[j];\\n            if(map[nums[j]]++ == 0)\\n                counter++;\\n            if(counter == k) {\\n                ans = max(ans, curSum);\\n            }\\n            curSum -= nums[i];\\n            if(map[nums[i]] == 1)\\n                counter--;\\n            map[nums[i]] = map[nums[i]] - 1;\\n            i++; j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        ll curSum = 0, counter = 0, ans = 0;\\n        unordered_map<int, int> map;\\n        int i = 0, j = 0;\\n        while(j < k - 1) {\\n            curSum += nums[j];\\n            if(map[nums[j]] == 0)\\n                counter++;\\n            map[nums[j]] = map[nums[j]] + 1;\\n            j++;\\n        }\\n        while(j < n) {\\n            curSum += nums[j];\\n            if(map[nums[j]]++ == 0)\\n                counter++;\\n            if(counter == k) {\\n                ans = max(ans, curSum);\\n            }\\n            curSum -= nums[i];\\n            if(map[nums[i]] == 1)\\n                counter--;\\n            map[nums[i]] = map[nums[i]] - 1;\\n            i++; j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783086,
                "title": "java-easy-hashset-solution",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n       HashSet<Integer>set=new HashSet<>();\\n      long max=0;\\n      int a_pointer=0;\\n      long sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        while(a_pointer<i&&(set.contains(nums[i])||set.size()>=k)){\\n          sum-=nums[a_pointer];\\n          set.remove(nums[a_pointer]);\\n          a_pointer++;\\n        }\\n        sum+=nums[i];\\n        set.add(nums[i]);\\n        \\n        if(set.size()==k){\\n          max=Math.max(sum,max);\\n        }\\n      }\\n      return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n       HashSet<Integer>set=new HashSet<>();\\n      long max=0;\\n      int a_pointer=0;\\n      long sum=0;\\n      for(int i=0;i<nums.length;i++){\\n        while(a_pointer<i&&(set.contains(nums[i])||set.size()>=k)){\\n          sum-=nums[a_pointer];\\n          set.remove(nums[a_pointer]);\\n          a_pointer++;\\n        }\\n        sum+=nums[i];\\n        set.add(nums[i]);\\n        \\n        if(set.size()==k){\\n          max=Math.max(sum,max);\\n        }\\n      }\\n      return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095317,
                "title": "clean-sliding-window-solution-in-java-time-o-n-space-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can check each subarray with length k and find the max from it.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf the question does not require unique characters then we can simply use fixed sliding window to find the max subarray with length k. To satisfy the unique character requirement, we need to know if the current subarray contains duplicate - we can use hash map to record the previous index. I use integer array (since we know the range) instead just to make the code cleaner.   \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long res = 0L, sum = 0L;\\n        int n = nums.length;\\n        int[] lastIndex = new int[100_001];\\n        Arrays.fill(lastIndex, -1);\\n        for (int start = 0, end = 0; end < n; end++) {\\n            while (lastIndex[nums[end]] != -1 || end - start + 1 > k) {\\n                sum -= nums[start];\\n                lastIndex[nums[start++]] = -1;\\n            }\\n            sum += nums[end];\\n            if (end - start + 1 == k) {\\n                res = Math.max(res, sum);\\n            }\\n            lastIndex[nums[end]] = end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long res = 0L, sum = 0L;\\n        int n = nums.length;\\n        int[] lastIndex = new int[100_001];\\n        Arrays.fill(lastIndex, -1);\\n        for (int start = 0, end = 0; end < n; end++) {\\n            while (lastIndex[nums[end]] != -1 || end - start + 1 > k) {\\n                sum -= nums[start];\\n                lastIndex[nums[start++]] = -1;\\n            }\\n            sum += nums[end];\\n            if (end - start + 1 == k) {\\n                res = Math.max(res, sum);\\n            }\\n            lastIndex[nums[end]] = end;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4095216,
                "title": "python-solution",
                "content": "# Intuition\\n\\nWe can solve this using a sliding window and set to keep track of repeated elements. We add a new item and then adjust the sliding window according to the problems conditions, similarly to what we did in [longest substring without repeating characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/solutions/3972863/python-solution/)\\n\\n# Approach\\n\\nThe key is the order in which we check adjustments to the sliding window. Before adding anything to our sliding window, we need to adjust it first, that way the code is simpler.\\n\\nThe length of `k` is `r - l + 1`, since we track `[l, r]`\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        l, maxSum, current = 0, 0, 0\\n        # sliding window growing to the right:\\n        for r, item in enumerate(nums):\\n            # shrink the window from the left\\n            while item in seen or (r - l + 1) > k:\\n                left = nums[l]                \\n                seen.remove(left)\\n                current -= left\\n                l += 1\\n            current += item                \\n            seen.add(item)                \\n            # calculate the max when we hit length k:\\n            if (r - l + 1) == k:\\n                maxSum = max(maxSum, current)\\n        \\n        return maxSum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python []\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        seen = set()\\n        l, maxSum, current = 0, 0, 0\\n        # sliding window growing to the right:\\n        for r, item in enumerate(nums):\\n            # shrink the window from the left\\n            while item in seen or (r - l + 1) > k:\\n                left = nums[l]                \\n                seen.remove(left)\\n                current -= left\\n                l += 1\\n            current += item                \\n            seen.add(item)                \\n            # calculate the max when we hit length k:\\n            if (r - l + 1) == k:\\n                maxSum = max(maxSum, current)\\n        \\n        return maxSum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094005,
                "title": "sliding-window-approach-hashmap-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        long long maxi = 0,sum=0;\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            if(mp[nums[j]]==1) cnt++;\\n\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k)\\n            {\\n                if(cnt==k)   maxi = max(maxi,sum);\\n                j++;\\n                sum-=nums[i];\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) cnt--;\\n                i++;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0,j=0;\\n        long long maxi = 0,sum=0;\\n        unordered_map<int,int>mp;\\n        int cnt=0;\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            if(mp[nums[j]]==1) cnt++;\\n\\n            if(j-i+1<k) j++;\\n            else if(j-i+1==k)\\n            {\\n                if(cnt==k)   maxi = max(maxi,sum);\\n                j++;\\n                sum-=nums[i];\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0) cnt--;\\n                i++;\\n            }\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083514,
                "title": "easy-java-solution-using-map-and-sliding-window",
                "content": "# Intuition\\nThe problem requires finding the maximum sum of distinct subarrays of length \\'k\\' within the given array \\'nums\\'. To achieve this, we can use a sliding window approach along with a HashMap to keep track of the elements and their frequencies within the current subarray. \\n\\n# Approach\\n1. Initialize two pointers, \\'i\\' and \\'j,\\' both initially pointing to the start of the array.\\n2. Initialize \\'max\\' and \\'sum\\' to keep track of the maximum sum and the current sum of the subarray, respectively.\\n3. Create a HashMap \\'map\\' to store the elements and their frequencies within the current subarray.\\n4. Move the \\'j\\' pointer to the right while maintaining the current subarray of length \\'k\\'. Update \\'sum\\' and \\'map\\' accordingly.\\n5. If the size of \\'map\\' becomes equal to \\'k\\', update \\'max\\' with the current \\'sum\\' as this subarray has distinct elements.\\n6. Slide the window by incrementing \\'i\\' and \\'j,\\' updating \\'sum\\' and \\'map\\' as elements are removed from the subarray and new elements are included.\\n7. If the size of \\'map\\' remains equal to \\'k,\\' update \\'max\\' if the current \\'sum\\' is greater.\\n8. Repeat steps 6 and 7 until \\'j\\' reaches the end of the array.\\n9. Return the maximum sum \\'max\\' found during the process.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(k)\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public long maximumSubarraySum(int[] nums, int k) \\n    {\\n        int i = 0, j = 0;\\n        long max = 0, sum = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        while(j < k)\\n        {\\n            sum = sum + nums[j];\\n            if(map.containsKey(nums[j]))\\n            {\\n                int v = map.get(nums[j]);\\n                map.put(nums[j], ++v);\\n            }\\n            else\\n            {\\n                map.put(nums[j], 1);\\n            }\\n            j++;\\n        }\\n        j--;\\n        if(map.size() == k)\\n            max = sum;\\n        \\n        while(j < nums.length-1)\\n        {\\n            i++;\\n            j++;\\n            sum = sum - nums[i-1];\\n            sum = sum + nums[j];\\n            \\n            if(map.get(nums[i-1]) == 1)\\n                map.remove(nums[i-1]);\\n            else\\n            {\\n                int val = map.get(nums[i-1]);\\n                map.put(nums[i-1], --val);\\n            }\\n            \\n            if(map.containsKey(nums[j]))\\n            {\\n                int v = map.get(nums[j]);\\n                map.put(nums[j], ++v);\\n            }\\n            else\\n            {\\n                map.put(nums[j], 1);\\n            }\\n            \\n            if(sum > max && map.size() == k)\\n                max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public long maximumSubarraySum(int[] nums, int k) \\n    {\\n        int i = 0, j = 0;\\n        long max = 0, sum = 0;\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        while(j < k)\\n        {\\n            sum = sum + nums[j];\\n            if(map.containsKey(nums[j]))\\n            {\\n                int v = map.get(nums[j]);\\n                map.put(nums[j], ++v);\\n            }\\n            else\\n            {\\n                map.put(nums[j], 1);\\n            }\\n            j++;\\n        }\\n        j--;\\n        if(map.size() == k)\\n            max = sum;\\n        \\n        while(j < nums.length-1)\\n        {\\n            i++;\\n            j++;\\n            sum = sum - nums[i-1];\\n            sum = sum + nums[j];\\n            \\n            if(map.get(nums[i-1]) == 1)\\n                map.remove(nums[i-1]);\\n            else\\n            {\\n                int val = map.get(nums[i-1]);\\n                map.put(nums[i-1], --val);\\n            }\\n            \\n            if(map.containsKey(nums[j]))\\n            {\\n                int v = map.get(nums[j]);\\n                map.put(nums[j], ++v);\\n            }\\n            else\\n            {\\n                map.put(nums[j], 1);\\n            }\\n            \\n            if(sum > max && map.size() == k)\\n                max = sum;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074881,
                "title": "python3-sliding-window-and-dictionary",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        left = 0\\n        right = 1\\n        num_to_idx = {nums[0] : 0}\\n        max_sum = 0\\n        cur_sum = nums[left]\\n        # edge case where k = 1 if not handled this messes up inclusive bounds for right - left\\n        if k == 1:\\n            return max(nums)\\n        while right < len(nums):\\n            # currently processed subarray has duplicate. Need to start a new subarray\\n            if nums[right] in num_to_idx:\\n                # start from number after duplicate number\\n                left = num_to_idx[nums[right]] + 1\\n                # right will be incremented below in all cases\\n                right = left\\n                # handle edge case where left is at the end of nums\\n                if left >= len(nums) -1:\\n                    return max_sum\\n                # reset num_to_idx and cur_sum\\n                cur_sum = 0\\n                num_to_idx = {}\\n            # always add right to current_sum and seen\\n            cur_sum += nums[right]\\n            num_to_idx[nums[right]] = right\\n            \\n            # right - left == k -> valid subarry update max and adjust left\\n            if right - left == k - 1:\\n                max_sum = max(max_sum, cur_sum)\\n                # old left value leaves subarray and running sum\\n                cur_sum -= nums[left]\\n                del num_to_idx[nums[left]]\\n                left +=1\\n            # always add in right to num_to_idx and current_sum\\n            right +=1\\n\\n        return max_sum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        left = 0\\n        right = 1\\n        num_to_idx = {nums[0] : 0}\\n        max_sum = 0\\n        cur_sum = nums[left]\\n        # edge case where k = 1 if not handled this messes up inclusive bounds for right - left\\n        if k == 1:\\n            return max(nums)\\n        while right < len(nums):\\n            # currently processed subarray has duplicate. Need to start a new subarray\\n            if nums[right] in num_to_idx:\\n                # start from number after duplicate number\\n                left = num_to_idx[nums[right]] + 1\\n                # right will be incremented below in all cases\\n                right = left\\n                # handle edge case where left is at the end of nums\\n                if left >= len(nums) -1:\\n                    return max_sum\\n                # reset num_to_idx and cur_sum\\n                cur_sum = 0\\n                num_to_idx = {}\\n            # always add right to current_sum and seen\\n            cur_sum += nums[right]\\n            num_to_idx[nums[right]] = right\\n            \\n            # right - left == k -> valid subarry update max and adjust left\\n            if right - left == k - 1:\\n                max_sum = max(max_sum, cur_sum)\\n                # old left value leaves subarray and running sum\\n                cur_sum -= nums[left]\\n                del num_to_idx[nums[left]]\\n                left +=1\\n            # always add in right to num_to_idx and current_sum\\n            right +=1\\n\\n        return max_sum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073930,
                "title": "very-easy-approach-code-is-explained-line-by-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nevery piece of code is explaine dline by line.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nlook at the code you will easily get it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0;//final answer\\n        long long temp_sum=0;//temporary sum\\n        unordered_map<long long,long long> map_ele;//map to store the frequency of elements\\n        for(long long index=0;index<nums.size();index++){\\n            map_ele[nums[index]]++;//pushing the elemnent of array into map as key and increasing its value by 1; \\n            temp_sum=temp_sum+nums[index]; //adding the element to temporary sum\\n\\n            if(index>=k-1){//checking if the index reached a value such that our required window size is achieved\\n                if(map_ele.size()==k) ans=max(ans,temp_sum);//checking whether we have three distinct elements in our map or not,if yes then updating our final ans;\\n                temp_sum=temp_sum-nums[index-k+1]; //deleting the first element of the window from our temp_sum;\\n                if(--map_ele[nums[index-k+1]]==0) map_ele.erase(nums[index-k+1]); //if frequency our first element is only one than remove that element from ourmap;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long ans=0;//final answer\\n        long long temp_sum=0;//temporary sum\\n        unordered_map<long long,long long> map_ele;//map to store the frequency of elements\\n        for(long long index=0;index<nums.size();index++){\\n            map_ele[nums[index]]++;//pushing the elemnent of array into map as key and increasing its value by 1; \\n            temp_sum=temp_sum+nums[index]; //adding the element to temporary sum\\n\\n            if(index>=k-1){//checking if the index reached a value such that our required window size is achieved\\n                if(map_ele.size()==k) ans=max(ans,temp_sum);//checking whether we have three distinct elements in our map or not,if yes then updating our final ans;\\n                temp_sum=temp_sum-nums[index-k+1]; //deleting the first element of the window from our temp_sum;\\n                if(--map_ele[nums[index-k+1]]==0) map_ele.erase(nums[index-k+1]); //if frequency our first element is only one than remove that element from ourmap;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072921,
                "title": "basic-approach-tried-to-solve-with-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        if(n <k)\\n        {\\n            return 0;\\n        }\\n        long long ans =0;\\n        int j=0;\\n        long long sum = 0;\\n        for(int i =0; i<n;i++)\\n        {\\n            sum +=nums[i];\\n            if(mp.find(nums[i]) == mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            if(i-j ==k-1)\\n            {\\n                ans=max(ans,sum);\\n\\n            }else if(i-j > k-1)\\n            {\\n                sum -= nums[j];\\n                mp.erase(nums[j]);\\n                j++;\\n                ans=max(ans,sum);\\n            }\\n            }else\\n            {\\n                while(j<=mp[nums[i]])\\n                {\\n                    sum -=nums[j];\\n                    mp.erase(nums[j]);\\n                    j++;\\n                }\\n                mp[nums[i]]=i;\\n                if(i -j> k-1)\\n                {\\n                    ans=max(ans,sum);\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        if(n <k)\\n        {\\n            return 0;\\n        }\\n        long long ans =0;\\n        int j=0;\\n        long long sum = 0;\\n        for(int i =0; i<n;i++)\\n        {\\n            sum +=nums[i];\\n            if(mp.find(nums[i]) == mp.end())\\n            {\\n                mp[nums[i]]=i;\\n            if(i-j ==k-1)\\n            {\\n                ans=max(ans,sum);\\n\\n            }else if(i-j > k-1)\\n            {\\n                sum -= nums[j];\\n                mp.erase(nums[j]);\\n                j++;\\n                ans=max(ans,sum);\\n            }\\n            }else\\n            {\\n                while(j<=mp[nums[i]])\\n                {\\n                    sum -=nums[j];\\n                    mp.erase(nums[j]);\\n                    j++;\\n                }\\n                mp[nums[i]]=i;\\n                if(i -j> k-1)\\n                {\\n                    ans=max(ans,sum);\\n                }\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070142,
                "title": "javascript-o-n-sliding-window-95-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Using a sliding window.\\nCounting disting occurunces of numbers in a sliding window.\\nKeep a count of distinct item in the sliding window.\\nIterating only once through the array of nums to keep time complexity linear O(n).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing a sliding window, by adding the `currentNum` (new number introduced to the sliding window) and by removing the `previousNum` (number to remove from the sliding window).\\nKeep a count of how many `distinct` numbers do I have in my current `slidingWindow` increasing or decreasing by 1 the relevant entry in the `slidingWindow`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nvar maximumSubarraySum = function(nums, k) {\\n    if (nums.length < k) return 0;\\n    \\n    let maxSum = 0;\\n    let currentSum = 0;\\n    const slidingWindow = {};\\n    let distinct = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n       const currentNum = nums[i];\\n       if ( slidingWindow[currentNum] ) {\\n          slidingWindow[currentNum] += 1;  \\n       } else {\\n         slidingWindow[currentNum] = 1;\\n         distinct++;\\n       }\\n       currentSum += currentNum;\\n       if ( i >= k ) {\\n         const prevNum = nums[i-k]\\n         if (slidingWindow[prevNum] === 1) {\\n           slidingWindow[prevNum] = undefined;\\n           distinct--;\\n         } else {\\n           slidingWindow[prevNum] -= 1;\\n         }\\n        currentSum -= prevNum;\\n       }       \\n       if (distinct === k && currentSum > maxSum) {\\n         maxSum = currentSum;\\n       }\\n    }\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maximumSubarraySum = function(nums, k) {\\n    if (nums.length < k) return 0;\\n    \\n    let maxSum = 0;\\n    let currentSum = 0;\\n    const slidingWindow = {};\\n    let distinct = 0;\\n\\n    for (let i = 0; i < nums.length; i++) {\\n       const currentNum = nums[i];\\n       if ( slidingWindow[currentNum] ) {\\n          slidingWindow[currentNum] += 1;  \\n       } else {\\n         slidingWindow[currentNum] = 1;\\n         distinct++;\\n       }\\n       currentSum += currentNum;\\n       if ( i >= k ) {\\n         const prevNum = nums[i-k]\\n         if (slidingWindow[prevNum] === 1) {\\n           slidingWindow[prevNum] = undefined;\\n           distinct--;\\n         } else {\\n           slidingWindow[prevNum] -= 1;\\n         }\\n        currentSum -= prevNum;\\n       }       \\n       if (distinct === k && currentSum > maxSum) {\\n         maxSum = currentSum;\\n       }\\n    }\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061028,
                "title": "simple-sliding-window-solution-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& v, int k) {\\n        long long ans=0;\\n        map<int,int>mp;\\n        long long sum=0;\\n        int j=0,c=0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(c<k)\\n            {\\n                sum+=v[i];\\n                mp[v[i]]++;\\n                c++;\\n                if(c==k)\\n                {\\n                    if(mp.size()==k)\\n                    {\\n                        ans=max(ans,sum);\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                sum-=v[j];\\n                mp[v[j]]--;\\n                if(mp[v[j]]==0)\\n                mp.erase(v[j]);\\n                j++;\\n                sum+=v[i];\\n                mp[v[i]]++;\\n                if(mp.size()==k)\\n                ans=max(ans,sum);\\n\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& v, int k) {\\n        long long ans=0;\\n        map<int,int>mp;\\n        long long sum=0;\\n        int j=0,c=0;\\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(c<k)\\n            {\\n                sum+=v[i];\\n                mp[v[i]]++;\\n                c++;\\n                if(c==k)\\n                {\\n                    if(mp.size()==k)\\n                    {\\n                        ans=max(ans,sum);\\n                    }\\n                }\\n            }\\n            else \\n            {\\n                sum-=v[j];\\n                mp[v[j]]--;\\n                if(mp[v[j]]==0)\\n                mp.erase(v[j]);\\n                j++;\\n                sum+=v[i];\\n                mp[v[i]]++;\\n                if(mp.size()==k)\\n                ans=max(ans,sum);\\n\\n            }\\n\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4051218,
                "title": "c-using-sliding-window-and-hash-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long i=0,j=0,sum=0,ans=0;\\n        unordered_map<long long, long long> mp;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            if(j-i+1<k)\\n             j++;\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                ans=max(sum,ans);\\n                sum=sum-nums[i];\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                i++;\\n                }\\n                else {\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)\\n                     mp.erase(nums[i]);\\n                     sum=sum-nums[i];\\n                     i++;\\n                }\\n                j++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        long long i=0,j=0,sum=0,ans=0;\\n        unordered_map<long long, long long> mp;\\n        while(j<nums.size()){\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n            if(j-i+1<k)\\n             j++;\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                ans=max(sum,ans);\\n                sum=sum-nums[i];\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                   mp.erase(nums[i]);\\n                i++;\\n                }\\n                else {\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]]==0)\\n                     mp.erase(nums[i]);\\n                     sum=sum-nums[i];\\n                     i++;\\n                }\\n                j++;\\n            } \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041791,
                "title": "sliding-window-with-hashmap-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding window with hashmap O(N)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nusing sliding window with hashmap to remember the duplicates.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumSubarraySum = function(nums, k) {\\n    let window = new Map();\\n    let windowSum = 0;\\n    let maxSum = 0;\\n    let startIndx = 0;\\n    for(let currentIndx = 0; currentIndx < nums.length; currentIndx++) {\\n        const currentNumber = nums[currentIndx];\\n        const existedIndx = window.get(currentNumber);\\n        // current element is duplicate regardless current window size\\n        if(window.has(currentNumber)) {\\n            // delete all numbers before duplicated index.\\n            for(let j = startIndx; j < existedIndx; j++){\\n                window.delete(nums[j]);\\n                windowSum -= nums[j];\\n            }\\n            // and start a new window after (existedIndx).\\n            startIndx = existedIndx + 1;\\n        } else if(window.size < k) { \\n            // current element not duplicate then add it to current (windowSum)\\n            windowSum += currentNumber;\\n        } else { \\n            // otherwise we have window of size (k) then we need to move the window.\\n            window.delete(nums[startIndx]);  \\n            windowSum = (windowSum - nums[startIndx]) + currentNumber;  \\n            startIndx++;\\n        }\\n        // update the current number indx\\n        window.set(currentNumber, currentIndx);\\n        // calculate max only if we have window of size (k)\\n        if(window.size === k) \\n           maxSum = Math.max(maxSum, windowSum);\\n    }\\n\\n    return maxSum;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumSubarraySum = function(nums, k) {\\n    let window = new Map();\\n    let windowSum = 0;\\n    let maxSum = 0;\\n    let startIndx = 0;\\n    for(let currentIndx = 0; currentIndx < nums.length; currentIndx++) {\\n        const currentNumber = nums[currentIndx];\\n        const existedIndx = window.get(currentNumber);\\n        // current element is duplicate regardless current window size\\n        if(window.has(currentNumber)) {\\n            // delete all numbers before duplicated index.\\n            for(let j = startIndx; j < existedIndx; j++){\\n                window.delete(nums[j]);\\n                windowSum -= nums[j];\\n            }\\n            // and start a new window after (existedIndx).\\n            startIndx = existedIndx + 1;\\n        } else if(window.size < k) { \\n            // current element not duplicate then add it to current (windowSum)\\n            windowSum += currentNumber;\\n        } else { \\n            // otherwise we have window of size (k) then we need to move the window.\\n            window.delete(nums[startIndx]);  \\n            windowSum = (windowSum - nums[startIndx]) + currentNumber;  \\n            startIndx++;\\n        }\\n        // update the current number indx\\n        window.set(currentNumber, currentIndx);\\n        // calculate max only if we have window of size (k)\\n        if(window.size === k) \\n           maxSum = Math.max(maxSum, windowSum);\\n    }\\n\\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4033262,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        int i = 0, j = 0;\\n        while(j < nums.length){\\n            while(hs.contains(nums[j])){\\n                sum -= nums[i];\\n                hs.remove(nums[i++]);\\n            }\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n            if(j - i + 1 == k){\\n                res = Math.max(res, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i++]);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long sum = 0, res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        int i = 0, j = 0;\\n        while(j < nums.length){\\n            while(hs.contains(nums[j])){\\n                sum -= nums[i];\\n                hs.remove(nums[i++]);\\n            }\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n            if(j - i + 1 == k){\\n                res = Math.max(res, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i++]);\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026255,
                "title": "sliding-window-using-has-map-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code you provided is an implementation of the sliding window algorithm used to find the maximum subarray sum with `k` distinct elements in a given vector `nums`. Let me explain the intuition behind this approach step by step:\\n\\n1. Initialize two pointers, `i` and `j`, to 0. These pointers represent the left and right boundaries of the sliding window.\\n\\n2. Initialize variables `sum` and `ans` to 0. `sum` will keep track of the current sum of elements within the sliding window, and `ans` will store the maximum subarray sum with `k` distinct elements found so far.\\n\\n3. Create an unordered map (`map`) to keep track of the frequency of elements within the current window. The keys of the map are the elements in the window, and the values are their frequencies.\\n\\n4. Start a while loop that runs until the right pointer `j` reaches the end of the array.\\n\\n5. Inside the loop:\\n   - Add the element `nums[j]` to the current sum `sum`.\\n   - Check if `nums[j]` is already in the map (i.e., it\\'s a distinct element within the current window). If not, add it to the map with a frequency of 1. If it\\'s already in the map, increment its frequency.\\n   - Check if the size of the map (`map.size()`) is equal to `k`. If it is, update `ans` by taking the maximum of the current `ans` and `sum`. This means you have found a subarray with `k` distinct elements, and you want to maximize the sum.\\n   \\n6. Check if the size of the current window (i.e., `j - i + 1`) is equal to `k`. If it is, it means the window size has reached `k` distinct elements. In this case:\\n   - Subtract the element `nums[i]` from the current sum `sum` as it\\'s moving out of the window.\\n   - Decrease the frequency of `nums[i]` in the map by 1.\\n   - If the frequency of `nums[i]` becomes 0, remove it from the map because it\\'s no longer in the window.\\n   - Increment the left pointer `i`, effectively moving the left boundary of the window to the right.\\n\\n7. Increment the right pointer `j` to expand the window.\\n\\n8. Repeat steps 5-7 until you\\'ve processed all elements in the array.\\n\\n9. Finally, return the value stored in `ans`, which represents the maximum subarray sum with `k` distinct elements.\\n\\nThis sliding window approach efficiently finds the maximum subarray sum with `k` distinct elements while maintaining a sliding window of distinct elements, making it a useful technique for various problems involving subarrays and distinct elements.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       int i=0,j=0,n=nums.size();\\n       long sum=0,ans=0;\\n       unordered_map<int,int>map;\\n       while(j<n) {\\n           sum+=nums[j];\\n           if (map.find(nums[j]) == map.end())\\n                map[nums[j]] = 1;\\n            else\\n                map[nums[j]]++;\\n            if(map.size()==k) ans=max(ans,sum);\\n            if(j-i+1==k){\\n                sum-= nums[i];\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0) map.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       int i=0,j=0,n=nums.size();\\n       long sum=0,ans=0;\\n       unordered_map<int,int>map;\\n       while(j<n) {\\n           sum+=nums[j];\\n           if (map.find(nums[j]) == map.end())\\n                map[nums[j]] = 1;\\n            else\\n                map[nums[j]]++;\\n            if(map.size()==k) ans=max(ans,sum);\\n            if(j-i+1==k){\\n                sum-= nums[i];\\n                map[nums[i]]--;\\n                if(map[nums[i]]==0) map.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010657,
                "title": "java-sliding-window-hashmap",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSubarraySum = 0;\\n        long windowSum = 0;\\n        int windowStart = 0;\\n\\n        // To check if the subarray is distinct\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i< nums.length; i++) {\\n            windowSum+=nums[i];\\n            \\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n\\n            if(i>=k-1) {\\n                if(map.size() == k) {\\n                    maxSubarraySum = Math.max(maxSubarraySum, windowSum);\\n                }\\n                windowSum-=nums[i+1-k];\\n                map.put(nums[i+1-k], map.get(nums[i+1-k])-1);\\n                if(map.get(nums[i+1-k]) == 0) map.remove(nums[i+1-k]);\\n            }\\n        }\\n        return maxSubarraySum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSubarraySum = 0;\\n        long windowSum = 0;\\n        int windowStart = 0;\\n\\n        // To check if the subarray is distinct\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for(int i = 0; i< nums.length; i++) {\\n            windowSum+=nums[i];\\n            \\n            map.put(nums[i], map.getOrDefault(nums[i], 0)+1);\\n\\n            if(i>=k-1) {\\n                if(map.size() == k) {\\n                    maxSubarraySum = Math.max(maxSubarraySum, windowSum);\\n                }\\n                windowSum-=nums[i+1-k];\\n                map.put(nums[i+1-k], map.get(nums[i+1-k])-1);\\n                if(map.get(nums[i+1-k]) == 0) map.remove(nums[i+1-k]);\\n            }\\n        }\\n        return maxSubarraySum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008347,
                "title": "hashmap-java-o-n",
                "content": "import java.util.*;\\n\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0;\\n        long[] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (long) nums[i];\\n        }\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n\\n        }\\n        maxSum = map.size() == k ? prefixSum[k - 1] : 0;\\n\\n        for (int i = k; i < nums.length; i++) {\\n            int olderVal = nums[i - k];\\n            int curVal = nums[i];\\n\\n            Integer count = map.get(olderVal);\\n            count--;\\n            if (count == 0) {\\n                map.remove(olderVal);\\n            } else {\\n                map.put(olderVal, count);\\n            }\\n            map.put(curVal, map.getOrDefault(curVal, 0) + 1);\\n            if (map.size() == k) {\\n                maxSum = Math.max(maxSum, prefixSum[i] - prefixSum[i - k]);\\n            }\\n\\n\\n        }\\n        return maxSum;\\n\\n\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        long maxSum = 0;\\n        long[] prefixSum = new long[nums.length];\\n        prefixSum[0] = nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + (long) nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4003734,
                "title": "easy-to-understand-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        long sum=0;\\n        long maxsum=0;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n\\n        while(i<nums.length){\\n            sum+=nums[i];\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            count++;\\n\\n            if(count==k){\\n                if(hm.size()==k){\\n                    maxsum=Math.max(maxsum,sum);\\n                }\\n                sum-=nums[j];\\n                hm.put(nums[j],hm.get(nums[j])-1);\\n                if(hm.get(nums[j])==0){\\n                    hm.remove(nums[j]);                  \\n                }\\n                j++;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        HashMap<Integer,Integer> hm=new HashMap<>();\\n        long sum=0;\\n        long maxsum=0;\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n\\n        while(i<nums.length){\\n            sum+=nums[i];\\n            hm.put(nums[i],hm.getOrDefault(nums[i],0)+1);\\n            count++;\\n\\n            if(count==k){\\n                if(hm.size()==k){\\n                    maxsum=Math.max(maxsum,sum);\\n                }\\n                sum-=nums[j];\\n                hm.put(nums[j],hm.get(nums[j])-1);\\n                if(hm.get(nums[j])==0){\\n                    hm.remove(nums[j]);                  \\n                }\\n                j++;\\n                count--;\\n            }\\n            i++;\\n        }\\n        return maxsum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3996271,
                "title": "fast-solution-hashmap-easy-to-understand",
                "content": "# Approach : \\n1. Initialize a `Map<Integer, Integer>` called `map` to store the count of distinct elements in the current window, `res` to store the maximum subarray sum, and `s` to maintain the running sum of the current window.\\n2. Iterate through the `nums` array using a loop:\\n    - If `i` is greater than or equal to `k`, it means the window has moved past the `k` elements. So, decrement the count of the element at the `(i - k)` position in the `map` by 1 using `map.merge(nums[i - k], -1, Integer::sum)`. If the count becomes 0 (meaning there are no more occurrences of that element), remove it from the `map`. Also, subtract the value of the element at the `(i - k)` position from the running sum `s`.\\n    - For the current element at position `i`, increment its count in the `map` by 1 using `map.merge(nums[i], 1, Integer::sum)`. Add the value of the current element to the running sum `s`.\\n    - Check if the size of the `map` is equal to `k`. If it is, it means you have a subarray with exactly `k` distinct elements. Update `res` with the maximum of `s` and the current `res`. This step ensures that you keep track of the maximum subarray sum with `k` distinct elements encountered so far.\\n\\n\\n# Small dru run of code : \\n![image.png](https://assets.leetcode.com/users/images/6539e383-33ae-4e36-a42d-aacda4c5d06b_1693730295.0052867.png)\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        long res = 0;\\n        long s = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i>=k){\\n                map.merge(nums[i-k],-1,Integer::sum);\\n                if(map.get(nums[i-k])==0)\\n                    map.remove(nums[i-k]);\\n                s-=nums[i-k];\\n            }\\n            map.merge(nums[i],1,Integer::sum);\\n            s+=nums[i];\\n            if(map.size()==k)\\n                res=Math.max(s,res);\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/3d918e4b-1ca8-4eec-b490-586a4be02be1_1693730342.704382.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        long res = 0;\\n        long s = 0;\\n        for(int i=0;i<nums.length;i++){\\n            if(i>=k){\\n                map.merge(nums[i-k],-1,Integer::sum);\\n                if(map.get(nums[i-k])==0)\\n                    map.remove(nums[i-k]);\\n                s-=nums[i-k];\\n            }\\n            map.merge(nums[i],1,Integer::sum);\\n            s+=nums[i];\\n            if(map.size()==k)\\n                res=Math.max(s,res);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3994798,
                "title": "in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n code is an implementation of a sliding window approach to find the maximum subarray sum of length `k` with distinct elements in an array `nums`. Here\\'s a step-by-step explanation of how your code works:\\n\\n1. Initialize two pointers `i` and `j` to 0. These pointers represent the left and right boundaries of the current window.\\n\\n2. Initialize `sum` and `max` to 0. `sum` will keep track of the current sum of elements within the window, and `max` will store the maximum sum encountered so far.\\n\\n3. Create a boolean array `vals` of size 100001 (you can adjust this size based on the expected range of values in `nums`). This array is used to keep track of whether an element has been visited within the current window.\\n\\n4. Enter a while loop that continues as long as the right pointer `j` is within the bounds of the `nums` array.\\n\\n5. Inside the loop:\\n   - Add the element `nums[j]` to the current sum `sum`.\\n   - Check if `nums[j]` has been visited before (i.e., `vals[nums[j]] == true`). If it hasn\\'t been visited, mark it as visited (`vals[nums[j]] = true`).\\n   - If `nums[j]` has been visited before, it means that there\\'s a duplicate element within the window. In this case, enter a nested while loop:\\n     - In the nested loop, move the left pointer `i` to the right until `nums[i]` becomes equal to `nums[j]`. While doing this, subtract `nums[i]` from the current sum `sum` and mark `nums[i]` as not visited (`vals[nums[i]] = false`).\\n   - After removing the duplicate elements, subtract `nums[i]` from the current sum `sum` and mark `nums[i]` as not visited. Increment the left pointer `i` to move the window to the right.\\n   - Check if the length of the current window (`j - i + 1`) is equal to `k`. If it is, update `max` to be the maximum of the current `max` and the current `sum`. Also, subtract `nums[i]` from the current sum `sum` and mark it as not visited, then increment `i` to move the window to the right.\\n\\n6. Increment the right pointer `j` to continue sliding the window to the right.\\n\\n7. Once the loop ends, return the maximum value stored in `max`, which represents the maximum subarray sum of length `k` with distinct elements in the `nums` array.\\n \\ncode efficiently finds the maximum subarray sum meeting the specified conditions by maintaining a sliding window and keeping track of visited elements using the `vals` array. It avoids recalculating sums and only updates the window and sum when necessary.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/*import java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        ArrayList<Integer> s1 = new ArrayList<>();\\n        ArrayList<Integer> s2 = new ArrayList<>();\\n\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            int count = 0;\\n            int j = i;\\n            int sum = 0; // Running sum of elements in s1\\n            \\n            while (count != k) {\\n                s1.add(nums[j]);\\n                sum += nums[j]; // Update the running sum\\n                j++;\\n                count++;\\n            }\\n\\n            HashSet<Integer> check = new HashSet<>(s1);\\n\\n            // Checking if s1 has distinct elements or not\\n            if (check.size() == s1.size()) {\\n                s2.add(sum); // Add the running sum to s2\\n            }\\n            s1.clear();\\n        }\\n\\n        Collections.sort(s2);\\n\\n        if (s2.isEmpty()) {\\n            return 0;\\n        }\\n\\n        return s2.get(s2.size() - 1);\\n    }\\n}\\n*/\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0,j=0;\\n        long sum =0,max=0;\\n        boolean vals[]=new boolean[100001];\\n       while(j<nums.length){\\n            sum+=nums[j];\\n            if(vals[nums[j]]!=true){\\n                vals[nums[j]]=true;\\n            }else{\\n                while(nums[i]!=nums[j] && i<j){\\n                    sum-=nums[i];\\n                    vals[nums[i]]=false;\\n                    i++;\\n                }\\n                sum-=nums[i];\\n                i++;\\n            }\\n            if(j-i+1==k){\\n                max = Math.max(max,sum);\\n                sum-=nums[i];\\n                vals[nums[i]]=false;\\n                i++;\\n            }\\n            j++;\\n        } \\n        return max;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*import java.util.ArrayList;\\nimport java.util.Collections;\\nimport java.util.HashSet;\\n\\npublic class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        ArrayList<Integer> s1 = new ArrayList<>();\\n        ArrayList<Integer> s2 = new ArrayList<>();\\n\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            int count = 0;\\n            int j = i;\\n            int sum = 0; // Running sum of elements in s1\\n            \\n            while (count != k) {\\n                s1.add(nums[j]);\\n                sum += nums[j]; // Update the running sum\\n                j++;\\n                count++;\\n            }\\n\\n            HashSet<Integer> check = new HashSet<>(s1);\\n\\n            // Checking if s1 has distinct elements or not\\n            if (check.size() == s1.size()) {\\n                s2.add(sum); // Add the running sum to s2\\n            }\\n            s1.clear();\\n        }\\n\\n        Collections.sort(s2);\\n\\n        if (s2.isEmpty()) {\\n            return 0;\\n        }\\n\\n        return s2.get(s2.size() - 1);\\n    }\\n}\\n*/\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int i=0,j=0;\\n        long sum =0,max=0;\\n        boolean vals[]=new boolean[100001];\\n       while(j<nums.length){\\n            sum+=nums[j];\\n            if(vals[nums[j]]!=true){\\n                vals[nums[j]]=true;\\n            }else{\\n                while(nums[i]!=nums[j] && i<j){\\n                    sum-=nums[i];\\n                    vals[nums[i]]=false;\\n                    i++;\\n                }\\n                sum-=nums[i];\\n                i++;\\n            }\\n            if(j-i+1==k){\\n                max = Math.max(max,sum);\\n                sum-=nums[i];\\n                vals[nums[i]]=false;\\n                i++;\\n            }\\n            j++;\\n        } \\n        return max;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3991274,
                "title": "easy-to-understand-c-solution-using-unordered-map-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       long long ans=0;\\n       long long curr_sum=0;\\n       int n=nums.size();\\n       int i=0;int j=0;\\n       unordered_map<int,int> mp;\\n       while(j<n){\\n        mp[nums[j]]++;\\n        curr_sum+=nums[j];\\n        if(j-i+1<k){\\n            j++;\\n        }\\n        else if(j-i+1==k){\\n           if(mp.size()==k){\\n               ans=max(ans,curr_sum);\\n           }\\n           curr_sum-=nums[i];\\n           mp[nums[i]]--;\\n           if(mp[nums[i]]==0) mp.erase(nums[i]);\\n           i++;j++;\\n        }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n       long long ans=0;\\n       long long curr_sum=0;\\n       int n=nums.size();\\n       int i=0;int j=0;\\n       unordered_map<int,int> mp;\\n       while(j<n){\\n        mp[nums[j]]++;\\n        curr_sum+=nums[j];\\n        if(j-i+1<k){\\n            j++;\\n        }\\n        else if(j-i+1==k){\\n           if(mp.size()==k){\\n               ans=max(ans,curr_sum);\\n           }\\n           curr_sum-=nums[i];\\n           mp[nums[i]]--;\\n           if(mp[nums[i]]==0) mp.erase(nums[i]);\\n           i++;j++;\\n        }\\n       }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987724,
                "title": "2461-maximum-sum-of-distinct-subarrays-with-length-k-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        long long maxi=0,sum =0;\\n\\n        for(int i =0;i<k-1;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n\\n        for(int i = k-1; i< n ;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n\\n            if(mp.size() == k) maxi = max(sum,maxi);\\n\\n            // if size is one the remove it because i include this \\n            if(mp[nums[i-k+1]] == 1) mp.erase(nums[i-k+1]);\\n\\n            else mp[nums[i-k+1]]--;\\n\\n            // save the output and move the window\\n            sum-=nums[i-k+1];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int,int> mp;\\n        int n = nums.size();\\n        long long maxi=0,sum =0;\\n\\n        for(int i =0;i<k-1;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n        }\\n\\n        for(int i = k-1; i< n ;i++){\\n            sum+=nums[i];\\n            mp[nums[i]]++;\\n\\n            if(mp.size() == k) maxi = max(sum,maxi);\\n\\n            // if size is one the remove it because i include this \\n            if(mp[nums[i-k+1]] == 1) mp.erase(nums[i-k+1]);\\n\\n            else mp[nums[i-k+1]]--;\\n\\n            // save the output and move the window\\n            sum-=nums[i-k+1];\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3986261,
                "title": "intuitive-oop-solution",
                "content": "# Approach\\nThis solution uses the sliding window approach but abstracts the window implementation details into an object. This leaves only the solution logic in the function making it easy to read/understand. \\n\\nThe drawback to this approach is the extra overhead from creating/manipulating an object.\\n\\nThis will pass the submission tests but with poor runtime/memory metrics. \\n\\n# Code\\n```\\nclass Solution:\\n    class Window:\\n        def __init__(self, k: int) -> None:\\n            self.windowSum = 0\\n            self.windowDict = collections.defaultdict(int)\\n            self.sizeLimit = k\\n            self.windowDupes = 0\\n\\n        def isValid(self) -> bool:\\n            if self.windowDupes == 0 and len(self.windowDict) == self.sizeLimit:\\n                return True\\n            return False\\n        \\n        def hasDupes(self) -> bool:\\n            return True if self.windowDupes > 0 else False\\n\\n        def hasExceededSize(self) -> bool:\\n            return True if len(self.windowDict) > self.sizeLimit else False\\n                \\n        def add(self, n: int) -> None:\\n            self.windowSum += n\\n            self.windowDict[n] += 1\\n            if self.windowDict[n] > 1:\\n                self.windowDupes += 1\\n        \\n        def remove(self, n: int) -> None:\\n            self.windowSum -= n\\n            self.windowDict[n] -= 1\\n            if self.windowDict[n] >= 1:\\n                self.windowDupes -= 1\\n            if self.windowDict[n] == 0:\\n                self.windowDict.pop(n)\\n        \\n        def sum(self) -> int:\\n            return self.windowSum\\n\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        leftIdx = 0\\n        maxSum = 0\\n        window = self.Window(k)\\n        for rightIdx in range(len(nums)):\\n            window.add(nums[rightIdx])\\n            \\n            while window.hasDupes() or window.hasExceededSize():\\n                window.remove(nums[leftIdx])\\n                leftIdx += 1\\n            \\n            if window.isValid():\\n                maxSum = max(maxSum, window.sum())\\n        return maxSum\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    class Window:\\n        def __init__(self, k: int) -> None:\\n            self.windowSum = 0\\n            self.windowDict = collections.defaultdict(int)\\n            self.sizeLimit = k\\n            self.windowDupes = 0\\n\\n        def isValid(self) -> bool:\\n            if self.windowDupes == 0 and len(self.windowDict) == self.sizeLimit:\\n                return True\\n            return False\\n        \\n        def hasDupes(self) -> bool:\\n            return True if self.windowDupes > 0 else False\\n\\n        def hasExceededSize(self) -> bool:\\n            return True if len(self.windowDict) > self.sizeLimit else False\\n                \\n        def add(self, n: int) -> None:\\n            self.windowSum += n\\n            self.windowDict[n] += 1\\n            if self.windowDict[n] > 1:\\n                self.windowDupes += 1\\n        \\n        def remove(self, n: int) -> None:\\n            self.windowSum -= n\\n            self.windowDict[n] -= 1\\n            if self.windowDict[n] >= 1:\\n                self.windowDupes -= 1\\n            if self.windowDict[n] == 0:\\n                self.windowDict.pop(n)\\n        \\n        def sum(self) -> int:\\n            return self.windowSum\\n\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        leftIdx = 0\\n        maxSum = 0\\n        window = self.Window(k)\\n        for rightIdx in range(len(nums)):\\n            window.add(nums[rightIdx])\\n            \\n            while window.hasDupes() or window.hasExceededSize():\\n                window.remove(nums[leftIdx])\\n                leftIdx += 1\\n            \\n            if window.isValid():\\n                maxSum = max(maxSum, window.sum())\\n        return maxSum\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985121,
                "title": "sliding-window-hashmap",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumSubarraySum = function(nums, k) {\\n    let size = nums.length;\\n    let i=0,j=0;\\n    let sum  = 0;\\n    let map = new Map();\\n    let maxi = -Infinity;\\n    while (j < size) {\\n        sum += nums[j];\\n        map.set(nums[j], (map.get(nums[j]) || 0) + 1);\\n        //The length of the subarray is k, and\\n        if (j - i + 1 == k) {   \\n         //All the elements of the subarray are distinct only then calculate maxi \\n            if (map.size == k) {\\n                maxi = Math.max(maxi, sum);\\n            }\\n            sum -= nums[i];\\n//when we move after length k we know ith element will be removed but as \\n//we have map so we remove its count and if its count was 0 means we can remove it completely\\n//to see why we cant use set take example 99912\\n            map.set(nums[i], map.get(nums[i]) - 1);\\n            if (map.get(nums[i]) === 0) {\\n                map.delete(nums[i]);\\n            }\\n            i++;\\n        }\\n        j++;\\n    }\\n    return (maxi == -Infinity ? 0 :  maxi);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar maximumSubarraySum = function(nums, k) {\\n    let size = nums.length;\\n    let i=0,j=0;\\n    let sum  = 0;\\n    let map = new Map();\\n    let maxi = -Infinity;\\n    while (j < size) {\\n        sum += nums[j];\\n        map.set(nums[j], (map.get(nums[j]) || 0) + 1);\\n        //The length of the subarray is k, and\\n        if (j - i + 1 == k) {   \\n         //All the elements of the subarray are distinct only then calculate maxi \\n            if (map.size == k) {\\n                maxi = Math.max(maxi, sum);\\n            }\\n            sum -= nums[i];\\n//when we move after length k we know ith element will be removed but as \\n//we have map so we remove its count and if its count was 0 means we can remove it completely\\n//to see why we cant use set take example 99912\\n            map.set(nums[i], map.get(nums[i]) - 1);\\n            if (map.get(nums[i]) === 0) {\\n                map.delete(nums[i]);\\n            }\\n            i++;\\n        }\\n        j++;\\n    }\\n    return (maxi == -Infinity ? 0 :  maxi);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985120,
                "title": "go-2-pointer-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maximumSubarraySum(nums []int, k int) int64 {\\n    // Map to store the freq of each element\\n    freq := make(map[int] int)\\n    n := len(nums)\\n    var maxSum int64 = 0 \\n    var runningSum int64 = 0 \\n    start := 0 \\n    end := 0 \\n    if k > n {\\n        return 0\\n    }\\n    for end < n {\\n        \\n            if c, ok := freq[nums[end]]; ok && c > 0 {\\n                // remove the first element \\n                freq[nums[start]] = freq[nums[start]] - 1\\n                runningSum -= int64(nums[start])\\n                start++ \\n                \\n                continue\\n            }else {\\n                freq[nums[end]] = 1\\n            }\\n            // Update the running sum \\n            runningSum += int64(nums[end])\\n\\n        if end - start + 1 < k {\\n            end++\\n        }else {\\n            // The length of subarray is now k.\\n            if runningSum > maxSum{\\n                maxSum = runningSum\\n            }\\n\\n            // Slide the window. Remove the last element and reduce its freq. \\n            freq[nums[start]] = freq[nums[start]] - 1\\n            // Recompute maxFreq \\n            runningSum -= int64(nums[start])\\n            start++\\n            end++\\n            \\n        }\\n    }\\n\\n    return maxSum\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maximumSubarraySum(nums []int, k int) int64 {\\n    // Map to store the freq of each element\\n    freq := make(map[int] int)\\n    n := len(nums)\\n    var maxSum int64 = 0 \\n    var runningSum int64 = 0 \\n    start := 0 \\n    end := 0 \\n    if k > n {\\n        return 0\\n    }\\n    for end < n {\\n        \\n            if c, ok := freq[nums[end]]; ok && c > 0 {\\n                // remove the first element \\n                freq[nums[start]] = freq[nums[start]] - 1\\n                runningSum -= int64(nums[start])\\n                start++ \\n                \\n                continue\\n            }else {\\n                freq[nums[end]] = 1\\n            }\\n            // Update the running sum \\n            runningSum += int64(nums[end])\\n\\n        if end - start + 1 < k {\\n            end++\\n        }else {\\n            // The length of subarray is now k.\\n            if runningSum > maxSum{\\n                maxSum = runningSum\\n            }\\n\\n            // Slide the window. Remove the last element and reduce its freq. \\n            freq[nums[start]] = freq[nums[start]] - 1\\n            // Recompute maxFreq \\n            runningSum -= int64(nums[start])\\n            start++\\n            end++\\n            \\n        }\\n    }\\n\\n    return maxSum\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983630,
                "title": "need-strong-test-cases",
                "content": "If you simply submit the code below, it will be accepted. However, it fails my custom test case of nums = [1,2,3,4,5,6,7,8,1,10], k = 9. It seems like it needs stronger test cases.\\n\\n# Code - Incorrect Solution\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        seen = set()\\n\\n        l = 0\\n\\n        cur_sum = 0\\n        max_sum = 0\\n        for i in range(len(nums)):\\n            if i - l >= k:\\n                max_sum = max(max_sum, cur_sum)\\n                cur_sum -= nums[l]\\n                seen.remove(nums[l])\\n                l += 1 \\n            if nums[i] in seen:\\n                cur_sum -= nums[l]\\n                t = nums[l]\\n                l += 1\\n                while l < i and nums[l] in seen:\\n                    if nums[l] != t:\\n                        seen.remove(t)\\n                        t = nums[l]\\n                    cur_sum -= nums[l]\\n                    l += 1\\n            cur_sum += nums[i]\\n            seen.add(nums[i])\\n        if len(seen) < k:\\n            cur_sum = 0\\n        if len(seen) == k:\\n            cur_sum = max(cur_sum, sum(seen))\\n        return max(max_sum, cur_sum)\\n```\\n\\n\\n# Code - Correct Solution\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        dic = {}\\n\\n        l = 0\\n\\n        cur_sum = 0\\n        max_sum = 0\\n        for i in range(len(nums)):\\n            if i - l >= k:\\n                max_sum = max(max_sum, cur_sum)\\n                cur_sum -= nums[l]\\n                if nums[l] in dic:\\n                    del dic[nums[l]]\\n                l += 1\\n            \\n            if nums[i] in dic and dic[nums[i]] >= 1:\\n                while nums[l] != nums[i]:\\n                    if nums[l] in dic:\\n                        del dic[nums[l]]\\n                    cur_sum -= nums[l]\\n                    l += 1\\n                cur_sum -= nums[l]\\n                del dic[nums[l]]\\n                l += 1\\n\\n            cur_sum += nums[i]\\n            if nums[i] in dic:\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1\\n    \\n        if len(dic) < k:\\n            cur_sum = 0\\n        if len(dic) == k:\\n            cur_sum = max(cur_sum, sum(dic))\\n        return max(max_sum, cur_sum)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        seen = set()\\n\\n        l = 0\\n\\n        cur_sum = 0\\n        max_sum = 0\\n        for i in range(len(nums)):\\n            if i - l >= k:\\n                max_sum = max(max_sum, cur_sum)\\n                cur_sum -= nums[l]\\n                seen.remove(nums[l])\\n                l += 1 \\n            if nums[i] in seen:\\n                cur_sum -= nums[l]\\n                t = nums[l]\\n                l += 1\\n                while l < i and nums[l] in seen:\\n                    if nums[l] != t:\\n                        seen.remove(t)\\n                        t = nums[l]\\n                    cur_sum -= nums[l]\\n                    l += 1\\n            cur_sum += nums[i]\\n            seen.add(nums[i])\\n        if len(seen) < k:\\n            cur_sum = 0\\n        if len(seen) == k:\\n            cur_sum = max(cur_sum, sum(seen))\\n        return max(max_sum, cur_sum)\\n```\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n\\n        dic = {}\\n\\n        l = 0\\n\\n        cur_sum = 0\\n        max_sum = 0\\n        for i in range(len(nums)):\\n            if i - l >= k:\\n                max_sum = max(max_sum, cur_sum)\\n                cur_sum -= nums[l]\\n                if nums[l] in dic:\\n                    del dic[nums[l]]\\n                l += 1\\n            \\n            if nums[i] in dic and dic[nums[i]] >= 1:\\n                while nums[l] != nums[i]:\\n                    if nums[l] in dic:\\n                        del dic[nums[l]]\\n                    cur_sum -= nums[l]\\n                    l += 1\\n                cur_sum -= nums[l]\\n                del dic[nums[l]]\\n                l += 1\\n\\n            cur_sum += nums[i]\\n            if nums[i] in dic:\\n                dic[nums[i]] += 1\\n            else:\\n                dic[nums[i]] = 1\\n    \\n        if len(dic) < k:\\n            cur_sum = 0\\n        if len(dic) == k:\\n            cur_sum = max(cur_sum, sum(dic))\\n        return max(max_sum, cur_sum)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3978347,
                "title": "my-own-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(int)\\n        \\n        res = 0\\n        curr = 0\\n\\n        for i in range(len(nums)):\\n            d[nums[i]] += 1\\n            curr += nums[i]\\n            if i >= k:\\n                curr -= nums[i-k]\\n                d[nums[i-k]] -= 1\\n                if d[nums[i-k]] == 0:\\n                    d.pop(nums[i-k])\\n                \\n            if len(d.keys()) == k:\\n                res = max(res, curr)\\n\\n        return res\\n\\n        # # TLE ERROR\\n        # for i in range(len(nums)):\\n        #     d[nums[i]] += 1\\n            \\n        #     if i >= k:\\n                \\n        #         d[nums[i-k]] -= 1\\n        #         if d[nums[i-k]] == 0:\\n        #             d.pop(nums[i-k])\\n        #     if len(d.keys()) == k and i >=k-1:\\n        #         res = max(res, sum(d.keys()))\\n        # return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        d = defaultdict(int)\\n        \\n        res = 0\\n        curr = 0\\n\\n        for i in range(len(nums)):\\n            d[nums[i]] += 1\\n            curr += nums[i]\\n            if i >= k:\\n                curr -= nums[i-k]\\n                d[nums[i-k]] -= 1\\n                if d[nums[i-k]] == 0:\\n                    d.pop(nums[i-k])\\n                \\n            if len(d.keys()) == k:\\n                res = max(res, curr)\\n\\n        return res\\n\\n        # # TLE ERROR\\n        # for i in range(len(nums)):\\n        #     d[nums[i]] += 1\\n            \\n        #     if i >= k:\\n                \\n        #         d[nums[i-k]] -= 1\\n        #         if d[nums[i-k]] == 0:\\n        #             d.pop(nums[i-k])\\n        #     if len(d.keys()) == k and i >=k-1:\\n        #         res = max(res, sum(d.keys()))\\n        # return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3974033,
                "title": "python-easy-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nKeeping track of the minimum allowed index for an element in the window.\\nIf we are past this index, then we satified the requirements and we can update our max_sum.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- $$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- $$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        max_sum, sum = 0, 0\\n        window = {}\\n        minimum_allowed = -1\\n        for right, n in enumerate(nums):\\n            if n in window and window[n] > minimum_allowed:\\n                minimum_allowed = window[n]\\n            window[n] = right\\n            sum += n\\n            if right + 1 >= k:\\n                if left > minimum_allowed:\\n                    max_sum = max(sum, max_sum)\\n                sum -= nums[left]\\n                left+=1    \\n        return max_sum\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        left, right = 0, len(nums) - 1\\n        max_sum, sum = 0, 0\\n        window = {}\\n        minimum_allowed = -1\\n        for right, n in enumerate(nums):\\n            if n in window and window[n] > minimum_allowed:\\n                minimum_allowed = window[n]\\n            window[n] = right\\n            sum += n\\n            if right + 1 >= k:\\n                if left > minimum_allowed:\\n                    max_sum = max(sum, max_sum)\\n                sum -= nums[left]\\n                left+=1    \\n        return max_sum\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973857,
                "title": "most-solutions-are-wrong-use-this-sliding-window-template-instead",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        table = set()\\n        window = 0\\n        maxsum, currsum = 0, 0\\n        for index, value in enumerate(nums):\\n            while value in table:\\n                currsum -= nums[window]\\n                table.remove(nums[window])\\n                window += 1\\n            currsum += value\\n            table.add(value)\\n            while index - window + 1 >= k:\\n                maxsum = max(maxsum, currsum)\\n                currsum -= nums[window]\\n                table.remove(nums[window])\\n                window += 1\\n        return maxsum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        table = set()\\n        window = 0\\n        maxsum, currsum = 0, 0\\n        for index, value in enumerate(nums):\\n            while value in table:\\n                currsum -= nums[window]\\n                table.remove(nums[window])\\n                window += 1\\n            currsum += value\\n            table.add(value)\\n            while index - window + 1 >= k:\\n                maxsum = max(maxsum, currsum)\\n                currsum -= nums[window]\\n                table.remove(nums[window])\\n                window += 1\\n        return maxsum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964347,
                "title": "easy-c-sliding-window-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        long long max_sum=0;\\n        unordered_set<int>seen;\\n        long long sum=0;\\n        for(;end<nums.size();end++)\\n        {\\n            sum+=(long long)nums[end];//i calculated the sum\\n             while(seen.find(nums[end])!=seen.end()) //agr kvi v set me mila ki ye already present elemnt hai to us waqt same mai work krunga ki vo substrng sum posible hai hi ny as hame sum unique elemnt presnt in subarrya wahi lena tha\\n            {\\n                sum-=nums[start];\\n                seen.erase(nums[start]);  //this process is same as max substring with no repeting characted\\n                start++;\\n            }\\n            seen.insert(nums[end]); //at last jab while loop me nhi hai to us set me insert krte rho\\n            if(end-start+1==k){ //jab size==k window size itna aa jaye to to max sum ko update kro\\n            //and start pointer ko age badhao for anther sliding winodw of size k ka sum nikalne k liye\\n            //uske liye phle strt++ krne se phle sum me jo us strt jisko ++ krne wale h us strt k chlte jo sum me aadd hua tha use remove kr do\\n            //and set se v us element ke occurence k remove kr do as vo to abwwindow me rhega hi ny n\\n            max_sum=max(max_sum,sum);\\n            sum-=nums[start];\\n            seen.erase(nums[start]);\\n            start++;\\n            \\n            }\\n        }\\n        return max_sum;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        long long max_sum=0;\\n        unordered_set<int>seen;\\n        long long sum=0;\\n        for(;end<nums.size();end++)\\n        {\\n            sum+=(long long)nums[end];//i calculated the sum\\n             while(seen.find(nums[end])!=seen.end()) //agr kvi v set me mila ki ye already present elemnt hai to us waqt same mai work krunga ki vo substrng sum posible hai hi ny as hame sum unique elemnt presnt in subarrya wahi lena tha\\n            {\\n                sum-=nums[start];\\n                seen.erase(nums[start]);  //this process is same as max substring with no repeting characted\\n                start++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3952929,
                "title": "python-using-set-o-n",
                "content": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        i = 0 \\n        n = len(nums)\\n        best = 0\\n        curr_set = set()\\n        cs = 0\\n        for r in range(n):\\n            while nums[r] in curr_set:\\n                curr_set.remove(nums[i])\\n                cs-=nums[i]\\n                i+=1\\n            if len(curr_set)<=k and nums[r] not in curr_set:\\n                curr_set.add(nums[r])\\n                cs+=nums[r]\\n            while len(curr_set)>k:\\n                curr_set.remove(nums[i])\\n                cs-=nums[i]\\n                i+=1\\n            if len(curr_set)==k:\\n                best = max(best,cs)\\n        return best\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        i = 0 \\n        n = len(nums)\\n        best = 0\\n        curr_set = set()\\n        cs = 0\\n        for r in range(n):\\n            while nums[r] in curr_set:\\n                curr_set.remove(nums[i])\\n                cs-=nums[i]\\n                i+=1\\n            if len(curr_set)<=k and nums[r] not in curr_set:\\n                curr_set.add(nums[r])\\n                cs+=nums[r]\\n            while len(curr_set)>k:\\n                curr_set.remove(nums[i])\\n                cs-=nums[i]\\n                i+=1\\n            if len(curr_set)==k:\\n                best = max(best,cs)\\n        return best\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3950009,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nsliding window with map for having distinct subarray\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        if(nums.length<k){\\n            return 0;\\n        }\\n\\n        long maxSum=0;\\n        long sum=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n\\n\\n        int end=0,start=0;\\n\\n        while(end<nums.length){\\n            if(map.containsKey(nums[end])){\\n                map.put(nums[end],map.get(nums[end])+1);\\n            }else{\\n                map.put(nums[end],1);\\n            }\\n             sum+=nums[end];\\n            if(end-start+1<k){\\n                \\n                    end++;\\n            }else if(end-start+1==k){\\n                if(map.size()==k){\\n                    maxSum=Math.max(sum,maxSum);\\n                     \\n                }\\n                \\n                    if(map.containsKey(nums[start])){\\n                        if(map.get(nums[start])>1){\\n                        map.put(nums[start],map.get(nums[start])-1);\\n                        }else{\\n                            map.remove(nums[start]);\\n                        }\\n                    }\\n                    sum-=nums[start];\\n                    start++;\\n\\n                    end++;\\n            }\\n\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        if(nums.length<k){\\n            return 0;\\n        }\\n\\n        long maxSum=0;\\n        long sum=0;\\n        Map<Integer,Integer> map=new HashMap<>();\\n\\n\\n        int end=0,start=0;\\n\\n        while(end<nums.length){\\n            if(map.containsKey(nums[end])){\\n                map.put(nums[end],map.get(nums[end])+1);\\n            }else{\\n                map.put(nums[end],1);\\n            }\\n             sum+=nums[end];\\n            if(end-start+1<k){\\n                \\n                    end++;\\n            }else if(end-start+1==k){\\n                if(map.size()==k){\\n                    maxSum=Math.max(sum,maxSum);\\n                     \\n                }\\n                \\n                    if(map.containsKey(nums[start])){\\n                        if(map.get(nums[start])>1){\\n                        map.put(nums[start],map.get(nums[start])-1);\\n                        }else{\\n                            map.remove(nums[start]);\\n                        }\\n                    }\\n                    sum-=nums[start];\\n                    start++;\\n\\n                    end++;\\n            }\\n\\n        }\\n\\n        return maxSum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945140,
                "title": "simple-c-solution-using-map-and-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i =0, j=0;\\n        int size = nums.size();\\n        long long currentSum = 0, maxSum = 0;\\n\\n        unordered_map<int, int> mp;\\n\\n        while(j<size){\\n            currentSum += nums[j];\\n            mp[nums[j]]++;\\n\\n            //reaching to window size\\n            if(j-i+1 < k)\\n                j++;\\n            \\n            //window size reached\\n            else if(j-i+1 == k){\\n                if(mp.size() == k)\\n                    maxSum = max(maxSum, currentSum);\\n                \\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n\\n                currentSum -= nums[i];\\n                i++, j++;\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i =0, j=0;\\n        int size = nums.size();\\n        long long currentSum = 0, maxSum = 0;\\n\\n        unordered_map<int, int> mp;\\n\\n        while(j<size){\\n            currentSum += nums[j];\\n            mp[nums[j]]++;\\n\\n            //reaching to window size\\n            if(j-i+1 < k)\\n                j++;\\n            \\n            //window size reached\\n            else if(j-i+1 == k){\\n                if(mp.size() == k)\\n                    maxSum = max(maxSum, currentSum);\\n                \\n                mp[nums[i]]--;\\n                if(mp[nums[i]] == 0)\\n                    mp.erase(nums[i]);\\n\\n                currentSum -= nums[i];\\n                i++, j++;\\n            }\\n        }\\n        return maxSum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938366,
                "title": "java-easy-solution-using-set",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        long max = 0, sum = 0;\\n        int windowStart = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (set.contains(nums[i]) || set.size() == k) {\\n                set.remove(nums[windowStart]);\\n                sum -= nums[windowStart++];\\n            }\\n            sum += nums[i];\\n            set.add(nums[i]);\\n            if (set.size() == k) {\\n                max = Math.max(max, sum);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        Set<Integer> set = new HashSet<>();\\n        long max = 0, sum = 0;\\n        int windowStart = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (set.contains(nums[i]) || set.size() == k) {\\n                set.remove(nums[windowStart]);\\n                sum -= nums[windowStart++];\\n            }\\n            sum += nums[i];\\n            set.add(nums[i]);\\n            if (set.size() == k) {\\n                max = Math.max(max, sum);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931665,
                "title": "sliding-window-and-dict-python-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(K) At worst case the python dict will store at most K number of keys\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        dd = dict()\\n        candidate_ans, ans, cur_len = 0, 0, 0\\n        i = 0\\n        while i < len(nums):\\n            if cur_len == k:\\n                dd.pop(nums[i-k], None)\\n                candidate_ans -= nums[i-k]\\n                cur_len -= 1\\n\\n            if 1000001 != dd.get(nums[i], 1000001):\\n                i = dd[nums[i]]+1\\n                cur_len = 1\\n                candidate_ans = nums[i]\\n                dd = dict()\\n                dd[nums[i]] = i\\n            else:\\n                candidate_ans += nums[i]\\n                dd[nums[i]] = i\\n                cur_len += 1\\n                if cur_len == k:\\n                    ans = max(ans, candidate_ans)\\n\\n            i += 1\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        dd = dict()\\n        candidate_ans, ans, cur_len = 0, 0, 0\\n        i = 0\\n        while i < len(nums):\\n            if cur_len == k:\\n                dd.pop(nums[i-k], None)\\n                candidate_ans -= nums[i-k]\\n                cur_len -= 1\\n\\n            if 1000001 != dd.get(nums[i], 1000001):\\n                i = dd[nums[i]]+1\\n                cur_len = 1\\n                candidate_ans = nums[i]\\n                dd = dict()\\n                dd[nums[i]] = i\\n            else:\\n                candidate_ans += nums[i]\\n                dd[nums[i]] = i\\n                cur_len += 1\\n                if cur_len == k:\\n                    ans = max(ans, candidate_ans)\\n\\n            i += 1\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3931227,
                "title": "sliding-window-brute-force-best-fastest-solution-upvote",
                "content": "\\n\\n# Code\\n```\\n/*\\nSliding window approach:- TC- O(n)\\n*/\\nclass Solution{\\n    public long maximumSubarraySum(int[] nums, int k){\\n        Set<Integer> set=new HashSet<>();\\n        long sum=0,maxSum=0;\\n        int i=0,j=0;\\n        while(j<nums.length){\\n            if(j-i<k && set.size()<k){\\n                while(set.size()>0 && set.contains(nums[j])){\\n                    sum=sum-nums[i];\\n                    set.remove(nums[i]);\\n                    i++;\\n                } \\n                sum=sum+nums[j];\\n                set.add(nums[j]);\\n                j++;\\n            }\\n            else{\\n                if(j-i==k && set.size()==k){\\n                    maxSum=Math.max(sum,maxSum);\\n                }\\n                sum=sum-nums[i];\\n                set.remove(nums[i]);\\n                i++;\\n            }\\n        }\\n        if(j-i==k && set.size()==k){\\n            maxSum=Math.max(maxSum,sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n\\n/*\\nBrute Force Solution: TC- O(n*k)\\n\\nclass Solution{\\n    public long maximumSubarraySum(int[] nums, int k){\\n\\n        int maxSum=0;\\n        for(int i=0;i<=nums.length-k;i++){\\n            boolean[] visited=new boolean[10001];\\n            boolean distinct=true;\\n            int sum=0;\\n            for(int j=i;j<i+k;j++){\\n                if(visited[nums[j]]){\\n                    distinct=false;\\n                    break;\\n                }\\n                visited[nums[j]]=true;\\n                sum+=nums[j];\\n            }\\n            if(distinct){\\n                maxSum=Math.max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n*/\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\nSliding window approach:- TC- O(n)\\n*/\\nclass Solution{\\n    public long maximumSubarraySum(int[] nums, int k){\\n        Set<Integer> set=new HashSet<>();\\n        long sum=0,maxSum=0;\\n        int i=0,j=0;\\n        while(j<nums.length){\\n            if(j-i<k && set.size()<k){\\n                while(set.size()>0 && set.contains(nums[j])){\\n                    sum=sum-nums[i];\\n                    set.remove(nums[i]);\\n                    i++;\\n                } \\n                sum=sum+nums[j];\\n                set.add(nums[j]);\\n                j++;\\n            }\\n            else{\\n                if(j-i==k && set.size()==k){\\n                    maxSum=Math.max(sum,maxSum);\\n                }\\n                sum=sum-nums[i];\\n                set.remove(nums[i]);\\n                i++;\\n            }\\n        }\\n        if(j-i==k && set.size()==k){\\n            maxSum=Math.max(maxSum,sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n\\n\\n/*\\nBrute Force Solution: TC- O(n*k)\\n\\nclass Solution{\\n    public long maximumSubarraySum(int[] nums, int k){\\n\\n        int maxSum=0;\\n        for(int i=0;i<=nums.length-k;i++){\\n            boolean[] visited=new boolean[10001];\\n            boolean distinct=true;\\n            int sum=0;\\n            for(int j=i;j<i+k;j++){\\n                if(visited[nums[j]]){\\n                    distinct=false;\\n                    break;\\n                }\\n                visited[nums[j]]=true;\\n                sum+=nums[j];\\n            }\\n            if(distinct){\\n                maxSum=Math.max(maxSum,sum);\\n            }\\n        }\\n        return maxSum;\\n    }\\n}\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920713,
                "title": "c-short-clean-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        long long  i=0, j=0, ans = 0, sum =0;\\n        \\n        for(int j=0; j<nums.size(); j++){\\n\\n            mp[nums[j]]++;\\n\\n            sum += nums[j];\\n            if( k == j - i + 1){\\n                if(mp.size() == k ) ans = max( ans , sum);\\n                sum -= nums[i];\\n                mp[nums[i]]--;\\n                if(!mp[nums[i]]) mp.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        \\n        unordered_map<int,int> mp;\\n        long long  i=0, j=0, ans = 0, sum =0;\\n        \\n        for(int j=0; j<nums.size(); j++){\\n\\n            mp[nums[j]]++;\\n\\n            sum += nums[j];\\n            if( k == j - i + 1){\\n                if(mp.size() == k ) ans = max( ans , sum);\\n                sum -= nums[i];\\n                mp[nums[i]]--;\\n                if(!mp[nums[i]]) mp.erase(nums[i]);\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1764922,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1672896,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1904578,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 2073113,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 2005177,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1999486,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1950396,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1918912,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1908803,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1779868,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1764922,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1672896,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1904578,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 2073113,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 2005177,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1999486,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1950396,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1918912,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1908803,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            },
            {
                "id": 1779868,
                "content": [
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "this question made my brain explode \\uD83D\\uDE05"
                    },
                    {
                        "username": "72engineers",
                        "content": "So... in order to get a good mark in this contest, I cram for it, practising problems for the entire Saturday. And feel tired and sleep at 8 o\\'clock, when I wake up and recognize that I have a contest, it only has about 27 mins left... FML!!! "
                    },
                    {
                        "username": "nat1902",
                        "content": "I feel so sorry for you but let me lol first :)))\\n"
                    },
                    {
                        "username": "VastDong",
                        "content": "hhhhhhhhhhhh"
                    },
                    {
                        "username": "Bhavyareddy_00",
                        "content": "Input: nums = [1,5,4,2,9,9,9], k = 3\\nOutput: 15\\n\\nHere i dont understand why the maximum cant be 18\\nas the sum of [5,4,9] is 18 and all elements are distinct.\\nAnybody help me out with this"
                    },
                    {
                        "username": "sopheary",
                        "content": "[@codevishal18](/codevishal18) because we return max of subarray , and subarray means those number have to be continuous."
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "The elements should be at  continuous index in array you can\\'t pick elements by leaving any element in b/w"
                    },
                    {
                        "username": "codevishal18",
                        "content": "subarray is specified not subsequence"
                    },
                    {
                        "username": "SamarthKadam",
                        "content": "int check(unordered_map<int,int> mp)\\n{\\n\\tfor(auto it:mp)\\n\\t{\\n\\t\\tif(it.second>1)\\n\\t\\t\\treturn true;\\n\\t}\\n\\treturn false;\\n}\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i=0;\\n        int j=0;\\n        long long sum=0;\\n        long long maxsum=LLONG_MIN;;\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n\\n        while(j<n)\\n        {\\n            sum+=nums[j];\\n            mp[nums[j]]++;\\n\\n            while(mp.size()>k||check(mp))\\n            {\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0)\\n                mp.erase(nums[i]);\\n                sum-=nums[i];\\n                i++;\\n            }\\n            j++;\\n            if(mp.size()==k)\\n            {\\n            maxsum=max(maxsum,sum);\\n            }\\n        }\\n        if(maxsum==LLONG_MIN)\\n        \\treturn 0;\\n        return maxsum;\\n    }\\n\\nCan anybody tell me why is this throwing time limit excedded instead it is 0(n) approach"
                    },
                    {
                        "username": "Aquars1989",
                        "content": "I got wrong answer at case 87, there are some mistake but I haven\\'t any idea, could anyone points it to me?\\n\\nclass Solution:\\n    def maximumSubarraySum(self, nums: List[int], k: int) -> int:\\n        if len(nums)<k:\\n            return 0\\n        l=k+1\\n        lastId={}\\n        tmp=[[0, 0] for _ in range(l)]\\n        cnt=0\\n        res=0\\n        for i,n in enumerate(nums):\\n            if n in lastId and ((i-lastId[n])<k):\\n                cnt=i-lastId[n]-1\\n            lastId[n]=i\\n            id=i%l\\n            before=(i-1)%l\\n            tail=(i+1)%l\\n            tmp[id]=[n,tmp[before][1]+n]\\n            if cnt==k-1:\\n                res=max(res,tmp[id][1]-tmp[tail][1])\\n            else:\\n                cnt+=1\\n        return res\\n\\nInput:\\n[92288,7285,36004,38608,80752,46073,63141,27823,65712,14101,5709,48750...]\\n5120\\nOutput:\\n259734121\\nExpected:\\n0"
                    },
                    {
                        "username": "user5066PR",
                        "content": "simple solution by sliding window :\n  public long maximumSubarraySum(int[] nums, int k) \n\n    {\n    long ans =0;\n    long currsum =0;\n    int n = nums.length;\n    Map<Integer,Integer> map = new HashMap<>();\n      int i=0;\n    int j=0;\n  while(j<n) {\n    currsum += nums[j];\n    map.put(nums[j],map.getOrDefault(nums[j],0)+1);\n    if(map.size()==k){\n      ans = Math.max(currsum,ans);\n    }\n    if(j-i+1<k) {\n       j++;\n    }\n    else if(j-i+1==k) {\n      map.put(nums[i],map.get(nums[i])-1);\n      if(map.get(nums[i])==0){\n        map.remove(nums[i]);\n      }\n      currsum -=nums[i];\n      i++;\n      j++;\n    }\n\n  }\n\n    return ans;\n  }"
                    },
                    {
                        "username": "parthasutradhar",
                        "content": "What is the problem here for 4,4,4 ? \\n```java\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int maxSum = Integer.MIN_VALUE;\\n        int windowSum = 0;\\n        List<Set<Integer>> setList = new ArrayList<>();\\n        for (int i = 0; i <= nums.length - k; i++) {\\n            Set<Integer> window = new HashSet<>(k);\\n            for (int j = i; j < i + k; j++) {\\n                window.add(nums[j]);\\n            }\\n            setList.add(new HashSet<>(window));\\n            window.clear();\\n        }\\n\\n        for (Set<Integer> subList : setList) {\\n            windowSum = 0;\\n            for (Integer num : subList) {\\n                windowSum += num;\\n            }\\n            maxSum = Math.max(windowSum, maxSum);\\n        }\\n        return maxSum;\\n    }\\n```"
                    },
                    {
                        "username": "surbhisharma_2",
                        "content": "89/92 test cases  passing, Can anyone tell what\\'s wrong with the code?\\nclass Solution {\\n\\n    public long maximumSubarraySum(int[] nums, int k) {\\n\\n        long ans = 0;\\n        long sum = 0;\\n        int i = 0, j = 0;\\n        HashSet<Integer> hs = new HashSet<>();\\n\\n        while (j < nums.length) {\\n\\n            if (hs.contains(nums[j])) {\\n                sum = 0;\\n                hs.remove(nums[i]);\\n                i++;\\n                continue;\\n            } \\n            \\n            else {\\n                hs.add(nums[j]);\\n                sum += nums[j];\\n            }\\n\\n            if (j - i + 1 == k) {\\n                ans = Math.max(ans, sum);\\n                sum -= nums[i];\\n                hs.remove(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n}\\n`"
                    },
                    {
                        "username": "nonameclub",
                        "content": "public long maximumSubarraySum(int[] nums, int k) {\\n\\n    long ans = 0;\\n    long sum = 0;\\n    int i = 0, j = 0;\\n    HashSet<Integer> hs = new HashSet<>();\\n\\n    while (j < nums.length) {\\n\\n        if (hs.contains(nums[j])) {\\n            sum -= nums[i]; # you should not set to zero\\n            hs.remove(nums[i]);\\n            i++;\\n            continue;\\n        } \\n        \\n        else {\\n            hs.add(nums[j]);\\n            sum += nums[j];\\n        }\\n\\n        if (j - i + 1 == k) {\\n            ans = Math.max(ans, sum);\\n            sum -= nums[i];\\n            hs.remove(nums[i]);\\n            i++;\\n        }\\n        j++;\\n    }\\n\\n    return ans;\\n}"
                    },
                    {
                        "username": "Surya2316",
                        "content": "class Solution {\\n    public long maximumSubarraySum(int[] nums, int k) {\\n        int start=0;\\n        long max_sum = 0L; // Changed to long type\\n        int max_window=0;\\n        long sum=0L;\\n        HashSet<Integer> hashSet= new HashSet<>();\\n        for(int end=0;end<nums.length;end++)\\n        {\\n           sum=sum+nums[end];\\n           while(hashSet.contains(nums[end])||end-start+1>k)\\n           {\\n               hashSet.remove(nums[start]);\\n               sum=sum-nums[start];\\n               start++;\\n           }\\n           hashSet.add(nums[end]);\\n          if(end-start+1==k) max_sum=Math.max(max_sum,sum);\\n        }\\n          return max_sum;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "_Albus_Dumbledore_",
                        "content": "class Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        unordered_map<int, int> freq;\\n        long long maxSum = 0;\\n        long long currentSum = 0;\\n\\n        for (int i = 0; i < nums.size(); i++) {\\n          \\n            freq[nums[i]]++;\\n            currentSum += nums[i];\\n\\n           \\n            if (i >= k) {\\n                freq[nums[i - k]]--;\\n                if (freq[nums[i - k]] == 0) {\\n                    freq.erase(nums[i - k]);\\n                }\\n                currentSum -= nums[i - k];\\n            }\\n\\n           \\n            if (freq.size() == k) {\\n                maxSum = max(maxSum, currentSum);\\n            }\\n        }\\n\\n        return maxSum;\\n    }\\n};\\ncan someone explain me how this code getting correct result and got accepted ,  this code is generated by chatgpt and i think it should check another condition as well if we find any element which is already present in freq map  ie. if(freq[i-k]==1) then it should have clear all elements of the map as i have implimented somewhat same logic using set instead of map.\\nclass Solution {\\npublic:\\n    long long maximumSubarraySum(vector<int>& nums, int k) {\\n        int i = 0;\\n        int j = 0;\\n        set<int> satyaa;\\n        long long sum = 0;\\n        long long maxi = INT_MIN;\\n        \\n        while (j < nums.size()) {\\n            if (satyaa.size() < k) {\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    satyaa.insert(nums[j]);\\n                    sum += nums[j];\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                }\\n                j++;\\n            } else if (satyaa.size() == k) {\\n                maxi = max(maxi, sum);\\n                if (satyaa.find(nums[j]) == satyaa.end()) {\\n                    sum -= nums[i];\\n                    satyaa.erase(nums[i]);\\n                    i++;\\n                } else {\\n                    sum = 0;\\n                    satyaa.clear();\\n                    satyaa.insert(nums[j]);\\n                    i = j;\\n                    j++;\\n                }\\n            }\\n        }\\n        \\n        maxi = max(maxi, sum);\\n        return maxi;\\n    }\\n};\\n"
                    },
                    {
                        "username": "dongbin_alistaire",
                        "content": " `\\n         max_sum = 0\\n        for i in range(len(nums) - k + 1):\\n            subarr = nums[i:i + k]\\n\\n            #set solution\\n            unique_numbers = list(set(subarr))\\n            if len(unique_numbers) != k:\\n                continue\\n                \\n            #hash table solution\\n            # unique_numbers = {}\\n            # is_distinct = True\\n            # for num in subarr:\\n            #     if num in unique_numbers:\\n            #         is_distinct = False\\n            #         break \\n            #     unique_numbers[num] = True\\n            # if not is_distinct:\\n            #     continue\\n\\n            subarr_sum = sum(subarr)\\n            max_sum = subarr_sum if subarr_sum > max_sum else max_sum \\n        return max_sum\\n`\\nWhat am I doing wrong? I cannot optimize this for linear time."
                    },
                    {
                        "username": "hadyawayda",
                        "content": "lol me too!!\\nfunction maximumSubarraySum(nums: number[], k: number): number {\\n  let max = 0\\n  let current = 0\\n\\n  for ( let i = 0; i <= nums.length - k; i++ ) {\\n    if ( i === 0 ) current = [...nums].slice(0, k).reduce((a, b) => a + b)\\n    if ( i !== 0 ) current = current + nums[i + k - 1] - nums[i - 1]\\n    let set = new Set([...[...nums].slice(i, i + k)])\\n    if ( set.size === k && current > max ) {\\n      max = current\\n    }\\n  }\\n  return max\\n};"
                    }
                ]
            }
        ]
    }
]