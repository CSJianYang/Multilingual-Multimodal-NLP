[
    {
        "title": "Next Permutation",
        "question_content": "A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\n\tFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\n\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\n\tFor example, the next permutation of arr = [1,2,3] is [1,3,2].\n\tSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\n\tWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\n\nGiven an array of integers nums, find the next permutation of nums.\nThe replacement must be in place and use only constant extra memory.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\n\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\n\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 100\n\t0 <= nums[i] <= 100",
        "solutions": [
            {
                "id": 13867,
                "title": "c-from-wikipedia",
                "content": "According to [Wikipedia](https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order), a man named Narayana Pandita presented the following simple algorithm to solve this problem in the 14th century.\\n\\n1. Find the largest index `k` such that `nums[k] < nums[k + 1]`. If no such index exists, just reverse `nums` and done.\\n2. Find the largest index `l > k` such that `nums[k] < nums[l]`.\\n3. Swap `nums[k]` and `nums[l]`.\\n4. Reverse the sub-array `nums[k + 1:]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```\\n\\nThe above algorithm can also handle duplicates and thus can be further used to solve [Permutations](https://leetcode.com/problems/permutations/) and [Permutations II](https://leetcode.com/problems/permutations-ii/).",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 13994,
                "title": "readable-code-without-confusing-i-j-and-with-explanation",
                "content": "Implementation based on description from [Project Nayuki](http://www.nayuki.io/page/next-lexicographical-permutation-algorithm). I cannot describe it better than them:\\n\\n![next permutation steps][1]\\n\\n\\tpublic class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }\\n\\t/*5*/   reverseSuffix(nums, pivot + 1); // reverses the whole list if there was no pivot\\n\\t/*6*/ }\\n\\t    \\n\\t    /**\\n\\t     * Find the last element which is a peak.\\n\\t     * In case there are multiple equal peaks, return the first of those.\\n\\t     * @return first index of last peak\\n\\t     */\\n\\t/*1*/ int indexOfLastPeak(int[] nums) {\\n\\t        for (int i = nums.length - 1; 0 < i; --i) {\\n\\t            if (nums[i - 1] < nums[i]) return i;\\n\\t        }\\n\\t        return 0;\\n\\t    }\\n\\n\\t    /** @return last index where the {@code num > threshold} or -1 if not found */\\n\\t/*3*/ int lastIndexOfGreater(int[] nums, int threshold) {\\n\\t        for (int i = nums.length - 1; 0 <= i; --i) {\\n\\t            if (threshold < nums[i]) return i;\\n\\t        }\\n\\t        return -1;\\n\\t    }\\n\\n\\t    /** Reverse numbers starting from an index till the end. */\\n\\t    void reverseSuffix(int[] nums, int start) {\\n\\t        int end = nums.length - 1;\\n\\t        while (start < end) {\\n\\t            swap(nums, start++, end--);\\n\\t        }\\n\\t    }\\n\\t    \\n\\t    void swap(int[] nums, int i, int j) {\\n\\t        int temp = nums[i];\\n\\t        nums[i] = nums[j];\\n\\t        nums[j] = temp;\\n\\t    }\\n\\t}\\n\\n\\n  [1]: https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.svg",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n\\t/*0*/ public void nextPermutation(int[] nums) {\\n\\t        // pivot is the element just before the non-increasing (weakly decreasing) suffix\\n\\t/*2*/   int pivot = indexOfLastPeak(nums) - 1;\\n\\t        // paritions nums into [prefix pivot suffix]\\n\\t        if (pivot != -1) {\\n\\t            int nextPrefix = lastIndexOfGreater(nums, nums[pivot]); // in the worst case it\\'s suffix[0]\\n\\t            // next prefix must exist because pivot < suffix[0], otherwise pivot would be part of suffix\\n\\t/*4*/       swap(nums, pivot, nextPrefix); // this minimizes the change in prefix\\n\\t        }",
                "codeTag": "Java"
            },
            {
                "id": 14054,
                "title": "python-solution-with-comments",
                "content": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "        \\n    def nextPermutation(self, nums):\\n        i = j = len(nums)-1\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        if i == 0:   # nums are in descending order\\n            nums.reverse()\\n            return \\n        k = i - 1    # find the last \"ascending\" position\\n        while nums[j] <= nums[k]:\\n            j -= 1\\n        nums[k], nums[j] = nums[j], nums[k]  \\n        l, r = k+1, len(nums)-1  # reverse the second part\\n        while l < r:\\n            nums[l], nums[r] = nums[r], nums[l]\\n            l +=1 ; r -= 1",
                "codeTag": "Python3"
            },
            {
                "id": 13866,
                "title": "share-my-o-n-time-solution",
                "content": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "solutionTags": [],
                "code": "My idea is for an array:\\n\\n 1. Start from its last element, traverse backward to find the first one with index i that satisfy  num[i-1] < num[i]. So, elements from num[i] to num[n-1] is reversely sorted. \\n 2. To find the next permutation, we have to swap some numbers at different positions, to minimize the increased amount, we have to make the highest changed position as high as possible. Notice that index larger than or equal to i is not possible as num[i,n-1] is reversely sorted. So, we want to increase the number at index i-1, clearly, swap it with the smallest number between num[i,n-1] that is larger than num[i-1]. For example, original number is 121543321, we want to swap the '1' at position 2 with '2' at position 7. \\n 3. The last step is to make the remaining higher position part as small as possible, we just have to reversely sort the num[i,n-1]\\n\\nThe following is my code:\\n\\n        \\n    public void nextPermutation(int[] num) {\\n        int n=num.length;\\n        if(n<2)\\n            return;\\n        int index=n-1;        \\n        while(index>0){\\n            if(num[index-1]<num[index])\\n                break;\\n            index--;\\n        }\\n        if(index==0){\\n            reverseSort(num,0,n-1);\\n            return;\\n        }\\n        else{\\n            int val=num[index-1];\\n            int j=n-1;\\n            while(j>=index){\\n                if(num[j]>val)\\n                    break;\\n                j--;\\n            }\\n            swap(num,j,index-1);\\n            reverseSort(num,index,n-1);\\n            return;\\n        }\\n    }\\n    \\n    public void swap(int[] num, int i, int j){\\n        int temp=0;\\n        temp=num[i];\\n        num[i]=num[j];\\n        num[j]=temp;\\n    }\\n    \\n    public void reverseSort(int[] num, int start, int end){   \\n        if(start>end)\\n            return;\\n        for(int i=start;i<=(end+start)/2;i++)\\n            swap(num,i,start+end-i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3473399,
                "title": "beats-100-full-explanation-in-steps",
                "content": "\\n\\n# Approach\\n The steps are the following:\\n\\n1. Find the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n2. To find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n3. If a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n![image.png](https://assets.leetcode.com/users/images/ec3b008b-3542-429e-aefe-07d870e88e5d_1682940260.9485922.png)\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/7c17f983-3b8b-4738-b722-c1c1466f9510_1682940288.2823734.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        // step 1 find breaking point \\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        // if there is no breaking  point \\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        \\n        else{\\n            // step 2 find next greater element and swap with ind2\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums,ind1,ind2);\\n            // step 3 reverse the rest right half\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13872,
                "title": "easiest-java-solution",
                "content": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Using a simple example, we can derive the following steps:\\n\\n    public void nextPermutation(int[] A) {\\n        if(A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while(i >= 0 && A[i] >= A[i + 1]) i--; // Find 1st id i that breaks descending order\\n        if(i >= 0) {                           // If not entirely descending\\n            int j = A.length - 1;              // Start from the end\\n            while(A[j] <= A[i]) j--;           // Find rightmost first larger id j\\n            swap(A, i, j);                     // Switch i and j\\n        }\\n        reverse(A, i + 1, A.length - 1);       // Reverse the descending sequence\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while(i < j) swap(A, i++, j--);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13921,
                "title": "1-4-11-lines-c",
                "content": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "**Solution 1**\\n\\nJust for info: There's a library function that does the job, even going from totally reverse sorted to sorted:\\n\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums), end(nums));\\n    }\\n\\n---\\n\\n**Solution 2**\\n\\nUsing library functions for all building blocks of the algorithm. Very nice how they all play together, notice the total lack of `+1`/`-1`, it all fits exactly.\\n\\n    void nextPermutation(vector<int>& nums) {\\n        auto i = is_sorted_until(nums.rbegin(), nums.rend());\\n        if (i != nums.rend())\\n            swap(*i, *upper_bound(nums.rbegin(), i, *i));\\n        reverse(nums.rbegin(), i);\\n    }\\n\\n---\\n\\n**Solution 3**\\n\\nDoing it all on my own (except `swap`, let's not be silly):\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            swap(nums[j], nums[k]);\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            swap(nums[i], nums[k]);\\n        }\\n    }\\n\\n---\\n\\n**Solution 4**\\n\\nOk, let's be silly after all and not even use `swap` :-)\\n\\n    void nextPermutation(vector<int>& nums) {\\n        int i = nums.size() - 1, k = i, tmp;\\n        while (i > 0 && nums[i-1] >= nums[i])\\n            i--;\\n        for (int j=i; j<k; j++, k--)\\n            tmp = nums[j], nums[j] = nums[k], nums[k] = tmp;\\n        if (i > 0) {\\n            k = i--;\\n            while (nums[k] <= nums[i])\\n                k++;\\n            tmp = nums[i], nums[i] = nums[k], nums[k] = tmp;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3169948,
                "title": "best-c-2-solution-two-pointers-optimized-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using 3 ways.\\n\\n1. Find all the permutation of Array(nums) then we can easily find next permutation.\\n2. Solved using Array + Two Pointers.\\n3. Solved using next_permutation (inbuilt) function.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of the Array(nums).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(1), Constant Space.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), Since we traverse the entire Array(nums) once in the worst case. Where N = size of\\n    the Array(nums).\\n\\n    Space Complexity : O(1), Constant Space.\\n\\n    Solved using Array + Two Pointers.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 First Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 1 Second Code *****************************************/\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909229,
                "title": "simple-easy-c-solution-explain-with-image",
                "content": "![image](https://assets.leetcode.com/users/images/d2dfaab0-542d-4cc8-a32a-d82dd29c4c95_1648961158.0012193.png)\\n\\n```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) \\n    {\\n        int n=nums.size();\\n        int l,r;\\n        for(l=n-2;l>=0;l--)                           // find decreasing sequence\\n        {\\n            if(nums[l]<nums[l+1]) break;\\n        }\\n        if(l<0) reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(r=n-1;r>l;r--)                       // find rightmost successor to pivot\\n            {\\n                if(nums[r]>nums[l]) break;\\n            }\\n            swap(nums[l],nums[r]);                  // swap l,r\\n            \\n            reverse(nums.begin()+l+1,nums.end());   // reverse from l+1 to end\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241286,
                "title": "c-simple-to-understand",
                "content": "# Find next permutation:\\n\\n### Algorithm:\\n\\n**step 1:** Linearly traverse given array from the end and find a number that is greater than its adjacent `nums[i] > nums[i-1]`. Store the index of smaller number in `breakPoint` variable. If there is no such element, reverse entire array and return.\\n\\n**step 2:** Linearly traverse from the end and this time find a number larger than `nums[breakPoint]`. Let\\'s call it `nums[i]`.\\n\\n**step 3:** Swap `nums[i] and nums[breakPoint]`.\\n\\n**step 4:** Reverse the array from index `breakPoint + 1` to `nums.size()`.\\n\\n### Example:\\n* Consider `nums[] = [1, 3, 5, 4, 2]`.\\n* Traverse from back and find a breakpoint. Here, index `breakPoint = 1` and `nums[breakPoint] = 3`\\n* Traverse from back and find a number larger than this. Here this number is: `nums[i] = 4`\\n* Swap `nums[breakPoint] and nums[i]`. Value after swapping: nums[] = [1, **4**, 5, **3**, 2].\\n* Reverse array from `breakPoint + 1` to `nums.size()` i.e. these elements: [1, 4, **5**, **3**, **2**]\\n* **`Final answer = [1, 4, 2, 3, 5]`.**\\n\\n**code:**\\n```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// find next permutation\\nvoid nextPermutation(vector<int> &nums)\\n{\\n    // initialize variable:\\n    int breakPoint = -1;\\n\\n    // find a breakpoint:\\n    for (int i = nums.size() - 1; i > 0; i--)\\n    {\\n        if (nums[i] > nums[i - 1])\\n        {\\n            breakPoint = i - 1;\\n            break;\\n        }\\n    }\\n\\n    // if no breakpoint\\n    if (breakPoint < 0)\\n    {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n\\n    // if found a breakpoint\\n    for (int i = nums.size() - 1; i >= 0; i--)\\n    {\\n        if (nums[i] > nums[breakPoint])\\n        {\\n            swap(nums[breakPoint], nums[i]);\\n            reverse(nums.begin() + breakPoint + 1, nums.end());\\n            break;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909728,
                "title": "simple-9-line-python-solution-with-detailed-explanation-easy-understand-for-beginners",
                "content": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```\\n\\n**Please upvote me if you think this is useful! Much appreciated!**\\n\\nImagine this as a wave or signal, what we want to do is to move the last peak one-bit forward with equal or smaller peak\\n\\nConsider the following example [1, 2, 3, 5, 2, 3, 7, 5, 4, 3, 0]\\n![image](https://assets.leetcode.com/users/images/f3d1862c-f3a1-4a4b-9910-b784b7bdb818_1648968377.4465942.png)\\n\\nThe last peak is the red dot (index = 6), the index before the last peak (aka the pre-last peak index) is the green dot (index = 5)\\n![image](https://assets.leetcode.com/users/images/450b8952-98cc-4cc1-ac26-7cb1e1df72c0_1648968377.4618545.png)\\n\\nThen sort the region after the pre-peak index (green dot), the sorted region is shown in yellow dots\\n![image](https://assets.leetcode.com/users/images/6e92ec4f-6bb3-4e95-a44f-0d3f1488201a_1648968735.369267.png)\\n\\nThen find the point where its value is just above the pre-peak index (green dot)\\nIn this example, it is the pink dot with index = 8\\n![image](https://assets.leetcode.com/users/images/3db777e4-ff85-420b-99b7-4070ff207579_1648968871.7919884.png)\\n\\nSwap the green dot and the pink dot\\n![image](https://assets.leetcode.com/users/images/cb34be94-d97d-447a-be46-3f762876d33f_1648969056.4870846.png)\\n\\n**Done!** Output the final list\\nIn this case, it is [1,2,3,5,2,4,0,3,3,5,7]",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def nextPermutation(self, nums):\\n        for i in range(len(nums)-1, 0, -1):\\n            # find the index of the last peak\\n            if nums[i - 1] < nums[i]:\\n                nums[i:] = sorted(nums[i:])\\n                \\n                # get the index before the last peak\\n                j = i - 1\\n                \\n                # swap the pre-last peak index with the value just large than it\\n                for k in range(i, len(nums)):\\n                    if nums[j] < nums[k]:\\n                        nums[k], nums[j] = nums[j], nums[k]\\n                        return nums\\n        return nums.reverse()\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 13907,
                "title": "easy-python-solution-based-on-lexicographical-permutation-algorithm",
                "content": "For the detailed algorithm and demonstration, please go to https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nThe steps are shown in the picture below.\\n![alt text](https://www.nayuki.io/res/next-lexicographical-permutation-algorithm/next-permutation-algorithm.png)\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # find longest non-increasing suffix\\n        right = len(nums)-1\\n        while nums[right] <= nums[right-1] and right-1 >=0:\\n            right -= 1\\n        if right == 0:\\n            return self.reverse(nums,0,len(nums)-1)\\n        # find pivot\\n        pivot = right-1\\n        successor = 0\\n        # find rightmost succesor\\n        for i in range(len(nums)-1,pivot,-1):\\n            if nums[i] > nums[pivot]:\\n                successor = i\\n                break\\n        # swap pivot and successor\\n        nums[pivot],nums[successor] = nums[successor],nums[pivot]  \\n        # reverse suffix\\n        self.reverse(nums,pivot+1,len(nums)-1)\\n        \\n    def reverse(self,nums,l,r):\\n        while l < r:\\n            nums[l],nums[r] = nums[r],nums[l]\\n            l += 1\\n            r -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179544,
                "title": "python-solution-with-easy-understanding-and-comments-bonus-related-links",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```\\n\\nTake an example from this site and try to re-run above code manually. This will better help to understand the code\\nhttps://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nRelated Link: \\nhttps://www.nayuki.io/res/next-lexicographical-permutation-algorithm/nextperm.py\\nhttps://en.wikipedia.org/wiki/Lexicographic_order",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # To find next permutations, we\\'ll start from the end\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number grater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now out pointer is pointing at two different positions\\n        # i. first non-assending number from end\\n        # j. first number greater than nums[i-1]\\n        \\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place\\n        \\'\\'\\'\\n            Dhruval\\n        \\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13885,
                "title": "9-lines-of-c-code-with-comments",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }\\n            \\n            // reverse all the numbers after violated number\\n            reverse(begin(num)+i+1, end(num));\\n            // if violated number not found, because we have reversed the whole array, then we are done!\\n            if (i == -1) return;\\n            // else binary search find the first number larger than the violated number\\n            auto itr = upper_bound(begin(num)+i+1, end(num), num[i]);\\n            // swap them, done!\\n            swap(num[i], *itr);\\n        }\\n    };\\n\\nYou might need to think for a while why this would work.",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int> &num) \\n        {\\n            if (num.empty()) return;\\n            \\n            // in reverse order, find the first number which is in increasing trend (we call it violated number here)\\n            int i;\\n            for (i = num.size()-2; i >= 0; --i)\\n            {\\n                if (num[i] < num[i+1]) break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 669387,
                "title": "javascript-clean-solution",
                "content": "Approach\\n*  Find the first decreasing index moving from end to start \\n\\t*  E.g. [7, 2, 3, 1, 5, 4, 3, 2, 0] num `1` is the first decreasing index going from the end backwards\\n*  Swap num `1` with the next large num to its right which is `2`\\n\\t*  [7, 2, 3, 2, 5, 4, 3, 1, 0]\\n*  Reverse/sort nums to the right\\n\\t*  [7, 2, 3, 2, 0, 1, 3, 4, 5]\\n*  If there is no next permutation reverse the array\\n\\n```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(nums) {\\n    \\n    for(let i = nums.length-1; i >= 0; i--) {\\n        if(nums[i] < nums[i+1]) {\\n            const large = nextLarge(i);\\n            swap(i, large);\\n            reverse(i+1);\\n            return;\\n        }\\n    }\\n\\t\\n\\t// If there is no next permutation reverse the arr\\n    nums.reverse()\\n    \\n    function swap(i, j) {\\n        [nums[i], nums[j]] = [nums[j], nums[i]];\\n    }\\n    \\n    function reverse(idx) {\\n        let start = idx, end = nums.length-1;\\n        \\n        while(start < end) {\\n            swap(start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    function nextLarge(idx) {\\n        for(let i = nums.length-1; i > idx; i--) {\\n            if(nums[i] > nums[idx]) return i;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229211,
                "title": "python-solution",
                "content": "First observe that if a list of numbers is in descending order, then there is no lexicographically next greater permutation. Hence `for i in range(n-1,0,-1)`, we search for the first occurrence of i such that `nums[i] < nums[i+1]`. If no such i exists, the list is in descending order, and we use `nums.reverse()` to reverse the list in-place. Otherwise, if such i exists, then `nums[i-1]` will be updated to get the lexicographically next greater permutation. Next, we need to search for the smallest number in `nums[i:]` that\\'s larger than `nums[i-1]`, and swap it with `nums[i-1]`. Note that `nums[i:]` is sorted in descending order. Hence we start with `j = i`, and `while j < n and nums[j] > nums[i-1]`, we do `idx = j, j += 1`. When we are out of the while loop, `nums[idx]` will be the smallest number in `nums[i:]` that\\'s larger than `nums[i]`. We then swap `nums[idx]` and `nums[i-1]`. After the swap, we just need to sort `nums[i:]` in ascending order to get the lexicographically next greater permutation. This can be achieved fairly easily in-place, because `nums[i:]` is already in descending order, and we just need to invert `nums[i:]` in-place to sort `nums[i:]` in ascending order. \\n\\nTo illustrate the algorithm with an example, consider `nums = [2,3,1,5,4,2]`. It is easy to see that `i = 2` is the first i (from the right) such that `nums[i] < nums[i+1]`. Then we swap `nums[2] = 1` with the smallest number in `nums[3:]` that is larger than 1, which is `nums[5] = 2`, after which we get `nums = [2,3,2,5,4,1]`. To get the lexicographically next greater permutation of `nums`, we just need to sort `nums[3:] = [5,4,1]` in-place. Finally, we reach `nums = [2,3,2,1,4,5]`.\\n\\nTime complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n = len(nums)\\n        for i in range(n-1, 0, -1):\\n            if nums[i] > nums[i-1]:\\n                j = i\\n                while j < n and nums[j] > nums[i-1]:\\n                    idx = j\\n                    j += 1\\n                nums[idx], nums[i-1] = nums[i-1], nums[idx]\\n                for k in range((n-i)//2):\\n                    nums[i+k], nums[n-1-k] = nums[n-1-k], nums[i+k]\\n                break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13890,
                "title": "sharing-my-really-simple-solution-with-explanation",
                "content": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "solutionTags": [
                    "C++",
                    "Math"
                ],
                "code": "    void nextPermutation(vector<int> &num) {\\n        for(int i = num.size() - 2; i >= 0; i--){\\n            if(num[i] < num[i + 1]){\\n                int pos;\\n                int diff = INT_MAX;\\n                for(int j = i + 1; j < num.size(); j++){\\n                    if(num[j] > num[i] && abs(num[i] - num[j]) < diff){\\n                        diff = abs(num[i] - num[j]);\\n                        pos = j;\\n                    }\\n                }\\n                swap(num[i], num[pos]);\\n                sort(num.begin() + i + 1, num.end());\\n                return;\\n            }\\n        }\\n        sort(num.begin(), num.end());\\n    }\\n\\nFor this problem, coding is not a big deal. Algorithm is!\\n\\nNow let's pick a number, for example, 24387651.\\n\\nwhat is the next permutation? 24513678.\\n\\nHow can I get the answer? \\n\\nFirst step: find the first ascending digit from the back of the number. 3 < 8 > 7 > 6 > 5 > 1. Then 3 is the digit.\\n\\nSecond step: swap that digit with the next big digit in following digits. Which one is the next big digit in 87651? 5! So swap them. Now the number becomes 24587631.\\n\\nThird step: sort 87631 into 13678. The final answer is 24513678.",
                "codeTag": "Unknown"
            },
            {
                "id": 1043577,
                "title": "python-o-n-inplace-solution-explained",
                "content": "This problem is very similar to problem **556. Next Greater Element III**, with exactly the same reasoning:\\n\\nImagine, that we have `nums = [2, 3, 4, 1, 5, 7, 6, 4, 1]` Then next permutation is `[2, 3, 4, 1, 6, 1, 4, 5, 7]`. Idea here is to start to look from the end and find decreasing pattern, like `[7, 6, 4, 1]` here, then look at previous element and insert it in correct place. For more details see https://leetcode.com/problems/next-greater-element-iii/discuss/983076/Python-O(m)-solution-explained.\\n\\n**Complexity**: time complexity it is `O(n)`, where `n` is length of `nums`. Space complexity is `O(1)` here, because we do everything in-place.\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        def reverse(L, start, end):\\n            while start < end:\\n                L[start], L[end] = L[end], L[start]\\n                start, end = start + 1, end - 1\\n        \\n        i, n = len(nums) - 1, len(nums)\\n        while i >= 1 and nums[i] <= nums[i-1]:\\n            i -= 1\\n            \\n        if i != 0:\\n            j = i\\n            while j + 1 < n and nums[j+1] > nums[i - 1]:\\n                j += 1\\n            \\n            nums[i-1], nums[j] = nums[j], nums[i-1]\\n        \\n        reverse(nums, i, n - 1)\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 152693,
                "title": "c-c-java-python-short-solution-with-comments-just-5-lines-of-clean-stl-c-code",
                "content": "1. Search from right to left for a point where the values stop ascending, that will be the point that must be updated.\\n2. Locate the point furthest right of this point that has a greater value than our destination point found in 1.\\n3. Swap the points found in 1. and 2 and reverse everything to the right of destination found in 1. as it is currently decending left to right and must be ascending.\\n\\n# **TL;DR**\\n**Python**\\n```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\\n**Java**\\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\\n**C++ STL Solution**\\nDetails below;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\n**C**\\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\\n\\n# **C++ Details**\\nAn initial solution might be;\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\\t\\t\\nOf course, you could cheat and do\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\\nBut where\\'s the fun in that?\\n\\nCan we do better though? Well all we\\'re really trying to do is find the first point where the ordering is no longer ascending when moving right to left. There\\'s an ~~app~~ algorithm for that! `std::is_sorted_until` will return the iterator of the first unsorted element, so using the reverse iterators to search from right to left, we get a one-liner to find the destination element.\\n\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t\\nThe actual code without comments is only a few, clean, lines.\\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\\t\\t",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```python\\ndef nextPermutation(self, nums: List[int]) -> None:\\n  # Find the first place moving from right to left that is not assending\\n  dest = len(nums) - 2\\n  while (0 <= dest and nums[dest] >= nums[dest + 1]):\\n    dest = dest - 1\\n\\n  # Found a destination to change\\n  if (0 <= dest):\\n    # Find the first number moving right to left bigger than destination number\\n    target = len(nums) - 1\\n    while (nums[target] <= nums[dest]):\\n      target = target - 1\\n\\n    nums[dest], nums[target] = nums[target], nums[dest]\\n\\n  # Reverse everything right of our destination\\n  nums[dest + 1:] = reversed(nums[dest + 1:])\\n```\n```java\\npublic void nextPermutation(int[] num) {\\n  // Find the first place moving from right to left that is not assending\\n  int dest = num.length - 2;\\n  for (; 0 <= dest && num[dest] >= num[dest + 1]; --dest)\\n    ;\\n\\n  // If we found a location that is not sorted\\n  if (0 <= dest) {\\n    // Find the right most value greater than our destination (there must be one)\\n    int target = num.length - 1;\\n    for (; num[dest] >= num[target]; --target)\\n      ;\\n\\n    // Swap the destination with the target\\n    int tmp = num[dest];\\n    num[dest] = num[target];\\n    num[target] = tmp;\\n  }\\n\\n  // Reverse everything right of the destination\\n  for (int end = num.length - 1; dest + 1 < end; ) {\\n    int tmp = num[++dest];\\n    num[dest] = num[end];\\n    num[end--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```c\\nvoid nextPermutation(int* nums, int numsSize) {\\n  /* Find the first place moving from right to left that is not assending */\\n  int dest = numsSize - 1;\\n  while (dest-- && nums[dest] >= nums[dest + 1])\\n    ;\\n\\n  if (0 <= dest) /* Found a destination to change */ {\\n    /* Find the right most value greater than our destination (there must be one) */\\n    int target = numsSize;\\n    while (nums[--target] <= nums[dest])\\n      ;\\n\\n    /* Swap the destination with the target */\\n    int tmp = nums[dest];\\n    nums[dest] = nums[target];\\n    nums[target] = tmp;\\n  }\\n  \\n  /* Reverse everything right of our destination */\\n  for (int back = numsSize - 1; dest + 1 < back; ) {\\n    int tmp = nums[++dest];\\n    nums[dest] = nums[back];\\n    nums[back--] = tmp;\\n  }\\n}\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      if (1 < nums.size()) {\\n        auto pos = nums.end() - 1;\\n        do {\\n          if (*pos > *(pos - 1)) {\\n            auto dest = pos - 1;\\n            // Find the first element that is greater then dest, this will be\\n            // the element between [pos, nums.end()] that is just above dest\\n            // Use the fact that [pos, nums.end()] is sorted in descending order to do a binary search\\n            auto target = --std::lower_bound(pos, nums.end(), *dest, std::greater<int>());\\n\\n            // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n            std::iter_swap(dest, target);\\n\\n            // At this point [pos, end) will be sorted descending, we need it to be\\n            // ascending\\n            // [3, 4, 2, 1] -> [3, 1, 2, 4] \\n            std::reverse(pos, nums.end());\\n            return;\\n          }\\n        } \\n        while (--pos != nums.begin());\\n\\n        // At the end of the permutation, reverse everything.\\n        std::reverse(nums.begin(), nums.end());\\n      }\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      std::next_permutation(nums.begin(), nums.end());\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      // Find the first point where the ordering from right to left is not sorted\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        // We found a point, find a candidate to swap with. The range [rbegin, dest) is sorted ascendingly\\n        // so we can binary search for the first element greater than our destination\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        \\n        // [2, 4, 3, 1] -> [3, 4, 2, 1]\\n        std::iter_swap(dest, target);\\n      }\\n      // Reverse everything to the right of our dest point. In the case of not being the whole vector this\\n      // reverses the ordering from being ascending (left to right) to being descending\\n      // [3, 4, 2, 1] -> [3, 1, 2, 4]\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```\n```cpp\\n    void nextPermutation(vector<int>& nums) {\\n      auto dest = std::is_sorted_until(nums.rbegin(), nums.rend());\\n      if (dest != nums.rend()) {\\n        auto target = std::upper_bound(nums.rbegin(), dest, *dest);\\n        std::iter_swap(dest, target);\\n      }\\n      std::reverse(nums.rbegin(), dest);\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1043648,
                "title": "easy-solution-w-detailed-explanation-beats-100-100",
                "content": "*(Note: This is part of a series of Leetcode solution explanations ([**index**](https://dev.to/seanpgallivan/leetcode-solutions-index-57fl)). If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n***Idea:***\\n\\nChanges made to the left part of an array have more impact on the lexicographical sorting than changes made to the right side, so logically, in order to find the next permutation that is lexicographically greater, we need to find the farthest right-most number that can be swapped for a larger number to its right.\\n\\nWe also then need to make sure that it\\'s not just any larger number, but the *next possible* larger number from the numbers to its right. Then, we\\'ll need to make sure that the remaining numbers to the right of our swapped target are in their lexicographically smallest configuration. (*Think of it like a counter rolling over from **0999** into **1000**.*)\\n\\n---\\n\\n***Implementation:***\\n\\nSo the first order of business is to find the target number we want to swap. As we check from the right to the left, if each number is larger than the one before, then we clearly can\\'t find a lexicographically larger number. Therefore, we have to move left until we find the first time a number is lower than the number to its right.\\n\\nOnce we find that target (**N[i]**), the very important thing to recognize is that the numbers to the target\\'s right are *already* in sorted order, just in the *reverse* order, so we can easily reverse them. (*Even if we don\\'t actually find the target, we still want to reverse the entire array, per the instructions.*)\\n\\nIt\\'s easy then to move from the smallest to largest of the reversed numbers and look for the first number (**N[j]**) that\\'s larger than our target so that we can swap the two. Since **N[j]** is lexicographically nearest to **N[i]**, the subarray to the right of **N[i]** will *still* be in the correct order even after the swap.\\n\\nA simple helper functions to swap array elements will be useful.\\n\\n---\\n\\n***Javascript Code:***\\n\\nThe best result for the code below is **72ms / 39.3MB** (beats 100% / 100%).\\n```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar nextPermutation = function(N) {\\n    const swap = (a, b) => [N[a],N[b]] = [N[b],N[a]]\\n    let len = N.length - 1, i, j\\n    for (i = len - 1; N[i] >= N[i+1];) i--\\n    for (let k = i+1; len > k; k++, len--) swap(k,len)\\n    if (~i) {\\n        for (j = i + 1; N[i] >= N[j];) j++\\n        swap(i,j)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2777680,
                "title": "easy-simple-o-n-c-code",
                "content": "# Please do upvote if you like the code ..ty\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Two Pointers",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(),k,l;\\n         \\n        // finding first element from the last which is smaller than\\n        // element next to it\\n        for(k=n-2 ; k>=0 ; k--)\\n            if(nums[k] < nums[k+1]) break;\\n\\n        // if we dont find any such element that means the vector \\n        // is already sorted in descending order\\n\\n        // i.e. It is already the biggest number that can be formed\\n        // using all the integers\\n\\n        // In this case the next Premutation will be the smallest\\n        // permutation that can be formed using the numbers of\\n        // array i.e. all the array elements in ascending order\\n        // which is nothing but the reverse of the current order\\n \\n        if(k<0)\\n            reverse(nums.begin() ,nums.end());\\n\\n        // After finding the index \"k\" of the number which is \\n        // smaller than the number next to it ,\\n        // we will again traverse from the right to \\n        // left and will find the first element which is greater\\n        // the element at index k ....which is indeed the smallest \\n        // of all the numbers right to the index k\\n\\n        // we will then swap both the characters \\n        // after swapping we will just reverse the digits after the\\n        // index k as that is in descending order and reversing it\\n        // will make it in increasing order and will make the whole\\n        // number smallest possible number greater than \\n        // the original number \\n        else{\\n            for(l = n-1; l >k ;l--)\\n                if(nums[l] > nums[k]) break;\\n            swap(nums[k], nums[l]); \\n            reverse(nums.begin()+k+1 ,  nums.end());\\n        }\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908568,
                "title": "python3-search-swap-sort-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThree steps:\\n1. Starting from the back, search for an element that has at least one element on the right side that is greater than it. [1, **2**, 4, 3, 1]\\n2. Swap the found element and the minimum element from the right side that is greater than the current. [1, **3**, 4, 2, 1]\\n3. Sort element on the right side. [1, 3, **1, 2, 4**]\\n\\nTime: **O(n^2)** - Can be linear if optimize searching for a candidate for swapping, and also instead of insertion sort just reverse the subarray :)\\nSpace: **O(1)**\\n\\nRuntime: 49 ms, faster than **72.04%** of Python3 online submissions for Next Permutation.\\nMemory Usage: 13.9 MB, less than **79.00%** of Python3 online submissions for Next Permutation\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        L = len(nums)\\n        for i in reversed(range(L - 1)):\\n            # Search\\n            cand = -1\\n            for j in range(i + 1, L):\\n                if nums[j] > nums[i]:\\n                    if cand < 0 or nums[j] < nums[cand]: cand = j\\n            if cand < 0: continue\\n\\n            # Swap\\n            nums[i], nums[cand] = nums[cand], nums[i]\\n                        \\n            # Insertion sort\\n            j = i + 2\\n            while j < L:\\n                k = j\\n                while k - 1 > i and nums[k - 1] > nums[k]:\\n                    nums[k - 1], nums[k] = nums[k], nums[k - 1]\\n                    k -= 1\\n                \\n                j += 1\\n\\n            break\\n        else:\\n            nums.reverse()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1394208,
                "title": "c-brute-force-optimal-time-o-n-auxiliary-space-o-1",
                "content": "**Brute Force Solution** \\n![image](https://assets.leetcode.com/users/images/312b7900-f2ea-4324-95b5-2a1c49055cb7_1628647022.5257127.gif)\\nPicture sourced from other coding sources\\n\\n**If n is the size of the array, then total number of permutations is n!. If nums[]={a,b,c} which means n=3, then the permutations are abc, acb, bac, bca, cba, cab. Time complexity of the brute force solution is O(NxN!) where N! is for the total number of permutations and N is for traversing each individual permutation**\\n```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\\n**Optimal Solution**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\\n**Optimal Solution(Inbuilt Function)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n**All suggestions are welcome. Please upvote if you like it. Thank you for reading the post.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n\\t    // Brute Force Solution Time O(N!*N) & Auxiliary Space O(N^2)\\n\\t\\t// Recursion & Backtracking\\n\\t    // TLE 64/265 test cases passed\\npublic:\\n\\t// permute function takes time of O(N*N!)\\n    void permute(int p,vector<int>& arr, vector<vector<int>>& res) {\\n        int n=arr.size();\\n        if(p==n) res.push_back(arr);\\n        for(int i=p;i<n;i++) {  // Time O(N) for traversal of each permutation\\n            swap(arr[i],arr[p]);\\n            permute(p+1,arr,res);  // Time O(N!) for total number of permutations\\n            swap(arr[i],arr[p]);\\n        }\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        vector<vector<int>> res; \\n        vector<int> arr=nums; \\n        permute(0,arr,res); \\n        set<vector<int>> s; // set stores unique elements in the sorted order\\n        for(int i=0;i<res.size();i++){\\n            s.insert(res[i]);\\n        }\\n        auto it=s.find(nums);\\n\\t\\t// If nums is last element of the permutation order, \\n\\t\\t// then nums is equal to the first element of the \\n\\t\\t// permutation sequence\\n        if(it==(--s.end())){\\n            it=s.begin();\\n            nums=*it;\\n        }\\n\\t\\t// else make nums equal to the immediate \\n\\t\\t// next element in the permutation sequence\\n        else{\\n            it++;\\n            nums=*it;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Narayana Panditha\\'s Algorithm\\n        int len=nums.size(), k=0, l=0;   // For example, if nums=[2,4,6,5,3]\\n        for(k=len-2;k>=0;k--){\\n            if(nums[k]<nums[k+1])\\n                break;  // k will point to 4 in nums=[2,4,6,5,3]\\n        }\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n            for(l=len-1;l>k;l--){\\n                if(nums[l]>nums[k])\\n                    break; //  l will point to 5 in nums=[2,4,6,5,3]\\n        }\\n            swap(nums[k],nums[l]); // nums=[2,5,6,4,3]\\n            reverse(nums.begin()+k+1,nums.end()); // nums=[2,5,3,4,6]\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\t    // Optimal Solution Time O(N) & Auxiliary Space O(1)\\n\\t    // Inbuilt Function\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349275,
                "title": "solution-swift-next-permutation-test-cases",
                "content": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 3 tests, with 0 failures (0 unexpected) in 0.016 (0.020) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func nextPermutation(_ nums: inout [Int]) {\\n        let len = nums.count\\n        var lhs = -1, rhs = -1, idx = len - 2\\n        while idx >= 0 {\\n            if nums[idx] < nums[idx + 1] { lhs = idx; break }\\n            idx -= 1\\n        }\\n        if lhs == -1 { nums = nums.reversed(); return }\\n        \\n        idx = len - 1\\n        while idx > lhs {\\n            rhs = idx\\n            if nums[idx] > nums[lhs] { break }\\n            idx -= 1\\n        }\\n        nums.swapAt(lhs, rhs)\\n        nums.replaceSubrange(lhs + 1..<len, with: nums[lhs + 1...len - 1].reversed())\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        var nums = [1,2,3]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,3,2])\\n    }\\n    \\n    func test1() {\\n        var nums = [3,2,1]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,2,3])\\n    }\\n    \\n    func test2() {\\n        var nums = [1,1,5]\\n        solution.nextPermutation(&nums)\\n        XCTAssertEqual(nums, [1,5,1])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908463,
                "title": "two-pointers-solution-with-detailed-explanation-code-commented",
                "content": "[Leetcode](https://leetcode.com/) [31. Next Permutation](https://leetcode.com/problems/next-permutation/).\\n\\n# Intuition\\n\\n- How to make a number **larger**? \\n\\nPick a **larger** number from the **lower** digit and swap it with the **higher** digit smaller number.\\n\\n- How to find the permutation which is **just larger** than the given number?\\n\\nThe increase should be as small as possible.\\n\\n# Two Pointers\\n\\nTake a example, $[3,2,1]$ which is decreasing order, there is no next permutation, it is already stable and cannot get larger.\\n\\nLike $[1,5,2,4,3,2]$, how can it be just larger than the given number?\\n\\n1. Scanning from right to left, find the **first** number which is smaller than the right digit, and swap it to the lower digit;\\n\\t- For example, $1 5 (2) 4 3 2$, the $2$ in the middle is the found one.\\n\\n2. Scanning from right to left, searching for the first number which is larger than it, and **swap** them.\\n\\t- For example, $1 5 (2) 4 (3) 2$, after swap: $1 5 (3) 4 (2) 2$.\\n\\nHowever, it\\'s not over yet!\\n\\nThe magnitude of the increase can be made smaller, the $3rd$ digit from right has become slightly larger, and the last three can be made smaller.\\n\\nThe last three digits are definitely **decreasing**, and they are flipped to become $[1,5,3,2,2,4]$, which is what is required.\\n\\n```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$\\n- **Space Complexity**: $O(1)$\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```java\\n    // Two Pointers time: O(n) space: O(1)\\n    public static void nextPermutation_tp(int[] nums) {\\n        if (nums == null || nums.length <= 1) {\\n            return;\\n        }\\n\\n        int len = nums.length;\\n        int left = len - 2;\\n        /**\\n         * from right to left, search for the first one which is smaller than the right digit.\\n         */\\n        while (left >= 0 && nums[left] >= nums[left + 1]) {\\n            left--;\\n        }\\n\\n        /**\\n         *  If the one exists, search a one which is larger than it from right to left.\\n         */\\n        if (left >= 0) {\\n            int right = nums.length - 1;\\n            while (right >= 0 && nums[left] >= nums[right]) {\\n                right--;\\n            }\\n            /**\\n             * swap them.\\n             */\\n            swap(nums, left, right);\\n        }\\n\\n        /**\\n         *  flip the right to make the number smaller.\\n         */\\n        reverse(nums, left + 1);\\n    }\\n\\n    public static void swap(int[] nums, int a, int b) {\\n        int temp = nums[a];\\n        nums[a] = nums[b];\\n        nums[b] = temp;\\n    }\\n\\n    public static void reverse(int[] nums, int low) {\\n        int left = low;\\n        int right = nums.length - 1;\\n        while (left < right) {\\n            swap(nums, left, right);\\n            left++;\\n            right--;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13894,
                "title": "two-pointer-solution-in-python-with-detail-expalanation",
                "content": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "Credit goes to http://blog.csdn.net/m6830098/article/details/17291259\\n\\n    class Solution(object):\\n        def nextPermutation(self, nums):\\n            \"\"\"\\n            :type nums: List[int]\\n            :rtype: void Do not return anything, modify nums in-place instead.\\n            \"\"\"\\n            # Use two-pointers: two pointers start from back\\n            # first pointer j stop at descending point\\n            # second pointer i stop at value > nums[j]\\n            # swap and sort rest\\n            if not nums: return None\\n            i = len(nums)-1\\n            j = -1 # j is set to -1 for case `4321`, so need to reverse all in following step\\n            while i > 0:\\n                if nums[i-1] < nums[i]: # first one violates the trend\\n                  j = i-1\\n                  break\\n                i-=1\\n            for i in xrange(len(nums)-1, -1, -1):\\n                if nums[i] > nums[j]: # \\n                    nums[i], nums[j] = nums[j], nums[i] # swap position\\n                    nums[j+1:] = sorted(nums[j+1:]) # sort rest\\n                    return",
                "codeTag": "Java"
            },
            {
                "id": 2516442,
                "title": "c-two-simplest-solutions-with-without-stl",
                "content": "Hey Guys,\\nHope you all are doing well!\\nIn this post, I\\'ve provided two simple and easy-to-understand solutions.\\nApproach 1:\\nStep 1: Linearly traverse the array from backwards\\xA0so that the array\\'s ith index value is less than the array\\'s (i+1)th index value. Store \\xA0that index into a variable.\\nStep 2: If the index value obtained in step 1 is less than zero. This indicates that the given input array has already been sorted in descending order. Simply reverse the given array to obtain the next permutation. Otherwise, simply traverse the array backwards to find the index that has\\xA0a value greater than the previously found index. Store index in another variable.\\nStep 3: Swap values present in indices found in the above two steps.\\nStep 4: Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\\nApproach 2: We can simply use the C++ STL library function ```next_permutation()``` to get the next lexicographically greater permutation.\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```\\nWhile traversing from backwards we are searching for an element whose value is smaller than the value of its previous element and in each step, we are decrementing the counter i by 1. \\nIf the given array is already sorted in descending order then we will not get a single element.  Eventually, counter i become -1.\\nAs we know to find the next permutation of any integer array which is already sorted in descending order simply take the reverse of it. \\n\\n![sample](https://user-images.githubusercontent.com/106552945/188268610-bb25b8c6-65b6-48a8-a3b6-ad652e6ab0d9.jpg)\\n\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\nPlease upvote if you found the solution useful.\\nHappy Coding!!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        int n=arr.size(),i,j;\\n        for(i=n-2;i>=0;i--){\\n            if(arr[i]<arr[i+1]) break;\\n        }\\n        if(i<0) reverse(arr.begin(),arr.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(arr[j]>arr[i]) break;\\n            }\\n            swap(arr[i],arr[j]);\\n            reverse(arr.begin()+i+1,arr.end());\\n        }\\n    }\\n};\\n```\n```next_permutation()```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& arr) {\\n        next_permutation(arr.begin(),arr.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13878,
                "title": "c-java-clean-code-with-really-simple-explanation",
                "content": "To understand this approach, we need to define 2 concept with a 5 digit example `12543`:\\n- `NCR - No Capacity Range` : the number in that `range` cannot be bigger, Like: \"543\"\\n- `DWC - Digit With Capacity` : A digit bring capacity to the range after it. Like: \"[2]543\"\\n\\nLet's get some hint from finding the Next Decimal:\\n```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\\nImagine how you increase this number `5999` to `6000`:\\nBecause the first 3 digits from right is a `No Capacity Range`, you have to flip the 4th digits (5, the first `Digit With Capacity`.), to what - The next smallest digits greater than `5`, which is `6`, then make the `rest 3 digits` the smallest combination, which is `\"000\"`, that's how you get this `\"6000\"`;\\n\\nIn an permutation though, the next smallest number for `DWC(Digit With Capacity)` would be whatever is available in that following `NCR(No Capacity Range)`\\n\\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\\nSo we have found the pattern is always to find the first `DWC(Digit With Capacity)`, then minimize the `NCR` after it.\\n\\nTo summarize:\\n1. Find the first `DWC`, which is 2;\\n```\\n1[2](5 4 3)\\n  ^\\n```\\n2. Reverse the `NCR` after it to make the `NCR` in increasing order(because it is already sorted in descending order).\\n```\\n1[2](3 4 5)\\n  ^\\n```\\n3. Swap the `DWC` with the `1st` digit in the reversed range that is slightly bigger than it.\\n```\\n1[3](2 4 5)\\n  ^--^\\n```\\nDONE!\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Java**\\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nNext Decimal\\n[5](9 9 9) <- NCR (No Capacity Range)\\n ^\\nDWC (Digit With Capacity)\\n=>\\n[6](0 0 0)\\n```\n```\\nNext Permutation\\n1[2](5 4 3) <- NCR (No Capacity Range)\\n  ^\\nDWC (Digit With Capacity)\\n=>\\n1[3](2 4 5)\\n```\n```\\n1[2](5 4 3)\\n  ^\\n```\n```\\n1[2](3 4 5)\\n  ^\\n```\n```\\n1[3](2 4 5)\\n  ^--^\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        if (a.size() <= 1) return;\\n        int dwc = -1; // Digit With Capacity\\n        for (int i = a.size() - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        // if dwc is not found, means this is a max array, reverse whole array and return;\\n        reverse(a.begin() + dwc + 1, a.end());\\n        if (dwc != -1) return;\\n        for (int i = dwc + 1; i < a.size(); i++) {\\n            if (a[i] > a[dwc]) {\\n                swap(a[i], a[dwc]); break;\\n            }\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * 0. For permutation of index, the smallest order is ever increasing, the largest order is ever decreasing.\\n * 1. no-capacity-range: NCR - Start from the end, as long as the next number is bigger, this whole range have no capacity.\\n * 2. First digit-with-capacity: DWC - find the first DWC index. reverse the rest. then switch the index with the first larger than index on the right.\\n */\\npublic class Solution {\\n    public void nextPermutation(int[] a) {\\n        if (a.length < 2) return;\\n        /* Find the first Digit With Capacity */\\n        int dwc = -1;\\n        for (int i = a.length - 2; i >= 0; i--) {\\n            if (a[i] < a[i + 1]) {\\n                dwc = i; break;\\n            }\\n        }\\n        /* Reverse the No Capacity Range after 1st DWC. */\\n        reverse(a, dwc + 1, a.length - 1);\\n        if (dwc != -1) {\\n            for (int i = dwc + 1; i < a.length; i++) {\\n                if (a[i] > a[dwc]) {\\n                    swap(a, dwc, i); break;\\n                }\\n            }\\n        }\\n    }\\n    private void reverse(int[] a, int i, int j) {\\n        for (; i < j; i++, j--) { swap(a, i, j); }\\n    }\\n    private void swap(int[] a, int i, int j) {\\n        int tmp = a[i];\\n        a[i] = a[j];\\n        a[j] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294256,
                "title": "simple-java-approach-with-100-beats",
                "content": "# Intuition\\nBasic Idealogy about the lexicographical order of permutations to the given input\\n\\n# Approach\\nStep 1:In first for loop, traverse the array from the end to find the first decreasing element from the right.(If any of the element had not been found means, just reverse the loop and exit the program.)\\n\\nStep 2:In second for loop, traverse the array from the end to find the first element which is greater than the element we had found before.\\n\\nStep 3:Swap the two elements we had found and stored previously.\\n\\nStep 4:Just reverse the array from the index next to the first swapped element to the end.\\n\\n\\n                        Do upvote for me!\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        int ind2=-1;\\n        for(int i=nums.length-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(ind1==-1){\\n            reverse(nums,0);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=0;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;\\n                    break;\\n                }\\n            }\\n            swap(nums,ind1,ind2);\\n            reverse(nums,ind1+1);\\n        }\\n    }\\n    void swap(int[] nums,int i,int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    void reverse(int[] nums,int start){\\n        int i=start;\\n        int j=nums.length-1;\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564964,
                "title": "c-solution-with-proper-explanation-along-with-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Find the point a[i]<a[i+1] by iterating from last. This is our index1.\\n- If there is no breakpoint that means the array is in descending order. So, simply reverse the full array.\\n- Else again iterate from last and find the element that is great than a[index1]. Store it as index2.\\n- Swap the 2elements at index1 and index2.\\n- Finally reverse the array from index1+1, so that we get the minimum number. Which means the next permutation.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i, j;\\n        int n= nums.size();\\n        int a=0;\\n        for(i=n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1]){\\n                break;\\n            }\\n        }\\n        if(i<0)\\n            reverse(nums.begin(), nums.end());\\n        else{\\n            for(j=n-1; j>=0; j--){\\n                if(nums[i]<nums[j]){\\n                    break;\\n                }\\n            }\\n            swap(nums[i], nums[j]);\\n            reverse(nums.begin()+i+1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910236,
                "title": "python-easy-o-n-solution-explained",
                "content": "**Explaination:**\\nLet\\'s take an example and try to understand.\\n```Example: curr = [1, 2, 4, 3]```\\n```next = [1, 3, 2, 4]``` , So How do we find next? \\n\\n**Step1:** Find the ```breakpoint``` from the end which breaks the non-increasing sequence. Why?\\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\\nNow Think, can we swap any element from ```right```? No we can\\'t because it will always result in lower permutation and not greater.\\nSo we find the break point\\n\\n**Step2:** Traverse from end in ```right``` part and find the first element greater than breakpoint. Why?\\nWe need to find the next lexicographically greater permutation, So we can\\'t just swap it with any number, In the above example, ```4``` and ```3``` both are greater than ```2```. Swapping with```4``` will be far greater, So we will swap it with ```3```\\n\\nAfter swapping ```1,  3, [ 4,  2 ] ```\\n\\n**Step3:** Reverse the right part. Why? \\nAfter getting the next greater ```breakpoint```, All the element at ```right``` part must be sorted as we need a next greater permutation\\nwe can\\'t just leave ```[4, 2]``` like this, because it will be far greater and not next greater.\\nSo we will sort the ```right```, but wait do we even need to sort it? No, bcoz right is already non-increasing, So we just need to reverse it in order to get it sorted.\\n```final = 1, 3, [2, 4]``` \\n\\n*Code*\\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\\n***\\n```Time Complexity:  O(n)```\\n```Space Complexity: O(1)```\\n***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Example: curr = [1, 2, 4, 3]```\n```next = [1, 3, 2, 4]```\n```breakpoint```\n```\\n    |-breakpoint\\n    |\\n1,  2, [ 4,  3 ] - right (non increasing sequence)\\n```\n```right```\n```right```\n```4```\n```3```\n```2```\n```4```\n```3```\n```1,  3, [ 4,  2 ] ```\n```breakpoint```\n```right```\n```[4, 2]```\n```right```\n```final = 1, 3, [2, 4]```\n```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        bPoint, n = -1, len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i] >= arr[i+1]: continue                   # Skip the non-increasing sequence\\n            bPoint = i                                        # Got our breakpoint\\n            for j in range(n-1,i,-1):                         # again traverse from end\\n                if arr[j] > arr[bPoint]:                      # Search an element greater the element present at the breakPoint.\\n                    arr[j], arr[bPoint] = arr[bPoint], arr[j] # Swap it\\n                    break                                     # We just need to swap once\\n            break                                             # Break this loop too\\n        arr[bPoint+1:] = reversed(arr[bPoint+1:])             # Reverse the element after the breakpoint\\n```\n```Time Complexity:  O(n)```\n```Space Complexity: O(1)```",
                "codeTag": "Java"
            },
            {
                "id": 2187200,
                "title": "c-solution-optimized-solution-tc-o-n",
                "content": "**Explanation:**\\n* Linearly traverse array from backward such that ith index value of the array is less than (i+1)th index value. Store that index in a variable.\\n\\n* If the index value received from step 1 is less than 0. This means the given input array is the largest lexicographical permutation. Hence, we will reverse the input array to get the minimum or starting permutation. Linearly traverse array from backward. Find an index that has a value greater than the previously found index. Store index is another variable.\\n* Swap values present in indices found in the above two steps.\\n* Reverse array from index+1 where the index is found at step 1 till the end of the array.\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\nTC -> `O(n)`\\nSC ->` O(1)`\\n**Please upvote if you find the solution useful, means a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1044321,
                "title": "c-2-pointer-solution-explained-100-time-90-space",
                "content": "This problem is similar to a few others here on getting the next bigger number with the same digits or the next permutation of a string, etc.\\n\\nThis is just easier since we work directly with a vector, so let\\'s crack on!\\n\\nFirst of all, we will create 2 support variables, our indexes `i` and `j`, respectively set to be pointing to the penultimate element and past the end of the vector.\\n\\nWe will then keep reducing `i` as long as it is non-negative and as long as it points to an element `>=` than the previous one.\\n\\nIf we were to finally end up with `i == -1`, it would mean that the whole vector is set in decreasing order, so no next permutation is possible, and we need to transform the array to the very first one, before leaving the function.\\n\\nNow, you might just opt to sort the vector, but since we know it is already ordered, just reversing it might just save us precious computation: `O(nlogn)` vs. `O(n)` (or, rather `O(n/2)`) is a no brainer.\\n\\nFor any other value of `i`, we will then search with `j` for the very first element that is `<= nums[i]`, which is guaranteed to be there (since all the elements before `i` are in decreasing order).\\n\\nOnce found, we will swap `nums[i]` and `nums[j]`, since `nums[j]` is the next number to go there, and set the rest of the positions from `i + 1` to be in increasing order - I guess here reversing and then using insertion sort would perform better, but I did not feel like going for that overkill just in case.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Combinatorics"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        // support variables\\n        int i = nums.size() - 2, j = i + 2;\\n        while (i >= 0 && nums[i] >= nums[i + 1]) i--;\\n        // edge case: already the highest permutation you can get\\n        if (i == -1) {\\n            reverse(begin(nums), end(nums));\\n            return;\\n        }\\n        // finding the first element > nums[i]\\n        while (nums[--j] <= nums[i]);\\n        // swapping i and j\\'s values\\n        swap(nums[i], nums[j]);\\n        // ordering the rest\\n        sort(begin(nums) + i + 1, end(nums));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 903596,
                "title": "o-n-js-solution-with-explanation",
                "content": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nI will consider given array as a number.\\n\\nIf given array is in descending order, there is no greater number.\\nHence, we reverse the array and return.\\n\\n1. We iterate through given array from the back. We look for the first dip because that is where we can swap numbers and make our number greater.\\n2. However, simply swapping adjacent numbers when a dip is found isn\\'t sufficient.\\nex) Given 1 2 6 8 7, next greater number isn\\'t 1 2 8 6 7. It\\'s 1 2 7 6 8. \\n3. We consider the first dip as the pivot. Then, we iterate again from the back. The first number greater than\\npivot will be swapped with the pivot. This logic works because all numbers up to the pivot (the first dip) are in descending order.\\n4. Then, we reverse arr[pivot+1...end] because we want to change these numbers from descending order to ascending order.\\nThis allows us to get the next greater number. The swap doesn\\'t change the descending order of arr[pivot+1...end].\\n*/\\nvar nextPermutation = function(nums) {\\n    let pivot = -1;\\n    for (let i = nums.length-1; i > 0; i--) {\\n        if (nums[i] > nums[i-1]) {\\n            pivot = i-1;\\n            break;\\n        }\\n    }\\n    if (pivot === -1) { // array is in descending order\\n        nums.reverse();\\n        return;\\n    }\\n    for (let i = nums.length-1; i > pivot; i--) {\\n        if (nums[i] > nums[pivot]) {\\n            swap(nums, i, pivot);\\n            break;\\n        }\\n    }\\n    for (let i = pivot+1, j = nums.length-1; i < j; i++, j--) {\\n        swap(nums, i, j);\\n    }\\n    // T.C: O(N)\\n    // S.C: O(1)\\n};\\n\\nfunction swap(nums, i, j) {\\n    [nums[i], nums[j]] = [nums[j], nums[i]];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13926,
                "title": "simple-o-n-java-solution-with-explanation-improved-using-binary-search",
                "content": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Idea:\\n    1. Reverse find first number which breaks descending order.\\n    2. Exchange this number with the least number that's greater than this number.\\n    3. Reverse sort the numbers after the exchanged number.\\n*/\\n\\npublic class Solution {\\n    public void nextPermutation(int[] nums) {\\n        /* 1. Reverse find first number which breaks descending order. */\\n        int i=nums.length-1;\\n        for(; i>=1; i--)\\n            if(nums[i-1]<nums[i]) break;\\n        \\n        /* if no break found in step 1 */\\n        if(i==0){\\n            /* for case \"1\" and \"1111\" */\\n            if(nums.length==1 || nums[0]==nums[1]) return; \\n            /* for case \"54321\" */\\n            int lo=i, hi=nums.length-1; \\n            while(lo<hi) swap(nums, lo++, hi--);\\n            return;\\n        }\\n        \\n        /* 2. Exchange this number with the least number that's greater than this number. */\\n        /* 2.1 Find the least number that's greater using binary search, O(log(nums.length-i)) */\\n        int j = binarySearchLeastGreater(nums, i, nums.length-1, nums[i-1]);\\n        \\n        /* 2.2 Exchange the numbers */\\n        if(j!=-1) swap(nums, i-1, j);\\n        \\n        /* 3. Reverse sort the numbers after the exchanged number. */\\n        int lo=i, hi=nums.length-1;\\n        while(lo<hi) swap(nums, lo++, hi--);\\n    }\\n    \\n    public int binarySearchLeastGreater(int[] nums, int lo, int hi, int key){\\n        while(lo<=hi){\\n            int mid = lo + (hi-lo)/2;\\n            if(nums[mid]>key){\\n                lo = mid+1;\\n            } else {\\n                hi = mid-1;\\n            }\\n        }\\n        return hi;\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int tmp = nums[j];\\n        nums[j] = nums[i];\\n        nums[i] = tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362645,
                "title": "amazon-sde-1-interview-o-n-approach",
                "content": "# **\\u2714 Approach-1 (Brute Force Approach ) O(N! N)**\\n*  **Find all the permutations of the given array/string/vector and then loop to find out the given permutation.**\\n* **Further, print its next permutation. If the given permutation is the last one, then print the first permutation.**\\n# **\\u2714 Approach-2  TC:O(N) SC:O(1)**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```\\n* Generally the permutations are in such a way that if we start from end, all the elements will be in sorted order till a specific break point. We need to find that break point element.\\n* Loop through the array starting from end till begin and find out such an element such that ele[i]<ele[i+1], where ele[i] is the break point element.\\n* Now, again loop through the end till i such that ele[j]>ele[i]. So basically we find first element from the end which is greater than ele[i].\\n* Now swap ele[i] and ele[j].\\n* Reverse all the elments after i to get the desired next permutation.\\n\\nThis video helped me. Thanks to @TUF and @Striver\\n[https://www.youtube.com/watch?v=LuLCLgMElus&list=PLgUwDviBIf0rPG3Ictpu74YWBQ1CaBkm2&index=9](http://)\\n\\n# **Please Upvote if it helps !  \\uD83D\\uDE4F**",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int k,j;\\n        for(k=nums.size()-2 ; k>=0 ; k--){               //O(n)          \\n            if(nums[k]<nums[k+1])                   \\n                break;\\n        }\\n//No Breakpoint i.e array is in desc. order already, so we print the\\n//1st permutation by reversing it which results in asc. order.\\n        if(k<0){\\n            reverse(nums.begin(),nums.end());  \\n        }\\n        else{\\n            for(j=nums.size()-1 ; j>k ; j--){           //O(n)\\n                if(nums[j]>nums[k])\\n                    break;\\n            }\\n            swap(nums[k],nums[j]);                      //O(1)\\n            reverse(nums.begin()+k+1,nums.end());       //O(n)\\n        }\\n    }\\n};\\n// Total TC:O(3n)~O(n)  SC:O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3376412,
                "title": "narayana-o-n",
                "content": "The algorithm is designed to generate the next permutation, but it can be made cyclic, thereby generating all permutations.\\n\\n# Algorithm\\n1. Find the maximum index $i$ for which $A_i < A_{i+1}$. *(It is optimal to search from the end of the permutation)*\\n2. Find the maximum index $j$ for which $A_j > A_i$. *(It is optimal to search from the end of the permutation)*\\n3. Swap $A_i$ and $A_j$.\\n4. Write the sequence $A_{i+1},...,A_n$ in reverse order.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n- Space complexity: $O(1)$\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int i = a.length - 2, j = a.length - 1;\\n\\n        while (i >= 0) {\\n            if (a[i] < a[i+1]) {\\n                break;\\n            } else {\\n                --i;\\n            }\\n        }\\n\\n        if (i == -1) {\\n            for(i = 0; i < a.length / 2; ++i) {\\n                int temp = a[i];\\n                a[i] = a[a.length - i - 1];\\n                a[a.length - i - 1] = temp;\\n            }\\n        } else {\\n            \\n            while (j >= 0) {\\n                if (a[j] > a[i]) {\\n                    break;\\n                } else {\\n                    --j;\\n                }\\n            }\\n\\n            int temp = a[i];\\n            a[i] = a[j];\\n            a[j] = temp;\\n\\n            int shift = i + 1;\\n\\n            for(int k = 0; k < (a.length - shift) / 2; ++k) {\\n                temp = a[shift + k];\\n                a[shift + k] = a[a.length - k - 1];\\n                a[a.length - k - 1] = temp;\\n            }\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902499,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the length of the nums.\\n    //   - space: O(1), only constant space is used.\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        let n = nums.count\\n        var i = n - 2\\n        while i >= 0, nums[i + 1] <= nums[i] { i -= 1 }\\n        \\n        guard i >= 0 else {\\n            reverse(&nums, start: i + 1, end: n - 1)\\n            return\\n        }\\n        \\n        var j = n - 1\\n        while j >= 0, nums[j] <= nums[i] { j -= 1 }\\n        nums.swapAt(i, j)\\n        reverse(&nums, start: i + 1, end: n - 1)\\n    }\\n    \\n\\n    private func reverse(_ nums: inout [Int], start: Int, end: Int) {\\n        var i = start\\n        var j = end\\n        while i < j {\\n            nums.swapAt(i, j)\\n            i += 1\\n            j -= 1\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448059,
                "title": "c-solution-with-explanation-easy-for-beginners",
                "content": "### Approach: (Without 1 liner XD)\\n\\nLet us start by taking an example of test case = [1 , 2 , 4 , 3]\\n\\nLexicographically next permutation would be [1 , 3 , 2 , 4]. \\n\\nHere, we have done 2 things:\\n- Swapped 2 with 3.\\n- Sorted the array after the swapped index.\\n\\nSo precisely, the generalised approach, which comes here in mind is:\\n\\n- Find the index from where we have to swap its value with its next greater value. For this, start from last, just find the index where number is greater than its next index. Say this index as small. \\n- Find the index of number, just greater than the number at the small.\\n- Swap the both values. And sort the array after the swapped index.\\n\\nEdge case: If array is in descending order, then we have to just sort it to ascending.\\n\\nMy submission:\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```\\n**PLEASE UPVOTE IF YOU LIKED IT, IT REALLY MOTIVATES :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& number) {\\n        int i = 0;\\n        for(i = number.size() - 1 ; i > 0; i--){        //Finding the index needed to be swapped.\\n            if(number[i] > number[i - 1]){\\n                break;\\n            }\\n        }\\n        if(i == 0){     \\n            reverse(number.begin() , number.end());     // Permutation is in descending order. Sort it to ascending order.\\n        } else {\\n            int x = number[i - 1], small = i;           \\n            for(int j = i + 1; j < number.size(); j++){     //Finding the number just greater than at index needed to be swapped.\\n                if(number[j] > x && number[j] <= number[small]){\\n                    small = j;\\n                }\\n            }\\n            \\n            swap(number[i - 1] , number[small]);        //Swapping the numbers.\\n        \\n            sort(number.begin() + i, number.end());     // Sorting the array after the swapped index.\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510520,
                "title": "next-permutation-100-faster-java-solution",
                "content": "**Time  Complexity : `O(n) + O(n) + O(n) \\u2245 O(n)`\\nSpace Complexity : `O(1)`**\\n\\n**O(n)** is for First traversal to find break point, \\n**O(n**) is for Second traversal to swap,\\n**O(n**) is for to reverse\\n\\n*Next Permutation*\\n![image](https://assets.leetcode.com/users/images/e12165af-45ea-4ce4-ac8f-4516144d77e4_1633695069.3101196.gif)\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null || nums.length <= 1)\\n            return;\\n        \\n        int i = nums.length - 2;\\n        while(i>=0 && nums[i] >= nums[i+1])\\n            i--;\\n        \\n        if(i>=0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i])\\n                j--;\\n            \\n          swap(nums, i, j);  \\n        }\\n        \\n        reverse(nums, i+1, nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i, int j){\\n        while(i<j)\\n            swap(nums, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1043674,
                "title": "c-simple-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n**Like it? please upvote...**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if (n < 2) return;\\n        \\n        int i = n-1, j = n-1;\\n        \\n        // Find the largest index i such that nums[i] < nums[i + 1]:\\n        while (i > 0 && nums[i-1] >= nums[i]) i--;\\n        \\n        // If no such index exists - reverse the array and were done:\\n        if (i == 0) {\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // Find the largest index j > i such that nums[i] < nums[j]:\\n        i--;\\n        while (j > i && nums[j] <= nums[i]) j--;\\n        \\n        // Swap nums[i] and nums[j]:\\n        swap(nums[i], nums[j]);\\n        \\n        // Reverse the array from index i until the end:\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910716,
                "title": "python-40-ms-and-beat-100-swap-method",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```\\nSimilar method(Problem 1053):-https://leetcode.com/problems/previous-permutation-with-one-swap/discuss/959167/Swap-Method-Python",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        i = len(nums)-1\\n        while i>0:\\n            if nums[i-1]<nums[i]:\\n                break\\n            i = i-1\\n        i = i-1\\n        j = len(nums)-1\\n        while j>i:\\n            if nums[j]>nums[i]:\\n                break\\n            j=j-1\\n        nums[i],nums[j]=nums[j],nums[i]  \\n        nums[i+1:]=sorted(nums[i+1:]) \\n# Thanks\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466198,
                "title": "easy-to-understand-java-solution-1ms-please-upvote",
                "content": "# Intuition\\nIn dictionary consider the names `sam`, `sai` and `sui`. `sai` would be exactly next to sam because it has **`longest prefix match -sa`**. Similarly `sui` will be after `sam` but exactly not after `sam` because it has **`smaller prefix match - s`**. So the permutation with longest prefix match has higher chances of being the next one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Find the breaking index :** \\n      - Breaking index occurs when a dip point is observered in the\\n        pattern of the nums.\\n        \\n        ![next permutation1.jpg](https://assets.leetcode.com/users/images/2c0a6174-3062-4837-be9d-6e1454b59591_1682771631.79299.jpeg)\\n      - `Base codition` occurs when there is no breaking point, this indicates the given nums array is the last permutation. Hence, `reverse` the nums array which gives us our next permutation.\\n      \\n        ![next permutation2.jpg](https://assets.leetcode.com/users/images/15cdbcdd-5553-455c-8a9c-a1cd41272202_1682771975.8683147.jpeg)\\n\\n1. **Finding num just greater than breaking idx :**\\n    - Traverse the nums array `n-1 to idx`, if `nums[i] > nums[idx]->swap`and exit the loop.\\n      \\n    ![next permutation3.jpg](https://assets.leetcode.com/users/images/0be1c019-bd65-4bb9-9be2-cd98f6fda16b_1682772625.132264.jpeg)\\n\\n1. **Reverse the remaining nums array :**\\n    - Reversing is needed because we need the just next Permutation.\\n    \\n    ![next permutation4.jpg](https://assets.leetcode.com/users/images/f20a7a5d-5af7-44c2-9095-f303b961b718_1682772824.645866.jpeg)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n      $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n      $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length;\\n        // store the breaking point\\n        int idx = -1;\\n\\n        for(int i = n-2 ; i>=0 ; i--) {\\n            if(nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        \\n        // base case - no breakpoint found\\n        if(idx == -1) {\\n            Arrays.sort(nums, 0, n);\\n            return;\\n        }\\n\\n\\n        // finding the greater but closest num\\n        for(int i=n-1 ; i>idx ; i--) {\\n            if(nums[i] > nums[idx]) {\\n                int temp = nums[i];\\n                nums[i] = nums[idx];\\n                nums[idx] = temp;\\n                break;\\n            }\\n        }\\n        // Reversing the remaining array.\\n        Arrays.sort(nums, idx+1, n);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416614,
                "title": "c-java-python-javascript-fully-explained-easy-to-understand",
                "content": "# Intuition:\\nThe problem requires finding the next permutation in lexicographic order of the given array. If the given permutation is the largest possible permutation, then the function should return the smallest possible permutation by rearranging the array in ascending order.\\n\\n# Approach:\\nThe algorithm finds the first pair of adjacent elements in the array that satisfy nums[k] < nums[k+1] from the right end of the array. If such a pair does not exist, then the entire array is sorted in descending order, and we need to reverse the entire array to obtain the smallest possible permutation.\\n\\nOtherwise, the algorithm finds the smallest element nums[l] to the right of nums[k] such that nums[l] > nums[k]. We swap nums[k] and nums[l], and then reverse the subarray starting at nums[k+1] to obtain the next lexicographic permutation of the array.\\n\\n# Complexity:\\n- Time complexity: The algorithm performs two passes over the array. The first pass has time complexity O(n), while the second pass also has time complexity O(n). Therefore, the overall time complexity of the algorithm is O(n).\\n\\n- Space complexity: The algorithm uses constant extra space, hence the space complexity of the algorithm is O(1).\\n\\n---\\n\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n# JAVA\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\\n---\\n\\n# JavaScript \\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t} \\n        else {\\n    \\t    for (l = n - 1; l > k; l--) {\\n                if (nums[l] > nums[k]) {\\n                    break;\\n                }\\n            } \\n    \\t    swap(nums[k], nums[l]);\\n    \\t    reverse(nums.begin() + k + 1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int n = nums.length, k = n - 2, l = n - 1;\\n        while (k >= 0 && nums[k] >= nums[k + 1]) {\\n            k--;\\n        }\\n        if (k < 0) {\\n            reverse(nums, 0, n - 1);\\n        } else {\\n            while (l > k && nums[l] <= nums[k]) {\\n                l--;\\n            }\\n            swap(nums, k, l);\\n            reverse(nums, k + 1, n - 1);\\n        }\\n    }\\n    \\n    private void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i++, j--);\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        n = len(nums)\\n        k, l = n - 2, n - 1\\n        while k >= 0 and nums[k] >= nums[k + 1]:\\n            k -= 1\\n        if k < 0:\\n            nums.reverse()\\n        else:\\n            while l > k and nums[l] <= nums[k]:\\n                l -= 1\\n            nums[k], nums[l] = nums[l], nums[k]\\n            nums[k + 1:n] = reversed(nums[k + 1:n])\\n\\n```\n```\\nvar nextPermutation = function(nums) {\\n    let n = nums.length;\\n    let k, l;\\n    for (k = n - 2; k >= 0; k--) {\\n        if (nums[k] < nums[k + 1]) {\\n            break;\\n        }\\n    }\\n    if (k < 0) {\\n        nums.reverse();\\n    } else {\\n        for (l = n - 1; l > k; l--) {\\n            if (nums[l] > nums[k]) {\\n                break;\\n            }\\n        }\\n        [nums[k], nums[l]] = [nums[l], nums[k]];\\n        nums.splice(k + 1, n - k - 1, ...nums.slice(k + 1).reverse());\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163376,
                "title": "python-c-easy-to-understand-no-recursion",
                "content": "# Approach\\n- From the right end of our list, we first discover the first decreasing element here.\\nThe next part is only a little bit bigger than the one we discovered from the right end.\\n- Next, switch the elements.\\n- And the reverse end of it.\\n\\nPlease do check it out because it is easier to understand after seeing the code.\\nIf you find it understandable, please give Heartly an upvote.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code :\\n### Python\\n```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\\n### C++\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, s: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # s = list(s)\\n        i = len(s) - 2\\n        while i >= 0 and s[i + 1] <= s[i]:\\n            i -= 1\\n\\n        if i >= 0:\\n            j = len(s) - 1\\n            while s[j] <= s[i]:\\n                j -= 1\\n            (s[i], s[j]) = (s[j], s[i])\\n\\n        s[::] = s[:i + 1] + s[i + 1:][::-1]\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-2;\\n        while(i>=0 && nums[i+1]<=nums[i]){\\n            i--;\\n        }\\n        if(i>=0){\\n            int j=nums.size()-1;\\n            while(nums[j]<=nums[i]){\\n                j--;\\n            }\\n            swap(nums , i ,j);\\n        }\\n        reverse(nums.begin()+i+1,nums.end());\\n    }\\n    void swap(vector<int> &nums , int i,int j){\\n        nums[i]^=nums[j];\\n        nums[j]^=nums[i];\\n        nums[i]^=nums[j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 804608,
                "title": "python-simple-solution-explained-code-video",
                "content": "https://www.youtube.com/watch?v=4wlBBRo4tYY\\n[](https://www.youtube.com/watch?v=4wlBBRo4tYY)\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        if length <= 2:\\n            return nums.reverse()\\n        pointer = length - 2\\n        \\n        while pointer >= 0 and nums[pointer] >= nums[pointer + 1]:\\n            pointer -= 1\\n        \\n        if pointer == -1:\\n            return nums.reverse()\\n        \\n        for x in range(length - 1, pointer, -1):\\n            if nums[pointer] < nums[x]:\\n                nums[pointer], nums[x] = nums[x], nums[pointer]\\n                break\\n        \\n        nums[pointer + 1:] = reversed(nums[pointer + 1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213704,
                "title": "rust",
                "content": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfn next_permutation(nums: &mut [i32]) {\\n    if let Some(i) = (1..nums.len()).rev().find(|&i| nums[i - 1] < nums[i]) {\\n        let j = (i..nums.len()).rev().find(|&j| nums[i - 1] < nums[j]).unwrap();\\n        nums.swap(i - 1, j);\\n        nums[i..].reverse();\\n    } else {\\n        nums.reverse();\\n    };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2228834,
                "title": "one-liner",
                "content": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "// C++\\n\\t\\n\\t\\n\\tvoid nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1908665,
                "title": "python-easy-nlogn-solution",
                "content": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "Steps I followed:\\n\\t1. Find the **latest peak** in the array *(A peak is an element that is greater that the previous element in the array)*\\n\\t\\t\\t2. If a peak is not found: it means it is in reverse order we just need to revert the array\\n\\t3. If a peak is found: it means we can rearrange the array and build a next permutation\\n\\t\\t4. Iterate from the **latest peak** to the end of the array and find the min value in that subarray that is **greater** than the previous of the latest peak! This because we want to build the next greater permutation\\n\\t\\t5. Swap the min value after the peak and the element previous the peak\\n\\t\\t6. Sort the array from the latest_peak to the end of the array\\n\\nTime complexity = O(nlogn)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        latest_peak = 0\\n        for i in range(1, len(nums)):\\n            if nums[i] > nums[i - 1]:\\n                latest_peak = i\\n                \\n        if latest_peak == 0:\\n            nums.reverse()\\n            return\\n        \\n        pre_peak = latest_peak - 1\\n        min_after_peak = latest_peak\\n        for i in range(latest_peak, len(nums)):\\n            if nums[i] > nums[pre_peak] and nums[i] < nums[min_after_peak]:\\n                min_after_peak = i\\n          \\n        temp = nums[pre_peak]\\n        nums[pre_peak] = nums[min_after_peak]\\n        nums[min_after_peak] = temp\\n        \\n        nums[latest_peak:] = sorted(nums[latest_peak:])\\n",
                "codeTag": "Java"
            },
            {
                "id": 1687454,
                "title": "easy-to-understand-with-comments-c-o-n",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }\\n        \\n        if(k < 0) //edge case\\n            reverse(nums.begin(), nums.end());\\n        else\\n        {\\n            for(l=n-1; l>k; l--) //step 2\\n            {\\n                if(nums[l] > nums[k])\\n                    break;\\n            }\\n            \\n            swap(nums[k], nums[l]); //step 3\\n        \\n            reverse(nums.begin() + k + 1, nums.end()); //step 4\\n        }              \\n\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        /*Step and intituitions to be followed:\\n        \\n        Step 1: Find a break point from last where a single element is not in incresing order \\n            i.e, ar[i] < ar[i+1] and keep that index such as ind1\\n        \\n        Step 2: Find again from last that which element is just greater than ind1 \\n            as to follow the dictionary order to place bigger element than ind1 and name ind2\\n            \\n        Step 3: Swap ar[ind1] and ar[ind2]\\n            \\n        Step 4: Reverse from the next elemnt of ind1 i.e, ind1 + 1 to last of the array\\n            \\n        Edge Case: If the array is already increasing order from the last then just reverse it. */\\n        \\n        int n = nums.size();\\n        int k; //to find break point\\n        int l; // to traverse from last and find the greater element han break point\\n        \\n        for(k=n-2; k>=0; k--) //step 1\\n        {\\n            if(nums[k] < nums[k+1])\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 557285,
                "title": "what-does-this-problem-mean",
                "content": "I\\'m having trouble understanding what this problem is asking. \\n\\nDoes\\n```\\n[1,2,3] -> [1,3,2]\\n```\\nbecause 3 comes after 2 lexographically?\\n\\nI put in my own example\\n```\\n[2,3,1] -> [3,1,2]\\n```\\n\\nWhy is [3,1,2] the output? a valid permutation is `[2,1,3]` but because this is not lexographically greater than `[2,3,1]` is that why `[3,1,2]` is the answer? Why isn\\'t `[3,2,1]` the lexographically next greater permutation?\\n\\n",
                "solutionTags": [],
                "code": "```\\n[1,2,3] -> [1,3,2]\\n```\n```\\n[2,3,1] -> [3,1,2]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 162049,
                "title": "explanations-java-python",
                "content": "**Thought**\\n* How do we catch the next bigger given current sequence?\\nWe \\u201Cincrease\\u201D the current sequence as little as possible. \\n* Which element should we modify?\\n**The element to the left of the longest suffix that is non-increasing** (becase this suffix is already the biggest so we cannot make a bigger permutation just by modifying it). We call it the `fisrtInc`. \\n* Since `fisrtInc` can only be modified by swapping with another element, which element should it be swapped with? \\n**The smallest element in the suffix that is greater than the fisrtInc** (then the prefix is minimized).\\n* Since we increased the prefix, we want to make the new suffix as low as possible. How ?\\n**We sort the suffix in non-decreasing order**. In fact, we can avoid sorting and simply reverse the suffix, because the replaced element respects the decreasing order.\\n\\n**Java**\\n```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```\\n\\n**I appreciate your VOTE UP \\u2727\\u207A\\u2E1C(\\u25CF\\u02D9\\u25BE\\u02D9\\u25CF)\\u2E1D\\u207A\\u2727**",
                "solutionTags": [],
                "code": "```\\n    public void nextPermutation(int[] nums) {\\n        \\n        int n = nums.length;\\n        int firstInc = n - 2; // The first index which is smaller than its next element.\\n        \\n        while (firstInc >= 0 && nums[firstInc] >= nums[firstInc + 1]) {\\n            firstInc--;\\n        }\\n        \\n        if (firstInc != -1) { // firstInc == -1 if nums is decreasing.\\n            for (int i = n - 1; i > firstInc; i--)\\n                if (nums[i] > nums[firstInc]) {\\n                    swap(nums, firstInc, i);  \\n                    break;\\n                }\\n        }\\n\\n        reverse(nums, firstInc + 1, n - 1);           \\n    }\\n    \\n    private void reverse(int[] nums, int start, int end) {\\n        while (start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int i, int j) {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n```\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"      \\n        first_inc = len(nums) - 2\\n        \\n        while first_inc >= 0 and nums[first_inc] >= nums[first_inc + 1]:\\n            first_inc -= 1\\n    \\n        if first_inc != -1:  # nums is not non-increasing as a whole\\n            for i in range(len(nums) - 1, first_inc, -1):\\n                if nums[i] > nums[first_inc]:\\n                    nums[first_inc], nums[i] = nums[i], nums[first_inc]\\n                    break\\n    \\n        nums[first_inc + 1: len(nums)] = nums[first_inc + 1: len(nums)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14013,
                "title": "my-12ms-c-solution-only-15lines",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }\\n            sort(nums.begin() + index,nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int index = 0,swapindex = 0;\\n            for (int i = 1; i < nums.size(); i++)\\n                if  (nums[i - 1] < nums[i])\\n                    index = i;\\n            if (index > 0){\\n                int i = nums.size() - 1;\\n                while (i > (index - 1) && nums[index-1] >= nums[i]) i--;\\n                swap(nums[index - 1],nums[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 14030,
                "title": "simple-java-solution-for-your-reference",
                "content": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void nextPermutation(int[] num) {\\n        for(int i = num.length-1; i > 0; i--) {\\n            if(num[i-1] < num[i]) {\\n                Arrays.sort(num, i, num.length);\\n                for(int j = i; j < num.length; j++) {\\n                    if(num[j] > num[i-1]) {\\n                       // swap num[i-1] and num[j]\\n                        num[i-1] = num[i-1] + num[j];\\n                        num[j] = num[i-1] - num[j];\\n                        num[i-1] = num[i-1] - num[j];\\n                        return;\\n                    }\\n                }\\n            }\\n        }\\n        Arrays.sort(num);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 14111,
                "title": "share-my-python-code-and-explain-how-to-get-the-solution",
                "content": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "solutionTags": [
                    "Python"
                ],
                "code": "It's not easy to find a rule for this question. \\n\\nAnd I think the example is not good.\\n\\nExamples here:\\n\\n1243\\n=> 12 43 (2 is the first num who is less than the next), and the num split to two parts, left: [1,2], right: [4,3]\\n\\n=> 13 42 (swap 2 with 3, because 3 is the first num greater than 2).\\n\\n=> 13 24 sort right. 13, 42 sorted to 24.\\n\\n=> 1324 merge left, right.\\n\\nAnother more complex example:\\n1342\\n=>13 42 split to left: 13  right: 42 (3 is the first num less than next);\\n\\n=>14 32 swap 3 and 4, because in the right part, 4 is the first num greater than 3, from right ->left scan.\\n\\n=>14 23 sort right part,  (**That's why we need to sort the right part**).\\n\\n=>1423 merge them \\n\\n\\n    class Solution:\\n    # @param num, a list of integer\\n    # @return a list of integer\\n    def nextPermutation(self, num):\\n        if(len(num)<=1):return num;\\n        else:\\n            splitIdx=-1;\\n            for i in range(len(num)-2,-1,-1):\\n                if(num[i]<num[i+1]):\\n                    splitIdx=i;\\n                    break;\\n            replaceIdx=len(num)-1;\\n            while(replaceIdx > splitIdx):\\n                if(num[replaceIdx]>num[splitIdx]):\\n                    break;\\n                replaceIdx-=1;\\n\\n            num[replaceIdx],num[splitIdx]=num[splitIdx],num[replaceIdx];\\n            \\n            right=num[splitIdx+1:];\\n            right=sorted(right);            \\n            return num[0:splitIdx+1]+right;",
                "codeTag": "Java"
            },
            {
                "id": 3797205,
                "title": "next-permutation-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/f0f088c6-8c8a-47ce-9461-10000fbb3af4_1689949086.1759074.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483577,
                "title": "o-n-time-and-o-1-space-easiest-beginner-friendly-solution",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem :\\n```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\\n1. *Find the first element from the right that is smaller than its adjacent element. This is the first element that can be swapped with a larger element to its right to create a greater permutation.*\\n    - int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n2. *If such an element is found, find the smallest element to the right of it that is larger than it.*\\n    - int j = n - 1;\\n        while (j >= 0 && nums[i] >= nums[j]) {\\n            j--;\\n        }\\n3. *Swap these two elements.*\\n    - swap(nums[i], nums[j]); \\n4. *Reverse the subarray to the right of the swapped element. This is because the elements to the right of the swapped element are in descending order, and reversing them creates the smallest possible permutation that is greater than the original one.*\\n    - reverse(nums.begin() + i + 1, nums.end()); \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(n)**, where n is the length of the input vector nums. This is because we traverse the vector from right to left at most once to find the first element that is smaller than its adjacent element and from right to left again to find the smallest element to the right of the element we found in the previous step. Then we reverse the subarray to the right of the swapped element in O(n/2) time. Therefore, the total time complexity is **O(n) + O(n) + O(n/2) = O(n)**.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)**. We use constant extra space throughout the algorithm.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\narr : [2,5,8,4,7,6,3] -> nextPermutation : [2,5,8,6,3,4,7]\\n\\n1. In below image arr[i] and arr[i+1] = 4 and 7. so, i = 3.\\n2. In below image arr[i] and arr[j] = 4 and 6. So, j = 5.\\n3. swap arr[i] and arr[j]. So, our new array will be [2,5,8,6,7,4,3]\\n4. reverse i+1 to n-1. So, our final array will be [2,5,8,6,3,4,7] which is the next permutaion of given array \\n\\n**NOTE : THE ABOVE 4 STEPS IS SAME AS BELOW EXPLAINED APPROACH.**\\n                             8\\n                            / \\\\\\n                           /   \\\\       7\\n                          /     \\\\     / \\\\\\n                         /       \\\\   /   6\\n                        5         \\\\ /     \\\\\\n                       /           4       \\\\\\n                      /                     \\\\\\n                     /                       3\\n                    /\\n                   2\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        \\n        // Find the first element from the right that is smaller(nums[i]) than its adjacent(nums[i+1]) element\\n        int i = n - 2;\\n        while (i >= 0 && nums[i] >= nums[i+1]) {\\n            i--;\\n        }\\n        \\n        // If such an element(nums[i]) is found, find the smallest element(nums[j]) to the right of it(nums[i]) that is just larger than it(nums[i]).\\n        if (i >= 0) {\\n            int j = n - 1;\\n            while (j >= 0 && nums[i] >= nums[j]) {\\n                j--;\\n            }\\n            // Swap the two elements\\n            swap(nums[i], nums[j]);\\n        }\\n        \\n        // Reverse the subarray to the right of the swapped element\\n        reverse(nums.begin() + i + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3269908,
                "title": "shortest-2-pointer-5-lines-compact-solution-c-easy-explained",
                "content": "# Intuition\\nEvery lexicographic sequence has increasing order. We aim to get a peak from where the increasing sequence starts.\\n\\n# Approach\\n1. From the right, find an element (i) which is greater than its previous element (i-1).\\n2. If no such number is found, it means that array is in highest possible order. So return the reverse of the array (To rearrange it in lowest possible order).\\n3. Now from the right, find an element (j) which is greater than (i-1).\\n4. Swap (i-1) and (j).\\n5. Reverse the array after (i-1), i.e. From (i) till end. (Here we are resetting the number after finding the peak).\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```\\n---\\n---\\n![3bjfi3.jpg](https://assets.leetcode.com/users/images/615d7731-d013-4da8-9502-8af799911cc5_1678215934.355254.jpeg)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i=nums.size()-1,j=nums.size()-1;\\n        while(i && nums[i-1]>=nums[i]) i--;\\n        if(!i) return reverse(nums.begin(),nums.end());\\n        while(nums[i-1]>=nums[j]) j--;\\n        swap(nums[i-1],nums[j]);\\n        return reverse(nums.begin()+i,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731188,
                "title": "next-permutation-very-easy-to-understand-much-better-in-terms-of-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) \\n    {\\n        \\n    int k=0;\\n    int l=0;\\n        \\n    int n=v.size();\\n        \\n    for(k=n-2;k>=0;k--)\\n    {\\n        if(v[k+1]>v[k])\\n        {\\n            break;\\n        }\\n    }\\n    \\n    if(k<=-1)\\n    {\\n        reverse(v.begin(),v.end());\\n    }\\n    else if(k>=0)\\n    {\\n        \\n        for(l=n-1;l>=0;l--)\\n        {\\n            if(v[l]>v[k])\\n            {\\n                break;\\n            }\\n        }\\n        \\n        swap(v[l],v[k]);\\n        \\n        reverse(v.begin()+k+1,v.end());\\n    }\\n        \\n        \\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908381,
                "title": "next-permutation-easy-solution-java",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n      if(nums == null || nums.length <= 1) return;\\n      int i = nums.length - 2;\\n      while(i >= 0 && nums[i] >= nums[i + 1]) i--; \\n      if(i >= 0) {                          \\n        int j = nums.length - 1;           \\n        while(nums[j] <= nums[i]) j--;           \\n        swap(nums, i, j);                     \\n    }\\n    reverse(nums, i + 1, nums.length - 1);       \\n}\\n\\npublic void swap(int[] nums, int i, int j) {\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n\\npublic void reverse(int[] nums, int i, int j) {\\n    while(i < j) \\n      swap(nums, i++, j--);\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1887933,
                "title": "python-simple-intutive-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \"\"\"\\n            Since we have to find the next greater permutation of array, we can think greedly by modifying only that part of array which will contribute in detemining the next greater permutation.\\n            Now, to determine the contributing sub-array, consider the below examples:\\n                - [1,2,3,4,5] -(next greater permutation)> [1,2,3,5,4]\\n                - [1,2,5,3,4] -(next greater permutation)> [1,2,5,4,3]\\n                - [1,2,4,3,5] -(next greater permutation)> [1,2,4,5,3]\\n                - [1,2,4,5,3] -(next greater permutation)> [1,2,5,4,3]->[1,2,5,3,4]\\n                - [1,3,5,4,2] -(next greater permutation)> [1,4,5,3,2]->[1,4,2,3,5]\\n                - [5,4,3,2,1] -(next greater permutation)> [1,2,3,4,5]\\n            From the above examples, we can see that if we traverse from end and check for the index(from right) from where the elements are not in descending order-\\n                - If found, it means that this index needs to be updated with the firs greater element from right to get any greater permutation.\\n\\t\\t\\t\\t\\t-  To get the NEXT GREATER PERMUTATION we can reverse the array from next index to end as they were in descending order and by reversing, they will be in ascending order and that would be our next greater permutation.\\n                - Else, Complete array is in descending order so just make it into ascending by reversing it.\\n        \"\"\"\\n        # Check for the index from right from where the array doesn\\'t follows the descending order.\\n        i = len(nums)-2\\n        while i >= 0 and nums[i+1] <= nums[i]:\\n            i -= 1\\n        \\n        # If any such index is found then swap its value with the first greater element from right.\\n        if i >= 0:\\n            j = len(nums)-1\\n            while j >= 0 and nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        \\n        # Reverse the further array items\\n        i += 1\\n        j = len(nums)-1\\n        while i < j:\\n            nums[i], nums[j] = nums[j], nums[i]\\n            i += 1\\n            j -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3836471,
                "title": "2-solutions-with-stl-beats-100-non-stl-solution",
                "content": "# STL Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int idx = -1;\\n        int n = nums.size();\\n\\n        for(int i = n-2;i >= 0;i--){\\n            if(nums[i] < nums[i+1]){\\n                idx = i;\\n                break;\\n            }\\n        }\\n\\n        if(idx == -1){\\n            reverse(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        for(int i = n-1;i >= 0;i--){\\n            if(nums[i] > nums[idx]){\\n                swap(nums[i], nums[idx]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + idx + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597823,
                "title": "o-n-solution-intuitive-and-easy-explaination",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTreating the array as real number for example [1,2,3] read as 123, the next permutation or the next greater  number that can be formed using these digits is 132 [1,3,2] is thus the next permutation.One thing to observe is that when we move from right to left as soon as we encounter a smaller number we think of swapping it with its just greater number because  we need a number just greater than the given number so using this observation we can loop in reverse order and find a number that is less than the current digit .On the contrary if we get a number greater than the current number then using the digits we cannot form a greater number so we are in search of a smaller number.As soon as it is found we break out from the loop. We then find a just greater number in the right half(already traversed part of the array just now) and swap the dip element with it. As we know if we swap a number greater than the dip element we need the other numbers to be in sorted order in th right half so that the number formed is just greater as the array was already sorted in descending order we just reverse it to get the increasing order.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j,n=nums.size();\\n       for(i=n-2;i>=0;i--)\\n       {\\n           if(nums[i]<nums[i+1])\\n                break;\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n       }\\n       else\\n       {\\n            for(j=n-1;j>=i;j--)\\n            {\\n                if(nums[j]>nums[i])\\n                    break;\\n            }\\n           swap(nums[i],nums[j]);\\n           reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084401,
                "title": "priority-queue-c-easy-to-understand",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n*log(n))$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n**First Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\\n**Second Approach**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), element;\\n        if(n==1){\\n            return;\\n        }\\n        int index=-1;\\n        priority_queue<int> pq;\\n        for(int i=n-1; i>=0; i--){\\n            pq.push(nums[i]);\\n            if(pq.top()!= nums[i]){\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        int check, k = n-1;\\n        bool flag = true;\\n        element = nums[index];\\n        while (!pq.empty()) {\\n            if(pq.top() == element && flag){\\n                check = k+1;\\n                flag = false;\\n            }\\n            nums[k] = pq.top();\\n            pq.pop();\\n            k--;\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        if(n==1){\\n            return;\\n        }\\n\\n        int index=-1,element,check;\\n        for(int i=n-1; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                index = i-1;\\n                element = nums[i-1];\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        sort(nums.begin() + index, nums.end());\\n        \\n        for(int i=n-1; i>=index; i--){\\n            if(nums[i] == element){\\n                check = i+1;\\n                break;\\n            }\\n        }\\n        \\n        reverse(nums.begin() + index, nums.begin() + check);\\n        reverse(nums.begin() + index, nums.begin() + check+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075088,
                "title": "javascript-very-very-easy-to-understand-solution",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/Lhsz3BSJEKY\\n\\n# Code\\n```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let swap = (l,r) =>{\\n        [nums[l],nums[r]] = [nums[r],nums[l]]\\n    }\\n    let reverse = (left) =>{\\n        let right = nums.length-1;\\n        while(left<right){\\n            swap(left,right)\\n            left++\\n            right--\\n        }\\n    }\\n\\n    for(let i = nums.length-2; i>=0; i--){\\n        for(let j = nums.length-1; j>i; j--){\\n            if(nums[j] >nums[i]){\\n                swap(i,j);\\n                reverse(i+1)\\n                return;\\n            }\\n        }\\n    }\\n    reverse(0)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1910550,
                "title": "concise-in-place-solution-with-no-backtracking",
                "content": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic void NextPermutation(int[] arr)\\n{\\n    int i = arr.Length - 2;\\n    while (i >= 0 && arr[i] >= arr[i + 1]) i--;\\n\\n    if (i >= 0)\\n    {\\n        int j = arr.Length - 1;\\n        while (arr[i] >= arr[j]) j--;\\n        (arr[i], arr[j]) = (arr[j], arr[i]);\\n    }\\n    \\n\\tarr.AsSpan(i + 1, arr.Length - i - 1).Reverse();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1909231,
                "title": "c-1ms-algorithm-explaination",
                "content": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n// Algorithm\\n//  1. find index i that arr[i] < arr[i+1] from end-1 to start of array.\\n//  2. Search for index j that arr[j] > arr[i] from back to start.\\n//  3. Swap (arr[i] > arr[j]).\\n//  4. Reverse Array from index i+1 to End of Array.\\n//  5. In Case we can not find i that means it is a Sorted Array(decreasing) , We have simply reverse Array.\\nclass Solution\\n{\\npublic:\\n    void nextPermutation(vector<int> &arr)\\n    {\\n        int firstIndex = INT_MAX;\\n        for (int i = arr.size() - 2; i >= 0; i--)\\n        {\\n            if (arr[i] < arr[i + 1])\\n            {\\n                firstIndex = i;\\n                break;\\n            }\\n        }\\n        if (firstIndex == INT_MAX)\\n        {\\n            reverse(arr.begin(), arr.end());\\n        }\\n        else\\n        {\\n            int highIndex = INT_MAX;\\n            for (int i = arr.size() - 1; i >= 0; i--)\\n            {\\n                if (arr[i] > arr[firstIndex])\\n                {\\n                    highIndex = i;\\n                    break;\\n                }\\n            }\\n            swap(arr[highIndex], arr[firstIndex]);\\n            reverse(arr.begin() + firstIndex + 1, arr.end());\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1723652,
                "title": "easiest-explanatation-guarantee-with-intuition-c",
                "content": "***Easiest Explanatation Guarantee***\\n\\nSo I will give the algorithm first, then what the algorithm does, and then the intuition\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```\\n\\n\\nYou can find this algorithm in the all over the discussion section, but here you will find the intuition\\n\\nSee, We convert a permutation into greater lexicographical order by converting the last part into largest lexicographical order\\nFor eg 1 2 4 3 5\\nWe will not change 1 2 till we convert 4 3 5 into the largest order ie 5 4 3 , then only we can change 1 2\\n\\nSo the first step is to find the string from the back which is already in the largest lexicographical order \\nWe do this by finding index1 from the back as all elements after index1 will be in largest lexicographical order.\\neg 1 2 5 4 3 , we will find index1 to be 1 (nums[index1]=2),\\n\\nIn second step we will find element greater than nums[index] to replace it with.\\nIn example we now need to change 2, that is why we start from end because we know the string 5 4 3 will be in descending order\\nWe will find index2 to be 4(nums[index2]=3)\\n\\nAfter that we swap nums[index1] with nums[index2] \\nSo order becomes 1 3 5 4 2 , \\nThen we reverse the 5 4 2 string so as to convert it into smallest order\\n\\nSo order becomes 1 3 2 4 5 \\n\\nPlease do upvote if you find it helpful\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index1=-1,index2=-1;\\n        for(int i=nums.size()-1;i>0;i--) {\\n            if(nums[i]>nums[i-1]) {\\n                index1=i-1;\\n                break;\\n            }\\n            \\n        }\\n        if(index1!=-1) {\\n            for(int i=nums.size()-1;i>0;i--) {\\n                if(nums[i]>nums[index1]) {\\n                    index2=i;\\n                    break;\\n                }\\n            }\\n            //swap\\n            swap(nums[index1],nums[index2]);\\n            \\n            \\n        }\\n        reverse(nums.begin()+index1 + 1,nums.end());\\nreturn ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864025,
                "title": "simple-c-solution-with-explanation-beats-94",
                "content": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/* The simple intution to solve this problem is to find the index which will get swaped.\\nNow if we dont find any index, that means that the vector is in descending order and \\nhence we must sort it in ascending order and return. Now the simple logic to find the \\nswap index is that it is the number which breaks the ascending order sequence from the right (nums[i-1] < nums[i]) .\\nEx:- 2543, so here 543 is in ascending order from right and 2 breaks the sequence. So 0 will be the swap index. \\nNow to get the next permutation and not any permutation, we must swap the index found previously\\nwith the first element which is greater than the nums[index]. Now we swap the \\ntwo elements. So our swap index now contains an element which is greater than what\\nit had earlier. So now to have the next permutation, we must sort all the elements to its\\nright in ascending order as it will become the minimum possible value that could have\\nbeen formed by replacing the swap index with some value greater than it. \\n\\t\\t\\t\\n\\t\\t\\t\\tPlease upvote, if you find the solution helpful. \\n*/\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        for(int i = nums.size()-1; i>=1; i--)\\n        {\\n            if(nums[i-1] < nums[i])\\n            {\\n                index = i-1;\\n                break;\\n            }\\n        }\\n        \\n        if(index == -1)\\n        {\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        for(int i = nums.size()-1; i>index; i--)\\n        {\\n            if(nums[i] > nums[index])\\n            {\\n                swap(nums[i], nums[index]);\\n                sort(nums.begin()+index+1, nums.end());\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 615545,
                "title": "easy-python-solution-o-n-time-w-comments",
                "content": "**notes/assumptions:**\\n- modify in place, no outputs\\n- inputs: list of integers \\n- space: O(1)\\n- no negative integers\\n\\n**approach:**\\n- iterate through nums in reverse order until I find my first decreasing element\\n\\t- if the num @ current index > the num @ previous index \\n\\t\\t- break out of the loop\\n\\n- if index == 0 --> return the reverse of the loop \\n\\n- iterate through nums to find the index of the next element greater than my first decreasing element\\n\\t- swap the elements\\n\\t- reverse the rest of the nums from index of my decreasing element onwards\\n\\n\\n**complexity:**\\n- time: O(n) - we iterate through at most len of nums elements\\n- space: O(1) - modify in place and only use variables to store index\\n\\n\\n``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "``` python\\nclass Solution(object):\\n\\tdef nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n\\t\\t# helper function to reverse the array from particular index\\n        def reverse_from_index(arr, start_idx, end_idx):\\n            while start_idx < end_idx:\\n                arr[start_idx], arr[end_idx] = arr[end_idx], arr[start_idx]\\n                start_idx += 1\\n                end_idx -= 1\\n            \\n        # find the first decreasing element\\n        first_decreasing_index = len(nums) - 1\\n        while first_decreasing_index > 0 and nums[first_decreasing_index] <= nums[first_decreasing_index - 1]:\\n            first_decreasing_index -= 1\\n\\n        # reverse nums because nums is in descending order and return \\n        if first_decreasing_index == 0:\\n            reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n            return\\n\\n        # find the next element greater than the first decreasing element\\n        next_num_index = len(nums) - 1\\n        while next_num_index > 0 and nums[next_num_index] <= nums[first_decreasing_index - 1]: \\n            next_num_index -= 1\\n\\n        # swap the two elements\\n        nums[first_decreasing_index - 1], nums[next_num_index] = nums[next_num_index], nums[first_decreasing_index - 1]\\n\\n        # reverse the rest of the list\\n        reverse_from_index(nums, first_decreasing_index, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561996,
                "title": "java-clean-code-time-o-n-space-o-1",
                "content": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        if (n == 0) return;\\n        int i = n - 2;\\n        while (i >= 0 && arr[i] >= arr[i+1]) i--; // Find first min point from the right\\n        if (i == -1) {\\n            reverse(arr, 0, n - 1);\\n        } else {\\n            int nextGreaterIndex = i;\\n            for (int j = i + 1; j < n; j++) {\\n                if (arr[j] > arr[i])\\n                    nextGreaterIndex = j;\\n            }\\n            swap(arr, i, nextGreaterIndex);\\n            reverse(arr, i + 1, n - 1);\\n        }\\n    }\\n    void swap(int[] arr, int i, int j) {\\n        int tmp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tmp;\\n    }\\n    void reverse(int[] arr, int l, int r) {\\n        while (l < r) swap(arr, l++, r--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248070,
                "title": "java-solution",
                "content": "**Solution 1:**\\n\\n**Intuition:**\\n- A permutation is a rearrangement of the members of the sequence into a new sequence. For example, there are `24` permutations of `[a, b, c, d]`; some of these are \\n`[b, a, d, c]`, `[d, a, b, c]`, and `[a, d, b, c]`.\\n- There exists `n!` permutations of `n` elements. These can totally ordered using the dictionary ordering. We define permutation `p` to appear before `q` if in the first place where `p` and `q` differ in their array representations, the corresponding entry for `p` is less than that for `q`.\\nFor example, `[2, 0, 1] < [2, 1, 0]`. Note that permutation `[0, 1, 2]` is the smallest permutation under dictionary ordering, and `[2, 1, 0]` is the largest permutation under dictionary ordering.\\n- Here the algorithm takes a permutation as an input and returns the next permutation under dictionary ordering. \\nFor example, if the input is `[1, 0, 3 ,2]`, then we return `[1, 2, 0, 3]`.\\n- If the input permutation is the last permutation, then we return the first permutation. \\nFor example, if the input is `[4, 3, 2 ,1]`, then we return `[1, 2, 3, 4]`.\\n---------------------\\n- The key insight is that we want to increase the permutation by as little as possible. Here we can not change the values, only reorder them. We will use input permutation \\n`[6, 2, 1, 5, 4, 3, 0]`.\\n- Specifically, we start from the right, and look at the longest decreasing `suffix`, which is `[5, 4, 3, 0]` for our example. We can not get the next permutation just by modifying this `suffix`, since it is already the maximum it can be.\\n- Instead we look at the entry `e` that appears just before the longest decreasing `suffix`, which is `1` in this case. \\n- If there is no such element, i.e., the longest decreasing `suffix` is the entire input permutation, for which the next permutation is the first permutation. In this case we return reverse of input permutation.\\n- Observe that `e` must be less than some entries in `suffix`, since the entry immediately after `e` is greater than `e`. Intuitively, we should swap `e` with the smallest entry `s` in the `suffix` which is larger than `e` so as to minimize the change to the `prefix`, which is defined to the part of the sequence that appears before the `suffix`.\\nFor example, here `e = 1` and `s = 3` Swapping `s` and `e` results in `[6, 2, 3, 5, 4, 1, 0]`.\\n- We are not done yet, since the new `prefix` is the smallest possible for all permutations greater than the initial permutation, but the new `suffix` may not be the smallest. We can get the smallest `suffix` by sorting the entries in the `suffix` from the smallest to largest. For our working example, this yields the `suffix` `[0, 1, 4, 5]`.\\n- As an optimization, it is not necessary to call the full blown sorting algorithm on `suffix`. Since the `suffix` was initially decreasing, and after replacing `s` by `e` it still remains decreasing, reversing the `suffix` has the effect of sorting it from smallest to largest.\\n---------------------\\n\\n**Algorithm:**\\n1. Find the largest index `i` such that `A[i] < A[i + 1]`. If no such index exists, just reverse `A` and done.\\n2. Find the largest index `j` such that `j > i` and `A[i] < A[j]`.\\n3. Swap `A[i]` and `A[j]`.\\n4. Reverse the sequence after position `i`. i.e. the sub-array `A[i + 1, n]`.\\n\\n- For example, given the sequence `[1, 2, 3, 4]`, which is in increasing order, and given that the index is zero-based, the steps are as follows:\\n  1. Index `i = 2`, because `3` is placed at an index that satisfies condition of being the largest index that is still less than `A[i + 1]` which is `4`.\\n  2. Index `j = 3`, because `4` is the only value in the sequence that is greater than `3` in order to satisfy the condition `A[i] < A[j]`.\\n  3. The values of `A[2]` and `A[3]` are swapped to form the new sequence `[1, 2, 4, 3]`.\\n  4. The sequence after `i` index, i.e. `A[2]` to the final element is reversed. Because only one value lies after this index (the `3`), the sequence remains unchanged in this instance. Thus the lexicographic successor of the initial state is permuted as: `[1, 2, 4, 3]`.\\n\\n- Following this algorithm, the next lexicographic permutation will be `[1, 3, 2, 4]`, and the `24`<sup>th</sup> permutation will be `[4, 3, 2, 1]` at which point `A[i] < A[i + 1]` does not exist, indicating that this is the last permutation.\\n\\n**Time complexity:** `O(N)`\\n**Space complexity:** `O(1)`\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        int N = A.length;\\n        int i;\\n        int j;\\n\\n        for (i = N - 2; i >= 0; i--) {\\n            if (A[i] < A[i + 1])\\n                break;\\n        }\\n\\n        if (i >= 0) {\\n            for (j = N - 1; j > i; j--) {\\n                if (A[i] < A[j])\\n                    break;\\n            }\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, N - 1);\\n    }\\n\\n    private void reverse(int[] A, int start, int end) {\\n        while (start < end) {\\n            swap(A, start++, end--);\\n        }\\n    }\\n\\n    private void swap(int[] A, int i, int j) {\\n        int temp = A[i];\\n        A[i] = A[j];\\n        A[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795248,
                "title": "really-simple-solution-everyone-can-understand-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAlgorithm / Intuition\\nThe steps are the following:\\n\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\nNote: For a better understanding of intuition, please watch the video at the bottom of the page.\\n\\n# Dry run\\n<!-- Describe your approach to solving the problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a7afeec0-e1c6-4065-a964-f204b2c3cd31_1689915729.846143.png)\\n![image.png](https://assets.leetcode.com/users/images/6ec6a3e9-da9b-42f5-ab15-8e8fac596a35_1689915741.7086728.png)\\n![image.png](https://assets.leetcode.com/users/images/dbbca798-e59f-45c5-86d9-d683129646ac_1689915753.1975505.png)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime Complexity: O(3N), where N = size of the given array\\nFinding the break-point, finding the next greater element, and reversal at the end takes O(N) for each, where N is the number of elements in the input array. This sums up to 3*O(N) which is approximately O(3N).\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity: Since no extra storage is required. Thus, its space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        int n = arr.length;\\n        int ind = -1;\\n        // for finding the break point\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (arr[i] < arr[i + 1]) {\\n                ind = i;\\n                break;\\n            }\\n        }\\n        // if the break point does not exist\\n        if (ind == -1) {\\n            reverse(arr, 0, n - 1);\\n            return;\\n        }\\n        // if the break point exists\\n        int j = n - 1;\\n        for (int i = n - 1; i >= ind + 1; i--) {\\n            if (arr[i] > arr[ind]) {\\n                swap(arr, i, ind);\\n                break;\\n            }\\n        }\\n        // Reverse the entire right half array\\n        reverse(arr, ind + 1, n - 1);\\n    }\\n\\n    // Function for reverse the array\\n    public void reverse(int[] arr, int l, int r) {\\n        int start = l;\\n        int end = r;\\n        while (start < end) {\\n            int temp = arr[start];\\n            arr[start] = arr[end];\\n            arr[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n\\n    // Function for swap the elements\\n    public void swap(int[] arr, int i, int j) {\\n        int tem = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = tem;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716085,
                "title": "easy-c-solution-o-n-time-complexity-beats-100-in-both",
                "content": "# Code\\n```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), index = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                index = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=index && index != -1; i--){\\n            if(nums[i] > nums[index]){\\n                swap(nums[i], nums[index]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145361,
                "title": "c-easy-explanation-0ms",
                "content": "**Approach to the Problem**\\n\\nLet\\'s understand the problem with an example.\\n```\\n1 2 3 4 \\n```\\nFirstly, we traverse from the end element i.e, 4. \\nFind the pnt where the element is less than the next element. here it is-> 2 as 2<3\\nCode for above two lines:\\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\\nNow if pnt<0 it means the number is in decreasing order and hence, the next permutation will be the reverse of it.\\ncode for it:\\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\\nElse check by traversing from the last element the number greater than the number at (pnt) if found then swap them.\\nCode for it:\\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\\nNow at the end, reverse the sequence starting after pnt and ending at nums end.\\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\\nfor eg. \\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\\nHere\\'s the whole code \\uD83D\\uDC47\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```\\n**IF You Liked the explanation please Upvote it:)**",
                "solutionTags": [
                    "C++",
                    "Brainteaser"
                ],
                "code": "```\\n1 2 3 4 \\n```\n```\\nfor(pnt=n-2;pnt>=0;pnt--){\\nif(nums[pnt]<nums[pnt+1]\\n  break;\\n}\\n```\n```\\nif(pnt<0)\\n reverse(nums.begin(),nums.end());\\n```\n```\\nelse{\\n  for(l=n-1;l>k;l--){\\n\\t if(nums[l]>nums[k])\\n\\t  break;\\n\\t}\\n\\tswap(nums[l],nums[k]);\\n```\n```\\nreverse(nums.begin()+pnt+1,nums.end());\\n```\n```\\n**1 2 3 4** \\nnext permutation=> **1 2 4 3** => swapped(3,4)\\nnext permutation=> 1 2 4 3 => 1 3 4 2(swapped 2 with 3)=>**1 3 2 4**(reversed the number after 4)\\nnext permutation=>1 3 2 4=> 1 3 4 2(swapped 2 wih 4)\\nnext permutation=>1 3 4 2=>1 4 3 2(swapped 3 with 4)=>**1 4 2 3**(reversed the number after 4)\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     int n=nums.size(),pnt,l;\\n     for(pnt=n-2;pnt>=0;pnt--){\\n         if(nums[pnt]<nums[pnt+1]){\\n             break;\\n         }\\n     }\\n     if(pnt<0){\\n         reverse(nums.begin(),nums.end());\\n     }else{\\n         for(l=n-1;l>pnt;l--){\\n             if(nums[l]>nums[pnt]){\\n                 break;\\n             }\\n         }\\n         swap(nums[l],nums[pnt]);\\n         reverse(nums.begin()+pnt+1,nums.end());\\n     }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117786,
                "title": "easily-understandable-solution-beats-99-30",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       next_permutation(nums.begin() ,nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1716217,
                "title": "python-easy-solution-comments",
                "content": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef nextPermutation(self, nums: List[int]) -> None:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\t# 1st Step...\\n\\t\\t\\ti = n-2\\n\\t\\t\\twhile i >= 0 and nums[i] >= nums[i+1]:\\n\\t\\t\\t\\ti -= 1\\n\\t\\t\\t# ...\\n\\n\\t\\t\\tif i < 0:\\n\\t\\t\\t\\t# It shows that all the elements are in descending order.\\n\\t\\t\\t\\tnums[:] = nums[::-1]\\n\\t\\t\\telse:\\n\\t\\t\\t\\t# 2nd Step...\\n\\t\\t\\t\\tj = n-1\\n\\t\\t\\t\\twhile nums[j] <= nums[i]:\\n\\t\\t\\t\\t\\tj -= 1\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 3rd Step...\\n\\t\\t\\t\\tnums[i], nums[j] = nums[j], nums[i]\\n\\t\\t\\t\\t# ...\\n\\n\\t\\t\\t\\t# 4th Step...\\n\\t\\t\\t\\tnums[i+1:] = sorted(nums[i+1:])\\n\\t\\t\\t\\t# ...\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1577491,
                "title": "java-detailed-explanation-with-diagram-o-n",
                "content": "The key observation in this algorithm is that when we want to compute the next permutation, we must \\u201Cincrease\\u201D the sequence as little as possible. Just like when we count up using numbers, we try to modify the rightmost elements and leave the left side unchanged.\\n\\nTo find next lexicographically greater permutation of numbers, follow following steps\\n1. Find the index (starting from right ending to left) which breaks the increasing order (nums[index - 1] < nums[index])\\n2. Find the FIRST number starting from right which is GREATER than the number we found at \\'index - 1\\' in step 1\\n3. After the swap, reverse the sequence which is RIGHT of \\'index - 1\\'\\n\\n![image](https://assets.leetcode.com/users/images/74a765af-58c3-4c4d-b284-39190c084e96_1636878412.2445583.png)\\n\\n\\nSource of diagram (good read) : https://www.nayuki.io/page/next-lexicographical-permutation-algorithm\\n\\nTC: O(N) -> all increasing order (worst case)\\nSC: O(1)\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int index = nums.length - 1;\\n        \\n        while(index > 0) {\\n            if(nums[index - 1] < nums[index]) { // find first index from right where the num breaks the increasing order (from right to left)\\n                break;\\n            }\\n            index--;\\n        }\\n        \\n        if(index == 0) { // if we have reached the index 0, this means the given array is in decreasing order so reverse it\\n            reverse(nums, index);\\n            return;\\n        } else {\\n            int val = nums[index - 1];\\n            int idxToSwap = nums.length - 1;\\n            while(idxToSwap > index - 1) {\\n                if(nums[idxToSwap] > val) { // find the first num which is grater than the num at \\'index - 1\\'\\n                    break;\\n                }\\n                idxToSwap--;\\n            }\\n            swap(nums, index - 1, idxToSwap); // swap the num, this will basically ATTEMPT to increase the original number \\'just a little\\'\\n            reverse(nums, index); // this step along with above step will basically increase the original number \\'just a little\\' (basically next lexicographically greater permutation of numbers)\\n            return;\\n        }\\n    }\\n    \\n    private void swap(int[] nums, int firstIdx, int secondIdx) {\\n        int temp = nums[firstIdx];\\n        nums[firstIdx] = nums[secondIdx];\\n        nums[secondIdx] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start) {\\n        int end = nums.length - 1;\\n        while(start < end) {\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400124,
                "title": "python-easy-sorting-binary-search-nlogn-time",
                "content": "***PLEASE DO UPVOTE***\\n```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom heapq import heappush, heappop, heapify\\nclass Solution:\\n    \\n    def find_ceil(self, a,i,j, key):\\n        ans = None\\n        while i<=j:\\n            mid = (i+j)//2\\n            if a[mid] > key: #strictly greater than key\\n                ans = mid\\n                i = mid+1\\n            else:\\n                j = mid-1\\n        return ans\\n    \\n    def sort(self,a, i, j):\\n        heap = []\\n        heapify(heap)\\n        for k in range(i, j+1):\\n            heappush(heap, a[k])\\n        for k in range(i, j+1):\\n            a[k] = heappop(heap)\\n            \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx,n = None, len(nums)\\n        for i in range(n-2,-1,-1):\\n            if nums[i] < nums[i+1]:\\n                idx = i \\n                break\\n        if idx!=None:\\n            idx2 = self.find_ceil(nums, idx+1, n-1, nums[idx])\\n            nums[idx], nums[idx2] = nums[idx2], nums[idx]\\n            self.sort(nums, idx+1, n-1)\\n        else:\\n            nums.sort()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1358174,
                "title": "java-solution-0ms-faster-than-100-submissions",
                "content": "**Please Upvote the Solution if you find it useful!!**\\n\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums==null||nums.length<=1) return;\\n        \\n        int i = nums.length-2;\\n        while(i>=0 && nums[i]>=nums[i+1]) i--;\\n        \\n        if(i>=0)\\n        {\\n            int j = nums.length-1;\\n            while(nums[j]<=nums[i]) j--;            \\n            swap(nums,i,j);                \\n        }\\n        reverse(nums,i+1,nums.length-1);\\n    }\\n    \\n    public void swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;        \\n    }\\n    \\n    public void reverse(int[] nums, int i,int j)\\n    {\\n        while(i<j)\\n        swap(nums,i++,j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313889,
                "title": "c-100-faster-easy-2-approaches",
                "content": "**1. OPTIMAL APPROACH**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\\n\\n**2. STL function**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(), k, l;\\n        for(k=n-2; k>=0; k--){\\n            if(nums[k]<nums[k+1]){\\n                break;\\n            }\\n        }\\n        if(k<0){\\n            reverse(nums.begin(), nums.end());\\n        }\\n        else{\\n            for(l=n-1; l>k; l--){\\n                if(nums[l]>nums[k]){\\n                    break;\\n                }\\n            }\\n            swap(nums[l], nums[k]);\\n            reverse(nums.begin()+k+1, nums.end());\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 968963,
                "title": "faster-easy-understanding-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i,n=nums.size();\\n        for(i=n-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        int j=i-1;\\n        int index=j;\\n        for(int i=n-1;j!=-1 && i>j;i--){\\n            if(nums[i]>nums[j]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(j!=-1)\\n        swap(nums[j],nums[index]);\\n        reverse(nums.begin()+j+1,nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806532,
                "title": "rust-usual-solutoin",
                "content": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn next_permutation(nums: &mut Vec<i32>) {\\n        let l = nums.len();\\n        let (mut i, mut j) = (l-1, l-1);\\n\\t\\t\\n\\t\\t// get the index of last increasing subseq elem from right\\n        while i > 0 && nums[i-1] >= nums[i] { i -= 1; }\\n\\t\\t\\n\\t\\t// nums[i-1] is the smallest in range (i-1..len-1)\\n\\t\\t// elems from (i..len - 1) are in descending\\n        if i > 0 {\\n\\t\\t\\t// get index of the first element >= nums[i-1]\\n\\t\\t\\t// equivalent to sorting the element in ascending and get the index of element right after nums[i-1]\\n             while j >= i && nums[j] <= nums[i-1] { j -= 1; }\\n\\t\\t\\t // swap the smallest and next greater element\\n             nums.swap(i-1, j);\\n        }\\n\\n\\t\\t// reverse the elements from (i to len - 1) to convert to ascending\\n        nums[i..l].reverse();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 545263,
                "title": "python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        idx = len(nums)-2\\n        while idx>=0:\\n            if nums[idx]<nums[idx+1]:\\n                break\\n            idx-=1\\n        if idx < 0:\\n            nums.sort()\\n            return\\n        \\n        nextIdx = idx+1\\n        while nextIdx<len(nums) and nums[nextIdx]>nums[idx]:\\n            nextIdx+=1\\n        \\n        #swap idx and nextIdx\\n        nums[idx], nums[nextIdx-1] = nums[nextIdx-1], nums[idx]\\n        nums[idx+1:] = nums[idx+1:][::-1]\\n\\t\\t\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 2 -> first element which is smaller that next element \\n\\n# 1\\u3000\\u30002\\u3000\\u30007\\u3000\\u30004\\u3000\\u30003\\u3000\\u30001   find 3 -> smallest emlement which is larget that 2\\n\\n# 1\\u3000\\u30003\\u3000\\u30007\\u3000\\u30004\\u3000\\u30002\\u3000\\u30001   swap 2 and 3\\n\\n# 1\\u3000\\u30003\\u3000\\u3000[1\\u3000\\u30002\\u3000\\u30004\\u3000\\u30007]   sort nums after 3\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412808,
                "title": "c-beats-100-on-memory-with-explanation",
                "content": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void nextPermutation(vector<int>& nums) { // Example <1,0,3,2>\\n\\t// We need the next permutation to be <1,2,0,3>\\n\\t// Start from the right side and find the first element that is less than the one immediately after it. \\n\\t// That is 0.\\n\\t\\n        auto inversionPoint = is_sorted_until(rbegin(nums),rend(nums));\\n        if (inversionPoint == rend(nums)) { // Note that if no element is found that smaller than the one\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// immediately after it we have reached the end of the vector, meaning we are at the last valid permutation\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// In that case, we want to return the first permutation (simply sort the vector).\\n            reverse(rbegin(nums),rend(nums)); // Using reverse on a vector sorted in ascending order \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t//(from right to left) will yield a vector that is sorted from left to right.\\n            return; \\n        }\\n        auto lowestUpper = upper_bound(rbegin(nums),inversionPoint, *inversionPoint); // Now we need to find the first number\\n\\t    // that is higher than our inversion point of 0. That is 2.\\n        \\n\\t\\titer_swap(lowestUpper, inversionPoint); // We swap 0 and 2. We now have <1, 2, 3, 0>\\n        reverse(rbegin(nums), inversionPoint); // We reverse from 0 to 2 non inclusive of 2 \\n        return; // We now arrive at  <1,2, 0, 3>\\n    }\\n\\t\\n\\t// If this was helpful please give me reputation. Thanks!",
                "codeTag": "Unknown"
            },
            {
                "id": 13902,
                "title": "simple-javascript-o-n-same-as-556-next-greater-element-iii",
                "content": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```\\nSee [#556](https://discuss.leetcode.com/topic/86405/javascript-o-log-n-time-and-o-1-space-using-buckets) for the strategy.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar nextPermutation = function(nums) {\\n    let j = nums.length - 1, i = j - 1;\\n    while (nums[i + 1] <= nums[i]) i--;\\n    if (~i) {\\n        while (nums[j] <= nums[i]) j--;\\n        swap(nums, i, j);\\n    }\\n    for (let k = i + 1, stop = (i + nums.length) / 2; k < stop; k++) {\\n        swap(nums, k, nums.length - k + i);\\n    }\\n};\\n\\nfunction swap(nums, i, j) {\\n    let temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13981,
                "title": "o-n-1ms-java-solution-with-comments",
                "content": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "solutionTags": [],
                "code": "        public void nextPermutation(int[] nums) {\\n            // Degenerate case.\\n            if (nums.length < 2) {\\n                return;\\n            }\\n    \\n            // Step 0: Working from right to left, find the index i of the first decreased value.\\n            int indexOfFirstDecrease;\\n            indexOfFirstDecrease = nums.length - 2;\\n            while (indexOfFirstDecrease >= 0 && nums[indexOfFirstDecrease] >= nums[indexOfFirstDecrease + 1]) {\\n                indexOfFirstDecrease--;\\n            }\\n    \\n            // Step 1: If it's a strictly decreasing array, there is no greater permutation, so we need to find the least\\n            // according to the problem statement. We can do this by reversing the array so it is strictly increasing.\\n            // Then we're finished.\\n            if (indexOfFirstDecrease == -1) {\\n                for (int j = 0; j < nums.length / 2; j++) {\\n                    int temp = nums[j];\\n                    nums[j] = nums[nums.length - 1 - j];\\n                    nums[nums.length - 1 - j] = temp;\\n                }\\n                return;\\n            }\\n    \\n            // Step 2: Find next-greatest number in the subpermutation after nums[indexOfFirstDecrease];\\n            // This works because we know that nums[i + 1], ..., nums[nums.length - 1] are in strictly non-increasing order\\n            int indexOfNextGreatestNumber = indexOfFirstDecrease + 1;\\n            while (indexOfNextGreatestNumber < nums.length - 1 && nums[indexOfNextGreatestNumber + 1] > nums[indexOfFirstDecrease]) {\\n                indexOfNextGreatestNumber++;\\n            }\\n    \\n            // Step 3: Interchange the values at indexOfFirstDecrease and indexOfNextGreatestNumber.\\n            int interchangeTemp = nums[indexOfFirstDecrease];\\n            nums[indexOfFirstDecrease] = nums[indexOfNextGreatestNumber];\\n            nums[indexOfNextGreatestNumber] = interchangeTemp;\\n    \\n            // Step 4: Reverse the values between indices (indexOfFirstDecrease + 1) and (nums.length - 1)\\n            int init = indexOfFirstDecrease + 1;\\n            for (int k = 0; k < (nums.length - init) / 2; k++) {\\n                int temp = nums[init + k];\\n                nums[init + k] = nums[nums.length - 1 - k];\\n                nums[nums.length - 1 - k] = temp;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 14106,
                "title": "share-my-short-solution",
                "content": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "solutionTags": [],
                "code": "    public void nextPermutation(int[] num) {\\n           int start = num.length - 1;\\n           while (start > 0 && num[start-1] >= num[start]) start--;\\n           if (start > 0) {\\n               int end = num.length - 1;\\n               while (num[end] <= num[start-1]) end--;\\n               swap(num, start-1, end);\\n           }\\n           //we don't need to sort, we can just reverse it\\n           for (int i=start; i<(start+num.length)/2; i++) {\\n               swap(num, i, num.length-1+start-i);\\n           }\\n        }\\n        \\n        void swap(int[] A, int i, int j) {\\n            int temp = A[i];\\n            A[i] = A[j];\\n            A[j] = temp;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 4079304,
                "title": "3-approaches-well-explained-bruteforce-better-optimized",
                "content": "# Approach 1: Brute Force \\uD83E\\uDDD0\\n\\n### Intuition \\uD83E\\uDD14\\nWe want to find the next lexicographically greater permutation of an array of integers, `nums`.\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nThe brute force solution has three steps:\\n1. Find all possible permutations of given array `nums`.\\n2. Linearly search for the given permutation.\\n3. Return the very next permutation of the given found permutation.\\n\\n### Time Complexity \\u23F3\\n- **Generating All Permutations:** Generating all permutations of an array with N elements has a time complexity of O(N!). This is because there are N! (N factorial) possible permutations of an array of size N.\\n\\n- **Finding a Particular Arrangement Linearly:** After generating all permutations, you would need to linearly search for a particular arrangement. This search would also take O(N!) time in the worst case because you might need to go through all permutations to find the desired one.\\n\\n- **Returning the Next Permutation of the Found Permutation:** Once you\\'ve found the desired permutation, finding the next permutation of it would also take O(N) time because you need to follow the steps for finding the next permutation on that specific permutation.\\n\\nThus, the time complexity of this approach would be O(N!) due to the generation of all permutations. It\\'s an inefficient approach, especially for large values of N, and is likely to give a **TLE**.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity for generating all permutations of an array with N elements is O(N!) because you\\'re storing N! different permutations.\\n\\n# Approach 2: Better Solution (only for cpp users) - Using `next_permutation()` fun\\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\nWe can use the `next_permutation()` function. The next_permutation function is a part of the C++ Standard Library\\'s `<algorithm>` header. It\\'s used to generate the next lexicographically greater permutation of a vector.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of the `next_permutation()` function is O(N), where N is the size of the input vector (nums in this case).\\nThe function traverses the vector from right to left to find the first pair of two consecutive elements such that the left element is less than the right element. This operation takes O(N) time in the worst case.\\nThe subsequent operations, such as finding the smallest greater element and reversing the subarray, also take O(N) time in total.\\nSo, the overall time complexity is O(N).\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe next_permutation function operates in-place and does not use any additional memory that scales with the input size. Therefore, the space complexity of the nextPermutation function is O(1), which means it uses constant extra memory.\\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\\n\\n# Approach 3: Optimized Solution \\uD83E\\uDDD0\\n\\n### Approach \\uD83D\\uDEE0\\uFE0F\\n- Like in a dictionary the very next word to a given word is almost the same except for a very few alphabets, e.g. in a dictionary Fire would come after fira. Notice how the first three alphabets are the same?\\n- Observing this lexicographical order in an English dictionary, we apply a similar approach in the array as well.\\n- Given array `nums` we find a **break point**. What is a breakpoint exactly and why are we finding it?\\n- Notice that the next permutation of [1,2,5,4,3,0] -> [1,3,5,4,2,0] -> [1,3,0,2,4,5]. Observe how two numbers have been swapped( 2 and 3) first, and then the rest of the array is reversed.\\n- This is because 2 is a breakpoint. A breakpoint here refers to a point that is lesser than the next element in the array.\\n- We traverse `nums` starting from i=n-2th index. We compare each `nums[i]` with `nums[i+1]`. If at any index `i`, `nums[i]`<`nums[i+1]`, we set `i` as out `breakindex` variable.\\n- Now after we\\'ve found the `breakindex`, we traverse the right half of the `nums` array after `breakindex`, so from `i=n-1` till `i=breakpint+1`, and look for the least greater after the `breakpoint`.\\n- In the array example taken above, index 1 was the `breakindex` and we traverse from element 5 to 0 and find that 3 is the least element greater than 1 in that portion of the array.\\n- Now, we swap the `breakindex` element with this `leastgreat` index element.\\n- Now we reverse the array from `breakindex+1` to `n-1`.\\n-**Edge case:** It may happen that the array in the input is the last possible maximum permutation possible for the elements like: [5,4,3,3,2,0], so the next permutation will be the reverse of it which is the first smallest possible permutation of the elements. So in case we do not find a `breakpoint` like in this case, we simply reverse the given `nums` array.\\n\\n### Time Complexity \\u23F3\\nThe time complexity of this approach is linear. We traverse the array twice: first to find the `breakpoint` and then to find the least greater element. Each traversal takes O(N) time.tore indices and values.\\n\\n### Space Complexity \\uD83D\\uDE80\\nThe space complexity is constant O(1) because the algorithm operates in-place without using any additional data structures that scale with the input size. \\n\\n### Code \\uD83D\\uDCBB\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```\\n\\n![CAN YOU PLEASE UPVOTE.jpg](https://assets.leetcode.com/users/images/fc2c0af7-4f47-44cf-b680-292fe4f08da0_1695449550.2816818.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        //find the breakpoint\\n        int breakpoint=-1;\\n        int n=nums.size();\\n        for(int i=n-2;i>=0;i--){\\n          if(nums[i]<nums[i+1]){\\n            breakpoint=i;\\n            break;\\n          }  \\n        } \\n        if(breakpoint==-1){reverse(nums.begin(),nums.end());return;}\\n        \\n        //find least greater of element at the breakpoint\\n        int leastgreater=-1; \\n        int leastGvalue=101;\\n        for(int i=n-1;i>breakpoint;i--){\\n            if(nums[i]>nums[breakpoint]){\\n                if(nums[i]<leastGvalue){\\n                    leastgreater=i;\\n                    leastGvalue=nums[i];\\n                }\\n            }\\n        }\\n\\n        //now swap breakpoint with leastgreater\\n        swap(nums[breakpoint],nums[leastgreater]);\\n        \\n        //reverse everything after the breakpoint\\n        reverse(nums.begin()+breakpoint+1,nums.end());\\nreturn;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009650,
                "title": "explained-every-step-0ms-100-beats-java",
                "content": "# Approach\\n- First we have to find where i < i+1 while we are traversing the array from second last element , second last beacause we are comapring it with i+1.If we start from last then it will give index out of bound.When we find that point where i < i+1 we store that i index in variable name ind which is firstly intialised as -1.\\nlet understand why we are doing this,\\n```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\\n- We can\\'t directly swap i with i+1 or any other number which can make array greater then previous beacuse output is according to the sorted permutation so we have to update it in sorted order before that think of edge case \\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\\n- Now lets decide with which element we can swap our ind index in order to make **Greater then previous** and **Next Permutation**\\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\\n- After this we have to sort the remainig array in order to make next permutation we can do it simply by reversing the array from ind+1 to a.legnth-1.\\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\\n\\n---\\n\\n*If there is some doubt or any mistake i have done in explaining please let me know in comments \\uD83D\\uDE4F*\\n# Complexity\\nin place and use only constant extra memory.\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n->In question asked of next permutation of given arr elements . \\nLet suppose the given arr = [1 2 3]\\nwe can rearrange it in 6 different ways or we say there is 3! permutations , which are\\n 1 2 3\\n 1 3 2<- This is our answer \\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we can see 1 3 2  > 1 2 3,\\n->so we have to check and take that prefix,if we make change on that then our modified array is greater then previous array . \\nunderstand this with different example \\n;-                  i    i+1\\n                    ^    ^\\ngiven arr = [1 , 2 , 0 , 5 , 1]\\n             this is where our condition stops \\nNow we store this i in ind variable and break the loop.\\n```\n```\\nEDGE CASE \\ngiven arr = [3 2 1]\\nAll permutation : -\\n 1 2 3\\n 1 3 2\\n 2 1 3\\n 2 3 1\\n 3 1 2\\n 3 2 1\\nAs we there is no next permutaion of  3 2 1  then we return the first permutation means\\n1 2 3 is our output in this case and we can get it by just reversing the array .\\n```\n```\\ngiven arr = [1 2 0 5 1]\\n            0 1 2 3 4<-Index\\nind  = 2 \\nnow we have 5 and 1 to swap with ind index in order to make it greater then previous array , \\ni can\\'t write all possible permutaion of  1 2 0 5 1 but i just write the next permutation of it which is \\n  1 2 1 0 5 is our next permutaion\\n->Now if we swap i with 5 then our array is greater but not our next permutation \\n-> If we swap ind index value with 1 then our array is \\n1 2 1 5 0\\n->So by this we understanded we have to pick smallest from all larger elements\\n->0(ind index value)<1<5,just greater then ind index value and smaller then all choices we have.\\n->We can find this by traversing the array from last to ind or 0.\\nif(a[i]>a[ind]){\\nswap(a[i],a[ind]);\\nbreak;\\n}\\nNow after this we have 1 2 1 5 0\\n```\n```\\n1 2 1 5 0<-a.length-1\\n      ^ \\n    ind+1\\nif we just reverse this portion then\\n 1  2 1 0 5 is array and this is also next permutation of our given array.\\n```\n```\\nclass Solution {\\n    public void nextPermutation(int[] a) {\\n        int ind = -1;\\n        for(int i = a.length-2;i>=0;i--){\\n            if(a[i]<a[i+1]){\\n                ind = i;\\n                break;\\n            }\\n        }\\n        if(ind==-1){\\n            arev(a,0,a.length-1);\\n            return;\\n        }\\n        for(int i = a.length-1;i>=0;i--){\\n            if(a[i]>a[ind]){\\n                int temp = a[i];\\n                a[i]=a[ind];\\n                a[ind]=temp;\\n                break;\\n            }\\n        }\\n        arev(a,ind+1,a.length-1);\\n\\n    }\\n        static void arev(int[] a,int low,int high){\\n        while(low<high){\\n            int temp = a[low];\\n            a[low]=a[high];\\n            a[high]=temp;\\n            low++;\\n            high--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3404423,
                "title": "c-beat-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for(int i = 0; i < n-1; i++) {\\n          if(nums[i]<nums[i+1]) idx = i;\\n        }\\n        if(idx == -1) {\\n          reverse(nums.begin(), nums.end());\\n          return;\\n        }\\n        int l = idx + 1;\\n        for(int i = idx + 1; i < n; i++) {\\n            if(nums[i] > nums[idx]) l = i;\\n        }\\n        swap(nums[idx], nums[l]);\\n        reverse(nums.begin() + 1 + idx, nums.end());\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3332720,
                "title": "simple-solution-in-python",
                "content": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\nimport itertools\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        \\n        \"\"\"\\n        1. From right to left find the one with misorer match that is the one that not in ascending            order\\n        2.Swap the element with next greatest element from its rigth sub array\\n        3.the reverse the right sub arrray (but here it is already reversed)\\n        \"\"\"\\n        right_subarr,n=[],len(nums)\\n        right_subarr.append(nums[-1]) \\n        for i in range(n-2,-1,-1):\\n            if nums[i]>=right_subarr[-1]:right_subarr.append(nums[i])\\n            else:\\n                temp=right_subarr[:]\\n                temp.sort()\\n                for next_greatest in temp:\\n                    if next_greatest>nums[i]:\\n                        m=next_greatest\\n                        break\\n                ind=right_subarr.index(m)\\n                \\n                nums[i],right_subarr[ind]=right_subarr[ind],nums[i]\\n                break\\n        if len(right_subarr)==n: nums[:]=right_subarr[:]\\n        else: nums[i+1:n]=right_subarr[:]\\n        print(right_subarr,nums)\\n        \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224452,
                "title": "next-permutation-o-n-solution-in-python",
                "content": "\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChange the array from the last and not from the start as it will change it drastically and we have to increase the sequence as little as possible\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- example: [2,3,8,5,4,1,0]\\n- First identify the longest non increasing subarray  from the last i.e [8,5,4,1,0]\\n- If whole array is in descending order, its already the largest permutation so just reverse it \\n- Now will swap the element to the left of the longest subarray(3) with the smallest element from the subarray i.e larger than that element. To find the element we will traverse from end untill you find element just greater than (3) i.e (4).\\n- Now swap them to get [2,4,8,5,3,1,0]\\n- Now just reverse the longest non increasing subarray(since its already in descending order) to get the smallest permutation i.e [2,4,0,1,3,5,8]\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        i=len(nums)-1\\n        while i>0 and nums[i-1]>=nums[i]:\\n            i=i-1\\n        if i<1:\\n            nums[:]=nums[::-1]\\n        else:\\n            j=len(nums)-1 #last element \\n            #we have to find element from last that is greater than nums[i-1]\\n            while nums[j]<=nums[i-1]:\\n                j=j-1\\n            nums[i-1], nums[j]= nums[j], nums[i-1]\\n            nums[i:]=reversed(nums[i:])\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3113745,
                "title": "easiest-o-n-solution-in-c-with-approach",
                "content": "# Approach\\nstep 1: find the element with a[i]>a[i-1];\\nstep 2: if non found then return a sort array.\\nstep 3: find the just greater element than step 1 element.\\nstep 4: swap step 3 and step 1 elements and reverse/sort the element before the step 1 index.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        // 1 3 5 4 2\\n        //find a[i]>a[i+1]\\n        int toswap=INT_MIN,withswap=INT_MIN;\\n        for(int i=a.size()-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                toswap=i-1;\\n                break;\\n            }\\n        }\\n        //edge case\\n        if(toswap==INT_MIN) return reverse(a.begin(),a.end());\\n        //just greater element than toswap.\\n        else{\\n            for(int i=a.size()-1;i>toswap;i--){\\n                if(a[i]>a[toswap]){\\n                    withswap=i;\\n                    break;\\n                }\\n            }\\n            swap(a[toswap],a[withswap]);\\n            return reverse(a.begin()+toswap+1,a.end()); \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2936089,
                "title": "time-o-n-easy-to-understanding",
                "content": "# Code\\n```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```\\nYou Can also Look At My SDE Prep Repo [*`\\uD83E\\uDDE2 GitHub`*](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    # To Reverse the Part of a List/Array\\n    def reverseLst(self,lst,left,right):\\n        while left < right:\\n            lst[left],lst[right] = lst[right],lst[left]\\n            left += 1\\n            right -= 1\\n        return lst\\n\\n    def nextPermutation(self, nums):\\n        numsLen = len(nums)\\n\\n        # Reaching the element which is Greater than the next and near to the right, and the element\\'s idx is  eleIdx\\n        eleIdx = numsLen - 1\\n        while 0 < eleIdx and nums[eleIdx-1] >= nums[eleIdx]:\\n            eleIdx -= 1\\n\\n        # if the eleIdx is 0 that mean the Whole lst is reversely sorted in this case just return the sorted array but don\\'t sort Just reverse it to get the sorted lst\\n        if eleIdx == 0:\\n            return self.reverseLst(nums,0,numsLen -1)\\n\\n        # Reversing the right sub array from the eleIdx to end -> indirectly Sorting\\n        nums = self.reverseLst(nums,eleIdx,numsLen -1)\\n\\n        # mainEle is the element that is neaded to swap with the next minum element after the mainEle\\'s idx\\n        mainEleIdx = eleIdx -1\\n\\n        # finding the right position for the mainElement and swapping it to the right position\\n        while eleIdx < numsLen and nums[mainEleIdx] >= nums[eleIdx]:\\n            eleIdx += 1\\n\\n        nums[mainEleIdx],nums[eleIdx] = nums[eleIdx],nums[mainEleIdx]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854196,
                "title": "pen-n-paper-solution-easy-with-comments-2-solved-examples",
                "content": "![tempImageMwxUvV.jpg](https://assets.leetcode.com/users/images/b7877058-c4d1-40f1-8361-5248a2ba97a6_1669566589.0427344.jpeg)\\n![tempImageFumuEH.jpg](https://assets.leetcode.com/users/images/c9fd7d51-3776-4056-b5ef-a612ff46817f_1669566608.6524541.jpeg)\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        # To find next permutations, we\\'ll start from the end\\n        \"\"\"\\n        i = j = len(nums)-1\\n        # First we\\'ll find the first non-increasing element starting from the end\\n        while i > 0 and nums[i-1] >= nums[i]:\\n            i -= 1\\n        # After completion of the first loop, there will be two cases\\n        # 1. Our i becomes zero (This will happen if the given array is sorted decreasingly). In this case, we\\'ll simply reverse the sequence and will return \\n        if i == 0:\\n            nums.reverse()\\n            return \\n        # 2. If it\\'s not zero then we\\'ll find the first number greater then nums[i-1] starting from end\\n        while nums[j] <= nums[i-1]:\\n            j -= 1\\n        # Now our pointer is pointing at two different positions\\n        # i. first non-ascending number from end\\n        # j. first number greater than nums[i-1]\\n        # We\\'ll swap these two numbers\\n        nums[i-1], nums[j] = nums[j], nums[i-1]\\n        # We\\'ll reverse a sequence strating from i to end\\n        nums[i:]= nums[len(nums)-1:i-1:-1]\\n        # We don\\'t need to return anything as we\\'ve modified nums in-place \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734334,
                "title": "clean-solution-in-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        int ind1,ind2,i;\\n        for(i=nums.size()-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                ind1=i;\\n                break;\\n            }\\n        }\\n        if(i<0){\\n            reverse(nums.begin(),nums.end());\\n        }\\n        else{\\n        for(int i=nums.size()-1;i>=0;i--){\\n            if(nums[i]>nums[ind1]){\\n                ind2=i;\\n                break;\\n            }\\n        }\\n        int temp=nums[ind1];\\n                nums[ind1]=nums[ind2];\\n                nums[ind2]=temp;\\n        \\n        reverse(nums.begin()+ind1+1,nums.end());  \\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570943,
                "title": "clean-code-with-comments-1ms",
                "content": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private void reverse(int[] arr, int start){\\n        int end = arr.length-1;\\n        while(start < end){\\n            swap(arr, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n    private void swap(int[] arr, int i, int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n    \\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length-2;\\n        // decreasing order find kro \\n        while(i>=0 && nums[i] >= nums[i+1]){\\n            i--;\\n        }\\n        // jese hi mila swap krdo\\n        if(i>=0){\\n            // required element dhundo swap krne ke liye \\n            int j = nums.length-1;\\n            while(j>=0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n            // jese hi element miljaye swap krdo \\n            swap(nums, i, j);\\n        }\\n        // reverse krdo baki ka \\n        reverse(nums, i+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316586,
                "title": "c-approach-and-intuition",
                "content": "**Basic Intution:**\\n* If we look carefully to the sample inputs we will always find an increasing order for a certain breakpoint.\\n* For e.g. in [1 2 3], the next permutation will be [1 3 2] ---> 1<3>2. Similarily in [2 1 3], the next permutation will be    [2 3 1]--->2<3>1.\\n* The only time this won\\'t apply is when the given input is in decreasing order.\\n\\n1. So, we can traverse from back and check for the index position whose value is lesser than its prior index position\\'s value. Let\\'s store it in a variable--idx1.\\n2. Next, we have to again traverse from back and check which value is greater than the idx1 position value. Swap the places to get the possible next greater element.\\n3. However, this swap will only ensure the correctness of breakpoint. We need to then, reverse the rest array elements to the right side of the breakpoint in order to find the next permutation.\\n\\n**Edge case**\\nWhen the given array is in decreasing order, the next permutation will be the same array in reverse order. So in that case we can simply just reverse the entire array. For e.g. [3 2 1] --> [1 2 3].\\n\\n**Happy Hunting**",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2126330,
                "title": "python-solution",
                "content": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "i=len(nums)-2\\n        while i>=0:\\n            if(nums[i]>=nums[i+1]):\\n                i-=1\\n            else:\\n                break\\n        j=len(nums)-1\\n        if i>=0:\\n            while j>=0:\\n                if(nums[j]<=nums[i]):\\n                    j-=1\\n                else:\\n                    break\\n            nums[j],nums[i]=nums[i],nums[j]\\n        def reverse(nums,a,b):\\n            while(a<b):\\n                nums[a],nums[b]=nums[b],nums[a]\\n                a+=1\\n                b-=1\\n        reverse(nums,i+1,len(nums)-1)\\n![image](https://assets.leetcode.com/users/images/47a26b6b-9549-48f3-8f40-3fc38ecce0a1_1654963496.6587029.jpeg)\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 1927066,
                "title": "4-step-explanation-linear-time-two-pointers",
                "content": "Hello Leetcoders, Hope you are doing well.\\n\\nLet\\'s continue with **next permutation**\\n\\n**Problem statement**\\nWe have an array of Integers, we need to find next permutation of that number in lexographic (Dictionary) order.\\ne.g\\n1 3 2\\n\\nso all permutations for the give number in dictionary order will be,\\nIndex 0 -> 1 2 3\\nIndex 1 -> 1 3 2\\nIndex 2 -> 2 1 3\\nIndex 3 -> 2 3 1\\nIndex 4 -> 3 1 2\\nIndex 5 -> 3 2 1\\n\\nour answer for input 1 3 2 (at index 1) will be 2 1 3 (at index 2)\\n\\n**How can we solve this problem**\\nFirst approcah comes in our mind will be **Brute-force approach**\\n\\nwhat we can do in brute-force method is\\n\\n* Store given array into temp array\\n* Sort given input array into increasing order\\n* Create a 2D arraylist\\n* Call recusrive function and calculate all permutations and store those permutations into 2D arrayList\\n* now find index of temp array in 2D arrayList\\n* print index + 1 from 2D arrayList\\n\\nTime complexity : too bad\\nSpace complexity : not O(1) as problem says\\n\\nNow how can we optimize the solution\\n\\n**Optimal Approach**\\nAccording to problem they want next permutation of the given array which comes in **lexographic order**\\nwe use lexographic order in dictionary (normal oxford one, not python ;->)\\nIf we dive into the dictionary can think about how they organised we will find our apprach.\\n\\nwe will understand dictionary work using example i.e **1 3 5 4 2**\\n\\n**Step 1 :**\\nIf you see the array carefully you will find that first numbers is in increasing order than after certain point it is decreasing. We will call this certain point **Break-point.**\\n\\n\\nwe have to find this break-point, A simple way we can do this\\n```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\\n\\n**Step 2**\\nwe have prefix which is arr[0, i] i.e 1 3 this need to be change in lexographic order, for that we have to replace 3 with some integer which is present in another subarray[i+1, last] i.e 5 4 2\\n\\nWhat options we have\\nReplace 3 by 5 -> 1 5\\nReplace 3 by 4 -> 1 4\\nReplace 3 by 2 -> 1 2\\n\\nbut we want our next permutaion so we have to find greater than 3 which means 2 is rejected\\nwe want in lexographic order means 1 4 comes before 1 5.\\nif you sum-up both above point it is basically saying that find smallest number which is greater than break-point integer\\n\\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\\n\\n**Step 3**\\nSwap both ith and jth index element to get smallest lexographic prefix\\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\\n\\n**Step 4**\\n\\nI will say again we want lexographically next permutation so we find our prifix i.e 1 4\\nnow try to find remaining combination\\n\\nso you will see after swaping, our array is 1 4 5 3 2\\ntake arr(i+1, last)\\n5 3 2\\n\\nwe want it in dictionary order so\\nreverse it 2 3 5\\n\\n**final output : 1 4 2 3 5**\\n\\n**Edge case**\\nWhat happen if we can\\'t find any break-point\\ne.g 3 2 1\\n\\nin this case step 1, 2, 3 will be skipped and we perform step 4 directly\\nreverse the arr\\n1 2 3 is our output\\n\\n**Code**\\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```\\n\\n**For break-point : O(n)\\nFor Smallest integer : O(n)\\nFor Swap : O(1)\\nFor Reverse : O(n)**\\n\\nT(n) : O(n)\\nSpace complexity : O(1)\\n\\nIn case of any doubt, feel free to comment down below, Thank you",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\ntraverse from 2nd last index and compare nums[i] >= nums[i+1] \\nwhen this fails we will find our break-point\\n\\nin our example \\ni = 3 (2nd last index)\\n\\nfirst iteration : 4 >= 2\\ni = 2\\n\\nsecond iteration : 5 >= 4\\ni=1\\n\\nthird iteration 3 >= 5\\nbreak\\n\\nour break-point i = 1\\n```\n```\\ntraverse from last \\nnums[j] <= nums[i]\\n\\n\\narray 1 3 5 4 2\\ni = 1\\n\\nj = 4 (last index)\\nnums[j] <= nums[i]\\n\\nfirst Iteration : 2 <= 3\\nj = 3\\n\\nsecond iteration : 4 <= 3\\nbreak\\n\\nj = 3\\n```\n```\\nswap(arr, i, j)\\n\\n\\ninput = 1 3 5 4 2\\noutput = 1 4 5 3 2\\n```\n```\\nclass Solution {\\n   public void nextPermutation(int[] nums) {\\n       if(nums == null || nums.length <= 1) return; // base case\\n       \\n       int i = nums.length - 2; // second last index\\n       while(i >= 0 && nums[i] >= nums[i+1]) i--; // find break point\\n       \\n       if(i >= 0) { // iff we found break point\\n           int j = nums.length - 1;\\n           while(nums[j] <= nums[i]) j--; // find smallest integer greater than break-point integer\\n           \\n           swap(nums, i, j); // swap the integers\\n       }\\n       reverse(nums, i+1, nums.length - 1); // reverse array apart from prefix\\n       \\n   }\\n   \\n   private void swap(int[] arr, int i, int j) {\\n       int temp = arr[i];\\n       arr[i] = arr[j];\\n       arr[j] = temp;\\n   }\\n   \\n   private void reverse(int arr[], int left, int right) {\\n       while(left < right) {\\n           swap(arr, left++, right--);\\n       }\\n   }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910927,
                "title": "c-1-lines-std-library",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```\\n\\nhttps://en.cppreference.com/w/cpp/algorithm/next_permutation",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(), nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910469,
                "title": "java-highly-commented-with-example-proof-o-n-0ms-runtime",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1st step --> Find the pivot\\n        \\n        /*iska matlab aisa number jisko tumhe actually swap karna hai basically \\n\\t\\tleft lesser value to right larger value. So yaha par pehle hum wo left lesser\\n\\t\\tvalue dhund rahe hai next step mein right larger value.Ex: 9 1 5 3 toh \\n\\t\\tisme check karo ki kab tumhe arr[idx+1]>arr[idx] mil jaaye is case mein 1st idx is pivot hoga.\\n\\t\\t*/\\n        \\n        int i = arr.length-2;\\n        while(i>=0 && arr[i]>=arr[i+1])\\n            i--;\\n        \\n  /*why if because in case of the largest number i will be -ve itself like 3 2 1\\n  have to return the smallest arrangement i.e. 1 2 3 so simply reverse no need of \\n  2nd step */\\n\\n        \\n        /*2nd step: Find the just larger value than your arr[i] so we can swap \\n\\t\\tboth the numbers. Ex: 9 1 5 3 mein 1 and 3 will be swapped because 3 is \\n\\t\\tjust immediate larger than our arr[i] */\\n        \\n        if(i>=0){  \\n            int j = arr.length-1;\\n            while(arr[i]>=arr[j])\\n            j--;\\n            \\n            /*Step 3: Swap both the indexes i.e. i and j in our example the resultant\\n\\t\\t\\twould look like 9 3 5 1 */\\n            \\n            swap(arr,i,j);\\n        }\\n        \\n        //Step-4 : Reverse the array after the pivot point\\n        \\n         /*Why see if you look carefully our number after swap becomes 9 3 5 1 \\n\\t\\t but according to question we want the next permutation which is just \\n\\t\\t immediate greater than the given number right so our resultant final answer \\n\\t\\t should be 9 3 1 5, for that we have to reverse the array after the pivot \\n\\t\\t point i.e. reverse from (i+1,arr.length-1) also if you remember our if check \\n\\t\\t is due to what if we provided with the highest number itself so we have to \\n\\t\\t return the smallest permutation i.e. reverse the whole array so our that \\n\\t\\t purpose is also serving because what we are passing is in our \\n\\t\\t reverse array (i+1,arr.length-1) and for highest number i = -1 \\n\\t\\t so automatically due to the function it will become(0,arr.length-1) .\\n */\\n        \\n        reverse(arr,i+1,arr.length-1);\\n        \\n    }\\n    \\n    public void reverse(int[] arr,int i,int j){\\n        while(i<j){\\n            swap(arr,i,j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    \\n    public void swap(int[] arr,int i,int j){\\n        int temp = arr[i];\\n        arr[i] = arr[j];\\n        arr[j] = temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1909160,
                "title": "o-n-solution-easy-solution-with-comments",
                "content": "**step1:** find the first decending number from the end. Store number in index.\\n**step2:** If we don\\'t find the index then there is no permutation possible for the current number. So we return the first permutation. To do that we need to return reversed array.\\n**Step 3:** If we got the index, Then we need to find the second index. Second index is basically the index which has value greater then the first index value from back. Store the second index value.\\n**Step 4:** Swap index and second index value.\\n**Step 5:** reverse all the array items after the index value. We are doing this bacause we need to find the minimum permutation value after the array index.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```\\n**TC: O(n)\\nSC: O(1)**",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    const len=nums.length-1;\\n    //stores the first index and second index for swapping.\\n    let index;\\n    let secIndex;\\n    \\n    //get the first index\\n    for(index=len-1;index>=0;index--){\\n        if(nums[index]<nums[index+1]){\\n            break;\\n        }\\n    }\\n    //if we don\\'t find first index we don\\'t find second index. we just reverse nums arr.\\n    //that means if we get [3,2,1] as input then our next permutation is [1,2,3].\\n    if(index<0){\\n        nums.reverse();\\n    }else{\\n        //find the second index from last.\\n        //if we find a value from back which is greater than value of index optained.\\n        for(secIndex=len;secIndex>index;secIndex--){\\n            if(nums[secIndex]>nums[index]){\\n                break;\\n            }\\n        }\\n        //swap values of index and secondindex.\\n        [nums[index],nums[secIndex]]=[nums[secIndex],nums[index]];\\n        \\n        //reverse values after the index value till last.\\n        let low=index+1;\\n        let high=len;\\n        while(low<high){\\n           [ nums[low],nums[high]]=[ nums[high],nums[low]];\\n            low++;\\n            high--\\n        }\\n    }\\n    \\n    \\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1908457,
                "title": "only-for-beginner-100-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        // if(next_permutation(nums.begin(), nums.end())){\\n        //     return;\\n        // }\\n        // sort(nums.begin(), nums.end());\\n        // return;\\n        \\n\\t\\t\\n\\t\\t// Dry run for better understanding , very easy logic\\n\\t\\t\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                sort(nums.begin()+i+1, nums.end());\\n                auto it = upper_bound(nums.begin()+i+1, nums.end(), nums[i]);\\n                swap(*it, nums[i]);\\n                sort(nums.begin()+i+1, nums.end());\\n                return ;\\n            }\\n        }\\n        sort(nums.begin(), nums.end());\\n        return;\\n    }\\n};\\n//  If you understand this then please upvote this.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922289,
                "title": "easy-c-well-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // we move from the left of array and find the first\\n        // element which is lesser than the previous one.\\n        int n = nums.size(), i;\\n        for(i = n-2; i>=0; i--){\\n            if(nums[i]<nums[i+1])\\n                break;\\n        }\\n        \\n        // if sorted in non-increasing order, we can not find\\n        // next permutation\\n        if(i == -1){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        \\n        // sort the array in non-decreasing order after ith \\n        // position, because we want the very next permutation\\n        sort(nums.begin()+(i+1), nums.end());\\n\\n        // find the very next greater number from nums[i] &\\n        // swap it with that\\n        int j = i+1;\\n        while(j<n && nums[j]<=nums[i]){\\n            j++;\\n        }\\n            \\n        swap(nums[i], nums[j]);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 559892,
                "title": "c-solution",
                "content": "## Intuition\\n1. Backward traverse the array until we find the two consecutive numbers such that ```nums[i] < nums[i + 1]```. Because the numbers to the right of ```nums[i]``` are in descending order, so we can\\'t make that part bigger.\\n2. Now we need to backward traverse the array again to find first number ```nums[j]``` such that ```nums[j] > nums[i]```, and then swap them to generate a bigger number.  \\n\\t* Why do we need to find the **first** ```nums[j]```? Because we need to generate the **smallest** permutation that is greater than the original number.\\n3.  After swapping ```nums[i]``` and ```nums[j]```, we need to reverse the numbers to the right of ```nums[i]``` to force this part to be the smallest. \\n\\t* Why do we use reverse rather than sort? Sorting will work as well. However, swapping ```nums[i]``` and ```nums[j]``` doesn\\'t change the fact that the numbers to the right of ```nums[i]``` are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\n## Implementation\\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```\\n\\n## Complexity\\n* Time compleixty: O(N)\\n* Space complexity: O(1)",
                "solutionTags": [],
                "code": "```nums[i] < nums[i + 1]```\n```nums[i]```\n```nums[j]```\n```nums[j] > nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```nums[i]```\n```nums[j]```\n```nums[i]```\n```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        \\n        int swap = -1;\\n        for(int i = nums.Length - 2; i >= 0; i--)\\n        {\\n            if(nums[i] < nums[i + 1])\\n            {\\n                swap = i;\\n                break;\\n            }\\n        }\\n\\n        if(swap == -1)\\n        {\\n            Reverse(nums, 0, nums.Length - 1);\\n            return;\\n        }  \\n        \\n        for(int j = nums.Length - 1; j >= 0; j--)\\n        {\\n            if(nums[j] > nums[swap])\\n            {\\n                Swap(nums, j, swap);\\n                break;\\n            }\\n        }\\n        \\n        Reverse(nums, swap + 1, nums.Length - 1);\\n    }\\n    \\n    public void Swap(int[] nums, int i, int j)\\n    {\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void Reverse(int[] nums, int start, int end)\\n    {\\n        while(start < end)\\n        {\\n            int temp = nums[start];\\n            nums[start] = nums[end];\\n            nums[end] = temp;\\n            start++;\\n            end--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 398787,
                "title": "python-solution-with-inline-explanation",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Two key observations in the problem:\\n            1. A decreasing array is the last permutation of the array, and the \\n               next one is the reverse of it. For example, `3,2,1` is the last \\n               permutation of this array and `1,2,3` will be next.\\n            2. For a decreasing subarray, there is a number right before the \\n               subarray that \"leads\" the subarray, e.g., `2,4,3,1` in which `2` \\n               \"leads\" the subarray `4,3,1`. Similarly, the decreasing subarray \\n               is the last permutation of itself, and the next one should be \\n               mostly the reverse of the subarray, except that the \"leading\" \\n               number is going to change. Looking at the previous example, the \\n               next permutation is `3,1,2,4` wherein the \"leading\" number is \\n               `3`, which is the next greater number than `2` in the sequence. \\n               Herein, the rule for generating the next permutation for a \\n               subarray is - 1) swap the \"leading\" number and the next greater \\n               one in the decreasing subarray; 2) reverse the decreasing \\n               subarray.\\n        In summary, the whole process should be the following:\\n            1. Find the decreasing subarray if not the entire array\\n            2. If it is not the entire array, swap the \"leading\" number and its \\n               next greater number in the decreasing subarray\\n            3. Reverse the decreasing part\\n        \"\"\"\\n        # if there is only a single number in the array, the next permutation is\\n        # itself\\n        if len(nums) == 1:\\n            return \\n\\n        # find the decreasing subarray from right to left and the pointer stops \\n        # at the \"leading\" number, if not the head of the array\\n        start = len(nums) - 2\\n        while start >= 0:\\n            if nums[start] < nums[start + 1]:\\n                break\\n            start -= 1\\n\\n        # find the two ends of the subarray to be reversed\\n        if start < 0:\\n            # if the entire array is decreasing, the entire array needs to be \\n            # reversed end-to-end\\n            start = 0\\n        else:\\n            # otherwise, we have a decreasing subarray and a \"leading\" number, \\n            # so we find and swap the \"leading\" number and its next greater \\n            # first \\n            i = start\\n            while i < len(nums) - 1 and nums[cur] < nums[i + 1]:\\n                i += 1\\n            nums[start], nums[i] = nums[i], nums[start]\\n            \\n            # the decreasing subarray will be reversed\\n            start += 1\\n\\n        # reverse the decreasing subarray in-place\\n        end = len(nums) - 1\\n        while start < end:\\n            nums[start], nums[end] = nums[end], nums[start]\\n            start += 1\\n            end -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279370,
                "title": "c-with-comments",
                "content": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void NextPermutation(int[] nums) {\\n        var n = nums.Length;\\n        // 1. find the last element of the increasing sequence from the back to the front\\n        var lastElementIndex = n - 1;\\n        while (lastElementIndex > 0 && nums[lastElementIndex - 1] >= nums[lastElementIndex]) {\\n            lastElementIndex--;\\n        }\\n\\n        var preLastElementIndex = lastElementIndex - 1;\\n\\n        if (preLastElementIndex < 0) {\\n            // Corner case: 4,3,2,1 => 1,2,3,4\\n            reverse(0, n - 1, nums);\\n        } else {\\n            // 2. find the fist element larger than the pre and replace from the back to the front\\n            var firstElementLargerIndex = n - 1;\\n            while (firstElementLargerIndex > 0 && nums[preLastElementIndex] >= nums[firstElementLargerIndex]) {\\n                firstElementLargerIndex--;\\n            }\\n\\n            // 3. swap\\n            var temp = nums[firstElementLargerIndex];\\n            nums[firstElementLargerIndex] = nums[preLastElementIndex];\\n            nums[preLastElementIndex] = temp;\\n\\n            // 4. reverse [lastElementIndex ... n - 1] in place\\n            reverse(lastElementIndex, n - 1, nums);\\n        }\\n    }\\n\\n    private void reverse(int left, int right, int[] nums) {\\n        while (left < right) {\\n            var temp = nums[left];\\n            nums[left] = nums[right];\\n            nums[right] = temp;\\n            left++;\\n            right--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061592,
                "title": "o-n-0ms-simple-java-solution-most-optimized-solution-easily-explained-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWrite down all the permuatation of that array in the copy and try to decode how the next permutation comes by fixing the prefixes by following lexicographical order \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the break-point, i: Break-point means the first index i from the back of the given array where arr[i] becomes smaller than arr[i+1].\\nFor example, if the given array is {2,1,5,4,3,0,0}, the break-point will be index 1(0-based indexing). Here from the back of the array, index 1 is the first index where arr[1] i.e. 1 is smaller than arr[i+1] i.e. 5.\\n\\nTo find the break-point, using a loop we will traverse the array backward and store the index i where arr[i] is less than the value at index (i+1) i.e. arr[i+1].\\n\\nIf such a break-point does not exist i.e. if the array is sorted in decreasing order, the given permutation is the last one in the sorted order of all possible permutations. So, the next permutation must be the first i.e. the permutation in increasing order.\\nSo, in this case, we will reverse the whole array and will return it as our answer.\\n\\nIf a break-point exists:\\nFind the smallest number i.e. > arr[i] and in the right half of index i(i.e. from index i+1 to n-1) and swap it with arr[i].\\n\\nReverse the entire right half(i.e. from index i+1 to n-1) of index i. And finally, return the array.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\no(1)\\n\\n# Code\\n```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n      public void swap(int[] nums, int i, int j){\\n        int temp=nums[i];\\n        nums[i]=nums[j];\\n        nums[j]=temp;\\n    }\\n    public void reverse(int[] nums, int i ,int j){\\n        while(i<j){\\n            swap(nums,i,j);\\n            i++;\\n            j--;\\n        }\\n\\n    }\\n    public void nextPermutation(int[] nums) {\\n        int index=-1;\\n        int n = nums.length;\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                index= i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            reverse(nums,0,n-1);\\n        }\\n        else{\\n            for(int i=n-1;i>index;i--){\\n                if(nums[i] > nums[index]){\\n                    swap(nums,i,index);\\n                    break;\\n                }\\n            }\\n            reverse(nums,index+1, n-1 );\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714796,
                "title": "superb-logic-with-unlimited-concept",
                "content": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, arr: List[int]) -> None:\\n        index=-1\\n        n=len(arr)\\n        for i in range(n-2,-1,-1):\\n            if arr[i]<arr[i+1]:\\n                index=i\\n                break\\n        if index==-1:\\n            arr[:]=arr[::-1]\\n            return arr\\n        for i in range(n-1,index-1,-1):\\n            if arr[index]<arr[i]:\\n                arr[index],arr[i]=arr[i],arr[index]\\n                break\\n        arr[::]=arr[:index+1]+sorted(arr[index+1:])\\n        return arr \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565329,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int idx = -1;\\n        for (int i = n-2; i >= 0; i--) {\\n            if (nums[i] < nums[i+1]) {\\n                idx = i;\\n                break;\\n            }\\n        }\\n        if (idx != -1) {\\n            for (int i = n-1; i > idx; i--) {\\n                if (nums[i] > nums[idx]) {\\n                    swap(nums[i], nums[idx]);\\n                    break;\\n                }\\n            }\\n        }\\n        reverse(nums.begin()+idx+1, nums.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537825,
                "title": "c-analytics-solution-runtime-beats-63-memory-beats-71",
                "content": "# Introduction\\nThis is a dumb solution where you ***understand how to create the next permutation manually***. Thus if you are looking for a solution that requires ***less algorithm skills but more thinking***, here is your place.\\n\\n# Code (!the explanation etc. is below this section!)\\n```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\\n\\n# Approach\\nLet us use a couple of examples to help us understand how to get the next permutation.\\nThis is how you find the next permutation:\\n\\n1. 5 4 3 2 1 -> [5 4 3 2 1] ---------------> 1 2 3 4 5 (special case)\\n2. 1 2 3 4 5 -> 1 2 3 4 [5] -> 1 2 **4** [5 3] -> 1 2 4 **3 5**\\n3. 1 3 5 4 2 -> 1 3 [5 4 2] -> 1 **4** [5 3 2] -> 1 4 **2 3 5**\\n4. 1 5 4 3 2 -> 1 [5 4 3 2] -> **2** [5 4 3 1] -> 2 **1 3 4 5**\\n\\nEx1 is **special**, so let us tryna solve case 2-4 first.\\n\\n- The first \"arrow\" represents **finding the longest decending array at the end of the nums**. We temporarily call this decending array as \"The ***queue***\".\\n- The second \"arrow\" represents **replace the num before the queue with the smallest number in the queue that is greater than this number**.\\n- The third \"arrow\" means **sorting the queue**. As the original queue is decending and the replaced number is still in place, we only need to **reverse the whole queue**.\\n\\nNow you know how my solution works. Why it works is just generally how to find the next permutation, you can notice how it works if you print out all the permutations and observe the pattern in it.\\n\\nThe code for this part is\\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\\n\\nNow for the special case. Our Ex1 is special is **Thoroughly Decending**, the next permutation is the sorted permutation. Hence, we need an \"if\" statement to watch out for this case, the code is below:\\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```\\n\\nThere you have it. This is my answer to this problem!\\n\\n# Complexity\\n- Time complexity: O(N) when it\\'s detecting the special case\\n\\n- Space complexity: O(1) only some parameters to keep track of info\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void swapAB(int &a, int &b){\\n        int tmp = a;\\n        a = b;\\n        b = tmp;\\n    }\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        // if it\\'s the last permutation\\n        bool flag = true;\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[i] > nums[i-1]){\\n                flag = false;\\n                break;\\n            }\\n        }\\n        if(flag == true){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n\\n        // if it\\'s not the last permutation\\n        int lastIndex = nums.size()-1;\\n        while(nums[lastIndex-1] >= nums[lastIndex])\\n            lastIndex --;\\n        lastIndex --;\\n\\n        int mid = 101, midIdx = lastIndex;\\n        for(int i=lastIndex+1; i<nums.size(); i++){\\n            if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n                mid = nums[i];\\n                midIdx = i;\\n            }\\n        }\\n        swap(nums[lastIndex], nums[midIdx]);\\n\\n        for(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n            if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n    }\\n};\\n```\n```\\n// step one / first \"->\"\\nint lastIndex = nums.size()-1;\\nwhile(nums[lastIndex-1] >= nums[lastIndex])\\n    lastIndex --;\\nlastIndex --;\\n// step two / second \"->\"\\nint mid = 101, midIdx = lastIndex;\\nfor(int i=lastIndex+1; i<nums.size(); i++){\\n    if(nums[i] <= mid && nums[i] > nums[lastIndex]){\\n        mid = nums[i];\\n        midIdx = i;\\n    }\\n}\\nswap(nums[lastIndex], nums[midIdx]);\\n// step three / third \"->\"\\nfor(int i=lastIndex+1, j=nums.size()-1; i<j; i++, j--)\\n    if(nums[i] > nums[j]) swap(nums[i], nums[j]);\\n```\n```\\nbool flag = true; // keep track of whether it\\'s decending overall\\nfor(int i=1; i<nums.size(); i++){\\n    if(nums[i] > nums[i-1]){\\n        flag = false;\\n        break;\\n    }\\n}\\nif(flag == true){\\n    sort(nums.begin(), nums.end());\\n    return; // remember to return here to keep the nums sorted!\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347668,
                "title": "java-solution-runtime-0-ms-beats-100-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```\\n# \\u2B06\\uFE0FUpvote if you like the solution",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] A) {\\n        if (A == null || A.length <= 1) return;\\n        int i = A.length - 2;\\n        while (i >= 0 && A[i] >= A[i + 1]) i--;\\n        if (i >= 0) {\\n            int j = A.length - 1;\\n            while (A[j] <= A[i]) j--;\\n            swap(A, i, j);\\n        }\\n        reverse(A, i + 1, A.length - 1);\\n    }\\n\\n    public void swap(int[] A, int i, int j) {\\n        int tmp = A[i];\\n        A[i] = A[j];\\n        A[j] = tmp;\\n    }\\n\\n    public void reverse(int[] A, int i, int j) {\\n        while (i < j) swap(A, i++, j--);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133449,
                "title": "simple-o-n-java-solution-with-explanation-and-example",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int ind1=-1;\\n        //Example\\n        //   3\\n        //  / \\\\\\n        // 1   2\\n\\n        //find the index of the first number that is lesser than it\\'s next\\n        for(int i=nums.length-1;i>=1;i--){\\n            if(nums[i-1]<nums[i]){\\n                ind1=i-1;       //nums[ind1]=1\\n                break;\\n            }\\n        }\\n        int ind2=-1;\\n        //if such a number exists, for a lexicographical order, find the number immediately bigger than it\\n        if(ind1!=-1){\\n            for(int i=nums.length-1;i>=ind1;i--){\\n                if(nums[i]>nums[ind1]){\\n                    ind2=i;     //nums[ind2]=2\\n                    break;\\n                }\\n            }\\n            //perform a swap of the two numbers\\n            int temp=nums[ind1];\\n            nums[ind1]=nums[ind2];\\n            nums[ind2]=temp;\\n\\n        //      3\\n        //     / \\\\\\n        //    2   1\\n        }\\n        //reverse the order after the break point(ind1) to ensure the lexicographical order\\n        for(int i=ind1+1,j=nums.length-1;i<j;i++,j--){\\n            int t=nums[i];\\n            nums[i]=nums[j];\\n            nums[j]=t;\\n        }\\n        // 2   3\\n        //  \\\\ /\\n        //   1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125459,
                "title": "python-easy-to-understand-beats-75-time-complexity",
                "content": "# Code\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        def reverse(nums, start):\\n            end = len(nums) - 1\\n            while start < end:\\n                nums[start], nums[end] = nums[end], nums[start]\\n                start += 1\\n                end -= 1\\n        i = len(nums) - 2\\n        while i >= 0 and nums[i + 1] <= nums[i]:\\n            i -= 1\\n        if i >= 0:\\n            j = len(nums) - 1\\n            while nums[j] <= nums[i]:\\n                j -= 1\\n            nums[i], nums[j] = nums[j], nums[i]\\n        reverse(nums, i + 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397776,
                "title": "next-permutation-simple-c-solution",
                "content": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "solutionTags": [],
                "code": "void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2256856,
                "title": "c-simple-fast-solution-next-permutation",
                "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }\\n        }\\n        if(inflectionPoint==0){\\n            sort(nums.begin(),nums.end());\\n        }\\n        else{               //if we get an inflection point\\n            int toSwap= nums[inflectionPoint-1];\\n            int min= INT_MAX;\\n            for(int j=inflectionPoint; j<=n; j++){\\n                if(nums[j]-toSwap>0 && nums[j]-toSwap<min){\\n                    int temp=nums[j];\\n                    nums[j]=nums[inflectionPoint-1];\\n                    nums[inflectionPoint-1]=temp;\\n                }\\n            }\\n            sort(nums.begin()+inflectionPoint, nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size()-1;\\n        int inflectionPoint=0;\\n        for(int i=n; i>0; i--){\\n            if(nums[i]>nums[i-1]){\\n                inflectionPoint=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2238691,
                "title": "functional-declarative-javascript-typescript-solution",
                "content": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n// mutative!\\nfunction swapValuesByIndex(array, index1, index2){\\n    let value1 = array[index1];\\n    array[index1] = array[index2];\\n    array[index2] = value1;\\n}\\n\\n// mutative! \\nfunction reversePartOfArray(array, startIndex, endIndex){\\n    while(startIndex < endIndex){\\n        swapValuesByIndex(array, startIndex, endIndex);\\n        startIndex += 1;\\n        endIndex -= 1;\\n    }\\n}\\n\\nfunction findLastIndexWhere(array, callbackFn){\\n    for(let i = array.length - 1; i >= 0; i--){\\n        if(callbackFn(array[i], i)) return i;\\n    }\\n}\\n\\n// mutative!\\nfunction nextPermutation(nums: number[]): void {\\n    // step 1: find the last digit that decreases from the one after it\\n    const firstIndex = findLastIndexWhere(nums, (num, i) => nums[i+1] !== undefined && num < nums[i+1]);\\n\\n    // step 1a: if the whole array is monotonically increasing from end to beginning, reverse the entire array\\n    if(firstIndex === undefined){\\n        reversePartOfArray(nums, 0, nums.length - 1);\\n        return;\\n    }\\n\\n    // step 2: find the last digit that is larger than our \"pivot\" digit\\n    const secondIndex = findLastIndexWhere(nums, (num, i) => num > nums[firstIndex]);\\n    \\n    // step 3: swap those digits\\n    swapValuesByIndex(nums, firstIndex, secondIndex);\\n    \\n    // step 4: reverse the part of the number after the swapped one\\n    reversePartOfArray(nums, firstIndex + 1, nums.length - 1);\\n};\\n\\n// time complexity: O(n + n + n) = O(n)\\n// space complexity: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2230218,
                "title": "easy-c-sol-naive-efficient-approach-linear-time",
                "content": "```\\n// Naive Solution Use the Inbuilt C++ function i.e, next_permutation : Time : O(N*N!) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }\\n};\\n\\n// Efficient Solution : Time : O(N) :: Aux_Space : O(1)\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n\\n        int n = nums.size();\\n\\n        int ind1,ind2;\\n\\n        for(int i=n-2;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                ind1 = i;\\n                break;\\n            }\\n        }\\n\\n        if(ind1 < 0){\\n            reverse(nums.begin(),nums.end());\\n        }else{\\n\\n            for(int i=n-1;i>ind1;i--){\\n                if(nums[i] > nums[ind1]){\\n                    ind2 = i;\\n                    break;\\n                }\\n            }\\n\\n            swap(nums[ind1],nums[ind2]);\\n\\n            reverse(nums.begin()+ind1+1,nums.end());\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(begin(nums),end(nums));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2007932,
                "title": "very-clearly-explained-using-examples-easy-to-understand-python-solution",
                "content": "A very **famous question**!\\nLet me explain using this example.\\n\\n**For example:**\\n2 5 4 3 1 -> 3 5 4 2 1 -> 3 1 2 4 5\\n\\n1. First loop from the end, find the first index that is not increasing,\\nin the example, it is the index of number 2.\\n2. Then we will again loop from the end, find the first index that is bigger than 2,\\nin the example, it is the index of number 3.\\n3. Swap these two.\\n4. At last reverse from 5 to end.\\n\\nTake care of the **duplicates**!\\nFor example:\\n2 5 5 3 1 -> 3 5 5 2 1 -> 3 1 2 5 5 \\n\\n**Time:** O(n)\\n**Space:** O(1)\\n\\n```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        if len(nums) == 0 or len(nums) == 1:\\n            return\\n        \\n        i = len(nums) - 1\\n        while i > 0 and nums[i] <= nums[i - 1]: # here must be <= to take care of the duplicates!\\n            i -= 1\\n        \\n        if i == 0:\\n            self.swap(nums, 0, len(nums) - 1)\\n            return\\n        left_index = i - 1\\n        \\n        i = len(nums) - 1\\n        while nums[i] <= nums[left_index]:\\n            i -= 1\\n        nums[i], nums[left_index] = nums[left_index], nums[i]\\n        self.swap(nums, left_index + 1, len(nums) - 1)\\n    \\n    def swap(self, nums, left, right):\\n        while left < right:\\n            nums[left], nums[right] = nums[right], nums[left]\\n            left += 1\\n            right -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1910219,
                "title": "daily-leet",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        int r=-1;\\n        int s=-1;\\n        for(int i=nums.length-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                r=i-1;\\n                break;\\n            }\\n        }\\n        if(r==-1){\\n            reverse(nums,0,nums.length-1);\\n        }\\n        else{\\n            for(int i=nums.length-1;i>=r;i--){\\n                if(nums[i]>nums[r]){\\n                    s=i;\\n                    break;\\n                }\\n            }    \\n            swap(nums,r,s);\\n            reverse(nums,r+1,nums.length-1);\\n        }\\n        return;    \\n    }\\n    public void reverse(int[] nums, int i, int j) {\\n        while (i < j) {\\n            swap(nums, i, j);\\n            i++;\\n            j--;\\n        }\\n    }\\n    public void swap(int[] nums, int i, int index) {\\n        int temp = nums[index];\\n        nums[index] = nums[i];\\n        nums[i] = temp;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908548,
                "title": "next-permutation-c-solution-commented-explained-easily",
                "content": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//Check from right to left for any position for while nums[i-1]<nums[i]\\n    void nextPermutation(vector<int>& nums) {\\n        // declaring i so as to store position where the condition is true;\\n        int i =0, n = nums.size()-1;\\n        for(i=n;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                break;\\n            }\\n        }\\n        // This case comes when the array is sorted in reverse order in that cause we directly sort it in \\n        // increasing order.\\n        if(i <=0){\\n            sort(nums.begin(), nums.end());\\n            return;\\n        }\\n        // Do the opertion move from right to left and find any number greater that nums[i] and then \\n        // swap it and sort from that position.\\n        for(int j = n;j>=0;j--){\\n            if(nums[j]>nums[i-1]){\\n                swap(nums[j], nums[i-1]);\\n                sort(nums.begin()+i, nums.end());\\n                break;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1871342,
                "title": "c-simple-code-easy-to-understand-tc-o-n-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nvoid nextPermutation(vector<int>& nums) {\\n    \\tint n = nums.size(), k, l;\\n    \\tfor (k = n - 2; k >= 0; k--) {\\n            if (nums[k] < nums[k + 1]) {\\n                for (l = n - 1; l > k; l--) {\\n                    if (nums[l] > nums[k]) {\\n                        break;\\n                    }\\n                } \\n                swap(nums[k], nums[l]);\\n                reverse(nums.begin() + k + 1, nums.end());\\n                break;\\n            }\\n        }\\n    \\tif (k < 0) {\\n    \\t    reverse(nums.begin(), nums.end());\\n    \\t}\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1846325,
                "title": "c-detailed-explanation-with-comments-with-example",
                "content": "Steps involved;\\nExample: find next permutation of {1,2,5,4,3}\\nfirstly select the no. which is lesser then its next element,while checking from backward  ans store its index j\\nfor this example .no is  2 of index 1,stored in j;\\nNow search for the least no which is greater then it starting last index;\\nHere its 3 of index  4;\\n\\nThen swap these,and reverse  from the index j+1;\\nswapping: {1,3,5,4,2};\\nreversing from j+1=1+1=2\\n{1,3,2,4,5} ans\\n\\nThe expection is that,if the no is in desending order,it means our loop will reach to i=-1 before breaking,so the next pemutation will be the no in ascending order or say reverse of current no.for ex:{4,3,2,1} its next permut: {1,2,3,4}\\n\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```\\n**Please do upvote if u find useful,It motivates me to post more such**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n     \\n        int n=nums.size();\\n        int i,j=0;\\n        for(i=n-2;i>=0;i--){\\n            \\n            if(nums[i]<nums[i+1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n          if(i==-1){\\n\\t\\t  reverse(nums.begin(),nums.end());   //for cases like {3,2,1}\\n\\t\\t  return;\\n\\t\\t  }\\n        \\n        for(i=n-1;i>j;i--){\\n            if(nums[i]>nums[j]){\\n                swap(nums[i],nums[j]);\\n                \\n                break;\\n            }\\n        }\\n      \\n       reverse(nums.begin()+j+1,nums.end());\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775228,
                "title": "c-easy-and-original-solution-with-comments",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n\\t// start from end\\n\\tfor (int i=nums.size()-1; i>=1; i--){ \\n\\t\\t\\t// if there is an number that is smaller than the next number, that means we can start swapping\\n\\t\\t\\tif (nums[i]>nums[i-1]){\\n\\t\\t\\t\\t// we search for the smallest number(but larger than current number) in the remaining vector and swap\\n\\t\\t\\t\\tfor (int j=nums.size()-1; j>=i; j--){\\n\\t\\t\\t\\t\\tif (nums[j]>nums[i-1]){\\n\\t\\t\\t\\t\\t\\tswap(nums[i-1],nums[j]);\\n\\t\\t\\t\\t\\t\\t// sort the remaining vector so its smallest possible with index i being the new number\\n\\t\\t\\t\\t\\t\\tsort(nums.begin()+i,nums.end());\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t}\\n\\t\\t}\\n\\tsort(nums.begin(),nums.end());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1392551,
                "title": "c-easy-to-understand-fast-intuitive",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n      int n=nums.size();\\n        int i,k;\\n        for(i=n-2;i>=0;i--)\\n        {\\n            if(nums[i]<nums[i+1])\\n            {\\n                break;\\n            }    \\n        }    \\n        if(i<0)\\n        reverse(nums.begin(),nums.end());\\n        else\\n        {\\n            for(k=n-1;k>=0;k--)\\n            {\\n                if(nums[k]>nums[i])\\n                break;\\n            }\\n            swap(nums[i],nums[k]);\\n            reverse(nums.begin()+i+1,nums.end());\\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1373821,
                "title": "optimized-solution-with-explanation-in-java-along-with-video",
                "content": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```\\nBackward traverse the array until we find the two consecutive numbers such that nums[i] < nums[i + 1]. Because the numbers to the right of nums[i] are in descending order, so we can\\'t make that part bigger.\\n\\nNow we need to backward traverse the array again to find the first number nums[j] such that nums[j] > nums[i], and then swap them to generate a bigger number, as we need to generate the smallest permutation that is greater than the original number.\\n\\nAfter swapping nums[i] and nums[j], we need to reverse the numbers to the right of nums[i] to force this part to be the smallest. As swapping nums[i] and nums[j] doesn\\'t change the fact that the numbers to the right of nums[i] are still in descending order. So reversing this part can make its value smallest and meanwhile achieve O(N) time complexity. If we use sorting, then the complexity of this part will be O(NlogN).\\n\\n\\nTime compleixty: O(N)\\nSpace complexity: O(1)\\n\\n\\n![image](https://assets.leetcode.com/users/images/f758bcfa-a02b-4887-9045-c00cc140499d_1627716482.0443752.png)\\n\\nDetailed Explanation with Video:\\nyoutu[dot]be/un9_wSaxn7w\\n(Replace [dot] with .)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        if(nums.length <=1){\\n            return;\\n        }\\n        \\n        int i=nums.length-2;\\n        for(;i>=0;i--){\\n            if(nums[i] < nums[i+1]){\\n                break;\\n            }\\n        }\\n        \\n        if(i==-1){\\n            reverse(nums, 0, nums.length-1);\\n            return;\\n        }\\n        \\n        int j=nums.length-1;\\n        for(;j>=0;j--){\\n            if(nums[j]>nums[i]){\\n                break;\\n            }\\n        }\\n        \\n        swap(nums, i, j);\\n        reverse(nums, i+1, nums.length-1);\\n        \\n    }\\n    \\n    private void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    private void reverse(int[] nums, int start, int end){\\n        while(start < end){\\n            swap(nums, start, end);\\n            start++;\\n            end--;\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179173,
                "title": "c-fully-detailed-solution",
                "content": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "solutionTags": [],
                "code": "So what do we mean my next permutation of the array\\n\\n# lets learn by basic concept of the permutation - \\n\\nso one of the test case be nums = {1,2,3} and the next permutaion be {1,3,2}\\n\\nso we have\\n\\n![image](https://assets.leetcode.com/users/images/566ca29b-45c5-4eaf-b33a-72ca1af46338_1619532968.2147515.png)\\n\\nSo with the help of the given recursion tree \\n\\nfor the first branch\\n\\n[1, , ,]  ->  we have two choices and than next child have only one possibility and that\\'s our answer but now how do we know that\\'s our answer \\nIf we see clearly that by recursion tree first change will we can made is in level 2 (from level 0) \\nSo if we have 1 as root than we have two choices so criteria for selecting the 2 and 3 is base on the last element as we always going to have one choice\\n\\nSo by the basics of the permutation algorithm - \\nWe can have following intutuion for the question given to us\\n\\n# Step1 - Find the first position in the array which follow the nums[i] > nums[i-1] for the ith element \\n# Step2 - After selecting the ith position we search for the next greater element than the ith element\\n# Step3 - Swap the both the current element at index i and next greater element\\n# Step4 - Reverse the numbers next to the ith position\\nFollow following step we will able to solve the question in **O(n) - time complexity and O(1) - time complexity**\\n\\n# Code -   \\n![image](https://assets.leetcode.com/users/images/6663e1a1-368a-4c0f-9a6b-636a35ee72f6_1619533848.548016.png)\\n\\nTo strengthen the grip on this algorithm try to solve following question\\n**1830. Minimum Number of Operations to Make String Sorted**\\n\\nI hope my explanation is enough for you guys to proceed.",
                "codeTag": "Unknown"
            },
            {
                "id": 1151884,
                "title": "100-faster-c-next-permutation",
                "content": "***Do upvote if you found it helpful as it motivates me to post more content***\\n***Make sure to make a dry run for better understanding***\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }\\n        }\\n        \\n        if(idx==-1) // if given in descending order then reverse it\\n            reverse(v.begin(),v.end());\\n        \\n        else\\n        {\\n              prev=idx;\\n            for(i=idx+1;i<n;i++)\\n            {\\n                if((v[i]>v[idx-1]) && (v[i]<=v[prev]))\\n                    prev=i;\\n            }\\n             swap(v[idx-1],v[prev]);\\n             reverse(v.begin()+idx,v.end());\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& v) {\\n        int idx=-1;\\n        int n=v.size();\\n        int i,prev;\\n        for(i=n-1;i>0;i--)\\n        {\\n            if(v[i]>v[i-1]) \\n            {\\n                idx=i;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1029262,
                "title": "c-10-lines-0ms-beats-100",
                "content": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```\\ni wrote this solution 2 weeks ago. \\nthe reason i came back to this solution is because I was doing [https://leetcode.com/problems/permutation-sequence/](http://) and thought i could resue codes in this problem. \\n",
                "solutionTags": [],
                "code": "```\\nvoid nextPermutation(vector<int>& nums) {\\n        for(int i = nums.size()-1; i >= 0; i--){\\n            for(int j = nums.size()-1; j >= i; j--){\\n                if(nums.at(j) > nums.at(i)){\\n                    swap(nums.at(j),nums.at(i));\\n                    reverse(nums.begin()+i+1, nums.end());\\n                    return;\\n                }\\n            }\\n        }\\n        reverse(nums.begin(), nums.end());             \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 724118,
                "title": "python3-solution",
                "content": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "solutionTags": [],
                "code": "```\\nimport bisect\\nclass Solution:\\n    \\n    def reverse(self,nums,low,high):\\n        while low<=high:\\n            nums[low],nums[high] = nums[high],nums[low]\\n            low+=1\\n            high-=1\\n    \\n    def nextPermutation(self, nums: List[int]) -> None:\\n        length = len(nums)\\n        i = length-2\\n        index = None\\n        while i>=0:\\n            if nums[i]<nums[i+1]:\\n                index = i\\n                break\\n            i = i-1\\n        if index==None:\\n            self.reverse(nums,0,length-1)\\n        else:\\n            self.reverse(nums,index+1,length-1)\\n            swap_index = bisect.bisect_right(nums,nums[index],index+1,length-1)\\n            nums[index],nums[swap_index] = nums[swap_index],nums[index]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375358,
                "title": "c-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }\\n        if(i==0) return reverse(nums.begin(), nums.end());\\n        pos=i-1;\\n        \\n        for(i=n-1; i>pos && i>=0; i--){\\n            if(nums[i]>nums[pos]){\\n                swap(nums[i], nums[pos]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin() + pos+1, nums.end());\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        if(nums.size()<=1) return;\\n        int n= nums.size(), pos, i;\\n        \\n        for(i=n-1; i>=1; i--){\\n            if(nums[i-1]<nums[i])\\n               break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 327076,
                "title": "python-24ms-beats-94-with-step-by-step-explanation",
                "content": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        card = len(nums)\\n        \\n        for k in range(card-1):             # check if a greater arrangement is not possible\\n            if nums[k] < nums[k+1]:\\n                break\\n        else:\\n            nums.reverse()                  # if it\\'s not possible - reverse sequence and stop\\n            return\\n\\n        for i in range(card - 1, 0, -1):    # card-1, card-2, card-3, ..., 2, 1\\n            if nums[i] > nums[i - 1]:       # from the end of sequence find the first decreasing element (\\'nums[i-1]\\')\\n                low = nums[i]\\n                \\n                # among afterward digits (nums[i]...nums[card-1]) we find the smallest digit (\\'low\\') that is bigger then \\'nums[i-1]\\'\\n                for n in range(i+1, card):  \\n                    if nums[i-1] < nums[n] < low:\\n                        low = nums[n]\\n\\n                low_index = nums.index(low, i) \\n                nums[i - 1], nums[low_index] = nums[low_index], nums[i - 1]  # swap \\'nums[i-1]\\' and \\'low\\' in a sequence\\n            \\n                for iter_num in range(card-1, i, -1):  # sort afterward digits (nums[i]...nums[card-1])\\n                    for idx in range(i, iter_num):     # PS: this is Bubble Sort algorithm, but you can choose smth faster\\n                        if nums[idx] > nums[idx + 1]:\\n                            nums[idx + 1], nums[idx] = nums[idx], nums[idx + 1]\\n                break                                  # STOP\\n```",
                "codeTag": "Java"
            },
            {
                "id": 301074,
                "title": "swift-16ms-100-beat-using-internet-logix",
                "content": "Check it out on the web. It\\'s good.\\n\\n```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```\\n\\nDig?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    func nextPermutation(_ nums: inout [Int]) {\\n        \\n        if nums.count <= 0 { return }\\n        \\n        var switchIndex: Int?\\n        var prev = nums.last!\\n        var i: Int = nums.count - 2\\n        \\n        while i >= 0 {    \\n            if nums[i] < prev {\\n                switchIndex = i\\n                break\\n            }\\n            prev = nums[i]\\n            i -= 1\\n        }\\n        \\n        guard let index = switchIndex else {\\n            nums.reverse()\\n            return\\n        }\\n        \\n        var successorValue: Int?\\n        var successorIndex: Int = index + 1\\n        \\n        for i in index+1..<nums.count {\\n            if nums[i] > nums[index] {\\n                if let value = successorValue {\\n                    if nums[i] <= value {\\n                        successorValue = nums[i]\\n                        successorIndex = i\\n                    }\\n                } else {\\n                    successorValue = nums[i]\\n                    successorIndex = i\\n                }\\n            }\\n        }\\n        \\n        nums.swapAt(successorIndex, index)\\n        nums[(index+1)...].reverse()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291800,
                "title": "simple-c-solution-beats-99",
                "content": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int i = 0;\\n        for(i = nums.size() - 2 ; i >= 0 ; i--){\\n            if(nums[i] < nums[i+1])break;\\n        }\\n        sort(nums.begin() + i + 1,nums.end());\\n        for(int j = i; j < nums.size();j++ ){\\n            if(nums[j] > nums[i]){\\n                swap(nums[i] , nums[j]);\\n                return;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 213308,
                "title": "simple-javascript-solution-beats-100",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void} Do not return anything, modify nums in-place instead.\\n */\\nvar nextPermutation = function(nums) {\\n    function swap(a, b) {\\n        const temp = nums[a]\\n        nums[a] = nums[b]\\n        nums[b] = temp\\n    }\\n    \\n    function reverse(start) {\\n        let end = nums.length - 1\\n        while (start < end) {\\n            swap(start, end)\\n            start++\\n            end--\\n        }\\n    }\\n    \\n    \\n    let i = nums.length - 2;\\n    while (i >= 0 && nums[i + 1] <= nums[i]) {\\n        i--;\\n    }\\n    if (i < 0) {\\n        reverse(0);\\n        return;\\n    }\\n    let j = nums.length - 1;\\n    while (j >= 0 && nums[j] <= nums[i]) {\\n        j--;\\n    }\\n    swap(i, j);\\n    reverse(i + 1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 119205,
                "title": "simple-python-code",
                "content": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: void Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        # 1. get the start index of non-increasing sequence from tail\\n        # 2. swap\\n        # 3. sort the non-increasing\\n        if not nums: return nums\\n        l = len(nums)\\n        i, j = l - 2, l - 1\\n        while i >= 0 and nums[i] >= nums[i+1]:\\n            i -= 1\\n        while j > i and nums[j] <= nums[i]:\\n            j -= 1\\n        nums[i], nums[j] = nums[j], nums[i]\\n        nums[i+1:] = sorted(nums[i+1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 14000,
                "title": "a-mathematical-solution-accepted-as-best-in-c-well-explained",
                "content": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "The following algorithm from [wiki][1] generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place.\\n\\n - Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation.\\n - Find the largest index l greater than k such that a[k] < a[l].\\n - Swap the value of a[k] with that of a[l].\\n - Reverse the sequence from a[k + 1] up to and including the final element a[n].\\n\\nAs for the demonstration, it will be presented in the comments of the solution as follows for your better understanding.\\n\\n----------\\n\\n    void swap(int* p, int* q)\\n    {\\n        int t = *p; *p = *q; *q = t;\\n    }\\n    void reverse(int* nums, int begin, int end)\\n    {\\n        for(int i = begin; i < (begin+end+1)/2; i++)\\n            swap(nums+i, nums+end+begin-i);\\n    }\\n    void nextPermutation(int* nums, int size)\\n    {\\n        int i=size-1, j=size-1;\\n        while(i>0 && nums[i]<=nums[i-1]) i--; //make sure the [i..size-1] is in descending order;\\n        if(i==0) //the whole array is descending now, reverse it to the smallest as problem requires;\\n        {\\n            reverse(nums, 0, size-1);\\n            return ;\\n        }\\n        while(nums[j] <= nums[i-1]) j--; //find the first bigger one backwards;\\n        swap(nums+j, nums+i-1); //ensure the next is bigger;\\n        reverse(nums, i, size-1); //since [i..size-1] is descending, after reverse it will be ascending and as a result - [i..size-1] will be the smallest - the smallest in the bigger results - the next permutation;\\n    }\\n\\n\\n  [1]: https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order",
                "codeTag": "Unknown"
            },
            {
                "id": 14008,
                "title": "20-line-1ms-in-place-java-code-with-expalantion",
                "content": "> 1. scan from right to left, find first pair where a[i] > a[i-1]. note that a[i:] is non-ascending.\\n> 2. scan from right to left again, find first element a[j] where a[j] > a[i-1]. since a[i:] is non-ascending, a[j] is the smallest number that > a[i-1].\\n> 3. swap a[i-1] with a[j]. note that after swap, a[i:] remains non-ascending.\\n> 4. reverse a[i:] so that a[i:] becomes non-descending.\\n\\n    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }\\n            if (p == 0) {  // case like [3,2,1]\\n                reverse(nums, 0, nums.length-1);\\n                return;\\n            }\\n            int q = nums.length-1;\\n            while (nums[q]<=nums[p-1]) { --q; }\\n            int temp = nums[p-1]; nums[p-1] = nums[q]; nums[q] = temp;\\n            reverse(nums, p, nums.length-1);\\n        }\\n        \\n        private void reverse(int[] a, int from, int to) {\\n            for (; from < to; ++from, --to) {\\n                int temp = a[from];\\n                a[from] = a[to];\\n                a[to] = temp;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int p = nums.length-1;\\n            while (p>0 && nums[p]<=nums[p-1]) { --p; }",
                "codeTag": "Java"
            },
            {
                "id": 14055,
                "title": "one-loop-simple-java-solution-with-comments",
                "content": "    public class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }\\n            }\\n            if(index == -1) Arrays.sort(nums);\\n            else {\\n                //sort the right part of index and swap the index with the min of nums bigger than nums[index] in the right part\\n                Arrays.sort(nums, index+1, len);\\n                for(int i=index+1; i<len; i++) {\\n                    if(nums[i] > nums[index]) {\\n                        swap(nums, i, index);\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        public void swap(int[]nums, int i, int j) {\\n            int tmp = nums[i];\\n            nums[i] = nums[j];\\n            nums[j] = tmp;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void nextPermutation(int[] nums) {\\n            int len = nums.length;\\n            int index = -1;\\n            //find out the index that is not ascending from right most\\n            for(int i=len-2; i>=0; i--) {\\n                if(nums[i] < nums[i+1]) {\\n                    index = i; break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 14073,
                "title": "4-line-12ms-c-code",
                "content": "    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }\\n    };\\n\\nThanks for the upper_bound idea from:\\nhttps://leetcode.com/discuss/41925/solution-lines-imitate-next_permutation-bring-binary-search\\n\\notherwise I search it myself:\\n\\n    class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i,j;\\n            \\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            if (i)\\n            {\\n                for(j = nums.size() - 1; nums[j] <= nums[i-1];j--);\\n                swap(nums[i-1],nums[j]);\\n            }\\n            std::reverse(nums.begin() + i, nums.end());\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void nextPermutation(vector<int>& nums) {\\n            int i;\\n            for(i = nums.size() - 1;i > 0 && nums[i-1] >= nums[i];i--);\\n            std::reverse(nums.begin() + i, nums.end());\\n            if (i>0) swap(nums[i-1],*upper_bound(nums.begin() + i, nums.end(),nums[i-1]));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 14079,
                "title": "my-12ms-c-solution-use-reverse-iterator-very-easy-to-understand",
                "content": "the next permutaion could be like this.\\n\\n 1. find the first element which is great than the previous one from the\\n    last.\\n 2. then judge whether it is the first element of the vector or not .if\\n    it is the first element ,it means the vector is descent ,like this\\n    [5,4,3,2,1]\\n 3. then just sort it ascend.if it is not ,then swap the iter+1 to the\\n    minimum element which is great than iter+1.then sort the remaining\\n    vector.\\n\\n    class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }\\n                }\\n            }\\n            swap(*(iter+1),*upper);\\n            \\n            //sort the element\\n            sort(nums.rbegin(),iter+1,greater<int>());\\n        }\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        \\n        if(nums.size()<2) return ;\\n        \\n        //use reverse iterator,because we want to iterate from the last to the first element\\n        auto iter=nums.rbegin();\\n        \\n        //find first element that is greater than the previous one.this time *(iter+1) is greater than *iter\\n        while(iter!=(nums.rend()-1)&&*iter<=*(iter+1))\\n            iter++;\\n            \\n        //if iter point to the first element .which means the origin vecotr is descand,just sort the vector\\n        if(iter==nums.rend()-1)\\n            sort(nums.begin(),nums.end());\\n        else\\n        {\\n            //or swap iter+1 to the element which is the mixest one but great than itself\\n            auto upper=iter;\\n            auto tmp=nums.rbegin();\\n            for(;tmp!=iter;tmp++)\\n            {\\n                if(*tmp>*(iter+1))\\n                {\\n                    if(*tmp<*upper)\\n                    {\\n                        upper=tmp;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4056343,
                "title": "c-one-line-code-2-approaches",
                "content": "# *PLEASE UPVOTE GUYS \\uD83E\\uDD79*\\n\\n\\n# Approach**\\n1. **With inbuilt STL function** \\n\\n2. **pointers**\\n- The nextPermutation function takes a vector nums as input and is used to find the next lexicographically greater permutation of the elements in nums.\\n\\n- It first calculates the size of the nums vector and initializes the index variable to -1.\\n\\n- It searches for the first element index from the right (starting from the second-to-last element) such that nums[i] is less than nums[i+1]. This step helps identify the rightmost element that can be modified to create a greater permutation.\\n\\n- If an index is found (i.e., there\\'s a possible next permutation), it proceeds to find the smallest element greater than nums[index] from the right. This element is found by iterating from the right end of the vector. Once found, it swaps this element with nums[index].\\n\\n- Finally, it reverses the elements to the right of index. This step ensures that the remaining elements to the right are in ascending order, making the permutation as small as possible while still being greater than the original.\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n                  ----------Approach 1----------\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        next_permutation(nums.begin(),nums.end());\\n    }\\n};\\n\\n                  ----------Approach 2----------\\n\\nclass Solution {\\npublic:\\n    // Function to find the next lexicographically greater permutation of \\'nums\\'\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size(); // Get the size of the \\'nums\\' vector\\n        int index = -1; // Initialize \\'index\\' to -1\\n\\n        // 1. Find the first element \\'index\\' from the right such that nums[i] < nums[i+1]\\n        for (int i = n - 2; i >= 0; i--) {\\n            if (nums[i] < nums[i + 1]) {\\n                index = i;\\n                break;\\n            }\\n        }\\n\\n        // 2. If \\'index\\' is found, find the smallest element greater than nums[index] from the right\\n        if (index != -1) {\\n            for (int i = n - 1; i >= index; i--) {\\n                if (nums[i] > nums[index]) {\\n                    swap(nums[i], nums[index]); // Swap nums[i] and nums[index]\\n                    break;\\n                }\\n            }\\n        }\\n\\n        // 3. Reverse the elements to the right of \\'index\\'\\n        reverse(nums.begin() + index + 1, nums.end());\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002581,
                "title": "leetcode-31-next-permutation-c-solution-explanation-and-complexity-analysis",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start by traversing the list of numbers from right to left until you find the first element (let\\'s call it nums[i]) that is smaller than its right neighbor (nums[i+1]). This element is the first candidate for swapping.\\n\\n- It simply means that if we have a number that is greater that number nums[i] on the right we can get an array that is greater (lexicographically ordering of elements) than the current number and as the permutation are in lexicographical order we can get our next permutation just by manipulating the elements on the right side.\\n\\n- If no such element is found (i.e., if i becomes -1), it means that the list is in descending order, and there is no greater permutation possible. In this case, reverse the entire list to obtain the smallest permutation and return it.\\n\\n- If you found an element to swap (i.e., i is not -1), proceed to find the smallest element to the right of nums[i] that is just greater than nums[i]. This is done by traversing the list again from right to left and stopping when you find an element greater than nums[i]. Let\\'s call this element nums[j].\\n\\n- Swap nums[i] and nums[j] to get the array that will have greater value.Like in [1,2,3,2,1] doing above steps will get us to [1,3,2,2,1].Since we got our array greater by just with index (i), the value of array on the right side of (i) must be lowest to get the next permutation.\\n\\n- Finally, sort the elements to the right of nums[i] in ascending order to ensure you have the next greater permutation.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void nextPermutation(vector<int>& nums) {\\n    int n = nums.size(), i = n - 2;\\n    while(i >= 0 && nums[i] >= nums[i + 1])i--;\\n    if(i < 0){\\n      reverse(nums.begin() + i + 1, nums.end());\\n      return;\\n    }\\n    int j = n - 1;\\n    while(j > i && nums[j] <= nums[i])j--;\\n    swap(nums[i], nums[j]);\\n    sort(nums.begin() + i + 1, nums.end());\\n  }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910626,
                "title": "better-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n=nums.size();\\n        int imp=n-1;\\n        while(imp>=0)\\n        {\\n               if(imp==0)\\n            break;\\n            if(nums[imp]<=nums[imp-1])\\n            {\\n                imp--;\\n            }\\n            else\\n            break;\\n         \\n        }\\n        if(imp!=0)\\n        {\\n            int greater=-1;\\n            for(int i=imp;i<n;i++)\\n            {\\n                if(greater==-1 || nums[greater]>nums[i])\\n                {\\n                   if(nums[imp-1]<nums[i])\\n                   {\\n                       greater=i;\\n                   }\\n                }\\n            }\\n            swap(nums[greater], nums[imp-1]);\\n        }\\n        sort(nums.begin()+imp, nums.end());\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3781549,
                "title": "c-optimized-approach-with-step-by-step-solution",
                "content": "# Intuition\\nI referred to a youtube video for Lexicographical ordering | Order of permutation | Discrete Mathematics\\n# Approach\\nThis can be divided into four Steps:\\n\\n**Step 1:** Find the largest value of i such that nums[i-1] < nums[i]\\n\\nA short note (If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation as in lexicographic orderring leading zeros are significant)\\n\\n**Step 2:** Find the largest value of j such that nums[i-1] < nums[j]\\n**Step 3:** Interchange nums[i-1] and nums[j]\\n**Step 4:** Reverse the numbers from index i to the end\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```\\nA pro tip I just discovered that you can directly use next_permutation(nums.begin(),nums.end());",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void nextPermutation(vector<int>& nums) {\\n    int n = nums.size();\\n    \\n    // Step 1: Find the largest value of i such that nums[i-1] < nums[i]\\n    int i = n - 1;\\n    while (i > 0 && nums[i-1] >= nums[i])\\n        i--;\\n    \\n    // If i is 0, it means the array is in descending order, so we reverse it to get the smallest permutation\\n    if (i == 0) {\\n        reverse(nums.begin(), nums.end());\\n        return;\\n    }\\n    \\n    // Step 2: Find the largest value of j such that nums[i-1] < nums[j]\\n    int j = n - 1;\\n    while (nums[j] <= nums[i-1])\\n        j--;\\n    \\n    // Step 3: Interchange nums[i-1] and nums[j]\\n    swap(nums[i-1], nums[j]);\\n    \\n    // Step 4: Reverse the numbers from index i to the end\\n    reverse(nums.begin() + i, nums.end());\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765713,
                "title": "c-fully-optimised-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index=-1;\\n        for(int i=nums.size()-1;i>0;i--){\\n            if(nums[i]>nums[i-1]){\\n                index=i-1;\\n                break;\\n            }\\n        }\\n        //finding the break point \\n        // now stored in index\\n\\n        if(index==-1){\\n            sort(nums.begin(),nums.end());\\n            return ;\\n        }\\n        // if no break point we sort the array and return\\n        // else\\n        for(int i=nums.size()-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                swap(nums[i],nums[index]);\\n                break;\\n            }\\n        }\\n        //swaping the min element which is greater than break point \\n        // and now sorting the remaining elements to get the next permutation\\n        sort(nums.begin()+index+1,nums.end());\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758581,
                "title": "easiest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n        \\n        int i = nums.length-2;\\n        \\n        while(i>=0 && nums[i+1] <= nums[i]){\\n            i--;\\n        }\\n        if(i >= 0){\\n            int j = nums.length - 1;\\n            while(nums[j] <= nums[i]){\\n                j--;\\n            }\\n            swap(nums,i,j);\\n        }\\n        reverse(nums, i+1);\\n        \\n    }\\n    \\n    public void swap(int[] nums, int i, int j){\\n        int temp = nums[i];\\n        nums[i] = nums[j];\\n        nums[j] = temp;\\n    }\\n    \\n    public void reverse(int[] nums, int i){\\n        int j= nums.length-1;\\n        \\n        while(i<j){\\n            swap(nums, j, i);\\n            i++;\\n            j--;\\n        }\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3691414,
                "title": "java-clean-code-beats-100-with-explanation",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void nextPermutation(int[] arr) {\\n        //1286931-->1289631-->1289136(ans)\\n        // find 1st decreasing element from the right\\n        int temp=0,i,min=Integer.MAX_VALUE,pivot=0,pos=0;\\n        for ( i=arr.length-1;i>=1;i--)\\n            if (arr[i]>arr[i-1])\\n            {\\n                pivot=i;break;\\n            }\\n        // find no. just larger than arr[pivot-1]\\n        if (pivot>0)//to check if there is a decreasing element to the left of pivot(i.e.pivot!=0)\\n        {\\n            for (i=pivot;i<arr.length;i++)\\n            {\\n                if (arr[i]>arr[pivot-1])\\n                    min=Math.min(min,arr[i]);\\n                if (min==arr[i])\\n                    pos=i;\\n            }\\n            //swap min and arr[pivot-1]\\n            swap(arr,pos,pivot-1);\\n        }\\n\\n        //reverse from pivot to end\\n        int high=arr.length-1;\\n        while(pivot<=high){\\n            swap(arr,pivot,high);\\n            high--;pivot++;\\n        }\\n    }\\n    private void swap(int[] arr,int low,int high){\\n            int temp=arr[low];\\n            arr[low]=arr[high];\\n            arr[high]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565400,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565269,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565562,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570786,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1565167,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1567466,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1568712,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1569214,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1570729,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1566711,
                "content": [
                    {
                        "username": "alexpoo",
                        "content": "I\\'ve just failed a pliminary Facebook interview with this question. \\nAfter some retrospec about my thought process, here is the intiution that might have worked for me:\\n\\nWe want to find a larger number, but not too large - just the next larger one =>\\nWe want to avoid chaning the number in the left - it will increase the number too much =>\\nExample: 43254**13** -> we can only change the last two numbers and have 4325**31** \\nWhat if it was 4325**31** in the first place? 31 cannot be increased.\\nLets try 531 - still no\\n2531 - this can be incrased - the smallest number that can be used to incrase the 2 is 3. so for now we have 3521. \\nNext we want to minimize 3521 - thats easier - just sort the numbers to the right of 3 - 3125. So the unswer is 4323125\\n"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Amazing thought process"
                    },
                    {
                        "username": "akmsabbir03",
                        "content": "it is not a good interview question. you need to know a specific algorithm for this. look like the interviewer wants you to fail. One of the purpose of an interview is that you will be given a problem so that you can start solving it. once you have a base solution then you will start applying different kind of optimization. Now, in this problem you need to know a specific algorithm to solve there is no base solution and optimization process is required. Therefore, it is not an interview question. if someone giving you this problem then there is something wrong about him."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "musicmaker99",
                        "content": "Problem description is useless. I had to google what on earth it meant. Examples don\\'t tell you what is going on or what is expected. Needs improvement."
                    },
                    {
                        "username": "BasedBrenden",
                        "content": "[@cartesPerforees](/cartesPerforees) Survivorship Bias in full display here."
                    },
                    {
                        "username": "olsonpm",
                        "content": "[@cartesPerforees](/cartesPerforees) the number of downvotes on this question indicates the question could use improvement.  There are a lot of questions on this site that could use drastic improvement, as also indicated by the frequent large ratio of downvotes."
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "happyfase",
                        "content": "[@cartesPerforees](/cartesPerforees) You sound like you have really low self-esteem. Hang in there man."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I personnally understood the problem from the description, which makes it pretty useful as far as I am concerned. \\nYou can either choose to blame leetcode for not holding your hand enough, or work on your problem reading/interpretation skill. "
                    },
                    {
                        "username": "kibi_kyl",
                        "content": "It wasn\\'t clear to me from the description what this problem was asking for.\\nIn hopes of helping out I have boiled it down to what makes the most sense to me.\\n\\n\\n Say we want to find all the different ways we can arrange the numbers in this array: [1,2,3]\\n These possibilities are:\\n\\n [1,2,3]\\n [1,3,2]\\n [2,1,3]\\n [2,3,1]\\n [3,1,2]\\n [3,2,1]\\n\\n \\n If you have seen this method of tracking all possible combinations, then this question is just asking:\\n \"If you are given an array that could be at any stage during this process, what is the array\\'s next stage?\"\\n\\n The above list is in order, so you only need to look to the next line to see what its next stage is. \\n If you are given the array at the last stage, then you should just return the first stage as the next.\\n\\n That\\'s it.\\n \\n If you are unfamiliar with the process above, I will walk through it: \\n\\n x = placeholder for a number we haven\\'t chosen yet.\\n\\n start:\\n [x,x,x].\\n In order to make sure we don\\'t double count arrangements, we start with the smallest number first, \\n find all possible arrangements with that number as the lead, then move on to the next smallest number\\n in that position and repeat until all numbers have been used in the starting position. \\n Here is a step-by-step process:\\n Of the numbers we have available, 1 is the smallest, so we use it initially in the first position.\\n So, our first arrangement is: \\n [1,x,x].\\n for the next position we repeat this process: Of the available numbers, (which are: (2,3).)\\n which is the smallest? 2 is the smallest available, so we use it and continue to the next position.\\n our arrangement is now: \\n [1,2,x]. \\n The only number left is 3, so there is only 1 possible way to arrange the remaining numbers.\\n So, we mark down:\\n [1,2,3]. \\n this is the first complete arrangement, and we backtrack a level to continue.\\n We are back at:\\n [1,x,x].\\n We have already used the 2 in the next position, so of the remaining numbers available we choose the \\n smallest of those to go next. The only number available is 3 so we use 3 as our next number. our arrangement is now:\\n [1,3,x].  \\n next we repeat the process with finding the smallest of the available numbers: which is only 2. so we then have:\\n [1,3,2].\\n We mark this as the next complete arrangement and we again backtrack a level:\\n [1,x,x].\\n This time we have used all available numbers in this position, so we have no numbers left to use here.\\n because of this we backtrack again and end back at the starting position:\\n [x,x,x].\\n The only number we cannot use as the next position is 1, as it was already used here. of the remaining\\n available numbers, 2 is the next smallest. So, we place 2 next and our arrangement is now:\\n [2,x,x].\\n The next is:\\n [2,1,x].\\n where we get the next complete arrangement of:\\n [2,1,3].\\n\\n This process repeats just like above until you run out of numbers and there is no place to backtrack to.\\n The longer the array the longer it takes this process to complete, this is just a simple example.\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "SharmaTushar1",
                        "content": "This problem is no way a medium problem if you don\\'t know the answer or algorithm already."
                    },
                    {
                        "username": "jackhammervyom",
                        "content": "Honestly, it took me some time to crack this, I didn't look it up, I tried a few test cases and cracked the algorithm, I think the permutation thing throws you off. Its just finding the number just greater than the current one, thinking in that aspect got me to the solution."
                    },
                    {
                        "username": "Sagar20032002",
                        "content": "[@aryanagarwal858](/aryanagarwal858) cout<<\"easy problem<<endl;"
                    },
                    {
                        "username": "ranbir7",
                        "content": "[@aryanagarwal858](/aryanagarwal858) only if u use the permutations function and also u learn how to code nd generate permutations of a given array..... \\nRest is easy. "
                    },
                    {
                        "username": "atharvgoel11",
                        "content": "[@aryanagarwal858](/aryanagarwal858)  i feel hard..."
                    },
                    {
                        "username": "aryanagarwal858",
                        "content": "what is this according to you an easy problem?"
                    },
                    {
                        "username": "LieFengXiXi",
                        "content": "can someone explain this question to me orz, I just dont understand what does it mean..."
                    },
                    {
                        "username": "rayrogar",
                        "content": "[@JaredMathis](/JaredMathis) You are good my friend, your logic is really easy but really good. I personally have to run many test cases to understand the problem and finally get the idea of that we need to find the smallest number, just bigger that the one there are given to us, after move the numbers in the array. The trouble was obtimize this!!!"
                    },
                    {
                        "username": "JaredMathis",
                        "content": "If you have some numbers like 1234 a permutation is some order of those. For example:\\n\\n1234\\n1243\\n3214\\n\\nThose are all permutations because they each have 4 numbers and the numbers are identical to the original\\n\\n12344 has all 4 numbers but has 5 digits so it\\'s not valid\\n\\n1233 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n1237 has 4 digits, but it doesn\\'t have a 4 so it\\'s invalid\\n\\n---\\n\\nNext, we\\'re basically asking this:\\n\\nSuppose we count starting at 1234 and ending at 4321. Like 1234, 1235, 1236, ... 4320, 4321. What are all the numbers in between that are permutations?\\n\\nSo 1235 comes after 1234 but it\\'s not a permutation because 5 isn\\'t a number in 1234.\\n\\nThe next number after 1234 that\\'s a permutation of 1234 is 1243.  Then 1324 (I think) and so on."
                    },
                    {
                        "username": "iamshubhamj",
                        "content": "Its difficult to understand at first time as you might not be knowing what they are asking.\\nTo simplify, you have to find a number just bigger by shifting/swapping the digits.\\n\\ne.g. 513 then the next greater will be 531 as 31 > 13 we swapped them to make the number bigger. If the number is larger there can be multiple possibilities here we consider the next greater instead of any greater element\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# AMAZON SDE-1 INTERVIEW | O(N) Approach\n\n\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-on-approach/"
                    },
                    {
                        "username": "gbersac",
                        "content": "I just don\\'t understand what it means. I looked at the solution, I understood it, but I still don\\'t understand what it means."
                    },
                    {
                        "username": "vasujhawar2001",
                        "content": "Do you understand what it means, today?"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/f4e831d2-86c3-4b8b-b63b-2b6f20c684fe_1642094328.0081844.png)\\n\\n![image](https://assets.leetcode.com/users/images/2995ce69-cf9d-4000-9718-655556dc61dd_1642094331.9171438.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDEA9AMAZON\\uD83D\\uDE28 SDE-1 INTERVIEW | O(N) Approach\\uD83D\\uDE4C\\nhttps://leetcode.com/problems/next-permutation/solutions/2362645/amazon-sde-1-interview-o-n-approach/"
                    },
                    {
                        "username": "jrpx",
                        "content": "https://en.wikipedia.org/wiki/Permutation#Generation_in_lexicographic_order\\n\\nGeez... this should be included with the description"
                    },
                    {
                        "username": "Badem48",
                        "content": "Yes, this is definitely missing in the description."
                    },
                    {
                        "username": "AG000-001",
                        "content": "Yes, this is actual solution of problem"
                    },
                    {
                        "username": "ktranada1403",
                        "content": "this is literally the solution"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Could be a hint. Since its the solution"
                    },
                    {
                        "username": "pavel26",
                        "content": "The description defines the following requirement:\\n\\n`0 <= nums[i] <= 100`.\\n\\nThis is confusing and I believe it should be `0 <= nums[i] <= 9` instead. I.e. the elements of the input array are digits (instead of saying _numbers_)."
                    },
                    {
                        "username": "fish-on-github",
                        "content": "[@harishrd](/harishrd) I believe the output of this interpretation is incorrect. For the test case [100, 99, 9], the expected output is [9, 99, 100], but the output [9, 100, 99] forms a smaller lexicographic number (100999 < 910099 < 999100), yet the judge expects 999100. I believe this is in error, unless the premise of the instructions are incorrect or not clearly stated."
                    },
                    {
                        "username": "harishrd",
                        "content": "The question states that the elements of the array are integers, not just digits.\\nFor example:\\n[1, 2, 3] should be rearranged as [1, 3, 2]\\n[10, 20, 30] should be rearranged as [10, 30, 20]"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 3.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/next-permutation/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Brute Force\n\n  \n**Approach 2:** Single Pass Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    }
                ]
            },
            {
                "id": 1575010,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568651,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1568433,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1567030,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1566322,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1804406,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1685039,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1575896,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1570227,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1572944,
                "content": [
                    {
                        "username": "cherockz19",
                        "content": "I am able to understand the problem but I think the \"lexicographic\" word has been incorrectly used here.\\nIsn\\'t it just about sorting the elements as numbers ?\\nFor e.g. \\nInput : [8,11,3]\\nExpected Output: [11,3,8]\\n\\nIf lexicographic, the output should be [8,3,11].\\n\\nPlease correct my understanding if I am mistaken."
                    },
                    {
                        "username": "umishra707",
                        "content": "lexicographically [8,3,11] precedes [8,11,3]. The order is as follows:\\n[3,8,11]\\n[3,11,8]\\n[8,3,11]\\n[8,11,3]\\n[11,3,8]\\n[11,8,3]"
                    },
                    {
                        "username": "Priyanshi_Negi",
                        "content": "I am unable to understand what the questions wants us to do can anyone please explain thanks in advance :)"
                    },
                    {
                        "username": "joshi22",
                        "content": "I find the examples limited and do not understand what is exactly being asked to do. Kindly help."
                    },
                    {
                        "username": "siddhantchimankar",
                        "content": "Without the knowledge of an advanced topic like Backtracking and Generating all permutations of an array, this problem will confuse you and you will end up cramming it. Once you get a hold of these concepts you can proceed to understand the algorithm for this problem annd why we do what we do."
                    },
                    {
                        "username": "rdoshi4",
                        "content": "i/p : [9,10,8,11,3]\\nAccepted solution o/p: [9,10,11,3,8]\\n\\nAs per the lexicographical order it should have been [9,10,8,3,11]"
                    },
                    {
                        "username": "anowarul_karim",
                        "content": "3 comes before 11, not after"
                    },
                    {
                        "username": "anujarya960",
                        "content": "here is optimized code in c++ for next permutation \\n\\nvoid nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int lastPeak=-1;\\n        // find the last peak index in array\\n        for(int i=1; i<n; i++){\\n            if(nums[i] > nums[i-1])\\n                lastPeak=i;\\n        }\\n        // last peak does not exist\\n        if(lastPeak==-1){// array element are descending in order\\n            sort(nums.begin(), nums.end());// we can also reverse array\\n            return ;\\n            }\\n        \\n        // find smallest element in range (nums[lastpeak-1]) to nums[lastpeak] to the right of lastpeak\\n        int index=lastPeak;\\n        for(int i=lastPeak; i<n; ++i){\\n            if(nums[i]<nums[index] && nums[i]>nums[lastPeak-1])\\n                index=i;\\n        }\\n        swap(nums[lastPeak-1] , nums[index]);\\n        sort(nums.begin()+ lastPeak, nums.end());\\n\\n    }\\n\\n"
                    },
                    {
                        "username": "krjukov",
                        "content": "Why duplicate numbers are allowed as per test case 3 nums = [1,1,5]?\\nIt brings ambiguity: impossible to evaluate the number of this permutation.\\nPlease see the description for numbers 1 2 3. For example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\\nI assume the mapping is\\n1 -> 1\\n2 -> 1\\n3 -> 5\\nand combinations now are\\n[1, 1, 5], [1, 5, 1], [1, 1, 5], [1, 5, 1], [5,1,1], [5,1,1]\\nCan you see that we have 3 pairs of duplicates now?"
                    },
                    {
                        "username": "asutkarayush",
                        "content": "And I believe all those combinations are different and should not be treated as same. Please correct me if I\\'m wrong."
                    },
                    {
                        "username": "Nanndy7007",
                        "content": "didn\\'t understand the question neither the testcases, can anyone help me to understand"
                    },
                    {
                        "username": "user9560j",
                        "content": "lexicographical order is alphabetical order. The other type is numerical ordering. Consider the following values,\\n\\n1, 10, 2\\n\\nThose values are in lexicographical order. 10 comes after 2 in numerical order, but 10 comes before 2 in \"alphabetical\" order."
                    },
                    {
                        "username": "leonwang541",
                        "content": "it seems different story if the nums[i]  has two or more digits."
                    }
                ]
            },
            {
                "id": 1569407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1967407,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1928220,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1673006,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1670882,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1636952,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576827,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1576497,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574308,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1574113,
                "content": [
                    {
                        "username": "zhoy_999",
                        "content": "as the question is to get the next lexicalgraphically-ordered sequence, it should consider the different number of digits, not just compare the two integers directly. see this example:\\noriginal sequence:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,1,20,13,10]\\nmy result:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,13,10,1,20]\\nexpected output:\\n[1,20,26,1,15,29,4,29,10,9,21,7,27,11,21,5,9,7,27,16,17,3,6,5,16,23,29,14,28,21,2,29,3,29,0,18,28,5,10,9,6,23,8,25,26,21,1,5,29,28,14,8,10,1,13,20]\\nlast four digits are different:\\norigin: \\n1,20,13,10\\nmy:\\n13,10,1,20\\nexpected:\\n10,1,13,20\\n\\nSee the above, the expected output thinks \\'101\\' is larger than \\'120\\' for the first two number sequence, this is not correct."
                    },
                    {
                        "username": "countdankula",
                        "content": "This needs to be in Hard. Plus the examples should be more intuitive and of bigger length"
                    },
                    {
                        "username": "Ritam_Dasgupta",
                        "content": " `def nextPermutation(self, nums: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        n=len(nums)\\n        if n==1:\\n            return\\n        for i in range(n-2,-1,-1):\\n            if nums[i]<nums[i+1]:\\n                break\\n        \\n        if i==0 and nums[i]>=nums[i+1]:\\n            nums.reverse()\\n            return\\n            \\n            \\n        \\n        minnums=nums[i+1]\\n        minindex=i+1\\n        for j in range(i+1,n):\\n            if nums[j]>nums[i]:\\n                minnums=min(minnums,nums[j])\\n                if minnums==nums[j]:\\n                    minindex=j\\n            \\n        nums[minindex],nums[i]=nums[i],nums[minindex]\\n        nums= list(nums[0:i+1]+nums[n-1:i:-1])\\n        return`\\n\\nWhy is the testcase [1,3,2] failing? When i am running it i am getting correct output."
                    },
                    {
                        "username": "jitendratd",
                        "content": "\n    let i = nums.length-1, k = i;\n    while(nums[k] >= nums[i] && k >= 0) k--;\n    if(k === -1 && nums[++k] > nums[i]){\n        nums = nums.sort();\n        return nums;\n    }    \n    let temp = nums[i];\n    nums[i] = nums[k];\n    nums[k] = temp;\n\n    nums = nums.slice(0, k+1).concat(nums.slice(k+1, nums.length).sort());\n    return nums;\n\n\nCan any one please help me why this code is failling for the test case [1,3,2]. \nIt is not giving correct output in leetcode ide, but working fine iin other js engines."
                    },
                    {
                        "username": "secret_hell",
                        "content": "\ndef nextpermutation(nums):\n    \n    i = len(nums) - 1\n    \n    # if array contains only 2 or only 1 element\n    if len(nums)<=2:\n        return nums[::-1]\n    \n    # case2 if array is in ascending order then next possible sequence would be swapping last two element\n    if nums == sorted(nums):\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n        return nums\n    \n    # checking for first peak with lower weightage\n    while i != 0 and nums[i-1] >= nums[i]:\n        i-=1\n    \n    if i==0:\n        return sorted(nums)\n    peaknxtback=nums[i-1]#3\n    peakval = nums[i]#5\n    j=i\n    x=None\n    while j<len(nums):\n    \n        if peaknxtback<nums[j]<peakval:\n            x=j\n        j=j+1\n      \n    # for case 1 i.e., if the array is in descending order\n    \n    \n    if  x is not None:\n        nums[i-1], nums[x]=nums[x], nums[i-1]\n    # swap if you find the peak value\n    else:\n        nums[i], nums[i-1] = nums[i-1], nums[i]\n    \n    nums= nums[:i]+sorted(nums[i:])\n    \n    return nums\n\n\narr1 = [1,2]\narr2 = [1,1,5]\narr3 = [1,3,5,4,2]\narr4 = [1, 2, 3, 4, 3, 2, 3, 4, 2]\nprint(nextpermutation(arr1))\nprint(nextpermutation(arr2))\nprint(nextpermutation(arr3))\nprint(nextpermutation(arr4))\n\n        \n    \n  # this code is working in vscode but not working in leetcode why...?\nanyone pls help:("
                    },
                    {
                        "username": "user7425K",
                        "content": "My answer is not comming on the test run. it is working fine in my system though. i wonder why this is happening. its happening on the time of submission too. "
                    },
                    {
                        "username": "kartik21928",
                        "content": "![image](https://assets.leetcode.com/users/images/74114f32-c0d4-4060-8c21-280dddb914c4_1653929424.8907866.jpeg)\\n"
                    },
                    {
                        "username": "bearxy39",
                        "content": "The question requires updating the input param `nums` rather than return the result, however, list is immutable in Racket, which means the `nums` list cannot be changed at all. \\n"
                    },
                    {
                        "username": "kdranjan",
                        "content": "Read this to understand lexicographic, before heading to algorithm or coding - great explanation here -  https://www.quora.com/What-is-lexicographic-order"
                    },
                    {
                        "username": "geek_1",
                        "content": "Nice explanation here and code in C++/Java/Python\\nhttps://www.techiedelight.com/find-lexicographically-next-permutations-string-sorted-ascending-order/\\n"
                    }
                ]
            },
            {
                "id": 1573290,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573223,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1573078,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1571870,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1570596,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 1575467,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074673,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2074405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2073000,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2068405,
                "content": [
                    {
                        "username": "bd1",
                        "content": "It is not at all obvious for me that \"you just find the peak and then swap it with the lowest following, and then reverse the rest of the list\". Especially the reverse part... How do you come up with that and prove it\\'s right?"
                    },
                    {
                        "username": "zzznotsomuch",
                        "content": "I wonder how leetcode defines medium vs hard? If you have never seen this problem before, this is definitely a hard!"
                    },
                    {
                        "username": "bhavyamallela123",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "OOPS replied to a 3 year old comment"
                    },
                    {
                        "username": "HarishThotakadsfasura",
                        "content": "Dam Bro got the One Liner\\'s\\n"
                    },
                    {
                        "username": "Struggle20",
                        "content": "I submitted my solution and failed at test case #220, where last 3 numbers in the array are '8,11,3'. My answer is '8,3,11' while expected answer is '11,3,8'. I don't understand why it's like this, since isn't 11 smaller than 8 in alphatical order?"
                    },
                    {
                        "username": "yabbadabbadoo123",
                        "content": "I hate this problem. That being said my basic understanding is that it is comparing individual items and not their parts. So 11 compared to 3. 11 > 3. It does not parse a number down into individual characters. 11 does not become 1,1.\\n\\nThank goodness! The problem would be infinitely harder otherwise!"
                    },
                    {
                        "username": "keiserea",
                        "content": "Im curious, did anyone understand exactly what the problem was asking from the description without any prior knowledge of this problem?"
                    },
                    {
                        "username": "vk94334",
                        "content": "next_permutation(nums.begin(),nums.end());"
                    },
                    {
                        "username": "squigity",
                        "content": " ```\nclass Solution:\n    def nextPermutation(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        from itertools import permutations\n        r: int = len(nums)\n        permutations : list = list(permutations(nums, r))\n        permutations = list(set(permutations))\n        permutations.sort()\n        i: int = permutations.index(tuple(nums))\n        if i + 1 == len(permutations):\n            nums = list(permutations[0])\n        else:\n            nums = list(permutations[i+1])\n    \n    ````\n\ncan someone tell me whats wrong here ?\ntest cases are failing here in leetcode, but locally when im testing im getting the correct answer"
                    },
                    {
                        "username": "user1280Eb",
                        "content": "Why can we not use the back tracking approach for this?"
                    },
                    {
                        "username": "_doomboo_",
                        "content": "very easy leetcode question! this should be rated as easy!"
                    },
                    {
                        "username": "AlphaHokage",
                        "content": "This is no way a medium problem. Such problems are enough to demotivate someone learning DSA for the first time"
                    }
                ]
            },
            {
                "id": 2061766,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2057195,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2053460,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2048586,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2044833,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2036705,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2035692,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029696,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2029289,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2025716,
                "content": [
                    {
                        "username": "520216",
                        "content": "For any one who doesn\\'t understand the question :-\\nfor 123 - next greater number is 132 \\nfor 115 -> next greater number is 151\\nfor 231 -> next greater number is 312\\nfor 321 -> there is not greater than this with this combination. so we give 123\\nSo, it is basically giving next greater number"
                    },
                    {
                        "username": "SiddheshKukade",
                        "content": "why it\\'s  not dp tagged ? "
                    },
                    {
                        "username": "solodjavadev91",
                        "content": "I hate problem like these ones. There is no concept of actually generating any kind of permutation. It is a totally radically different approach to solve it. Jesus."
                    },
                    {
                        "username": "Garv_23",
                        "content": "My code is showing the required output in my VS code editor but its failing the same test Case on the leetCode editor. Is somebody suffering from the same issue for this specific question?"
                    },
                    {
                        "username": "adarshsingh160798",
                        "content": "What\\'s the intuition behind this algo?"
                    },
                    {
                        "username": "BatMe",
                        "content": "Am I dumb or everyone else also struggled to solve this questions on their own? \\n"
                    },
                    {
                        "username": "thanir10",
                        "content": "Hint : Longest Matching Prefix"
                    },
                    {
                        "username": "abhaymishra8765",
                        "content": "i don\\'t know what we have to return in this question it is just void function\\n "
                    },
                    {
                        "username": "charucjoshi",
                        "content": "bhai konsi tak padhe ho?\\n"
                    },
                    {
                        "username": "luffy29",
                        "content": "\\nCan anyone tell me the error in code I am not passing the testcase[3,2,1] my output is 3,2,1 and expected output is 1,2,3\\nvoid nextPermutation(int* nums, int numsSize){\\n     int index=-1;\\n        for(int i=numsSize-2;i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index=i;\\n                break;\\n            }\\n        }\\n        if(index==-1){\\n            int start=0;\\n            int end=numsSize-1;\\n            while(start<end){\\n                int temp=nums[end];\\n                nums[end]=nums[start];\\n                nums[start]=temp;\\n                start++;\\n                end--;\\n            }\\n        }\\n            else{\\n                for(int i=numsSize-1;i>=index;i--){\\n                    if(nums[i]>nums[index]){\\n                        int temp1=nums[index];\\n                        nums[index]=nums[i];\\n                        nums[i]=temp1;\\n                        break;\\n                    }\\n\\n                }\\n               \\n            }\\n             int s=index+1;\\n                int e=numsSize-1;\\n                while(s<e){\\n                    int temp2=nums[s];\\n                    nums[s]=nums[e];\\n                    nums[e]=temp2;\\n                    s++;\\n                    e--;\\n                }\\n\\n\\n}"
                    },
                    {
                        "username": "codemode365",
                        "content": "Before solving this problem , please understand the problem https://leetcode.com/problems/permutations/\\n\\nIt is recommended , otherwise this problem doesn\\'t make sense"
                    }
                ]
            },
            {
                "id": 2022674,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2022489,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009841,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2009524,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2005917,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 2004595,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1999023,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997557,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1997551,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987560,
                "content": [
                    {
                        "username": "swap_kore",
                        "content": " The question is lot more than what appears, for logic check this out:\\nhttps://stemhash.com/efficient-permutations-in-lexicographic-order/"
                    },
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Brute Force approach involves finding all permutations  and then finding given next permutation"
                    },
                    {
                        "username": "DeepakSS",
                        "content": "can any please suggest some thing,here i am facing an error ,i am getting correct output in stdout but wrong in output, i tried it in ide.geeks,there it works fine ,i don\\'t know what is the issue ,please help"
                    },
                    {
                        "username": "s3stan",
                        "content": "Perhaps it\\'s a mismatch between the types of returned or received data"
                    },
                    {
                        "username": "charant587",
                        "content": "if none understood the question so example:\\n123>132>213>231>312>321"
                    },
                    {
                        "username": "Darshan119",
                        "content": "Can Anyone tell why my code is not working ?  \\n\"class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int index = -1;\\n        int n = nums.size();\\n        for(int i = n-2 ; i>=0;i--){\\n            if(nums[i]<nums[i+1]){\\n                index = i ;\\n                break;\\n            }\\n        }\\n\\n        if(index == -1){\\n            reverse(nums.begin(),nums.end());\\n            // return nums;\\n        }\\n        else{\\n        for(int i = n-1;i>index;i--){\\n            if(nums[i]>nums[index]){\\n                break;\\n            }\\n                swap(nums[i],nums[index]);\\n        reverse(nums.begin()+index+1,nums.end());\\n        }\\n            \\n        }\\n        // return nums;\\n    }\\n};\""
                    },
                    {
                        "username": "s3stan",
                        "content": "Here you need to do this\n   instead of this code -\n        for(int i = n-1;i>index;i--){\n        if (numbers[i]>numbers[index]){\n            break;\n        }\n   need one - \n        int swapIndex = -1;\n        for (int i = n - 1; i > index; i--)\n        {\n            if (nums[i] > nums[index])\n            {\n                swapIndex = i;\n                break;\n            }\n        }"
                    },
                    {
                        "username": "Umair9912",
                        "content": "How badly is it frowned upon to use the next_permutation built-in function? "
                    },
                    {
                        "username": "s3stan",
                        "content": "The task is simple if you know the algorithm:\n1. Find the first exchange point such that n[i] < n[i+1].\n    If there is no such combination, then the array is ordered in reverse order.\n    So it needs to be sorted in ascending order.\n2. Find the second exchange point n[i] < n[j], and j must be the rightmost one.\n3. Swap i element with j.\n4. The remainder of the array starting from element i+1 must be flipped."
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "1.) Find breaking point \\n2.) swap it with its nearer number\\n3.) reverse from the breaking point\\n\\nNote:- if cant find breaking point reverse the array and return it"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "should be marked as hard "
                    },
                    {
                        "username": "Pratyushkr17",
                        "content": "class Solution {\\npublic:\\nvoid nextPermutation(vector& nums) {\\nint n=nums.size();\\nint ind=-1;\\nfor(int i=n-2; i>=0; i--)\\n{\\nif(nums[i]<nums[i+1])\\n{\\nind=i;\\nbreak;\\n}\\n}\\n/* if(ind==-1)\\n{\\nreverse(nums.begin(), nums.end());\\n}*/\\nif(ind!=-1)\\n{\\nfor(int i=n-1; i>ind; i--)\\n{\\nif(nums[i]>nums[ind])\\n{\\nswap(nums[i],nums[ind]);\\nbreak;\\n}\\n}\\n}\\nreverse(nums.begin()+ind+1, nums.end());\\n}\\n};\\nwhen i use the commented part to check whether ind==-1 it throws ans error like this:\\nLine 1034: Char 34: runtime error: addition of unsigned offset to 0x602000000170 overflowed to 0x60200000016c (stl_vector.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/stl_vector.h\\nCan someone explain me why is this happening?"
                    }
                ]
            },
            {
                "id": 1987074,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1982735,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1967012,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1966109,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1964653,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1940853,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1925601,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1920437,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1916945,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1901514,
                "content": [
                    {
                        "username": "Badem48",
                        "content": "I think the reason why people downgrade this question is because of the word \"lexicographically\", which is very hard to understand.\\nInstead if it says remove the comas and put in order;  [123] [132] [213] [231] [312] [321]\\nthen it makes more sense."
                    },
                    {
                        "username": "ZdyyLee",
                        "content": "Do not know why there are so many people hate this question. This is a really good one. Candidates need to be mathematically observant in order to solve this kind of question. Some companies (like JP Morgan) just need this kind of Candidates."
                    },
                    {
                        "username": "getbusylivingOrgetbusydying",
                        "content": "next_permutation(nums.begin(), nums.end());\n in c++"
                    },
                    {
                        "username": "shefalisawant1499",
                        "content": "Consider whole array as a single number, [ 1, 2, 3]=>123 then you\\'ll understand description. Basically we need to find next number just greater than current number in this case it\\'s 132, if it is already greatest then revert it back to smallest for 321 it\\'ll be 123."
                    },
                    {
                        "username": "johansen_sagala",
                        "content": "does anyone know what\\'s wrong with this code...?\\n\\nin vs code, if input [1, 3, 2] given, then it results [2, 1, 3]...but here in leetcode it was wrong and they say this code return [2, 3, 1]\\n\\n\\nfunction nextPermutation (arr) {\\n\\n    let len = arr.length;\\n    let newArr;\\n    let leftArr;\\n    let rightArr;\\n    let isBiggest = true;\\n    \\n    main:\\n    for (let i = len - 1; i >= 1; i--) {\\n        for (let j = i - 1; j >= 0; j--) {\\n            if (arr[i] > arr[j]) {\\n                let temp = arr[j];\\n                arr[j] = arr[i];\\n                arr[i] = temp;\\n\\n                leftArr = arr.slice(0, j + 1);\\n                rightArr = arr.slice(j + 1, len);\\n\\n                rightArr = rightArr.sort((a, b) => a - b);\\n\\n                newArr = leftArr.concat(rightArr);\\n                \\n                isBiggest = false;\\n\\n                break main;\\n            }\\n        }\\n    }\\n\\n    if (isBiggest == true) {\\n        newArr = arr.sort((a, b) => a - b);\\n    }\\n\\n    return newArr;\\n}\\n"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Suppose if we have arr = [1,2,3]. All the possible permutations of arr in the lexicographic order is [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]. Now think of this array as just numbers. 123, 132, 213, 231, 312, 321.\\nAll the numbers are also in ascending order. So to find the next permutation of 123 in lexicographic order is 132. Also the next permutation of 213 is 231. Also the next permutation of 321 is ... As we know there is no permutation after that. so just sort 321 in ascending order and the answer is 123.\\nSo basically if we are given a number return just a number which is greater than it. but not too greater. ( a number which is next greater to it ).\\nNow let\\'s get back to the question.\\nTake the example [1,2,3] . We can just check from the end to start for an index i where arr[i] > arr[i + 1]. In this example we will have 3. In the same way starting from end to i + 1; find an index j where arr[j] > arr[i]. In this example we will have 2. Now we have 2 indexes. Swap the two elements. so arr becomes [1,3,2]. For this example we got the answer here. but we also need to reverse the elements from i + 1 to end. Here the elements to be reversed are from i + 1 to end. In that way you will have the next greater element.\\n(Try with a array with more that 3 elements and you will understand why we need to reverse the elements.)"
                    },
                    {
                        "username": "user2398is",
                        "content": "My code is not working here, but with the same cases in VisualStudio and Jupyter everything works correctly. Please, support team, check my code and give some feedback.\\nCode on Python:\\n\\n        nums.reverse()\\n        el = [nums[0]]\\n        for value in nums[1::]:\\n            if value >= max(el):\\n                el.append(value)\\n            else:\\n                el.append(value)\\n                el.sort()\\n                b = el[el.index(value) + 1]\\n                nextValue = el[el.index(value) + 1]\\n                nums[nums.index(value)] = nextValue\\n                nums[nums.index(b)] = value\\n                firstlist = nums[:nums.index(nextValue):]\\n                nums.reverse()\\n                nums = nums[:nums.index(nextValue)+1:]\\n                nums.extend(firstlist)\\n                break "
                    },
                    {
                        "username": "CalCreate",
                        "content": "Took me quite a few failed submissions to consider the edge cases. "
                    },
                    {
                        "username": "tripti_verma",
                        "content": "The problem involves finding the next lexicographically greater permutation of an array of integers. Let's break it down into simpler terms.\n\nImagine you have an array of numbers, and you need to rearrange the elements in such a way that you get the next greater permutation. By \"next greater permutation,\" we mean the arrangement of numbers that comes immediately after the current arrangement in lexicographical order.\n\nTo understand lexicographical order, think of it as the order you would find words in a dictionary. For example, \"apple\" comes before \"banana\" because \"a\" comes before \"b\" in the alphabet.\n\nHere's an example: let's say we have an array [1, 2, 3]. The permutations of this array are [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1]. If we sort these permutations in lexicographical order, the order would be [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], and [3, 2, 1].\n\nTo find the next permutation, you need to rearrange the numbers in such a way that you get the smallest possible permutation that is greater than the current one. If there is no such permutation, you should return the smallest possible permutation (i.e., the sorted array).\n\nFor example, given the array [1, 2, 3], the next permutation is [1, 3, 2]. This is because [1, 3, 2] is the smallest permutation greater than [1, 2, 3]. Similarly, the next permutation of [2, 3, 1] is [3, 1, 2]. However, for [3, 2, 1], there is no lexicographically greater arrangement possible, so we return [1, 2, 3] because it is the smallest possible permutation.\n\nTo solve this problem, you need to implement an algorithm that finds the next permutation in place, meaning you modify the given array itself without using any extra memory.\n\nThe constraints state that the length of the array will be between 1 and 100, and the elements will be between 0 and 100.\n\nI hope this explanation helps you understand the problem better!"
                    },
                    {
                        "username": "glaucusec",
                        "content": "Nice explanation. I was also trying to explain the solution. but I think this look good."
                    },
                    {
                        "username": "harrabikhalil93",
                        "content": "can somone tell me what is wrong with this code. Thanks in advance. \\n `class Solution(object):\\n    def nextPermutation(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: None Do not return anything, modify nums in-place instead.\\n        \"\"\"\\n        permutations = [[]]  # Start with an empty permutation\\n\\n        for element in nums:\\n            new_permutations = []  # List to store new permutations with the current element\\n\\n            for permutation in permutations:\\n                for i in range(len(permutation) + 1):\\n                    new_permutations.append(permutation[:i] + [element] + permutation[i:])\\n\\n            permutations = new_permutations  # Update the list of permutations\\n        permutations.sort()\\n        return permutations[permutations.index(nums)+1]` "
                    }
                ]
            },
            {
                "id": 1892281,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1891452,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889718,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889684,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1889680,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1880139,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1858142,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1844600,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1831749,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1829892,
                "content": [
                    {
                        "username": "user5577hI",
                        "content": "Unfortunately this question has some problems as it\\'s set up. They have a particular algorithm in mind but it doesn\\'t match up with the question as stated. If the program is given a permutation as input then it\\'s clear what it should do, but if it\\'s given some arbitrary list with repeated elements it\\'s not. \\n\\nMy first attempt used a binary search at one point. This made the program slightly more efficient on permutations but gave the \"wrong\" answer on some of the examples with repeated elements. Solving the question required figuring out what algorithm was really wanted from the failed test cases. The correct algorithm is neither returning the next permutation, which would *only* return permutations on any input, nor returning the next list in lexicographical order."
                    },
                    {
                        "username": "lnrayalu542",
                        "content": "class Solution(object):\\n    def nextPermutation(self, nums):\\n        i=len(nums)-2\\n        while(i>=0):\\n            if nums[i]<nums[i+1]:break\\n            i-=1\\n        if i==-1:nums.sort();return nums\\n        mind=i+1\\n        for j in range(i+1,len(nums)):\\n            if nums[j]>nums[i] and nums[j]<nums[mind]:mind=j\\n        nums[i],nums[mind]=nums[mind],nums[i]\\n        nums=nums[:i+1]+sorted(nums[i+1:])\\n        print(nums)\\n        return nums\\nwhy this code i not working\\n"
                    },
                    {
                        "username": "Garima_tata",
                        "content": "I had confusion in the below codes because my approach was to find nums[i]<nums[i+1] from starting and second code I randomly got using the runtime graph had same approach as me but in that someone is trying to find nums[i]<nums[i+1] from last.\\nThen I ask CHATGPT THE DIFFERENCE it gave me this answer \"In summary, both implementations are correct, but the first implementation is more efficient than the second implementation as it does not need to scan the entire array to find the rightmost element that is smaller than the element to its right.\"\\nCAN ANYONE HELP in explaining where the problem come if we use second code!!!!\\n```class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=n-2; i>=0; i--){\\n            if(nums[i] < nums[i+1]){\\n                count = i;\\n                break;\\n            }\\n        }\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n        int n = nums.size();\\n        int count = -1;\\n        for(int i=0;i<=n-2;i++){\\n            if(nums[i]<nums[i+1]){\\n                count=i+1;\\n                break;\\n            }\\n        }\\n        cout<<count<<endl;\\n        for(int i=n-1; i>=0 && count!=-1;i--){\\n            if(nums[i]>nums[count]){\\n                swap(nums[i],nums[count]);\\n                break;\\n            }\\n        }\\n        reverse(nums.begin()+count+1, nums.end());\\n    }\\n}; ```\\n\\n"
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "algorithm :\n1. From right end search for the first index i such that nums[i] > nums[i-1]. If no such index exists, reverse array and end\n2. From right index search for the first index j such that nums[j] > nums[i-1].\n3. Swap nums[j] and nums[i-1].\n4. From index i onwards, reverse the list."
                    },
                    {
                        "username": "AbishekNanjappa",
                        "content": "whats wrong here ?\nn = len(nums)\n        i = -1\n        j = -1\n        for k in range(n - 1 , 0 , -1):\n            if nums[k] > nums[k - 1]:\n                i = k\n                break\n        if i == -1:\n            nums = nums[::-1]\n        else:\n            for k in range(n - 1 , 0 , -1):\n                if nums[k] > nums[i - 1]:\n                    j = k\n                    break\n            nums[j] , nums[i - 1] = nums[i - 1] , nums[j]\n            nums[i:] = nums[i:][::-1]\n\nit is passing 262/265 testcases,  not passing [3,2,1] testcase"
                    },
                    {
                        "username": "ShrekPNG",
                        "content": "For anyone, who doesn\\'t understand what the problem even means:\\nLexicographic order is the order of words in a dictionary.\\nFor example, \"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\". Except in this problem we use numbers instead of letters. So \"the next permutation of lexicographic order\" here simply means \"the next word in a dictionary\""
                    },
                    {
                        "username": "iklosallesop",
                        "content": "In C++ it can be done in 1 command.\\n(Ask ChatGPT).\\n"
                    },
                    {
                        "username": "chandan_kumar_ram",
                        "content": "Quality question , if we understood the algorithm and most importantly intuition."
                    },
                    {
                        "username": "benjsalah",
                        "content": "this seems wrong, the example says after 2,3,1 comes 3,1,2 but if you do:\\n `for i in sorted([213,231,312]):\\n...     print(i)`\\n\\nit prints: 213, 231, 312"
                    },
                    {
                        "username": "Sanjukta19",
                        "content": "Hello everyone. I am new to this platform. \n  while(nums[j] <= nums[i]) j--; this line is giving me some exception handling error which i'm not able to understand. can anyone help me?\n\njava.lang.ArrayIndexOutOfBoundsException: Index -1 out of bounds for length 2\n  at line 10, Solution.nextPermutation\n  at line 54, __DriverSolution__.__helper__\n  at line 84, __Driver__.main\n\nthis is the error"
                    }
                ]
            },
            {
                "id": 1808656,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1807808,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1794691,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1789383,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1777049,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1761635,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759819,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1754439,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752918,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1752597,
                "content": [
                    {
                        "username": "YashuCoder",
                        "content": "Actually it was a quite good question . It is actually saying to find the next dictionary array that's it . After taking some inputs and checking through trail and error and I came to sort out an algorithm for this one . It was quite a complex one but try to understand if you can . Let's take for example [1,2,5,3] . For this array in general we can say that the next permutation is [1,3,2,5] . If we think of this through my algorithm we will take two variable which keeps track of the two elements starting from the end . In this array starting from 3 and 5 and it iterates over the array from end to start like for this we can say that 3 and 5 and then 5 and 2 and then 2 and 1 like that . Let's take the 5 as a and 2 as b . While iterating whenever we get b smaller than a (b<a) then we have to replace the b with the nearest successor in the right side elements of the b and then we have to sort the elements that are right side of b . That's it . It seems somewhat complex . But I think it was a good one it beats 70 % in time and 80 % in memory . I had also uploaded the code for that . You can check it out"
                    },
                    {
                        "username": "ShreVis",
                        "content": "My approach was to generate all possible permutations of nums, and then check whether an element exists at the index after the input in the permutation list. I understand that this is very inefficient for large arrays, but am still wondering whether my approach is right in the first place"
                    },
                    {
                        "username": "kushagrajain7aug",
                        "content": "Java Solution O(n)\\n\\nclass Solution {\\n    public void nextPermutation(int[] nums) {\\n\\n       int x = nums.length-1;\\n\\n       while(x>0 && nums[x]<=nums[x-1])\\n       {\\n           x--;\\n       }\\n       //System.out.println(nums.length-1+\" \"+x);\\n       if(x-1>=0){\\n       for(int i=nums.length-1;i>=x;i--)\\n       {\\n           if(nums[i]>nums[x-1])\\n           {\\n               int temp = nums[x-1];\\n               nums[x-1] = nums[i];\\n               nums[i] = temp;\\n               break;\\n           }\\n       }\\n       }\\n       int i=x;\\n       int j=nums.length-1;\\n\\n       while(i<j)\\n       {\\n           int temp = nums[i];\\n           nums[i] = nums[j];\\n           nums[j] = temp;\\n           i++;\\n           j--;\\n       }\\n\\n       for(int i1=0;i1<=nums.length-1;i1++)\\n       {\\n           System.out.print(nums[i1]+\" \");\\n       }\\n        \\n    }\\n}"
                    },
                    {
                        "username": "codesharma452",
                        "content": "I cant Understand the meaning of lexicographical arrangments ? please explain."
                    },
                    {
                        "username": "Bman2386",
                        "content": ".splice() bug (JavaScript) \nI'm using .splice() to reorder the array.  (More info on splice here: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)\n\n```\nlet highest = Math.max(...nums) // find largest num\nlet temp = [...nums] // copy original array\nlet idx = nums.indexOf(highest) - 1 // find index of  num before largest\nlet second = nums[idx]\ntemp.splice(idx, 2, highest, second) // [1, 2, 3] => [1, 3, 2]\nreturn temp\n``` \nThe above code works in VS Code, but not LeetCode???\nex. given [1,2,3]:\n VS Code returns [1,3,2]\nLeetCode returns [1,2,3]\n(LeetCode logs => [2,3])\n"
                    },
                    {
                        "username": "patchristy",
                        "content": "Problem statement is so unclear, need to re-read multiple times to understand."
                    },
                    {
                        "username": "sunnyjha1512002",
                        "content": "[@LeetCode](/LeetCode) \n- It will be good for coders if You add this Test Case in question\nBetter Test Case : `[1,5,8,4,7,6,5,3,1] `\n"
                    },
                    {
                        "username": "gaurav_singh842930",
                        "content": "The problem statement is simple but leetcode has made this problem little complex to understand. The problem requires to find the just greater number of a given number. I think it will help to understand the problem easily.\nFor example if the number is 123 then the just greater number than this will be 132."
                    },
                    {
                        "username": "bharatsingh9808355780",
                        "content": "CAN ANYONE TELL ME WHY ITS RUNTIME ERROR\\n\\nclass Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n            //  Write your code here.\\n            vector<int> permutation=nums;\\n    vector<int> real=permutation;\\n    \\n    vector<int> check=permutation;\\n    sort(real.begin(),real.end());\\n    int lastpointer=permutation.size()-1;\\n   while(permutation[lastpointer]>permutation[lastpointer-1]&&lastpointer>0){\\n        lastpointer--;\\n   }\\n    vector<int> ans;\\n    for(int i=0;i<real.size()-1;i++){\\n        if(real[i]==permutation[lastpointer])\\n            permutation[lastpointer]=real[i+1];\\n    }\\n    for(int i=0;i<=lastpointer;i++){\\n        ans.push_back(permutation[i]);\\n    }\\n    vector<int> now=ans;\\n    for(int i=0;i<now.size();i++){\\n        check.erase(find(check.begin(),check.end(),now[i]));\\n    }\\n    sort(check.begin(),check.end());\\n   for(int i=0;i<check.size();i++)\\n       ans.push_back(check[i]);\\nnums.clear();\\nnums=ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1737199,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1729224,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728678,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1728478,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1725436,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710694,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1710323,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1709660,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1708744,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            },
            {
                "id": 1693918,
                "content": [
                    {
                        "username": "redrosh",
                        "content": "For anyone struggling with this problem. I recommend watching these videos  [  Compute The Next Permutation of A Numeric Sequence ](https://www.youtube.com/watch?v=quAS1iydq7U) and [ How To Permute A String - Generate All Permutations Of A String ](https://www.youtube.com/watch?v=GCm7m5671Ps). I was able to implement the solution after checking the videos."
                    },
                    {
                        "username": "adhith",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& a) {\\n        //if(a.size()==NULL || a.size()<=1)return;\\n        if( a.size()<=1)return;\\n        int n=a.size();\\n        int ii,ji;\\n        for(int i=n-1;i>0;i--){\\n            if(a[i]>a[i-1]){\\n                ii=i;\\n               break;\\n            }\\n        }\\n        if(ii==0){\\n            sort(a.begin(),a.end());\\n        }\\n        else{\\n            int min=INT_MAX;\\n            int ts=a[ii-1];\\n            for(int j=n-1;j>ii-1;j--){\\n                if(a[j]>ts && a[j]-ts<min ){\\n                    int temp=a[j];\\n                    a[j]=ts;\\n                    a[ii-1]=temp;\\n                    min=a[j]-ts;\\n                }\\n            }\\n            sort(a.begin()+ii,a.end());\\n        }\\n\\n       \\n\\n    }\\n  \\n  \\n};"
                    },
                    {
                        "username": "pjethaniya99",
                        "content": "class Solution {\\n    public void nextPermutation(int[] nums) {\\n        int i = nums.length - 2;\\n            while(i >= 0 && nums[i+1] <= nums[i]){\\n                i--;\\n            }\\n            if (i >= 0){\\n        int j = nums.length - 1;\\n            while(j >= 0 && nums[j] <= nums[i]){\\n                j--;\\n            }\\n    swap(nums ,i ,j);\\n}\\nreverse(nums,i + 1);\\n}\\nvoid reverse (int[] nums, int start){\\n    int i = start, j = nums.length - 1;\\n    while(i < j)\\n    {\\n        swap(nums, i , j);\\n        i++;\\n        j--;\\n    }\\n}\\nvoid swap (int[] nums, int i, int j){\\n    int temp = nums[i];\\n    nums[i] = nums[j];\\n    nums[j] = temp;\\n}\\n}  @"
                    },
                    {
                        "username": "Akash_Naik",
                        "content": "Can\\'t really understand what this question is trying to say\\n"
                    },
                    {
                        "username": "keerthivibisan",
                        "content": "# Problem Steps Explained [Problem Breakdown]\\n\\n// Note we cannot find next permutation when the elements are sorted in Descending order\\n\\nStep 1: Track the array from back [for Descending order check], if Some point breaking the series of Descending order, take it as Inflation point and its left adjacent element as Swap or Breaking point.\\n\\n------ Condition If inflation == 0 then Sort in ascending and return -----\\n\\nStep 2: Then find the next greater number for the swap point [within Inflation to n]\\nStep 3: Then Swap the two numbers [break or swap point and the next greater]\\nStep 4: Then Sort the rest array in ascending order from inflation point to n\\n\\t\\t"
                    },
                    {
                        "username": "shashankmishra9190",
                        "content": "my two text cases is pass but 1 is fail!!!!"
                    },
                    {
                        "username": "aditya170302",
                        "content": "class Solution {\\npublic:\\n    void nextPermutation(vector<int>& nums) {\\n       int i,j;\\n       int n=nums.size();\\n       for(int i=n-2;i>=0;i--){\\n           if(nums[i]<nums[i+1]){\\n           break;\\n           }\\n       } \\n       if(i<0)\\n       {\\n           reverse(nums.begin(),nums.end());\\n           }\\n       else{\\n           for(int j=n-1;j>i;j--){\\n               if(nums[j]>nums[i]){\\n                   break;\\n               }\\n           \\n           }\\n               swap(nums[i],nums[j]);\\n              reverse(nums.begin()+i+1,nums.end());\\n       }\\n    }\\n};"
                    },
                    {
                        "username": "padmansh_20",
                        "content": "`\\nvar nextPermutation = function (nums) {\\n    let idx;\\n    for (let i = nums.length - 2; i >= 0; i--) {\\n        if (nums[i] < nums[i + 1]) {\\n            idx = i;\\n            break;\\n        }\\n    }\\n\\n    let justMax = Infinity;\\n    let justMaxIdx;\\n\\n    if (idx === 0 || idx) {\\n        for (let i = idx + 1; i < nums.length; i++) {\\n            if (nums[i] > nums[idx] && nums[i] < justMax) {\\n                justMax = nums[i];\\n                justMaxIdx = i;\\n            }\\n        }\\n\\n        let temp;\\n\\n        temp = nums[idx];\\n        nums[idx] = nums[justMaxIdx];\\n        nums[justMaxIdx] = temp;\\n\\n        nums = [...nums.slice(0, idx + 1), ...nums.slice(idx + 1).sort((a, b) => a - b)];\\n    }\\n    else {\\n        nums.reverse();\\n    }\\n};\\n`\\n\\nnot working on leetcode ditor but working in console on testcase [1,3,2]"
                    },
                    {
                        "username": "phungvandat",
                        "content": "nums = [1, 16, 85]\\nexpected = [1, 85, 16]\\nwhy is not = [16, 1, 85] ?\\n16185 < 18516"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "because you need to compare them separately, not combining them as 1 number"
                    },
                    {
                        "username": "Pavankhandarkar19",
                        "content": "cannot understand question.can anyone explain me what actually asked in these question."
                    }
                ]
            }
        ]
    },
    {
        "title": "Palindrome Partitioning",
        "question_content": "<p>Given a string <code>s</code>, partition <code>s</code> such that every <span data-keyword=\"substring-nonempty\">substring</span> of the partition is a <span data-keyword=\"palindrome-string\"><strong>palindrome</strong></span>. Return <em>all possible palindrome partitioning of </em><code>s</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> s = \"aab\"\n<strong>Output:</strong> [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> s = \"a\"\n<strong>Output:</strong> [[\"a\"]]\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length &lt;= 16</code></li>\n\t<li><code>s</code> contains only lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 182307,
                "title": "java-backtracking-template-general-approach",
                "content": "All backtracking problems are composed by these three steps: ```choose```, ```explore```, ```unchoose```.\\nSo for each problem, you need to know:\\n1. \\t```choose what?``` For this problem, we choose each substring.\\n2. \\t```how to explore?``` For this problem, we do the same thing to the remained string.\\n3. \\t```unchoose``` Do the opposite operation of choose.\\n\\nLet\\'s take this problem as an example:\\n```1.Define helper()```: Usually we need a helper funcition in backtracking problem, to accept more parameters.\\n```2.Parameters```:  Usually we need the following parameters\\n```\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n```\\n```3.Base case```:  The base case defines when to add step into result, and when to return.\\n```4.Use for-loop ```:  Usually we need a for loop to iterate though the input String s, so that we can choose all the options.\\n```5.Choose ```: In this problem, if the substring of s is palindrome, we add it into the step, which means we choose this substring.\\n```6.Explore ```: In this problem, we want to do the same thing to the remaining substring. So we recursively call our function.\\n```7.Un-Choose ```: We draw back, remove the chosen substring, in order to try other options. \\n\\n<hr/>\\n\\n```The above is mainly the template, the code is shown below:```\\n\\n```java\\npublic List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n```\\nOther related backtracking problems discuss:\\n[A general approach to backtracking questions in Java (Subsets, Permutations, Combination Sum, Palindrome Partitioning)\\n](https://leetcode.com/problems/subsets/discuss/27281/A-general-approach-to-backtracking-questions-in-Java-(Subsets-Permutations-Combination-Sum-Palindrome-Partitioning))",
                "solutionTags": [],
                "code": "```choose```\n```explore```\n```unchoose```\n```choose what?```\n```how to explore?```\n```unchoose```\n```1.Define helper()```\n```2.Parameters```\n```\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n```\n```3.Base case```\n```4.Use for-loop ```\n```5.Choose ```\n```6.Explore ```\n```7.Un-Choose ```\n```The above is mainly the template, the code is shown below:```\n```java\\npublic List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 41963,
                "title": "java-backtracking-solution",
                "content": "if the input is \"aab\", check if [0,0] \"a\" is palindrome. then check [0,1] \"aa\", then [0,2] \"aab\".\\nWhile checking [0,0], the rest of string is \"ab\",  use ab as input to make a recursive call.\\n![enter image description here][1]\\n\\nin this example, in the loop of i=l+1, a recursive call will be made with input = \"ab\".\\nEvery time a recursive call is made, the position of l move right. \\n\\nHow to define a correct answer?\\nThink about DFS, if the current string to be checked (Palindrome) contains the last position, in this case \"c\", this path is a correct answer, otherwise, it's a false answer.\\n\\n![enter image description here][2]\\n\\nline 13:  is the boundary to check if the current string contains the last element. \\n l>=s.length()  \\n\\n    public class Solution {\\n            List<List<String>> resultLst;\\n    \\t    ArrayList<String> currLst;\\n    \\t    public List<List<String>> partition(String s) {\\n    \\t        resultLst = new ArrayList<List<String>>();\\n    \\t        currLst = new ArrayList<String>();\\n    \\t        backTrack(s,0);\\n    \\t        return resultLst;\\n    \\t    }\\n    \\t    public void backTrack(String s, int l){\\n    \\t        if(currLst.size()>0 //the initial str could be palindrome\\n    \\t            && l>=s.length()){\\n    \\t                List<String> r = (ArrayList<String>) currLst.clone();\\n    \\t                resultLst.add(r);\\n    \\t        }\\n    \\t        for(int i=l;i<s.length();i++){\\n    \\t            if(isPalindrome(s,l,i)){\\n    \\t                if(l==i)\\n    \\t                    currLst.add(Character.toString(s.charAt(i)));\\n    \\t                else\\n    \\t                    currLst.add(s.substring(l,i+1));\\n    \\t                backTrack(s,i+1);\\n    \\t                currLst.remove(currLst.size()-1);\\n    \\t            }\\n    \\t        }\\n    \\t    }\\n    \\t    public boolean isPalindrome(String str, int l, int r){\\n    \\t        if(l==r) return true;\\n    \\t        while(l<r){\\n    \\t            if(str.charAt(l)!=str.charAt(r)) return false;\\n    \\t            l++;r--;\\n    \\t        }\\n    \\t        return true;\\n    \\t    }\\n    }\\n\\n\\n  [1]: http://1.bp.blogspot.com/-3g_qWEIsyUI/VJR0Co__PcI/AAAAAAAAAfg/okeb7u1mZnI/s1600/test.png\\n  [2]: http://i58.tinypic.com/2la69p2.png",
                "solutionTags": [],
                "code": "class Solution {\\n            List<List<String>> resultLst;\\n    \\t    ArrayList<String> currLst;\\n    \\t    public List<List<String>> partition(String s) {\\n    \\t        resultLst = new ArrayList<List<String>>();\\n    \\t        currLst = new ArrayList<String>();\\n    \\t        backTrack(s,0);\\n    \\t        return resultLst;\\n    \\t    }",
                "codeTag": "Java"
            },
            {
                "id": 41982,
                "title": "java-dp-dfs-solution",
                "content": "The normal dfs backtracking will need to check each substring for palindrome, but a dp array can be used to record the possible break for palindrome before we start recursion.\\n\\nEdit:\\nSharing my thought process:\\nfirst, I ask myself that how to check if a string is palindrome or not, usually a two point solution scanning from front and back.  Here if you want to get all the possible palindrome partition, first a nested for loop to get every possible partitions for a string, then a scanning for all the partitions.  That's a O(n^2) for partition and O(n^2) for the scanning of string, totaling at O(n^4) just for the partition.  However, if we use a 2d array to keep track of any string we have scanned so far, with an addition pair, we can determine whether it's palindrome or not by justing looking at that pair, which is this line `if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1]))`.  This way, the 2d array `dp` contains the possible palindrome partition among all.  \\n\\nsecond, based on the prescanned palindrome partitions saved in dp array, a simple backtrack does the job.\\n\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<>();\\n            boolean[][] dp = new boolean[s.length()][s.length()];\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }\\n                }\\n            }\\n            helper(res, new ArrayList<>(), dp, s, 0);\\n            return res;\\n        }\\n        \\n        private void helper(List<List<String>> res, List<String> path, boolean[][] dp, String s, int pos) {\\n            if(pos == s.length()) {\\n                res.add(new ArrayList<>(path));\\n                return;\\n            }\\n            \\n            for(int i = pos; i < s.length(); i++) {\\n                if(dp[pos][i]) {\\n                    path.add(s.substring(pos,i+1));\\n                    helper(res, path, dp, s, i+1);\\n                    path.remove(path.size()-1);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<>();\\n            boolean[][] dp = new boolean[s.length()][s.length()];\\n            for(int i = 0; i < s.length(); i++) {\\n                for(int j = 0; j <= i; j++) {\\n                    if(s.charAt(i) == s.charAt(j) && (i - j <= 2 || dp[j+1][i-1])) {\\n                        dp[j][i] = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 41973,
                "title": "python-recursive-iterative-backtracking-solution",
                "content": "Inspired by caikehe's solution:\\n\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n            return\\n        for i in range(1, len(s)+1):\\n            if self.isPal(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n        \\n    def isPal(self, s):\\n        return s == s[::-1]",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "Inspired by caikehe's solution:\\n\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n            return\\n        for i in range(1, len(s)+1):\\n            if self.isPal(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n        \\n    def isPal(self, s):\\n        return s == s[::-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1667786,
                "title": "python-simple-recursion-detailed-explanation-easy-to-understand",
                "content": "**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.** \\n* Find answer recursively and memory trick can save some time\\n* traverse and check every prefix `s[:i]` of `s`\\n\\t* if prefix `s[:i]` is a palindrome, then process the left suffix `s[i:]` recursively\\n\\t* since the suffix `s[i:]` may repeat, **the memory trick can save some time**\\n\\n![image](https://assets.leetcode.com/users/images/e6650768-c996-457d-94c9-c5508860df35_1641356753.0113478.png)\\n\\n\\n```\\nTime  Complexity: O(N * (2 ^ N))\\nSpace Complexity: O(N * (2 ^ N))\\n```\\n\\n**Python3**\\n```\\nclass Solution(object):\\n    @cache  # the memory trick can save some time\\n    def partition(self, s):\\n        if not s: return [[]]\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        return ans\\n```\\n**Python**\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.memory = collections.defaultdict(list)\\n        \\n    def partition(self, s):\\n        if not s: return [[]]\\n        if s in self.memory: return self.memory[s]  # the memory trick can save some time\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        self.memory[s] = ans\\n        return ans\\n```\\n**PLEASE UPVOTE if you like** \\uD83D\\uDE01 **If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nTime  Complexity: O(N * (2 ^ N))\\nSpace Complexity: O(N * (2 ^ N))\\n```\n```\\nclass Solution(object):\\n    @cache  # the memory trick can save some time\\n    def partition(self, s):\\n        if not s: return [[]]\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        return ans\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.memory = collections.defaultdict(list)\\n        \\n    def partition(self, s):\\n        if not s: return [[]]\\n        if s in self.memory: return self.memory[s]  # the memory trick can save some time\\n        ans = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  # prefix is a palindrome\\n                for suf in self.partition(s[i:]):  # process suffix recursively\\n                    ans.append([s[:i]] + suf)\\n        self.memory[s] = ans\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41964,
                "title": "clean-c-backtracking-solution",
                "content": "The Idea is simple: loop through the string, check if substr(0, i) is palindrome. If it is, recursively call dfs() on the rest of sub string: substr(i+1, length). keep the current palindrome partition so far in the 'path' argument of dfs(). When reaching the end of string, add current partition in the result.\\n\\n    class Solution {\\n    public:\\n        vector<vector<string>> partition(string s) {\\n            vector<vector<string> > ret;\\n            if(s.empty()) return ret;\\n            \\n            vector<string> path;\\n            dfs(0, s, path, ret);\\n            \\n            return ret;\\n        }\\n        \\n        void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n            if(index == s.size()) {\\n                ret.push_back(path);\\n                return;\\n            }\\n            for(int i = index; i < s.size(); ++i) {\\n                if(isPalindrome(s, index, i)) {\\n                    path.push_back(s.substr(index, i - index + 1));\\n                    dfs(i+1, s, path, ret);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n        \\n        bool isPalindrome(const string& s, int start, int end) {\\n            while(start <= end) {\\n                if(s[start++] != s[end--])\\n                    return false;\\n            }\\n            return true;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<string>> partition(string s) {\\n            vector<vector<string> > ret;\\n            if(s.empty()) return ret;\\n            \\n            vector<string> path;\\n            dfs(0, s, path, ret);\\n            \\n            return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3171259,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if(start==n){\\n            pars.push_back(par);\\n        }else{\\n            for(int i = start ; i < n ;i ++){\\n               if(isPalindrome(s,start,i)){\\n                   par.push_back(s.substr(start,i-start+1));\\n                   partition(s,i+1,par,pars);\\n                   par.pop_back();\\n               }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```\\n\\n```Java []\\nclass Solution {\\n    int n;\\n    boolean[][] is_palindrome;\\n    String[][] substrings;\\n\\n    List<List<String>> ans;\\n\\n    void FindSubstrings(int ind, ArrayList<String> list) {\\n        if (ind == n) {\\n            ans.add(new ArrayList<String>(list));\\n            return;\\n        }\\n\\n        for (int i = ind + 1; i <= n; i++) {\\n            if (!is_palindrome[ind][i]) continue;\\n            list.add(substrings[ind][i]);\\n            FindSubstrings(i, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        n = s.length();\\n        is_palindrome = new boolean[n + 1][n + 1];\\n        substrings = new String[n + 1][n + 1];\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) {\\n            substrings[i][j] = s.substring(i, j);\\n            is_palindrome[i][j] = IsPalindrome(substrings[i][j]);\\n        }\\n\\n        ans = new ArrayList<List<String>>();\\n        FindSubstrings(0, new ArrayList<String>());\\n        return ans;\\n    }\\n\\n    boolean IsPalindrome(String s) {\\n        int lower = 0;\\n        int higher = s.length() - 1;\\n        while (lower < higher) {\\n            if (s.charAt(lower) != s.charAt(higher)) return false;\\n            lower++;\\n            higher--;\\n        }\\n        return true;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if(start==n){\\n            pars.push_back(par);\\n        }else{\\n            for(int i = start ; i < n ;i ++){\\n               if(isPalindrome(s,start,i)){\\n                   par.push_back(s.substr(start,i-start+1));\\n                   partition(s,i+1,par,pars);\\n                   par.pop_back();\\n               }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```\n```Java []\\nclass Solution {\\n    int n;\\n    boolean[][] is_palindrome;\\n    String[][] substrings;\\n\\n    List<List<String>> ans;\\n\\n    void FindSubstrings(int ind, ArrayList<String> list) {\\n        if (ind == n) {\\n            ans.add(new ArrayList<String>(list));\\n            return;\\n        }\\n\\n        for (int i = ind + 1; i <= n; i++) {\\n            if (!is_palindrome[ind][i]) continue;\\n            list.add(substrings[ind][i]);\\n            FindSubstrings(i, list);\\n            list.remove(list.size() - 1);\\n        }\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        n = s.length();\\n        is_palindrome = new boolean[n + 1][n + 1];\\n        substrings = new String[n + 1][n + 1];\\n        for (int i = 0; i < n; i++) for (int j = i + 1; j <= n; j++) {\\n            substrings[i][j] = s.substring(i, j);\\n            is_palindrome[i][j] = IsPalindrome(substrings[i][j]);\\n        }\\n\\n        ans = new ArrayList<List<String>>();\\n        FindSubstrings(0, new ArrayList<String>());\\n        return ans;\\n    }\\n\\n    boolean IsPalindrome(String s) {\\n        int lower = 0;\\n        int higher = s.length() - 1;\\n        while (lower < higher) {\\n            if (s.charAt(lower) != s.charAt(higher)) return false;\\n            lower++;\\n            higher--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667647,
                "title": "well-explained-java-c-python-javascript-easy-for-mind-to-accept-it",
                "content": "**Intitution :**\\n```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\\n# **`JUST UNDERSTAND IT LIKE THIS :-`**\\n![image](https://assets.leetcode.com/users/images/510ea72a-009d-43ef-8afc-7c79b0596948_1641351439.2749941.png)\\n\\n**Approach Explaination :-** \\n`A basic summary of diagram, how we are doing it`\\nTake an example, \"xxyy\". \\nIf we partition over x|xyy so the substring \"x\" is a palindrome. Where i can have the first partition.\\n\\nBut, if they don\\'t allow to partition over there, then our second partition will be xx|yy. Because this \"xx\" is a palindrome substring. Thus we still left out with yy, so if i do the partion over here xxy|y the answer will be no, because if i do the partition over here the substring \"xxy\" is not a palindrome.\\n\\nCan i do a partition over here xxyy|. No. Because xxyy is not a palindromic substring. So, we can see when we started we can do a partition over here x|xyy OR xx|yy so that is what we do. We try to do partition where ever it is possible\\n\\nSo, in the first case we did a partition over x|xyy where we left out with xyy. So, if i do a partiton like x|x|yy where x it\\'self a palindrome. And we left out with a substring yy\\nNow can you do a partition over here x|xy|y. No, because this substring xy is not a palindrome\\nAgain can we do a partition over here x|xyy|. No, because this substring xyy is not a palindrome\\n\\nSo, the only partition possible is x|x|yy. And after that we tend to call the recursion for remaining substring\\n\\nIf i try to do a partition over here x|x|y|y so, the substring y in itself is a palindromic substring. After that we left out with remaining y substring.\\nNow you ask can we do a partition over here x|x|yy|, Yes \\n\\nLike this way, we do the partition in complete STRING using recursion. And with the help of Backtracking we store our answer.\\n![image](https://assets.leetcode.com/users/images/104d7464-a56c-45c3-87cc-4caea3a05103_1641347225.9497328.png)\\n\\n![image](https://assets.leetcode.com/users/images/f091240a-0866-4fcb-b774-416cdc7dc560_1641347244.659475.png)\\n\\n*h means, helper function* \\n**JAVA**\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # which will be our answer\\n        self.helper(res, [], s) # calling to recursion function \\n        return res\\n    \\n    # Entire recursive function, that generates all the partition substring\\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n        \\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]): # what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:]) # take the substring and store it in our list & call the next substring from index + 1\\n    \\n    # A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```\\n\\n*`EDIT : JavaScript code added`*\\n\\n**JavaScript**\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const res = [];\\n    const path = [];\\n    \\n    const helper = (s, i, j) =>{\\n        if(i === s.length){\\n            res.push([...path]);\\n            return;\\n        }\\n        \\n        for(let index = j; index <= s.length; ++index){\\n            if(isPalindrome(s, i, index)){\\n                path.push(s.slice(i, index));\\n                helper(s, index, index+1);\\n                path.pop();\\n            }\\n        }\\n    }\\n    \\n    const isPalindrome = (s, i, j) =>{\\n        while(i < j - 1){\\n            if(s[i] !== s[j-1]){\\n                return false;\\n            }\\n            ++i;\\n            --j;\\n        }\\n        return true;\\n    };\\n    \\n    helper(s, 0, 1);\\n    return res;\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(N*2^N) where N is the length of string s. This is the worst-case time complexity when all the possible substrings are palindrome.\\n\\n* **Space Complexity :-** BigO(N) as space will be used to store the recursion stack",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # which will be our answer\\n        self.helper(res, [], s) # calling to recursion function \\n        return res\\n    \\n    # Entire recursive function, that generates all the partition substring\\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n        \\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]): # what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:]) # take the substring and store it in our list & call the next substring from index + 1\\n    \\n    # A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const res = [];\\n    const path = [];\\n    \\n    const helper = (s, i, j) =>{\\n        if(i === s.length){\\n            res.push([...path]);\\n            return;\\n        }\\n        \\n        for(let index = j; index <= s.length; ++index){\\n            if(isPalindrome(s, i, index)){\\n                path.push(s.slice(i, index));\\n                helper(s, index, index+1);\\n                path.pop();\\n            }\\n        }\\n    }\\n    \\n    const isPalindrome = (s, i, j) =>{\\n        while(i < j - 1){\\n            if(s[i] !== s[j-1]){\\n                return false;\\n            }\\n            ++i;\\n            --j;\\n        }\\n        return true;\\n    };\\n    \\n    helper(s, 0, 1);\\n    return res;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42101,
                "title": "c-backtracking",
                "content": "The problem has a nice structure that backtracking naturally fits in. The structure is, given a starting position `start`, we search from `start` till the end of the string. Once we reach a position `i` such that the sub-string from `start` to `i` (`s.substr(start, i  - start + 1)`) is a palindrome, we add it to a temporary `par`. Then we recursively call the same function to process the remaining sub-string. Once we reach the end of the string, we add `par` into the result `pars` of all the possible partitioning.\\n \\nThen, backtracking happens. Remember that at position `i`, we find `s.substr(start, i - start + 1)` to be a palindrome and we immediately add it to `par`. It is obvious that there may be some other position `j` such that `j > i` and `s.substr(start, j - start + 1)` is also a palindrome. So we need to recover to the state before adding `s.substr(start, i - start + 1)` to `par` and continue to find the next palindrome position after `i`. And we simply need to pop `s.substr(start, i - start + 1)` out of `par` to make things work.  \\n \\nPutting these together, the code is as follows, which should be self-explanatory.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    par.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, par, pars);\\n                    par.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\nprivate: \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    par.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, par, pars);\\n                    par.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083493,
                "title": "day-22-beginner-friendly-solution-with-diagram-backtracking",
                "content": "# Intuition\\nGenerate all the substrings using recursion and check if they are palindrome or not.If not Backtrack form there. Recursively traverse over the string.\\n![0d06f29b-d12b-4b0b-8568-32ef95c6c849_1674351396.3135014.png](https://assets.leetcode.com/users/images/21f16e09-d0af-463c-9c78-266e5f7efbf0_1674351816.1919978.png)\\n\\n![Screenshot_20230122_055612.png](https://assets.leetcode.com/users/images/51c8fea9-fefa-45ab-99ff-9260d093bdb2_1674348126.053113.png)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Create a function called \"checkPalindrome\" that takes in a string, start index and end index as parameters. This function checks if the substring of the string from start index to end index is a palindrome or not.\\n2. Create a function called \"palindromePartition\" that takes in an index, a vector of strings, a 2D vector of strings, and a string as parameters. This function partitions the given string into all possible palindrome partitions.\\n3. In the \"palindromePartition\" function, check if the current index is equal to the length of the string. If it is, add the current partition to the output vector and return.\\n4. Iterate from the current index to the end of the string.\\n5. For each iteration, check if the substring from current index to the current iterator is a palindrome using the \"checkPalindrome\" function.\\n6. If it is a palindrome, add it to the partition vector and recursively call the \"palindromePartition\" function with the updated partition and the next index.\\n7. After the recursive call, remove the last element from the partition vector.\\n8. Return the output vector after all partitions have been found.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean checkPalindrome(String str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str.charAt(startIndex) != str.charAt(lastIndex))\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    public void palindromePartition(int index, List<String> ds, List<List<String>> output, String str){\\n        if(index == str.length()){\\n            output.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.add(str.substring(index, i + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> output = new ArrayList<>();\\n        List<String> ds = new ArrayList<>();\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def checkPalindrome(self, str, startIndex, lastIndex):\\n        while startIndex <= lastIndex:\\n            if str[startIndex] != str[lastIndex]:\\n                return False\\n            startIndex += 1\\n            lastIndex -= 1\\n        return True\\n\\n    def palindromePartition(self, index, ds, output, str):\\n        if index == len(str):\\n            output.append(ds[:])\\n            return\\n        for i in range(index, len(str)):\\n            if self.checkPalindrome(str, index, i):\\n                ds.append(str[index:i+1])\\n                self.palindromePartition(i+1, ds, output, str)\\n                ds.pop()\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        output = []\\n        ds = []\\n        self.palindromePartition(0, ds, output, s)\\n        return output\\n\\n```\\n\\n\\n# Complexity\\n- Time complexity: **O(2^n*n)**\\nThe time complexity is O(2^n) because for each character in the input string, the algorithm generates two recursive calls, one for including the character in the current partition and one for not including it. Since the input string can have up to n characters, this results in 2^n possible partitions. The algorithm must check each partition to see if it is a palindrome, and therefore the time complexity is O(2^n)and O(N) time to generate the substring and determine if it is a palindrome or not. So overall time complexity is O(2^n*n).\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)**\\nThe space complexity is O(n) because the algorithm uses a single vector to store the current partition. The size of the vector is directly proportional to the number of characters in the input string and therefore the space complexity is O(n). Additionally, the algorithm uses a 2D vector to store all the partitions, the size of this vector also increase linearly as the size of the input string increase, so the space complexity is O(n).\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Backtracking"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean checkPalindrome(String str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str.charAt(startIndex) != str.charAt(lastIndex))\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    public void palindromePartition(int index, List<String> ds, List<List<String>> output, String str){\\n        if(index == str.length()){\\n            output.add(new ArrayList<>(ds));\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.add(str.substring(index, i + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.remove(ds.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> output = new ArrayList<>();\\n        List<String> ds = new ArrayList<>();\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def checkPalindrome(self, str, startIndex, lastIndex):\\n        while startIndex <= lastIndex:\\n            if str[startIndex] != str[lastIndex]:\\n                return False\\n            startIndex += 1\\n            lastIndex -= 1\\n        return True\\n\\n    def palindromePartition(self, index, ds, output, str):\\n        if index == len(str):\\n            output.append(ds[:])\\n            return\\n        for i in range(index, len(str)):\\n            if self.checkPalindrome(str, index, i):\\n                ds.append(str[index:i+1])\\n                self.palindromePartition(i+1, ds, output, str)\\n                ds.pop()\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        output = []\\n        ds = []\\n        self.palindromePartition(0, ds, output, s)\\n        return output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41974,
                "title": "my-java-dp-only-solution-without-recursion-o-n-2",
                "content": "  \\n\\n           \\n    public class Solution {\\n     \\tpublic static List<List<String>> partition(String s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tList<List<String>>[] result = new List[len + 1];\\n    \\t\\tresult[0] = new ArrayList<List<String>>();\\n    \\t\\tresult[0].add(new ArrayList<String>());\\n    \\n    \\t\\tboolean[][] pair = new boolean[len][len];\\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tresult[i + 1] = new ArrayList<List<String>>();\\n    \\t\\t\\tfor (int left = 0; left <= i; left++) {\\n    \\t\\t\\t\\tif (s.charAt(left) == s.charAt(i) && (i-left <= 1 || pair[left + 1][i - 1])) {\\n    \\t\\t\\t\\t\\tpair[left][i] = true;\\n    \\t\\t\\t\\t\\tString str = s.substring(left, i + 1);\\n    \\t\\t\\t\\t\\tfor (List<String> r : result[left]) {\\n    \\t\\t\\t\\t\\t\\tList<String> ri = new ArrayList<String>(r);\\n    \\t\\t\\t\\t\\t\\tri.add(str);\\n    \\t\\t\\t\\t\\t\\tresult[i + 1].add(ri);\\n    \\t\\t\\t\\t\\t}\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn result[len];\\n    \\t}\\n    }\\n\\nHere the **pair** is to mark a range for the substring is a Pal. if pair[i][j] is true, that means sub string from i to j is pal.\\n\\nThe **result[i]**, is to store from beginng until current index i (Non inclusive), all possible partitions. From the past result we can determine current result.",
                "solutionTags": [],
                "code": "class Solution {\\n     \\tpublic static List<List<String>> partition(String s) {\\n    \\t\\tint len = s.length();\\n    \\t\\tList<List<String>>[] result = new List[len + 1];\\n    \\t\\tresult[0] = new ArrayList<List<String>>();\\n    \\t\\tresult[0].add(new ArrayList<String>());\\n    \\n    \\t\\tboolean[][] pair = new boolean[len][len];\\n    \\t\\tfor (int i = 0; i < s.length(); i++) {\\n    \\t\\t\\tresult[i + 1] = new ArrayList<List<String>>();\\n    \\t\\t\\tfor (int left = 0; left <= i; left++) {\\n    \\t\\t\\t\\tif (s.charAt(left) == s.charAt(i) && (i-left <= 1 || pair[left + 1][i - 1])) {\\n    \\t\\t\\t\\t\\tpair[left][i] = true;\\n    \\t\\t\\t\\t\\tString str = s.substring(left, i + 1);\\n    \\t\\t\\t\\t\\tfor (List<String> r : result[left]) {\\n    \\t\\t\\t\\t\\t\\tList<String> ri = new ArrayList<String>(r);\\n    \\t\\t\\t\\t\\t\\tri.add(str);\\n    \\t\\t\\t\\t\\t\\tresult[i + 1].add(ri);\\n    \\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 42025,
                "title": "1-liner-python-ruby",
                "content": "Python:\\n\\nBroken into several physical lines for readability, but still one logical line and just one simple statement.\\n\\n    def partition(self, s):\\n        return [[s[:i]] + rest\\n                for i in xrange(1, len(s)+1)\\n                if s[:i] == s[i-1::-1]\\n                for rest in self.partition(s[i:])] or [[]]\\n\\nRuby:\\n\\n    def partition(s)\\n      s == '' ? [[]] : s.size.times.flat_map { |i| s[0..i] != s[0..i].reverse ? [] :\\n        partition(s[i+1..-1]).map { |rest| [s[0..i]] + rest }\\n      }\\n    end",
                "solutionTags": [
                    "Python"
                ],
                "code": "Python:\\n\\nBroken into several physical lines for readability, but still one logical line and just one simple statement.\\n\\n    def partition(self, s):\\n        return [[s[:i]] + rest\\n                for i in xrange(1, len(s)+1)\\n                if s[:i] == s[i-1::-1]\\n                for rest in self.partition(s[i:])] or [[]]\\n\\nRuby:\\n\\n    def partition(s)\\n      s == '' ? [[]] : s.size.times.flat_map { |i| s[0..i] != s[0..i].reverse ? [] :\\n        partition(s[i+1..-1]).map { |rest| [s[0..i]] + rest }\\n      }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 42100,
                "title": "python-easy-to-understand-backtracking-solution",
                "content": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n        for i in range(1, len(s)+1):\\n            if self.isPalindrome(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n                 \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l += 1; r -= 1\\n        return True\\n\\t\\t\\n\\tdef isPalindrome1(self, s):\\n\\t\\treturn s == s[::-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res = []\\n        self.dfs(s, [], res)\\n        return res\\n    \\n    def dfs(self, s, path, res):\\n        if not s:\\n            res.append(path)\\n        for i in range(1, len(s)+1):\\n            if self.isPalindrome(s[:i]):\\n                self.dfs(s[i:], path+[s[:i]], res)\\n                 \\n    def isPalindrome(self, s):\\n        l, r = 0, len(s)-1\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l += 1; r -= 1\\n        return True\\n\\t\\t\\n\\tdef isPalindrome1(self, s):\\n\\t\\treturn s == s[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667714,
                "title": "c-easy-to-solve-beginner-friendly-with-detailed-explanation",
                "content": "**Reframing the question:-**\\nFind all the substrings which satisfies the palindrome condition of given string s.\\n\\n***\\n\\n**Intuition:-**\\n* The structure of the question is quite clear that it **promotes the use of recursion** . The recursion approach of this question can be like:  we start iteration from beginning and step by step we increase the size of substr that we are checking for palindromes . Once the palindrome substr is found ,the substr needs to go to a vector/list storing those palindromes substr . This is how the brute recursion will work .\\n* The **optimization** of the above recursion is **backtracking**. \\nA **backtracking algorithm uses the depth-first search method**. When it starts exploring the solutions, a bounding or a helper function is applied so that the **algorithm can check if the so-far built solution satisfies the constraints**. If it does, it continues searching. If it doesn\\u2019t, the branch would be eliminated, and the algorithm goes back to the level before. In simple words backtracking starts from some intermediate position where there is still a hope to get a new palindrome .\\n* In backtracking algo there is **always a helper metod** or a safe checker merhod which checks whether the built soution satisifes the conditions or not . This one thing has **certainity of 100%**.\\n\\n***\\n\\n**Algorithm :-** \\n1. As i told you in **backtracking,** one thing is sure i.e a **helper method**. In our problem we will need a bool helper method which will check the palindrome conditions, let\\'s name it as `bool isPalindrome()` .\\n2. Now let\\'s **create some variables** : `result` vector for storing all the substring which satisfies the palindrome condition , `path` vector for storing the ongoing substr which has the potential of satisfying the conditions of palindrome , `start` variable for storing the start position of the current substr , `index i` for traversing inside the substring and `n` fro storing the size of given string `s`.\\n3. **Now we search** from `start` till the end of the string. Once we reach a position `i` such that the sub-string from `start to i (s.substr(start, i - start + 1)) is a palindrome`, we add it to our `path` variable. Then we recursively call the same method to execute the remaining substring . Once we reach the end of the string, we add palindromes `path` into the `result`  of all the *possible partitioning* . \\n4. Remember that at position `i` , we find `s.substr(start, i - start + 1)` to be a palindrome and we immediately add it to `path` . Now think that there may be a  position `j` such that `j > i` and `s.substr(start, j - start + 1)` is also a palindrome. Thus now we need to go back to our `start`  before adding `s.substr(start, i - start + 1)` to `path` and continue to find the next palindrome position after `i` . And after this evertime we simply need to remove or pop `s.substr(start, i - start + 1)` out of `path` to execute the backtracking algo . \\n5. The steps we executed in the above step is none other than the **famous dfs** . \\n\\n***\\n\\n**Code:-**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n**Time Complexity :-** *`O(n*(2^n)) [n=length of the string] `*\\n**Space Complexity :-** *`O(n) [beacause of recursion stack]`*\\n***\\n\\n***\\n\\n**[My Github Repo](https://github.com/Jatin-Shihora/LeetCode-Solutions) where I keep track of my solutions :)))**\\n\\n***\\n\\n***\\n**If you have some doubts feel free to bug me anytime or If you understood than don\\'t forget to upvote ;)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42021,
                "title": "backtrack-summary-general-solution-for-10-questions-python-combination-sum-subsets-permutation-palindrome",
                "content": "For Java version, please refer to [isssac3's answer.](https://discuss.leetcode.com/topic/46162/a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partioning)\\n\\n**39. Combination Sum**\\nhttps://leetcode.com/problems/combination-sum/\\n```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\\n\\n**40. Combination Sum II**\\nhttps://leetcode.com/problems/combination-sum-ii/\\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\\n\\n**78. Subsets**\\nhttps://leetcode.com/problems/subsets/\\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**90. Subsets II**\\nhttps://leetcode.com/problems/subsets-ii/\\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\\n\\n**46. Permutations**\\nhttps://leetcode.com/problems/permutations/\\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\\n\\n**47. Permutations II**\\nhttps://leetcode.com/problems/permutations-ii/\\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\\n\\n**60. Permutation Sequence**\\nhttps://leetcode.com/problems/permutation-sequence/\\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\\n\\n**131. Palindrome Partitioning**\\nhttps://leetcode.com/problems/palindrome-partitioning/\\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\\n\\n****\\n\\n\\n**267. Palindrome Permutation II**\\nhttps://leetcode.com/problems/palindrome-permutation-ii/\\nRelated to this two:\\n`31. Next Permutation`: https://leetcode.com/problems/next-permutation/\\n`266. Palindrome Permutation`: https://leetcode.com/problems/palindrome-permutation/\\n\\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates, target):\\n        def backtrack(tmp, start, end, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    tmp.append(candidates[i])\\n                    backtrack(tmp, i, end, target - candidates[i])\\n                    tmp.pop()\\n        ans = [] \\n        candidates.sort(reverse= True)\\n        backtrack([], 0, len(candidates), target)\\n        return ans\\n```\n```\\n    def combinationSum2(self, candidates, target):\\n        def backtrack(start, end, tmp, target):\\n            if target == 0:\\n                ans.append(tmp[:])\\n            elif target > 0:\\n                for i in range(start, end):\\n                    if i > start and candidates[i] == candidates[i-1]:\\n                        continue\\n                    tmp.append(candidates[i])\\n                    backtrack(i+1, end, tmp, target - candidates[i])\\n                    tmp.pop()\\n        ans = []\\n        candidates.sort(reverse= True)\\n        backtrack(0, len(candidates), [], target)\\n        return ans\\n```\n```\\n    def subsets(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def subsetsWithDup(self, nums):\\n        def backtrack(start, end, tmp):\\n            ans.append(tmp[:])\\n            for i in range(start, end):\\n                if i > start and nums[i] == nums[i-1]:\\n                    continue\\n                tmp.append(nums[i])\\n                backtrack(i+1, end, tmp)\\n                tmp.pop()\\n        ans = []\\n        nums.sort()\\n        backtrack(0, len(nums), [])\\n        return ans\\n```\n```\\n    def permute(self, nums):\\n        def backtrack(start, end):\\n            if start == end:\\n                ans.append(nums[:])\\n            for i in range(start, end):\\n                nums[start], nums[i] = nums[i], nums[start]\\n                backtrack(start+1, end)\\n                nums[start], nums[i] = nums[i], nums[start]\\n                \\n        ans = []\\n        backtrack(0, len(nums))\\n        return ans\\n```\n```\\n    def permuteUnique(self, nums):\\n        def backtrack(tmp, size):\\n            if len(tmp) == size:\\n                ans.append(tmp[:])\\n            else:\\n                for i in range(size):\\n                    if visited[i] or (i > 0 and nums[i-1] == nums[i] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(nums[i])\\n                    backtrack(tmp, size)\\n                    tmp.pop()\\n                    visited[i] = False\\n        ans = []\\n        visited = [False] * len(nums)\\n        nums.sort()\\n        backtrack([], len(nums))\\n        return ans\\n```\n```\\n    def getPermutation(self, n, k):\\n        nums = [str(i) for i in range(1, n+1)]\\n        fact = [1] * n\\n        for i in range(1,n):\\n            fact[i] = i*fact[i-1]\\n        k -= 1\\n        ans = []\\n        for i in range(n, 0, -1):\\n            id = k / fact[i-1]\\n            k %= fact[i-1]\\n            ans.append(nums[id])\\n            nums.pop(id)\\n        return ''.join(ans)\\n```\n```\\n    def partition(self, s):\\n        def backtrack(start, end, tmp):\\n            if start == end:\\n                ans.append(tmp[:])\\n            for i in range(start, end):\\n                cur = s[start:i+1]\\n                if cur == cur[::-1]:\\n                    tmp.append(cur)\\n                    backtrack(i+1, end, tmp)\\n                    tmp.pop()\\n        ans = []\\n        backtrack(0, len(s), [])\\n        return ans\\n```\n```\\n    def generatePalindromes(self, s):\\n        kv = collections.Counter(s)\\n        mid = [k for k, v in kv.iteritems() if v%2]\\n        if len(mid) > 1:\\n            return []\\n        mid = '' if mid == [] else mid[0]\\n        half = ''.join([k * (v/2) for k, v in kv.iteritems()])\\n        half = [c for c in half]\\n        \\n        def backtrack(end, tmp):\\n            if len(tmp) == end:\\n                cur = ''.join(tmp)\\n                ans.append(cur + mid + cur[::-1])\\n            else:\\n                for i in range(end):\\n                    if visited[i] or (i>0 and half[i] == half[i-1] and not visited[i-1]):\\n                        continue\\n                    visited[i] = True\\n                    tmp.append(half[i])\\n                    backtrack(end, tmp)\\n                    visited[i] = False\\n                    tmp.pop()\\n                    \\n        ans = []\\n        visited = [False] * len(half)\\n        backtrack(len(half), [])\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 315175,
                "title": "python-dp-bottom-up-beats-99-55",
                "content": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[-1] = [[]]\\n        for i in range(len(s) - 1, -1, -1):\\n            for j in range(i + 1, len(s) + 1):\\n                if s[i:j] == s[i:j][::-1]:\\n                    for each in dp[j]:\\n                        dp[i].append([s[i:j]] + each)\\n        return dp[0]\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = [[] for _ in range(len(s) + 1)]\\n        dp[-1] = [[]]\\n        for i in range(len(s) - 1, -1, -1):\\n            for j in range(i + 1, len(s) + 1):\\n                if s[i:j] == s[i:j][::-1]:\\n                    for each in dp[j]:\\n                        dp[i].append([s[i:j]] + each)\\n        return dp[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084823,
                "title": "c-beats-93-easy-image-explanation-backtracking",
                "content": "# Intuition\\n![Screenshot (707).png](https://assets.leetcode.com/users/images/f81f345a-003e-4d43-9e47-a916b58ebd50_1674370162.0126262.png)\\n\\nsteps:-\\n1) lets us consider string **aab** here we take first string that is **a** and check whether it is palindrome or not ;\\n2) if it is palindrome  then we add it to temp vector and recursively call dfs function for substring(i+1) i.e **ab**\\n3) now here also we check first substring i.e **a** is palindrome or not as we did earlier and add it to temp if it is palindrome, recursively call function for **b** alone by now our temp contains [\"a\",\"a\"];\\n4) now when we are left with **b** only then on recursive call fun, our temp becomes [\"a\",\"a\",\"b\"].  we call fn after b then there is empty string and we consider it base condition. storing temp in ans vector.\\n5)  whatever changes we made need to backtrack for next possible solution so we backtrack by poping out from temp . after one pop up we get temp as [\"a\",\"a\"]. we backtrack and check for **ab** only as **ab** is not palindrome so we increase i and check for next. repeat the same .\\n\\n**watch picture for better understanding**\\nLets Connect On Linkedin https://www.linkedin.com/in/sonal-prasad-sahu-78973a229/\\n\\n![Screenshot (709).png](https://assets.leetcode.com/users/images/98696b6d-1e78-4ef3-bd53-2efbaadcc4ed_1674371319.542758.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n\\n    bool ispalindrome(string s){\\n        for(int i=0;i<s.size()/2;++i){\\n            if(s[i]==s[s.size()-1-i]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\npublic: void dfs(vector<vector<string>>&ans,vector<string>&temp,string s){\\n   if(s.size()==0){  //base condistion when there is no string left\\n       ans.push_back(temp);\\n       return;\\n   }\\n    for(int i=0;i<s.size();++i){\\n        string check=s.substr(0,i+1);\\n        if(ispalindrome(check)){\\n            temp.push_back(check);\\n            dfs(ans,temp,s.substr(i+1));\\n            temp.pop_back();\\n\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>temp;\\n        dfs(ans,temp,s);\\n        return ans;\\n    }\\n};\\n```\\n![begging.jpg](https://assets.leetcode.com/users/images/8501d672-af23-4012-9d2f-0bca258c3c6f_1674388006.9311438.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n\\n    bool ispalindrome(string s){\\n        for(int i=0;i<s.size()/2;++i){\\n            if(s[i]==s[s.size()-1-i]){\\n                continue;\\n            }\\n            return false;\\n        }\\n        return true;\\n    }\\npublic: void dfs(vector<vector<string>>&ans,vector<string>&temp,string s){\\n   if(s.size()==0){  //base condistion when there is no string left\\n       ans.push_back(temp);\\n       return;\\n   }\\n    for(int i=0;i<s.size();++i){\\n        string check=s.substr(0,i+1);\\n        if(ispalindrome(check)){\\n            temp.push_back(check);\\n            dfs(ans,temp,s.substr(i+1));\\n            temp.pop_back();\\n\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>temp;\\n        dfs(ans,temp,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083543,
                "title": "easy-explanation-with-video-and-pics-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe basic idea is whenever the problem requires doing something repeatedly and we also have to store this result --> Back Tracking is the answer.\\n![Screenshot 2023-01-22 at 6.58.38 AM.png](https://assets.leetcode.com/users/images/f60ae877-3305-4205-b8c6-9c99bff8c2e4_1674350931.9986715.png)\\n\\nThe idea of recursion is we will make someone do things repeatedly after they have produced the result. Say in the above example we give a log of size 4 to the wood cutter he gives 1, 3 back but we again pass him 3 and he gives 1 and 2, 2 is passed again until cut is no longer possible. The return statement.\\n\\n\\n# BackTracking\\nHere comes a concept people feel difficult but let me explain with respect to above example. \\n![Screenshot 2023-01-22 at 7.02.22 AM.png](https://assets.leetcode.com/users/images/0de593ca-2f90-4df9-91f6-fc82666829c8_1674351166.8143.png)\\n\\nThe idea is simple, We have to store the result. ex you give the wood cutter log of 4 units, he gives 1 and 3, but look we have 3 more possibilities with 3. So we store the left part 1 and pass the right part again and again. (1,3) (1, 2, 1) (1,1,2) are the possible result and are stored.\\n\\n![Screenshot 2023-01-22 at 7.06.20 AM.png](https://assets.leetcode.com/users/images/0d06f29b-d12b-4b0b-8568-32ef95c6c849_1674351396.3135014.png)\\n\\nThe same goes with the string, we cut the string, check if the left part is palindrome, if not we stop it here, since that is not what is required.\\nPass the result down and so on until its no longer possible.\\n\\n\\nVideo Explanation: https://youtu.be/fhXo6BDTIJc\\n\\n\\n![sfw-please-upvote-me-v0-u5cacra0rnca1.webp](https://assets.leetcode.com/users/images/9a71e63c-438f-42f5-9476-77ece82e3a25_1674351598.3380027.webp)\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        \\n        woodcutter(s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    public void woodcutter(String s, List<String> subResult) {\\n        // Base case\\n        if( s.length() == 0 || s == null) {\\n            result.add(new ArrayList<>(subResult));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String cut = s.substring(0, i);\\n            if(!isPalindrome(cut)) continue;\\n            \\n            subResult.add(cut); \\n            woodcutter(s.substring(i, s.length()), subResult);\\n            subResult.remove(subResult.size() - 1); \\n        }\\n        return;\\n    }\\n\\n    public boolean isPalindrome(String s){\\n        int i = 0; int j = s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        \\n        woodcutter(s, new ArrayList<>());\\n        return result;\\n    }\\n\\n    public void woodcutter(String s, List<String> subResult) {\\n        // Base case\\n        if( s.length() == 0 || s == null) {\\n            result.add(new ArrayList<>(subResult));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String cut = s.substring(0, i);\\n            if(!isPalindrome(cut)) continue;\\n            \\n            subResult.add(cut); \\n            woodcutter(s.substring(i, s.length()), subResult);\\n            subResult.remove(subResult.size() - 1); \\n        }\\n        return;\\n    }\\n\\n    public boolean isPalindrome(String s){\\n        int i = 0; int j = s.length()-1;\\n        while(i<=j){\\n            if(s.charAt(i)!=s.charAt(j)) return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42023,
                "title": "concise-java-solution",
                "content": "    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res=new ArrayList<List<String>>();\\n            if(s.length()==0)return res;\\n            recur(res,new ArrayList<String>(),s);\\n            return res;\\n        }\\n        \\n        public void recur(List<List<String>> res,List<String> temp, String s){\\n            if(s.length()==0){\\n                res.add(new ArrayList<String>(temp));\\n                return;\\n            }\\n            for(int i=0;i<s.length();i++){\\n                if(isPalin(s.substring(0,i+1))){\\n                    temp.add(s.substring(0,i+1));\\n                    recur(res,temp,s.substring(i+1));\\n                    temp.remove(temp.size()-1);\\n                }\\n            }\\n        }\\n        \\n        public boolean isPalin(String s){\\n            for(int i=0;i<s.length()/2;i++){\\n                if(s.charAt(i)!=s.charAt(s.length()-1-i))return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res=new ArrayList<List<String>>();\\n            if(s.length()==0)return res;\\n            recur(res,new ArrayList<String>(),s);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486544,
                "title": "python-straightforward-recursion-easy-above-average-performance-well-explained",
                "content": "First, we create a globar list `res` - this is the result we are going return.\\n\\nSecond, we define a recursive function.  It takes two arguments:\\n\\n`arr` - a list of palindromes we have found up to this point\\n`str` - the string left to analyze\\n\\nSince it\\'s a recursive function, let\\'s define the exit criteria. If `str` is empty and `arr` is not - that means we\\'ve been able to break up the whole intial string `s` into palindromes. So we just add `arr` to `res` and return. If `str` is empty but `arr` is also empty - that means we got an empty `s`. So we just return without adding `arr` to `res`.\\n\\nOk, now we define the recursion step. We look at every substring of `str` `(str[:1],...,str[:-1]` and check if it is a palindrome. The check is simply `if str[:i] == str[:i][::-1]:` . If this substring is a palindrome, we continue recursion by calling helper again with `arr+[str[:i]]` (the extended palindrome sequence) and what is left from `str: str[i:]`.\\n\\nThat\\'s it!\\n\\n\\n```\\nclass Solution(object):\\n    def partition(self, s):\\n        res=[]\\n        \\n        def helper(arr, str):\\n            if str:\\n                for i in range(1, len(str)+1):\\n                    if str[:i] == str[:i][::-1]:\\n                        helper(arr+[str[:i]], str[i:])\\n            elif arr: \\n                    res.append(arr)\\n        \\n        helper([], s)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def partition(self, s):\\n        res=[]\\n        \\n        def helper(arr, str):\\n            if str:\\n                for i in range(1, len(str)+1):\\n                    if str[:i] == str[:i][::-1]:\\n                        helper(arr+[str[:i]], str[i:])\\n            elif arr: \\n                    res.append(arr)\\n        \\n        helper([], s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971898,
                "title": "python-dp-dfs-solution-explained",
                "content": "First thing we need to see when we look at problem description, that `n` is pretty small, no more than `15`, and it is done for reason: we will see in our complexity analysis why. Let us use function `find_all_palindromes`, where:\\n\\n1. `s` is input string, imagine `abacc`.\\n2. Output is lengths of biggest palindromes for each of the `2n-1` possible middles. Why there is `2n-1`? Because it can be either letter or in between letters.\\n3. Here I use very simple way to find all palindromes: just consider every possible substring, there will be `O(n^2)` of them and check in `O(n)` if it is palindrome. Total complexity of this step is `O(n^3)`, but we do not care here: complexity of the next step will be much bigger.\\n\\nNow, let us `dp[i+1]` be solution for `s[:i]`. How we can find `dp[i+1]`? We need to iterate over all `k in range (0, N)`: possible starts of last palindrome and check `if B[2*i-k+1] >= k`: this condition means that `s[i-k: i+1]` is palindrome: so now we just iterate over all solutions for `dp[i-k]` and add this string to the end of solutions. Why I prefer here `dp` solution, not backtracking, because it is more universal and you can solve **132. Palindrome Partitioning II** just changing code a bit.\\n\\n**Comlexity**: as we discussed, complexity of finding all palindromes is `O(n^3)`. Now, imagine we have string `aaa...aa` with length `n`. Then there will be exactly `2^(n-1)` ways to split this string in palindromes: we can cut it in any of `n-1` places. So, there will be `O(2^n* n)` time and space to keep solution for `s`. Also we keep solution for all prefixes of `s`, but we have `O(2^n * n + 2^(n-1)*(n-1) + ...)` which is still `O(2^n * n)`. Space complexity is the same: we need this amount of memory just to keep answer.\\n\\n**Remark** I ran this code 6 months ago and it was around 60-70ms, now it is 600-700ms, this means, that leetcode added new tests and histogram is not relevant at the moment. Do not be discouraged whey you see something like  faster than 10%, it is not true.\\n\\n**Remark2** Note again, that `find_all_palindromes(s)` has complexity `O(n^3)` here, and there is `O(n^2)` and even `O(n)` algorithms for this. But if you change this part, difference will be negligible: you can try and will see.\\n\\n```\\nclass Solution:\\n    def partition(self, s):\\n        def find_all_palindromes(s):\\n            B = [0] * (2*n)\\n            for i, j in combinations_with_replacement(range(n), 2):\\n                if s[i:j+1] == s[i:j+1][::-1]:\\n                    B[i+j+1] = max(B[i+j+1], j-i+1)\\n            return B\\n        \\n        n = len(s)\\n        B = find_all_palindromes(s)\\n        \\n        dp = [[] for _ in range(n+1)]\\n        dp[0] = [[]]\\n        for i in range(0, n):\\n            for k in range(0, i+1):\\n                if B[2*i-k+1] >= k:\\n                    for elem in dp[i-k]:\\n                        dp[i + 1].append(elem  + [s[i-k:i+1]])\\n\\n        return dp[-1]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s):\\n        def find_all_palindromes(s):\\n            B = [0] * (2*n)\\n            for i, j in combinations_with_replacement(range(n), 2):\\n                if s[i:j+1] == s[i:j+1][::-1]:\\n                    B[i+j+1] = max(B[i+j+1], j-i+1)\\n            return B\\n        \\n        n = len(s)\\n        B = find_all_palindromes(s)\\n        \\n        dp = [[] for _ in range(n+1)]\\n        dp[0] = [[]]\\n        for i in range(0, n):\\n            for k in range(0, i+1):\\n                if B[2*i-k+1] >= k:\\n                    for elem in dp[i-k]:\\n                        dp[i + 1].append(elem  + [s[i-k:i+1]])\\n\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084642,
                "title": "python3-simple-backtracking-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this problem DP can be considered but as we are not calculating number of solutions but to return all the possible solutions.So it is better to backtrack. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Consider a function palindrome to check whether a string is palindrome or not.\\n- an other function dfs to backtrack with parameters \\'i\\' -> current position and curr -> current solution\\n- first condition if postion \\'i\\' is the last position of the string we got our complete traversal and append to the solution\\n- else traverse the string from  \\'i\\' to len(s) and if current partition \\'sol\\' is palindrome backtrack again for all possible solutions.\\n- In a nutshell we get all the possible solutions just by backtracking.\\n\\n# Complexity\\n- Time complexity: O(2^n)*O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> For Each character in the input string the algorithm generates 2 recursive calls, one for including the character and one for not including it.For this O(2^n).To check whether the string is palindrome or not we have O(n) time complexity.\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The list stores single list for a current partition.So in the worst case if each character is considered a palindrome then the time complexity will be O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        lst = []\\n        def palindrome(a):\\n            return a == a[::-1]\\n        def dfs(i,curr):\\n            if i == len(s):\\n                lst.append(curr)\\n                return \\n            for j in range(i,len(s)):\\n                sol = s[i:j+1]\\n                if palindrome(sol):\\n                    dfs(j+1, curr + [sol] )\\n            return \\n        dfs(0,[])\\n        return lst\\n            \\n\\n```\\nps: s[::-1] easy way to reverse a string",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        lst = []\\n        def palindrome(a):\\n            return a == a[::-1]\\n        def dfs(i,curr):\\n            if i == len(s):\\n                lst.append(curr)\\n                return \\n            for j in range(i,len(s)):\\n                sol = s[i:j+1]\\n                if palindrome(sol):\\n                    dfs(j+1, curr + [sol] )\\n            return \\n        dfs(0,[])\\n        return lst\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154417,
                "title": "easy-backtracking-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string prefix)\\n    {\\n        int l=0;\\n        int r=prefix.size()-1;\\n        while(l<r)\\n        {\\n            if(prefix[l]!=prefix[r])\\n                return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n    void solve(string s,vector<vector<string>>&ans,vector<string>&v)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string prefix=s.substr(0,i+1);\\n            string left=s.substr(i+1);\\n            if(palindrome(prefix))\\n            {\\n                v.push_back(prefix);\\n                solve(left,ans,v);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool palindrome(string prefix)\\n    {\\n        int l=0;\\n        int r=prefix.size()-1;\\n        while(l<r)\\n        {\\n            if(prefix[l]!=prefix[r])\\n                return false;\\n            l++;r--;\\n        }\\n        return true;\\n    }\\n    void solve(string s,vector<vector<string>>&ans,vector<string>&v)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string prefix=s.substr(0,i+1);\\n            string left=s.substr(i+1);\\n            if(palindrome(prefix))\\n            {\\n                v.push_back(prefix);\\n                solve(left,ans,v);\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 971863,
                "title": "python-js-c-go-by-dfs-backtracking-w-comment",
                "content": "Python by DFS backtracking\\n\\n---\\n\\n**Implementation**:\\n\\nin **Python**:\\n\\n```\\nclass Solution:\\n    \\n    # -----------------------------------------------------\\n    def dfs(self, s, partition, result):\\n        \\n        if not s:\\n            \\n            ## base case aka stop condition\\n            # add into result when we meet a empty string\\n            result.append( partition[::] )\\n            return\\n        \\n        \\n        ## general cases:\\n        # scan each possible split index\\n        \\n        for i in range(1, len(s)+1):\\n            \\n            prefix, postfix = s[:i], s[i:]\\n            \\n            if self.is_palindrome( prefix ):\\n                \\n                # current prefix is palindrome, keep trying to make more partition in DFS\\n                partition.append( prefix )\\n                self.dfs(postfix, partition, result)\\n                partition.pop()\\n\\n    # -----------------------------------------------------\\n    \\n    def is_palindrome(self, s):\\n        \\n        # helper function to chceck palindrome\\n        return s == s[::-1]\\n    \\n    # -----------------------------------------------------\\n    \\n    def partition(self, s):\\n\\n        # record for solution\\n        result = []\\n\\n        # make palindrome partition in DFS\\n        self.dfs(s, [], result)\\n        return result\\n```\\n\\n---\\n\\nIn **Javascript**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\t\\n```\\nconst isPalindrome = str => ( str === str.split(\\'\\').reverse().join(\\'\\') );\\n\\n\\nvar dfs = function(s, partition, result){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if( 0 == s.length ){\\n        \\n        result.push( [...partition] );\\n        return;\\n    }\\n    \\n    \\n    // General cases:\\n    \\n    for( let i = 1; i <= s.length ; i++ ){\\n        \\n        let prefix = s.substring(0, i);\\n        let postfix = s.substring(i);\\n        \\n        // Current prefix is palindrome, keep trying to make more partition in postfix by DFS\\n        if( isPalindrome(prefix) ){\\n            \\n            partition.push( prefix );\\n            \\n            dfs( postfix, partition, result);\\n            \\n            partition.pop();\\n        }\\n        \\n    }\\n    return\\n};\\n\\nvar partition = function(s) {\\n    \\n    // buffer for partition in DFS\\n    let partition = [];\\n    \\n    // final output of palindrome substrings\\n    let result = [];\\n    \\n    dfs(s, partition, result);\\n    \\n    return result;\\n};\\n```\\n\\n</details>\\n\\n---\\n\\nIn **C++**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\t\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        \\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        \\n        // Make palindrome partition in DFS\\n        dfs( s, partition, result);\\n        \\n        return result;\\n        \\n    }\\nprivate:\\n    bool isPalindrome(const string &s){\\n        \\n        string revStr = s;\\n        reverse( revStr.begin(), revStr.end() );\\n        \\n        return s == revStr;\\n    }\\n        \\n        \\n    void dfs(string &s, vector<string> &partition, vector< vector<string> > &result ){\\n        \\n        // Base case:\\n        // Empty string must be palindrome\\n        \\n        if( 0 == s.size() ){\\n            \\n            result.push_back( partition );\\n            return;\\n        } \\n        \\n        \\n        // General cases:\\n        for( int i = 1 ; i <= s.size() ; i++ ){\\n            \\n            string prefix = s.substr(0, i);\\n            string postfix = s.substr(i);\\n            \\n            // Current prefix is palindrome, leep trying to make more partition in postfix by DFS\\n            if( isPalindrome(prefix) ){\\n\\n                partition.push_back( prefix );\\n\\n                dfs( postfix, partition, result);\\n                \\n                partition.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n```\\n\\n</details>\\n\\n---\\n\\nIn **Go**:\\n\\n<details>\\n\\t<summary>Expand to see source code</summary>\\n\\n```\\nfunc isPalindrome(s string)bool{\\n    \\n    left, right := 0, len(s)-1\\n    \\n    for left < right{\\n    \\n        if s[left] != s[right]{\\n            return false;\\n        }\\n        \\n        left, right = left+1, right-1\\n    }\\n    \\n    return true;\\n}\\n\\n\\nfunc dfs(s string, partition *[]string, result *[][]string){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if 0 == len(s){\\n        \\n        // Make a copy of current partition, and save into result\\n        goodPartition := make([]string, len(*partition))\\n        copy(goodPartition, *partition)\\n\\n        *result = append(*result, goodPartition)\\n        return\\n    }\\n    \\n    \\n    // General case:\\n    for i := 1 ; i <= len(s) ; i++{\\n        \\n        prefix := s[0:i]\\n        postfix := s[i:]\\n        \\n        if isPalindrome( prefix ){\\n            \\n            *partition = append(*partition, prefix)\\n            \\n            dfs( postfix, partition, result)\\n            \\n            // golang doesn\\'t have built-in pop function for slice\\n            *partition = (*partition)[:len(*partition)-1]\\n        }\\n    }\\n    return\\n}\\n\\n\\nfunc partition(s string) [][]string {\\n    \\n    // buffer for partition in DFS\\n    part := make([]string,0)\\n    \\n    // final output of palindrome substrins\\n    result := make([][]string,0)\\n    \\n    dfs(s, &part, &result)\\n    return result\\n}\\n```\\n\\n</details>\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki : Palindrome](https://en.wikipedia.org/wiki/Palindrome)\\n\\n[2] [Python official docs about string and sting slicing](https://docs.python.org/3/tutorial/introduction.html#strings)\\n\\n[3] [MDN: Javascript docs about substring](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/substring)\\n\\n[4] [Cpp reference about C++ substring](https://www.cplusplus.com/reference/string/string/substr/)\\n\\n[5] [Golang Docs about substring](https://golangdocs.com/substring-in-golang)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "String",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # -----------------------------------------------------\\n    def dfs(self, s, partition, result):\\n        \\n        if not s:\\n            \\n            ## base case aka stop condition\\n            # add into result when we meet a empty string\\n            result.append( partition[::] )\\n            return\\n        \\n        \\n        ## general cases:\\n        # scan each possible split index\\n        \\n        for i in range(1, len(s)+1):\\n            \\n            prefix, postfix = s[:i], s[i:]\\n            \\n            if self.is_palindrome( prefix ):\\n                \\n                # current prefix is palindrome, keep trying to make more partition in DFS\\n                partition.append( prefix )\\n                self.dfs(postfix, partition, result)\\n                partition.pop()\\n\\n    # -----------------------------------------------------\\n    \\n    def is_palindrome(self, s):\\n        \\n        # helper function to chceck palindrome\\n        return s == s[::-1]\\n    \\n    # -----------------------------------------------------\\n    \\n    def partition(self, s):\\n\\n        # record for solution\\n        result = []\\n\\n        # make palindrome partition in DFS\\n        self.dfs(s, [], result)\\n        return result\\n```\n```\\nconst isPalindrome = str => ( str === str.split(\\'\\').reverse().join(\\'\\') );\\n\\n\\nvar dfs = function(s, partition, result){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if( 0 == s.length ){\\n        \\n        result.push( [...partition] );\\n        return;\\n    }\\n    \\n    \\n    // General cases:\\n    \\n    for( let i = 1; i <= s.length ; i++ ){\\n        \\n        let prefix = s.substring(0, i);\\n        let postfix = s.substring(i);\\n        \\n        // Current prefix is palindrome, keep trying to make more partition in postfix by DFS\\n        if( isPalindrome(prefix) ){\\n            \\n            partition.push( prefix );\\n            \\n            dfs( postfix, partition, result);\\n            \\n            partition.pop();\\n        }\\n        \\n    }\\n    return\\n};\\n\\nvar partition = function(s) {\\n    \\n    // buffer for partition in DFS\\n    let partition = [];\\n    \\n    // final output of palindrome substrings\\n    let result = [];\\n    \\n    dfs(s, partition, result);\\n    \\n    return result;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        \\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        \\n        // Make palindrome partition in DFS\\n        dfs( s, partition, result);\\n        \\n        return result;\\n        \\n    }\\nprivate:\\n    bool isPalindrome(const string &s){\\n        \\n        string revStr = s;\\n        reverse( revStr.begin(), revStr.end() );\\n        \\n        return s == revStr;\\n    }\\n        \\n        \\n    void dfs(string &s, vector<string> &partition, vector< vector<string> > &result ){\\n        \\n        // Base case:\\n        // Empty string must be palindrome\\n        \\n        if( 0 == s.size() ){\\n            \\n            result.push_back( partition );\\n            return;\\n        } \\n        \\n        \\n        // General cases:\\n        for( int i = 1 ; i <= s.size() ; i++ ){\\n            \\n            string prefix = s.substr(0, i);\\n            string postfix = s.substr(i);\\n            \\n            // Current prefix is palindrome, leep trying to make more partition in postfix by DFS\\n            if( isPalindrome(prefix) ){\\n\\n                partition.push_back( prefix );\\n\\n                dfs( postfix, partition, result);\\n                \\n                partition.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n};\\n\\n```\n```\\nfunc isPalindrome(s string)bool{\\n    \\n    left, right := 0, len(s)-1\\n    \\n    for left < right{\\n    \\n        if s[left] != s[right]{\\n            return false;\\n        }\\n        \\n        left, right = left+1, right-1\\n    }\\n    \\n    return true;\\n}\\n\\n\\nfunc dfs(s string, partition *[]string, result *[][]string){\\n    \\n    // Base case:\\n    // Empty string must be palindrome\\n    if 0 == len(s){\\n        \\n        // Make a copy of current partition, and save into result\\n        goodPartition := make([]string, len(*partition))\\n        copy(goodPartition, *partition)\\n\\n        *result = append(*result, goodPartition)\\n        return\\n    }\\n    \\n    \\n    // General case:\\n    for i := 1 ; i <= len(s) ; i++{\\n        \\n        prefix := s[0:i]\\n        postfix := s[i:]\\n        \\n        if isPalindrome( prefix ){\\n            \\n            *partition = append(*partition, prefix)\\n            \\n            dfs( postfix, partition, result)\\n            \\n            // golang doesn\\'t have built-in pop function for slice\\n            *partition = (*partition)[:len(*partition)-1]\\n        }\\n    }\\n    return\\n}\\n\\n\\nfunc partition(s string) [][]string {\\n    \\n    // buffer for partition in DFS\\n    part := make([]string,0)\\n    \\n    // final output of palindrome substrins\\n    result := make([][]string,0)\\n    \\n    dfs(s, &part, &result)\\n    return result\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083724,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=x_cz9YqULlk&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=22) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/bWBHaVW2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Rust"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=x_cz9YqULlk&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=22) if you are interested.\\n\\n---\\n\\n<iframe src=\"https://leetcode.com/playground/bWBHaVW2/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 3084168,
                "title": "3-solutions-deep-explaination-backtracking-c-java-python3",
                "content": "# Approach : Backtracking\\n```\\nExample - xxyy\\n```\\n![104d7464-a56c-45c3-87cc-4caea3a05103_1641347225.9497328.png](https://assets.leetcode.com/users/images/23e40e5d-a8dd-4ea5-b19f-5c369ea62d6f_1674362772.6449003.png)\\n\\n# Complexity :\\n- Time Complexity :- BigO(N*2^N)\\n- Space Complexity :- BigO(N)\\n\\n# Request \\uD83D\\uDE0A :\\n- If you find this solution easy to understand and helpful, then Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n![ezgif-3-22a360561c.gif](https://assets.leetcode.com/users/images/1049379a-7a98-48f2-beea-227de8d2370b_1674361539.0190594.gif)\\n\\n# Code [C++]: \\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n# Code [Java]:\\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\n# Code [Python3]:\\uD83D\\uDD25\\uD83D\\uDD25\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        palindro = []\\n        path = []\\n        self.helper(0, s, path, palindro)\\n        return palindro\\n\\n    def helper(self, index, s, path, palindro):\\n        if index == len(s):\\n            palindro.append(path[:])\\n            return\\n        for i in range(index, len(s)):\\n            if self.is_palindro(s, index, i):\\n                path.append(s[index:i+1])\\n                self.helper(i+1, s, path, palindro)\\n                path.pop()\\n\\n    def is_palindro(self, s, start, end):\\n        while start <= end:\\n            if s[start] != s[end]:\\n                return False\\n            start += 1\\n            end -= 1\\n        return True\\n\\n```\\ncredits to [@hi-malik](https://leetcode.com/hi-malik/) for helping me out",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nExample - xxyy\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // which will be our answer\\n        vector<string> path; // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>(); // which will be our answer\\n        List<String> path = new ArrayList<>(); // as we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res;\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    public void helper(int index, String s, List<String> path, List<List<String>> res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.length()){\\n            res.add(new ArrayList<>(path));\\n            return;\\n        }\\n        // Let\\'s talk about partition\\n        for(int i = index; i < s.length(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.add(s.substring(index, i + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.remove(path.size() - 1); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    } \\n    \\n    public boolean isPalindrome(String s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s.charAt(start++) != s.charAt(end--)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        palindro = []\\n        path = []\\n        self.helper(0, s, path, palindro)\\n        return palindro\\n\\n    def helper(self, index, s, path, palindro):\\n        if index == len(s):\\n            palindro.append(path[:])\\n            return\\n        for i in range(index, len(s)):\\n            if self.is_palindro(s, index, i):\\n                path.append(s[index:i+1])\\n                self.helper(i+1, s, path, palindro)\\n                path.pop()\\n\\n    def is_palindro(self, s, start, end):\\n        while start <= end:\\n            if s[start] != s[end]:\\n                return False\\n            start += 1\\n            end -= 1\\n        return True\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42113,
                "title": "share-my-dynamic-programming-solution-with-explaination",
                "content": "Use a DP vecor DP[i] to record all solutions using string s[:i+1]\\n\\n    class Solution:\\n        # @param {string} s\\n        # @return {string[][]}\\n        def partition(self, s):\\n            if not s:\\n                return [[]]\\n            dp = {0:[[]], 1:[[s[0]]]}\\n            for ii in xrange(1, len(s)):\\n                dp[ii+1] = []\\n                for jj in xrange(0, ii+1):\\n                    if self.isPalindrome(s[jj:ii+1]):\\n                        for sol in dp[jj]:\\n                            dp[ii+1].append(sol+[s[jj:ii+1]])\\n            return dp[len(s)]\\n\\n        \\n        def isPalindrome(self, string):\\n            return string == string[::-1]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "class Solution:\\n        # @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 557573,
                "title": "intuitive-javascript-solution-with-dfs",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const output = [];\\n    const partitions = [];\\n    const isPalindrome = str => str === str.split(\\'\\').reverse().join(\\'\\');\\n    const findPalindrome = (str, start, parts, result) => {\\n        if (start === str.length) {\\n            result.push([...parts])\\n            return;\\n        }\\n        \\n        for (let i = start + 1; i <= str.length; i++) {\\n            const target = str.substring(start, i);\\n            if (isPalindrome(target)) {\\n                parts.push(target);\\n                findPalindrome(str, i, parts, result);        \\n                parts.pop();\\n            }\\n        }\\n    }\\n    /*\\n        string: \\'aab\\'\\n        start = 0 will find palindrome in \\'a\\', \\'aa\\', \\'aab\\'\\n        start = 1 will find palindrome in      \\'a\\',  \\'ab\\'\\n        start = 2 will find palindrome in            \\'b\\'\\n     */\\n    findPalindrome(s, 0, partitions, output);   \\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    const output = [];\\n    const partitions = [];\\n    const isPalindrome = str => str === str.split(\\'\\').reverse().join(\\'\\');\\n    const findPalindrome = (str, start, parts, result) => {\\n        if (start === str.length) {\\n            result.push([...parts])\\n            return;\\n        }\\n        \\n        for (let i = start + 1; i <= str.length; i++) {\\n            const target = str.substring(start, i);\\n            if (isPalindrome(target)) {\\n                parts.push(target);\\n                findPalindrome(str, i, parts, result);        \\n                parts.pop();\\n            }\\n        }\\n    }\\n    /*\\n        string: \\'aab\\'\\n        start = 0 will find palindrome in \\'a\\', \\'aa\\', \\'aab\\'\\n        start = 1 will find palindrome in      \\'a\\',  \\'ab\\'\\n        start = 2 will find palindrome in            \\'b\\'\\n     */\\n    findPalindrome(s, 0, partitions, output);   \\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3323894,
                "title": "short-c-java-python-js-explained-solution",
                "content": "\\n# **Read Article COde with Explaination:\\n# **\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n![WhatsApp Image 2023-01-22 at 11.27.47 AM.jpeg](https://assets.leetcode.com/users/images/0f629558-6de6-4518-840a-9d79536debdd_1674368333.426988.jpeg)\\n\\n\\n\\nRead Article COde with Explaination:\\n\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/7671beaf-d6ab-412a-8d70-58fb792be7a6_1674368322.430683.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "\\n# **Read Article COde with Explaination:\\n# **\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n![WhatsApp Image 2023-01-22 at 11.27.47 AM.jpeg](https://assets.leetcode.com/users/images/0f629558-6de6-4518-840a-9d79536debdd_1674368333.426988.jpeg)\\n\\n\\n\\nRead Article COde with Explaination:\\n\\nhttps://www.nileshblog.tech/2023/01/palindrome-partitioning-of-a-string-leetcode-problem-solution/\\n\\n\\n\\n![0c02f9a6-2084-4ebb-b8f3-600c8b5f62a4_1674006448.3568876.jpeg](https://assets.leetcode.com/users/images/7671beaf-d6ab-412a-8d70-58fb792be7a6_1674368322.430683.jpeg)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2779787,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string> > ret;\\n        if(s.empty()) return ret;\\n        \\n        vector<string> path;\\n        dfs(0, s, path, ret);\\n        \\n        return ret;\\n    }\\n    \\n    void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n        if(index == s.size()) {\\n            ret.push_back(path);\\n            return;\\n        }\\n        for(int i = index; i < s.size(); ++i) {\\n            if(isPalindrome(s, index, i)) {\\n                path.push_back(s.substr(index, i - index + 1));\\n                dfs(i+1, s, path, ret);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(const string& s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string> > ret;\\n        if(s.empty()) return ret;\\n        \\n        vector<string> path;\\n        dfs(0, s, path, ret);\\n        \\n        return ret;\\n    }\\n    \\n    void dfs(int index, string& s, vector<string>& path, vector<vector<string> >& ret) {\\n        if(index == s.size()) {\\n            ret.push_back(path);\\n            return;\\n        }\\n        for(int i = index; i < s.size(); ++i) {\\n            if(isPalindrome(s, index, i)) {\\n                path.push_back(s.substr(index, i - index + 1));\\n                dfs(i+1, s, path, ret);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(const string& s, int start, int end) {\\n        while(start <= end) {\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1435290,
                "title": "c-recursion-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<string>> partition(string s) {\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tvector<string>path;\\n\\t\\tint n = s.size();\\n\\t\\tsolve(0, n, s, path, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid solve(int index, int n, string s, vector<string>&path, vector<vector<string>>&ans)\\n\\t{\\n\\t\\tif (index == n)\\n\\t\\t{\\n\\t\\t\\tans.push_back(path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = index; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == s[index] && ispalindrome(index, i, s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpath.push_back(s.substr(index, i - index + 1));\\n\\t\\t\\t\\tsolve(i + 1, n, s, path, ans);\\n\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool ispalindrome(int start, int end, string &s)\\n\\t{\\n\\t\\twhile (start < end)\\n\\t\\t{\\n\\t\\t\\tif (s[start++] != s[end--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\tvector<vector<string>> partition(string s) {\\n\\t\\tvector<vector<string>> ans;\\n\\t\\tvector<string>path;\\n\\t\\tint n = s.size();\\n\\t\\tsolve(0, n, s, path, ans);\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tvoid solve(int index, int n, string s, vector<string>&path, vector<vector<string>>&ans)\\n\\t{\\n\\t\\tif (index == n)\\n\\t\\t{\\n\\t\\t\\tans.push_back(path);\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tfor (int i = index; i < n; i++)\\n\\t\\t{\\n\\t\\t\\tif (s[i] == s[index] && ispalindrome(index, i, s))\\n\\t\\t\\t{\\n\\t\\t\\t\\tpath.push_back(s.substr(index, i - index + 1));\\n\\t\\t\\t\\tsolve(i + 1, n, s, path, ans);\\n\\t\\t\\t\\tpath.pop_back();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tbool ispalindrome(int start, int end, string &s)\\n\\t{\\n\\t\\twhile (start < end)\\n\\t\\t{\\n\\t\\t\\tif (s[start++] != s[end--])\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn true;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083432,
                "title": "well-explained-beginner-friendly-java-c-py-with-algorithm-short-simple",
                "content": "\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5ab61190-e3d5-486b-bd64-33b691de34f7_1674345818.8312604.png)\\n\\n```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\\n\\nTake an example, \"xxyy\".\\nIf we partition over x|xyy so the substring \"x\" is a palindrome. Where i can have the first partition.\\n\\nBut, if they don\\'t allow to partition over there, then our second partition will be xx|yy. Because this \"xx\" is a palindrome substring. Thus we still left out with yy, so if i do the partion over here xxy|y the answer will be no, because if i do the partition over here the substring \"xxy\" is not a palindrome.\\n\\nCan i do a partition over here xxyy|. No. Because xxyy is not a palindromic substring. So, we can see when we started we can do a partition over here x|xyy OR xx|yy so that is what we do. We try to do partition where ever it is possible\\n\\nSo, in the first case we did a partition over x|xyy where we left out with xyy. So, if i do a partiton like x|x|yy where x it\\'self a palindrome. And we left out with a substring yy\\nNow can you do a partition over here x|xy|y. No, because this substring xy is not a palindrome\\nAgain can we do a partition over here x|xyy|. No, because this substring xyy is not a palindrome\\n\\nSo, the only partition possible is x|x|yy. And after that we tend to call the recursion for remaining substring\\n\\nIf i try to do a partition over here x|x|y|y so, the substring y in itself is a palindromic substring. After that we left out with remaining y substring.\\nNow you ask can we do a partition over here x|x|yy|, Yes\\n\\nLike this way, we do the partition in complete STRING using recursion. And with the help of Backtracking we store our answer.\\n\\n![image.png](https://assets.leetcode.com/users/images/1b01b518-620e-4e35-b0a3-49f034611e67_1674347528.772972.png)\\n![image.png](https://assets.leetcode.com/users/images/ba149c7d-b4d5-4c1d-abb8-8b76f8342241_1674347548.816257.png)\\n\\n\\nAll backtracking problems are composed by these three steps: choose, explore, unchoose.\\nSo for each problem, you need to know:\\n\\nchoose what? For this problem, we choose each substring.\\nhow to explore? For this problem, we do the same thing to the remained string. unchoose Do the opposite operation of choose.\\nLet\\'s take this problem as an example:\\n1. Define helper(): Usually we need a helper funcition in backtracking problem, to accept more parameters.\\n2. Parameters: Usually we need the following parameters\\n\\n    1. The object you are working on:  For this problem is String s.\\n    2. A start index or an end index which indicate which part you are working on: For this problem, we use substring to indicate the start index.\\n    3. A step result, to remember current choose and then do unchoose : For this problem, we use List<String> step.\\n    4. A final result, to remember the final result. Usually when we add, we use \\'result.add(new ArrayList<>(step))\\' instead of \\'result.add(step)\\', since step is reference passed. We will modify step later, so we need to copy it and add the copy to the result;\\n\\n3 .Base case: The base case defines when to add step into result, and when to return.\\n4 .Use for-loop : Usually we need a for loop to iterate though the input String s, so that we can choose all the options.\\n5 .Choose : In this problem, if the substring of s is palindrome, we add it into the step, which means we choose this substring.\\n6 .Explore : In this problem, we want to do the same thing to the remaining substring. So we recursively call our function.\\n7 .Un-Choose : We draw back, remove the chosen substring, in order to try other options.\\n\\n# Code\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\\n\\n\\n# Algorithm :-\\n\\n1. As i told you in backtracking, one thing is sure i.e a helper method. In our problem we will need a bool helper method which will check the palindrome conditions, let\\'s name it as bool isPalindrome().\\n2. Now let\\'s create some variables : result vector for storing all the substring which satisfies the palindrome condition , path vector for storing the ongoing substr which has the potential of satisfying the conditions of palindrome , start variable for storing the start position of the current substr , index i for traversing inside the substring and n fro storing the size of given string s.\\n3. Now we search from start till the end of the string. Once we reach a position i such that the sub-string from start to i (s.substr(start, i - start + 1)) is a palindrome, we add it to our path variable. Then we recursively call the same method to execute the remaining substring . Once we reach the end of the string, we add palindromes path into the result of all the possible partitioning .\\n4. Remember that at position i , we find s.substr(start, i - start + 1) to be a palindrome and we immediately add it to path . Now think that there may be a position j such that j > i and s.substr(start, j - start + 1) is also a palindrome. Thus now we need to go back to our start before adding s.substr(start, i - start + 1) to path and continue to find the next palindrome position after i . And after this evertime we simply need to remove or pop s.substr(start, i - start + 1) out of path to execute the backtracking algo .\\n5. The steps we executed in the above step is none other than the famous dfs .\\n\\n# Code\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes.\\nLet me know in comment if i can do better.\\nLets connect on [Linkedin](https://www.linkedin.com/in/kailas-rathod/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nLet\\'s Understood with an example:\\n\\n\"xxyy\" -> [\"x\", \"x\", \"y\", \"y\"] // 1st List of all the substring\\n          [\"x\", \"x\", \"yy\"] // 2nd List of all the substring\\n          [\"xx\", \"y\", \"y\"] // 3rd List of all the substring\\n          [\"xx\", \"yy\"] // 4th List of all the substring\\n\\nIn the above example we can only have 4 possible list\\'s\\n\\nOur task is to return a list of all of these list\\'s, that are possible\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```\n```java []\\nclass Solution {\\n   public List<List<String>> partition(String s) {\\n        // Backtracking\\n        // Edge case\\n        if(s == null || s.length() == 0) return new ArrayList<>();\\n        \\n        List<List<String>> result = new ArrayList<>();\\n        helper(s, new ArrayList<>(), result);\\n        return result;\\n    }\\n    public void helper(String s, List<String> step, List<List<String>> result) {\\n        // Base case\\n        if(s == null || s.length() == 0) {\\n            result.add(new ArrayList<>(step));\\n            return;\\n        }\\n        for(int i = 1; i <= s.length(); i++) {\\n            String temp = s.substring(0, i);\\n            if(!isPalindrome(temp)) continue; // only do backtracking when current string is palindrome\\n            \\n            step.add(temp);  // choose\\n            helper(s.substring(i, s.length()), step, result); // explore\\n            step.remove(step.size() - 1); // unchoose\\n        }\\n        return;\\n    }\\n    public boolean isPalindrome(String s) {\\n        int left = 0, right = s.length() - 1;\\n        while(left <= right) {\\n            if(s.charAt(left) != s.charAt(right))\\n                return false;\\n            left ++;\\n            right --;\\n        }\\n        return true;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> path; // here we are generating list everythime, so at the end this will be our list\\n        helper(0, s, path, res); // calling to recursion function start from index 0 and string s\\n        return res; //returning\\n    }\\n    // Entire recursive function, that generates all the partition substring\\n    void helper(int index, string s, vector<string> &path, vector<vector<string>> &res){\\n        // Base Condition, which means when we have done partition at the end (n), then add it to our ultimate result\\n        if(index == s.size()){\\n            res.push_back(path);\\n            return;//returning\\n        }\\n        // then partition\\n        for(int i = index; i < s.size(); i++){\\n            if(isPalindrome(s, index, i)){ // what we are checking over here is, if we partition the string from index to i Example-(0, 0) is palindrome or not\\n                path.push_back(s.substr(index, i - index + 1)); // take the substring and store it in our list & call the next substring from index + 1\\n                helper(i + 1, s, path, res); // as we have done for (0, 0) then our next will be from (1)\\n                path.pop_back(); // please make sure you remove when you backtrack. \\n                // Why? Because let say i had partion y, so when i go back. I can\\'t have yy\\n            }\\n        }\\n    }\\n    bool isPalindrome(string s, int start, int end){ // A simple palindromic function start from 0 go till end. And basically keep on checking till they don\\'t cross. \\n        while(start <= end){\\n            if(s[start++] != s[end--]) return false; //returning if false\\n        }\\n        return true;//returning if true\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935375,
                "title": "100-fastest-swift-solution-time-o-n-2-n-space-o-n-2",
                "content": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * 2^n), where n is the length of s.\\n    //   - space: O(n^2), where n is the length of s.\\n\\n    func partition(_ s: String) -> [[String]] {\\n        let n = s.count\\n        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\\n        var ans = [[String]]()\\n        var currentList = [String]()\\n\\n        dfs(&ans, str: Array(s), n: n, start: 0, &currentList, &dp)\\n        return ans\\n    }\\n\\n    \\n    private func dfs(_ ans: inout [[String]], str: [Character], n: Int, start: Int, _ currentList: inout [String], _ dp: inout [[Bool]]) {\\n        guard start < n else { ans.append(currentList); return }\\n            \\n        for end in start..<n {\\n            guard str[start] == str[end], (end - start <= 2 || dp[start + 1][end - 1]) else { continue }\\n            dp[start][end] = true\\n            currentList.append(String(str[start...end]))\\n            dfs(&ans, str: str, n: n, start: end + 1, &currentList, &dp)\\n            currentList.removeLast()\\n        }\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n * 2^n), where n is the length of s.\\n    //   - space: O(n^2), where n is the length of s.\\n\\n    func partition(_ s: String) -> [[String]] {\\n        let n = s.count\\n        var dp = [[Bool]](repeating: [Bool](repeating: false, count: n), count: n)\\n        var ans = [[String]]()\\n        var currentList = [String]()\\n\\n        dfs(&ans, str: Array(s), n: n, start: 0, &currentList, &dp)\\n        return ans\\n    }\\n\\n    \\n    private func dfs(_ ans: inout [[String]], str: [Character], n: Int, start: Int, _ currentList: inout [String], _ dp: inout [[Bool]]) {\\n        guard start < n else { ans.append(currentList); return }\\n            \\n        for end in start..<n {\\n            guard str[start] == str[end], (end - start <= 2 || dp[start + 1][end - 1]) else { continue }\\n            dp[start][end] = true\\n            currentList.append(String(str[start...end]))\\n            dfs(&ans, str: str, n: n, start: end + 1, &currentList, &dp)\\n            currentList.removeLast()\\n        }\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668362,
                "title": "solution-swift-palindrome-partitioning-test-cases",
                "content": "```swift\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        guard s.count > 1 else { return [[s]] }\\n        var path: [String] = [], paths: [[String]] = []\\n        dfs(&paths, &path, Array(s), 0)\\n        return paths\\n    }\\n    \\n    private func dfs(_ paths: inout [[String]], _ path: inout [String], _ s: [Character], _ idx: Int) {\\n        guard idx != s.count else { paths.append(Array(path)); return }\\n        \\n        for i in idx..<s.count {\\n            let curr = String(s[idx...i])\\n            if isPalindrome(curr) {\\n                path.append(curr)\\n                dfs(&paths, &path, s, i + 1)\\n                path.removeLast()\\n            }\\n        }\\n    }\\n    private func isPalindrome(_ s: String) -> Bool {\\n        guard s.count > 1 else { return true }\\n        let len = s.count, chars = [Character](s)\\n        for i in 0..<len >> 1 where chars[i] != chars[len - 1 - i] {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.032 (0.035) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.partition(\"aab\")\\n        XCTAssertEqual(value, [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.partition(\"a\")\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        guard s.count > 1 else { return [[s]] }\\n        var path: [String] = [], paths: [[String]] = []\\n        dfs(&paths, &path, Array(s), 0)\\n        return paths\\n    }\\n    \\n    private func dfs(_ paths: inout [[String]], _ path: inout [String], _ s: [Character], _ idx: Int) {\\n        guard idx != s.count else { paths.append(Array(path)); return }\\n        \\n        for i in idx..<s.count {\\n            let curr = String(s[idx...i])\\n            if isPalindrome(curr) {\\n                path.append(curr)\\n                dfs(&paths, &path, s, i + 1)\\n                path.removeLast()\\n            }\\n        }\\n    }\\n    private func isPalindrome(_ s: String) -> Bool {\\n        guard s.count > 1 else { return true }\\n        let len = s.count, chars = [Character](s)\\n        for i in 0..<len >> 1 where chars[i] != chars[len - 1 - i] {\\n            return false\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.partition(\"aab\")\\n        XCTAssertEqual(value, [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]])\\n    }\\n    \\n    func test1() {\\n        let value = solution.partition(\"a\")\\n        XCTAssertEqual(value, [[\"a\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 324347,
                "title": "c-99-beat-o-2-n-time-complexity-using-dynamic-rememberance",
                "content": "Rather than thunderbolting our many extra useless substrings and having to perform a potentially O(N) IS_PALINDROME computation, we can use dynamic programming to arrive at a SHORTER RUNNING solution. We take advantage of the fact that \"a\" is a pally, \"aa\" is a pally, and \"a\"{PALLY}\"a\" is a pally. No need to re-compute over and over.\\n\\nWe use a triangular dynamic grid to represent our palindrome points.\\n\\nTake the word \"BOOBOO\"\\n\\nRow[B] = {1, 0, 0, 1, 0, 0}\\nRow[O] = {0, 1, 1, 0, 0, 1}\\nRow[O] = {0, 0, 1, 0, 1, 0}\\nRow[B] = {0, 0, 0, 1, 0, 0}\\nRow[O] = {0, 0, 0, 0, 1, 1}\\nRow[O] = {0, 0, 0, 0, 0, 1}\\n\\nIgnore the bottom-left triangle.\\n\\nSlot[1][1] Represents the 1st O\\nSlot[2][1] Represents the 1st O and the 2nd O \"OO\" => Which is pally.\\n\\n\\n\\n\\nThe recursive step is still O(2 ^ N) because there can potentially be that many solutions...\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> partition(string s) {\\n        \\n        int **aPally = new int*[s.size() + 1];\\n        for (int i=0;i<=s.size();i++) {\\n            aPally[i] = new int[s.size() + 1];\\n            for (int k=0;k<=s.size();k++) {\\n                aPally[i][k] = 0;\\n            }\\n        }\\n        \\n        //All single characters are pallys.\\n        for (int i=0;i<s.size();i++) {\\n            aPally[i][i] = 1;\\n        }\\n        \\n        //\"aa\" is a pally, \"bb\" is a pally, etc.\\n        for (int i=1;i<s.size();i++) {\\n            aPally[i][i-1] = (s[i-1] == s[i]);\\n        }\\n        \\n        //\"a\"{Pally}\"a\" is a pally, dynamic shortcut.\\n        int aGap, i, j;\\n        for (aGap=2;aGap<s.size();aGap++) {\\n            for (i=aGap;i<s.size();i++) {\\n                j = i - aGap; \\n                if (aPally[i-1][j+1] && s[i] == s[j]) {\\n                    aPally[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aPally, aTemp, 0);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, int **pPally, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            //Look up the chunk in our table. If it\\'s a pally, add the substring\\n            //to our temp solution and continue to probe deeper and deeper.\\n            if (pPally[pIndex + aLen - 1][pIndex]) {\\n                pTemp.push_back(pString.substr(pIndex, aLen));\\n                helper(pResult, pString, pPally, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> partition(string s) {\\n        \\n        int **aPally = new int*[s.size() + 1];\\n        for (int i=0;i<=s.size();i++) {\\n            aPally[i] = new int[s.size() + 1];\\n            for (int k=0;k<=s.size();k++) {\\n                aPally[i][k] = 0;\\n            }\\n        }\\n        \\n        //All single characters are pallys.\\n        for (int i=0;i<s.size();i++) {\\n            aPally[i][i] = 1;\\n        }\\n        \\n        //\"aa\" is a pally, \"bb\" is a pally, etc.\\n        for (int i=1;i<s.size();i++) {\\n            aPally[i][i-1] = (s[i-1] == s[i]);\\n        }\\n        \\n        //\"a\"{Pally}\"a\" is a pally, dynamic shortcut.\\n        int aGap, i, j;\\n        for (aGap=2;aGap<s.size();aGap++) {\\n            for (i=aGap;i<s.size();i++) {\\n                j = i - aGap; \\n                if (aPally[i-1][j+1] && s[i] == s[j]) {\\n                    aPally[i][j] = 1;\\n                }\\n            }\\n        }\\n        \\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aPally, aTemp, 0);\\n        \\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, int **pPally, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            //Look up the chunk in our table. If it\\'s a pally, add the substring\\n            //to our temp solution and continue to probe deeper and deeper.\\n            if (pPally[pIndex + aLen - 1][pIndex]) {\\n                pTemp.push_back(pString.substr(pIndex, aLen));\\n                helper(pResult, pString, pPally, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085951,
                "title": "easy-solution-fully-explained-c-python3-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n```\\n                    Please Upvote If You Find It Helpful.\\n```\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe iterate through each substring of the string and perform the following operations:\\n1. First, we check current substring is palindrome or not and next substring is palindrome or not and so on.\\n2. If the substring is palindrome then add this to the output otherwise ignore it.\\n3. If index == n then, add this output vector to the answer vector.\\nExample: Given string S = \"aab\"\\n\\n                            aab\\n                           / |  \\\\\\n                          /  |   \\\\\\n                         a   aa   aab(x)\\n                        / \\\\   \\\\   \\n                       /   \\\\   \\\\\\n                      a    ab   b\\n                     /     (x)\\n                    /\\n                   b\\n        \\n        ans = {{\\'a\\',\\'a\\',\\'b\\'}, {\\'aa\\', \\'b\\'}}\\n\\n# Approach : Backtracking\\n<!-- Describe your approach to solving the problem. -->\\n\\nTime Complexity : O(N*2^N)\\nSpace Complexity : O(N)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // main function that takes in a string and returns all possible partitions of the string\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // vector to store all possible partitions\\n        vector<string> path; // vector to store current partition\\n        func(0, s, res, path); // call helper function to start recursion\\n        return res;\\n     }\\n\\n    // helper function that uses recursion to find all possible partitions\\n    void func(int ind, string s, vector<vector<string>>& res, vector<string>& path){\\n        if(ind == s.size()){ // base case: if we have reached the end of the string\\n            res.push_back(path); // add current partition to the result vector\\n            return ;\\n        }\\n        for(int i=ind;i<s.size();++i){ // iterate through all substrings starting from the current index\\n            if(isPalindrome(s, ind, i)){ // check if the current substring is a palindrome\\n                path.push_back(s.substr(ind, i-ind+1)); // if it is, add it to the current partition\\n                func(i+1, s, res, path); // call function recursively with the next index as the starting point\\n                path.pop_back(); // backtrack to check for other partitions\\n            }\\n        }\\n    }\\n\\n    // helper function that checks if a substring is a palindrome\\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){ // iterate through the substring\\n            if(s[start++]!=s[end--]) // check if current characters are not equal\\n                return false; // if they are not, return false\\n        }\\n        return true; // if we reach this point, the substring is a palindrome\\n    }\\n};\\n\\n```\\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # vector to store all possible partitions\\n        path = [] # vector to store current partition\\n        self.func(0, s, res, path) # call helper function to start recursion\\n        return res\\n\\n    # helper function that uses recursion to find all possible partitions\\n    def func(self, ind, s, res, path):\\n        if ind == len(s): # base case: if we have reached the end of the string\\n            res.append(path[:]) # add current partition to the result vector\\n            return \\n        for i in range(ind, len(s)): # iterate through all substrings starting from the current index\\n            if self.isPalindrome(s, ind, i): # check if the current substring is a palindrome\\n                path.append(s[ind:i+1]) # if it is, add it to the current partition\\n                self.func(i+1, s, res, path) # call function recursively with the next index as the starting point\\n                path.pop() # backtrack to check for other partitions\\n\\n    # helper function that checks if a substring is a palindrome\\n    def isPalindrome(self, s, start, end):\\n        while start <= end: # iterate through the substring\\n            if s[start] != s[end]: # check if current characters are not equal\\n                return False # if they are not, return false\\n            start += 1\\n            end -= 1\\n        return True # if we reach this point, the substring is a palindrome\\n\\n```\\n```\\n                          Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n                    Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // main function that takes in a string and returns all possible partitions of the string\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res; // vector to store all possible partitions\\n        vector<string> path; // vector to store current partition\\n        func(0, s, res, path); // call helper function to start recursion\\n        return res;\\n     }\\n\\n    // helper function that uses recursion to find all possible partitions\\n    void func(int ind, string s, vector<vector<string>>& res, vector<string>& path){\\n        if(ind == s.size()){ // base case: if we have reached the end of the string\\n            res.push_back(path); // add current partition to the result vector\\n            return ;\\n        }\\n        for(int i=ind;i<s.size();++i){ // iterate through all substrings starting from the current index\\n            if(isPalindrome(s, ind, i)){ // check if the current substring is a palindrome\\n                path.push_back(s.substr(ind, i-ind+1)); // if it is, add it to the current partition\\n                func(i+1, s, res, path); // call function recursively with the next index as the starting point\\n                path.pop_back(); // backtrack to check for other partitions\\n            }\\n        }\\n    }\\n\\n    // helper function that checks if a substring is a palindrome\\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){ // iterate through the substring\\n            if(s[start++]!=s[end--]) // check if current characters are not equal\\n                return false; // if they are not, return false\\n        }\\n        return true; // if we reach this point, the substring is a palindrome\\n    }\\n};\\n\\n```\n```python []\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = [] # vector to store all possible partitions\\n        path = [] # vector to store current partition\\n        self.func(0, s, res, path) # call helper function to start recursion\\n        return res\\n\\n    # helper function that uses recursion to find all possible partitions\\n    def func(self, ind, s, res, path):\\n        if ind == len(s): # base case: if we have reached the end of the string\\n            res.append(path[:]) # add current partition to the result vector\\n            return \\n        for i in range(ind, len(s)): # iterate through all substrings starting from the current index\\n            if self.isPalindrome(s, ind, i): # check if the current substring is a palindrome\\n                path.append(s[ind:i+1]) # if it is, add it to the current partition\\n                self.func(i+1, s, res, path) # call function recursively with the next index as the starting point\\n                path.pop() # backtrack to check for other partitions\\n\\n    # helper function that checks if a substring is a palindrome\\n    def isPalindrome(self, s, start, end):\\n        while start <= end: # iterate through the substring\\n            if s[start] != s[end]: # check if current characters are not equal\\n                return False # if they are not, return false\\n            start += 1\\n            end -= 1\\n        return True # if we reach this point, the substring is a palindrome\\n\\n```\n```\\n                          Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084227,
                "title": "c-simple-backtracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply generate all the substrings using recursion and check if they are palindrome or not.If not Backtrack form there.Recursively traverse over the string like in dfs.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to keep track of the last partition index  and to iterate from that index to the end of the array to check whether we can form a palindrome substring or not. If we are able to find such a substring we use recursion to continue exploring . If we reach the end whole string it means we were able to partition the string into x number of palindromes. Save the result and backtrack to continue exploring.\\n# Complexity\\n- Time complexity:($$O(n*2^n)$$)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>>ans;\\n    bool isPalindrome(string& s,int i,int j){\\n    \\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n     \\n\\n    void generate(string& s,int start, vector<string>&temp){\\n          if(s.size()==start){\\n             ans.push_back(temp); \\n             return;\\n          }\\n\\n          for(int i=start;i<s.length();i++){\\n              if(isPalindrome(s,start,i)){\\n                  temp.push_back(s.substr(start,i-start+1));\\n                  generate(s,i+1,temp);\\n                  temp.pop_back();\\n              }\\n          }\\n          \\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string>temp;\\n        generate(s,0,temp);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>>ans;\\n    bool isPalindrome(string& s,int i,int j){\\n    \\n        while(i<j){\\n            if(s[i++]!=s[j--])return false;\\n        }\\n        return true;\\n    }\\n     \\n\\n    void generate(string& s,int start, vector<string>&temp){\\n          if(s.size()==start){\\n             ans.push_back(temp); \\n             return;\\n          }\\n\\n          for(int i=start;i<s.length();i++){\\n              if(isPalindrome(s,start,i)){\\n                  temp.push_back(s.substr(start,i-start+1));\\n                  generate(s,i+1,temp);\\n                  temp.pop_back();\\n              }\\n          }\\n          \\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string>temp;\\n        generate(s,0,temp);\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1913154,
                "title": "recursive-solution-using-c-with-time-complexity-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we\\u2019re dividing the string into substrings and checking if it\\u2019s palindrome or not.\\n- We\\u2019re storing all the palindromic substrings into a temp vector, using the help function to divide them into substrings.\\n- In our help function our base condition if the checking index is equal to string size, that means we are at last index, so simply push back temp to our ans vector.\\n- Else we\\u2019ll check palindrome for the rest of the string & take a loop, divide index by index and check for palindrome.\\n- If it\\u2019s a palindrome substring then we\\u2019ll push it to ans & then we\\u2019ll call again the help function for the rest.\\n- After the function returns we\\u2019ll pop back the element from temp, which means there is another substring that is not a palindrome.\\n- **Time complexity:** O(n*2^n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        help(0, s, temp, ans);\\n        return ans;\\n    }\\n    \\n    void help(int index, string s, vector<string> &temp, vector<vector<string>> &ans){\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                help(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        help(0, s, temp, ans);\\n        return ans;\\n    }\\n    \\n    void help(int index, string s, vector<string> &temp, vector<vector<string>> &ans){\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                help(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end){\\n        while(start<=end){\\n            if(s[start++] != s[end--])\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744058,
                "title": "must-see-simple-c-solution-detailed-explanation-how-to-link-problems",
                "content": "**Approach:  **\\nFirst thing that comes to everyone\\'s mind to:\\ngiven a string like: \\n\\ns=\"aba\"\\nIf I can print something this: \\n \\n(a)(b)(a)\\n(a)(ba)\\n(ab)(a)\\n(aba).\\n\\nThen, I will just check each bracket and if its a palidrome, I will add else not. \\n\\nI Approached the same Way: \\nFirst I wrote the code for this: \\n\\n```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid bt(string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            for(auto x:comb) cout<<x;\\n            cout<<endl;\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(\"(\");\\n        comb.push_back(s.substr(pos,1));\\n        comb.push_back(\")\");\\n        bt(s, pos + 1, comb);\\n        comb.pop_back();\\n        comb.pop_back();\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n                comb.push_back(\"(\");\\n                comb.push_back(s.substr(pos, step));\\n                comb.push_back(\")\");\\n                bt(s, pos + step, comb);\\n                comb.pop_back();\\n                comb.pop_back();\\n                comb.pop_back();\\n        }\\n    }\\nint main()\\n{\\n    string temp;\\n    vector<string>t;\\n    string s(\"aba\");\\n    bt(s,0,t);\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/ce898062-b969-477c-8871-2e9551a122f7_1595161362.6001675.png)\\n\\n\\nThen, I just a Line to this to check Palindrome or not and removed that brackets pushes and popes and we are done.\\n\\n\\n```\\n vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n          **  if(isPalindrome(s.substr(pos, step))){**     -------->>>>>>>>>>>ONLY CHANGE\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```\\n\\n\\nPS: Implement from what you know. \\uD83D\\uDE0E\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#include<bits/stdc++.h>\\nusing namespace std;\\n\\nvoid bt(string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            for(auto x:comb) cout<<x;\\n            cout<<endl;\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(\"(\");\\n        comb.push_back(s.substr(pos,1));\\n        comb.push_back(\")\");\\n        bt(s, pos + 1, comb);\\n        comb.pop_back();\\n        comb.pop_back();\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n                comb.push_back(\"(\");\\n                comb.push_back(s.substr(pos, step));\\n                comb.push_back(\")\");\\n                bt(s, pos + step, comb);\\n                comb.pop_back();\\n                comb.pop_back();\\n                comb.pop_back();\\n        }\\n    }\\nint main()\\n{\\n    string temp;\\n    vector<string>t;\\n    string s(\"aba\");\\n    bt(s,0,t);\\n}\\n```\n```\\n vector<vector<string>> partition(string s) {\\n        vector<vector<string>>res;\\n        backtrack(res,s,0,vector<string>());\\n        return res;\\n    }\\n    \\n    void backtrack(vector<vector<string>>& res, string s, int pos, vector<string> comb){\\n        if(pos >= s.size()){\\n            res.push_back(comb);\\n            return;\\n        }\\n        // Palindrome length == 1\\n        comb.push_back(s.substr(pos,1));\\n        backtrack(res, s, pos + 1, comb);\\n        comb.pop_back();\\n        // Palindrome length > 1\\n        for(int step = 2; pos + step <= s.size(); step++){\\n          **  if(isPalindrome(s.substr(pos, step))){**     -------->>>>>>>>>>>ONLY CHANGE\\n                comb.push_back(s.substr(pos, step));\\n                backtrack(res, s, pos + step, comb);\\n                comb.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s){\\n        int i(0), j(s.size()-1);\\n        while(i < j) \\n            if(s[i++] != s[j--]) return false;\\n        return true;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 670391,
                "title": "javascript-clean-backtracking-beats-95",
                "content": "Time Complexity : O(N * 2^(N-1))\\nSpace Complexity: O(2^(N-1))\\n```javascript\\nvar partition = function(s) {\\n    \\n    function isPalindrome(str) {\\n        let left = 0, right = str.length-1;\\n        \\n        while(left < right) {\\n            if(str[left] !== str[right]) return false\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    const result = [];\\n    \\n    function permute(arr, str) {\\n        if(!str.length) result.push(arr);\\n        \\n        for(let i = 1; i <= str.length; i++) {\\n            const subStr = str.slice(0, i);\\n            if(isPalindrome(subStr)) {\\n                permute([...arr, subStr], str.slice(i));\\n            }\\n        }\\n    }\\n    permute([], s);\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar partition = function(s) {\\n    \\n    function isPalindrome(str) {\\n        let left = 0, right = str.length-1;\\n        \\n        while(left < right) {\\n            if(str[left] !== str[right]) return false\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    }\\n    \\n    const result = [];\\n    \\n    function permute(arr, str) {\\n        if(!str.length) result.push(arr);\\n        \\n        for(let i = 1; i <= str.length; i++) {\\n            const subStr = str.slice(0, i);\\n            if(isPalindrome(subStr)) {\\n                permute([...arr, subStr], str.slice(i));\\n            }\\n        }\\n    }\\n    permute([], s);\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 289392,
                "title": "js-beating-100-with-explanation",
                "content": "``` javascript\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nlet partition = function(s) {\\n  let res = []\\n  let plds = []\\n  helper(s, 0, plds, res)\\n  return res\\n}\\n\\nlet helper = (s, start, plds, res) => {\\n//goal\\n  if (start === s.length) {\\n    res.push(plds.concat())\\n  }\\n  for (let i = start; i < s.length; i++) {\\n  //constraint\\n    if (isPalindrome(s.substring(start, i + 1))) {\\n      plds.push(s.substring(start, i + 1))\\n\\t  //choices\\n      helper(s, i + 1, plds, res)\\n      plds.pop()\\n    }\\n  }\\n}\\n\\nlet isPalindrome = (s) => {\\n  let l = 0\\n  let r = s.length - 1\\n  while (r > l) {\\n    if (s[l] !== s[r]) {\\n      return false\\n    }\\n    l++\\n    r--\\n  }\\n  return true\\n}\\n```\\n\\nFor backtracking problems, there are always three elements\\n1. choice (decision)\\n2. goal\\n3. constraint\\n\\nIn this problem, we need return all possible palindrome partitioning of s.\\nSo, we  need to check all the combinations of substrings of s.\\n\\nThe `choice` can be assumed as how to partition s, so we can get the substring by\\n`s.substring(start, i + 1)` where `start` is the start index of the substring, `i` is the end index of the substring. Each level of the choice can be expanded to the length of s, so we got the `for` loop.\\nThe start index of next substring (choice) can be assumed as `i + 1`.\\n\\nIf the substring is not palindrome, we should stop exploring the choices. This is `constraint`.\\n\\nIf the `start` index equals to the length of s, we meet our `goal`. which means all the choices(substrings) we expolres so far is palindrome.\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "``` javascript\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nlet partition = function(s) {\\n  let res = []\\n  let plds = []\\n  helper(s, 0, plds, res)\\n  return res\\n}\\n\\nlet helper = (s, start, plds, res) => {\\n//goal\\n  if (start === s.length) {\\n    res.push(plds.concat())\\n  }\\n  for (let i = start; i < s.length; i++) {\\n  //constraint\\n    if (isPalindrome(s.substring(start, i + 1))) {\\n      plds.push(s.substring(start, i + 1))\\n\\t  //choices\\n      helper(s, i + 1, plds, res)\\n      plds.pop()\\n    }\\n  }\\n}\\n\\nlet isPalindrome = (s) => {\\n  let l = 0\\n  let r = s.length - 1\\n  while (r > l) {\\n    if (s[l] !== s[r]) {\\n      return false\\n    }\\n    l++\\n    r--\\n  }\\n  return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42134,
                "title": "my-c-solution-13ms-backtracking",
                "content": "    class Solution {\\n    public:\\n        void palPart (vector<vector<string>> &ans,vector<string> &temp,string s,int j){\\n            if(s.size()==0)\\n                return;\\n            //\\u7279\\u6b8a\\u8f93\\u5165\\n            if(j>s.size()-1){\\n            ans.push_back(temp);\\n            return;\\n            }\\n            //\\u8fb9\\u754c\\u6761\\u4ef6\\uff0c\\u5f88\\u91cd\\u8981\\n            int m,n,l;\\n            \\n            for(m=s.size()-1;m>=j;m--){\\n                l=j;\\n                n=m;\\n                \\n                while(l<n&&s[l]==s[n]){\\n                    \\n                    l++;\\n                    n--;\\n                    \\n                }//\\u5224\\u65ads(j,m)\\u662f\\u4e0d\\u662f\\u56de\\u6587\\n                if(l>=n){\\n                    \\n                    temp.push_back(s.substr(j,m-j+1));//\\u5b50\\u4e32\\u5165\\u6808\\n                    \\n                    palPart(ans,temp,s,m+1);//\\u904d\\u5386\\n                    \\n                    temp.pop_back();//\\u904d\\u5386\\u5b8c\\u6bd5\\uff0c\\u5b50\\u4e32\\u51fa\\u6808\\n                }\\n            }\\n        }\\n    \\n        vector<vector<string>> partition(string s) {\\n        vector<vector<string> >  ans;\\n        vector<string> temp;\\n        palPart (ans,temp,s,0);\\n        return ans;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void palPart (vector<vector<string>> &ans,vector<string> &temp,string s,int j){\\n            if(s.size()==0)\\n                return;\\n            //\\u7279\\u6b8a\\u8f93\\u5165\\n            if(j>s.size()-1){\\n            ans.push_back(temp);\\n            return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42136,
                "title": "concise-java-solution",
                "content": "DFS to find every combinations of the string, if the substring is not Palindrome, ignore it then go to the next.\\n\\n    public class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        public List<List<String>> partition(String s) {\\n            helper(s, new ArrayList<String>());\\n            return result;\\n        }        \\n        \\n        public void helper(String s, List<String> cur){                 //DFS every combinations\\n            if(s.length() == 0){result.add(cur); return;}        \\n            for(int i = 1; i <= s.length(); i++){\\n                String sub = s.substring(0,i);\\n                if(isPal(sub)){\\n                    List<String> newList = new ArrayList<String>(cur);\\n                    newList.add(sub);\\n                    helper(s.substring(i,s.length()), newList);\\n                }\\n                else continue;                                    //not palindrome, ignore it\\n            }        \\n        }                \\n        \\n        public boolean isPal(String str){\\n            int l = 0;\\n            int r = str.length()-1;\\n            while(l <= r){\\n                if(str.charAt(l) != str.charAt(r))  return false;\\n                l++;r--;\\n            }\\n            return true;\\n        }\\n    } \\n\\n\\nnote: I found some people using the same method of mine, but they like to call their methods \"backtracking\", it is actually DFS, note backtracking.",
                "solutionTags": [],
                "code": "class Solution {\\n        List<List<String>> result = new ArrayList<List<String>>();\\n        public List<List<String>> partition(String s) {\\n            helper(s, new ArrayList<String>());\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2213062,
                "title": "c-palindrome-partitioning-all-variations",
                "content": "**Do Upvote if it helps :-)**\\n\\n**MUST CHECK->**\\n**Best Time to Buy and Sell Stock All Variations\\uD83D\\uDC49**[Click Me](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/discuss/2237933/C%2B%2B-Best-Time-to-Buy-and-Sell-Stock-All-Variations-Recursion%2BMemoization)\\n\\n[131. Palindrome Partitioning I](https://leetcode.com/problems/palindrome-partitioning/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tl++;\\n\\t\\t\\t\\tr--;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tvoid check(int ind,string &s,vector<string> &cur){\\n\\t\\t\\tif(ind==s.size()){\\n\\t\\t\\t\\tans.push_back(cur);\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=ind;i<s.size();i++){\\n\\t\\t\\t\\tif(isPali(s,ind,i)){\\n\\t\\t\\t\\t\\tcur.push_back(s.substr(ind,i-ind+1));\\n\\t\\t\\t\\t\\tcheck(i+1,s,cur);\\n\\t\\t\\t\\t\\tcur.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvector<vector<string>> partition(string s) {\\n\\t\\t\\tvector<string>cur;\\n\\t\\t\\tcheck(0,s,cur);\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n[132. Palindrome Partitioning II](https://leetcode.com/problems/palindrome-partitioning-ii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l++]!=s[r--]) return false;\\n\\t\\t\\t}\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t\\tint solve(string &s,int pos,int n){\\n\\t\\t\\tif(pos>=n  || isPali(s,pos,n)) return 0;\\n\\t\\t\\tif(dp[pos]!=-1) return dp[pos];\\n\\t\\t\\tint ans=0,tmp=INT_MAX;\\n\\t\\t\\tfor(int i=pos;i<n;i++){\\n\\t\\t\\t\\tif(isPali(s,pos,i)){\\n\\t\\t\\t\\t\\tans=1+solve(s,i+1,n);\\n\\t\\t\\t\\t\\ttmp=min(tmp,ans);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos] = tmp;\\n\\t\\t}\\n\\t\\tint minCut(string s) {\\n\\t\\t\\tdp.assign(s.size(),-1);\\n\\t\\t\\treturn solve(s,0,s.size())-1;\\n\\t\\t}\\n\\t};\\n\\t\\n[1278. Palindrome Partitioning III](https://leetcode.com/problems/palindrome-partitioning-iii/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<vector<int>> cost;\\n\\t\\tint costFun(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 0;\\n\\t\\t\\tif(cost[l][r]!=-1) return cost[l][r];\\n\\t\\t\\treturn cost[l][r] = (s[l]!=s[r]) + costFun(s,l+1,r-1);\\n\\t\\t}\\n\\n\\t\\tvector<vector<int>>dp;\\n\\t\\tint solve(string &s,int k,int pos,int n){\\n\\t\\t\\tif(k==0) return costFun(s,pos,n-1);\\n\\t\\t\\tif(pos>=n) return INT_MAX;\\n\\t\\t\\tif(dp[pos][k]!=-1) return dp[pos][k];\\n\\t\\t\\tint ans=1e6;\\n\\t\\t\\tfor(int i=pos;i<n-1;i++){\\n\\t\\t\\t\\tans=min(ans,costFun(s,pos,i)+solve(s,k-1,i+1,n));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[pos][k] = ans;\\n\\t\\t}\\n\\t\\tint palindromePartition(string s, int k) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tcost.assign(n,vector<int>(n,-1));\\n\\t\\t\\tdp.assign(n,vector<int>(k+1,-1));\\n\\t\\t\\treturn solve(s,k-1,0,n);\\n\\t\\t}\\n\\t};\\n\\t\\n[1745. Palindrome Partitioning IV](https://leetcode.com/problems/palindrome-partitioning-iv/)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> dp;\\n\\t\\tvector<vector<int>> pali;\\n\\t\\tint isPali(string &s,int l,int r){\\n\\t\\t\\tif(l>=r) return 1;\\n\\t\\t\\tif(pali[l][r]!=-1) return pali[l][r];\\n\\t\\t\\tif(s[l]==s[r]) return pali[l][r] = isPali(s,l+1,r-1);\\n\\t\\t\\treturn pali[l][r] = 0;\\n\\t\\t}\\n\\n\\t\\tbool checkPartitioning(string s) {\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tpali.assign(n,vector<int>(n,-1));\\n\\t\\t\\tfor(int i=1;i<n-1;i++){\\n\\t\\t\\t\\tfor(int j=1;j<=i;j++){\\n\\t\\t\\t\\t\\tif(isPali(s,0,j-1) && isPali(s,j,i) && isPali(s,i+1,n-1)) return true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<vector<string>>ans;\\n\\t\\tbool isPali(string s,int l,int r){\\n\\t\\t\\twhile(l<r){\\n\\t\\t\\t\\tif(s[l]!=s[r]){\\n\\t\\t\\t\\t\\treturn false;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 805513,
                "title": "c-solution-using-backtracking-and-mcm-concepts-12ms-93-faster",
                "content": "```\\nvector<vector<string>> ans;\\nint n;\\nstring s;\\nbool isPalin(int i,int j)// check for palindrome\\n{\\n    while(i<j)\\n    {\\n        if(s[i]!=s[j])return 0;\\n        i++;j--;\\n    }\\n    return 1;\\n}\\nvoid palinParti(vector<string>& cur,int start)\\n{\\n    if(start==n){ans.push_back(cur);return;} // base case\\n    \\n        for(int i=start;i<n;i++)\\n        {\\n            if(isPalin(start,i))\\n            {\\n                cur.push_back(s.substr(start,i-start+1));// push the current substring on to the vector.\\n                \\n                palinParti(cur,i+1); // typical MCM(Matrix-Chain-Multiplication) based approach\\n                \\n                cur.pop_back(); // back-track for next substring from (start to i)\\n            }\\n        }\\n}\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string S)\\n    {s=S;\\n      n=s.length();\\n      ans.clear();\\n      vector<string> cur;\\n     \\n     palinParti(cur,0);\\n     \\n     return ans;\\n    }\\n};\\n//For better explannation refer this video. [https://www.youtube.com/watch?v=szKVpQtBHh8](http://)",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> partition(string S)\\n    {s=S;\\n      n=s.length();\\n      ans.clear();\\n      vector<string> cur;\\n     \\n     palinParti(cur,0);\\n     \\n     return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 777877,
                "title": "python-easy-simple-dfs-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ans = []\\n\\n        def dfs(currList, k):\\n            if k == len(s):\\n                ans.append(currList)\\n                return\\n\\n            for i in range(k, len(s)):\\n                tmpStr = s[k:i + 1]\\n                if tmpStr == tmpStr[::-1]:\\n                    dfs(currList + [tmpStr], i + 1)\\n\\n        dfs([], 0)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ans = []\\n\\n        def dfs(currList, k):\\n            if k == len(s):\\n                ans.append(currList)\\n                return\\n\\n            for i in range(k, len(s)):\\n                tmpStr = s[k:i + 1]\\n                if tmpStr == tmpStr[::-1]:\\n                    dfs(currList + [tmpStr], i + 1)\\n\\n        dfs([], 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42103,
                "title": "simple-backtracking-java-solution-with-95-performance",
                "content": "    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if (s.equals(\"\")) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }\\n            for (int i = 0; i < s.length(); i++) {\\n                if (isPalindrome(s, i + 1)) {\\n                    for (List<String> list : partition(s.substring(i+1))) {\\n                        list.add(0, s.substring(0, i + 1));\\n                        res.add(list);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n        \\n        public boolean isPalindrome(String s, int n) {\\n            for (int i = 0; i < n / 2; i++) {\\n                if (s.charAt(i) != s.charAt(n - i - 1))\\n                    return false;\\n            }\\n            return true;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if (s.equals(\"\")) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3084574,
                "title": "c-java-recursion-deep-dive-explanation",
                "content": "# Approach\\nFor every position of string we have two choices, either to put a partion over there or not, if we put the partition we are supposed to caheck if all our partitions are **palindromes** or not.\\nRecursion is an obivous choice to find all the partitions possible.\\n\\n*Palindome : a word that is the same when read forwards or backwards.*\\n\\n# Code Explanation\\n\\n***Helper function palind(string s)*** : \\nthat checks whether a given string s is a palindrome. It does this by creating a copy of the string s, reversing it and comparing it with the original string. If they are the same, it returns true, otherwise it returns false.\\n\\n***Helper function call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)*** :\\nrecursive function to find all possible partitions of the string s into palindromes.\\n\\nThis function takes four parameters:\\n\\n1. **Integer ind** representing the current index in the string s being processed.\\n2. A reference to a **vector of vectors of strings ans** to store all the partitions.\\n3. A reference to a **vector of strings vec** to store the current partition being processed.\\n4. A **string s** representing the original string to be partitioned.\\n\\n**BASE CASE:**\\n1. The function checks current index ind is equal to the size of the string s. If it is, it pushes the current partition stored in the vec to the ans and return.\\n\\nIt starts a for loop from the current index ind to the end of the string s, and for each substring from ind to i, it checks if the substring is a palindrome using the helper function palind(string s).\\n\\nIf the substring is a palindrome, it pushes the substring to the vec and calls the helper function recursively with updated index i+1 and vec. After the recursive call, it pops the last element from the vec to restore the vec to its previous state and try next substring.\\n\\nIt continues this process until all possible partitions have been found and stored in the ans vector. Finally, it returns the ans vector.\\n\\n\\n# C++ Code\\n```\\nclass Solution {\\n    bool palind(string s)\\n    {\\n        string a=s;\\n        reverse(a.begin(),a.end());\\n        if (a==s) return true;\\n        else return false;\\n    }\\n    \\n    void call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)\\n    {\\n        if (ind==s.size())\\n        {\\n            ans.push_back(vec);\\n        }\\n        \\n        for (int i=ind;i<s.size();i++)\\n        {\\n            if (palind(s.substr(ind,i-ind+1)))\\n            {\\n                vec.push_back(s.substr(ind,i-ind+1));\\n                call(i+1,ans,vec,s);\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> vec;\\n        call(0,ans,vec,s);\\n        return ans;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    boolean palind(String s) {\\n        String a = new StringBuilder(s).reverse().toString();\\n        if (a.equals(s)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    void call(int ind, List<List<String>> ans, List<String> vec, String s) {\\n        if (ind == s.length()) {\\n            ans.add(new ArrayList<String>(vec));\\n        }\\n        \\n        for (int i = ind; i < s.length(); i++) {\\n            if (palind(s.substring(ind, i + 1))) {\\n                vec.add(s.substring(ind, i + 1));\\n                call(i + 1, ans, vec, s);\\n                vec.remove(vec.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        List<String> vec = new ArrayList<String>();\\n        call(0, ans, vec, s);\\n        return ans;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\nO((2^n*n) : The reason for this is that the function \\'call\\' is called recursively for each possible substring of \\'s\\' and the function \\'palind\\' is called for each substring to check if it is a palindrome. \\n\\n- Space complexity:\\nO(n^2) : the function \\'call\\' is using a recursive call stack and the function \\'palind\\' is creating a copy of the input string for each call. Additionally, the \\'ans\\' and \\'vec\\' vectors are also using O(n^2) space in the worst case.\\n.\\n.\\n.\\n*DO UPVOTE IF THIS HELPED :)*",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Recursion",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    bool palind(string s)\\n    {\\n        string a=s;\\n        reverse(a.begin(),a.end());\\n        if (a==s) return true;\\n        else return false;\\n    }\\n    \\n    void call(int ind,vector<vector<string>>& ans,vector<string>& vec,string s)\\n    {\\n        if (ind==s.size())\\n        {\\n            ans.push_back(vec);\\n        }\\n        \\n        for (int i=ind;i<s.size();i++)\\n        {\\n            if (palind(s.substr(ind,i-ind+1)))\\n            {\\n                vec.push_back(s.substr(ind,i-ind+1));\\n                call(i+1,ans,vec,s);\\n                vec.pop_back();\\n            }\\n        }\\n    }\\n    \\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> vec;\\n        call(0,ans,vec,s);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    boolean palind(String s) {\\n        String a = new StringBuilder(s).reverse().toString();\\n        if (a.equals(s)) {\\n            return true;\\n        } else {\\n            return false;\\n        }\\n    }\\n    \\n    void call(int ind, List<List<String>> ans, List<String> vec, String s) {\\n        if (ind == s.length()) {\\n            ans.add(new ArrayList<String>(vec));\\n        }\\n        \\n        for (int i = ind; i < s.length(); i++) {\\n            if (palind(s.substring(ind, i + 1))) {\\n                vec.add(s.substring(ind, i + 1));\\n                call(i + 1, ans, vec, s);\\n                vec.remove(vec.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<List<String>>();\\n        List<String> vec = new ArrayList<String>();\\n        call(0, ans, vec, s);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668997,
                "title": "beats-100-in-time-and-99-97-in-memory-4ms-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a6671596-c281-458c-a1f5-64cb89039273_1641400322.9022577.png)\\n```class Solution {\\n        boolean dp[][];//global array for finding whether the String is palindromic or not\\n        String str_arr[][];\\n        List < List < String >> rv;//return value\\n        int len;\\n        ArrayList<String> helper;\\n\\n        public void fill_palindromic_arr(String str) {\\n            len = str.length();\\n            dp = new boolean[len][len];\\n            str_arr = new String[len][len];\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                dp[i][i] = true;\\n            }\\n            for (int i = 0; i < len - 1; i++) {\\n                dp[i][i + 1] = str.charAt(i) == str.charAt(i + 1);\\n            }\\n            for (int g = 2; g < len; g++) {\\n                for (int si = 0; si < len; si++) {\\n                    int ei = si + g;\\n                    if (ei < len && str.charAt(si) == str.charAt(ei)) {\\n                        dp[si][ei] |= dp[si + 1][ei - 1];\\n                    }\\n                }\\n            }\\n\\t\\t\\t//creating and storing only the palindromic substring\\n\\t\\t\\t// do not create each and every substring otherwise exactly O(N*N*N) time will be taken even for the best case\\n\\t\\t\\t//for example when length is 16 and all characters are unique in case only 16 palindromic strings need to be created\\n\\t\\t\\t//whereas if we create all the strings steps taken would be N*N for number of substrings and N for creation of each substring\\n\\t\\t\\t//i.e 16*16*16 along with that it will also strain java internpool for maintaining so many strings\\n\\t\\t\\t//also there would be lot of garbage for the garbage collector to collect\\n\\t\\t\\t// check https://en.wikipedia.org/wiki/String_interning\\n\\t\\t\\t\\n            for (int si = 0; si < len; si++) {\\n                for (int ei = si; ei < len; ei++) {\\n                    if(dp[si][ei])\\n                    str_arr[si][ei] = str.substring(si, ei + 1);\\n                }\\n            }\\n        }\\n\\n        public List<List<String>> partition(String s) {\\n            rv = new ArrayList<>();\\n            fill_palindromic_arr(s);\\n            helper = new ArrayList<String>(len);\\n            fill(0);\\n            return rv;\\n        }\\n\\n        public void fill(int si) {\\n            // this function is supposed to fill the complete List for string defined from si\\n            if (si >= len) {\\n\\t\\t\\t\\t//base case\\n                rv.add(new ArrayList<String>(helper));\\n                return;\\n            }\\n            for (int ei = si; ei < len; ei++) {\\n                if (dp[si][ei]) {\\n                    // the string was a palindrome\\n\\t\\t\\t\\t\\t//consume the palindrome equivalent to doing work for own\\n                    helper.add(str_arr[si][ei]);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//having faith on recursion that it will work for the subquery\\n                    fill(ei + 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//clearing the arraylist for another call\\n\\t\\t\\t\\t\\t//this string has been explored and used, now it can not be used\\n\\t\\t\\t\\t\\t//because when we return from stack trace at that time our helper\\n\\t\\t\\t\\t\\t//arraylist should not have plaindromes from index beyond its call\\n                    helper.remove(helper.size()-1);\\n                }\\n            }\\n        }\\n    }\\n```\\nPoints to be focused\\n1 ) Instead of creating string each and every time we can simply pass a refrence of it, in the above code see the usage of String str_arr[][]\\nAlso notice that only palindromic substrings were filled\\n2 ) Initialized the size of the arraylist of string to the s.length() in order to avoid its resizing\\n3 ) used bottom up dp(tabulation) for checking whether the string is a palindrome or not\\n\\nMotivation Point :  See your solution in an unclickable area",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```class Solution {\\n        boolean dp[][];//global array for finding whether the String is palindromic or not\\n        String str_arr[][];\\n        List < List < String >> rv;//return value\\n        int len;\\n        ArrayList<String> helper;\\n\\n        public void fill_palindromic_arr(String str) {\\n            len = str.length();\\n            dp = new boolean[len][len];\\n            str_arr = new String[len][len];\\n\\t\\t\\t\\n            for (int i = 0; i < len; i++) {\\n                dp[i][i] = true;\\n            }\\n            for (int i = 0; i < len - 1; i++) {\\n                dp[i][i + 1] = str.charAt(i) == str.charAt(i + 1);\\n            }\\n            for (int g = 2; g < len; g++) {\\n                for (int si = 0; si < len; si++) {\\n                    int ei = si + g;\\n                    if (ei < len && str.charAt(si) == str.charAt(ei)) {\\n                        dp[si][ei] |= dp[si + 1][ei - 1];\\n                    }\\n                }\\n            }\\n\\t\\t\\t//creating and storing only the palindromic substring\\n\\t\\t\\t// do not create each and every substring otherwise exactly O(N*N*N) time will be taken even for the best case\\n\\t\\t\\t//for example when length is 16 and all characters are unique in case only 16 palindromic strings need to be created\\n\\t\\t\\t//whereas if we create all the strings steps taken would be N*N for number of substrings and N for creation of each substring\\n\\t\\t\\t//i.e 16*16*16 along with that it will also strain java internpool for maintaining so many strings\\n\\t\\t\\t//also there would be lot of garbage for the garbage collector to collect\\n\\t\\t\\t// check https://en.wikipedia.org/wiki/String_interning\\n\\t\\t\\t\\n            for (int si = 0; si < len; si++) {\\n                for (int ei = si; ei < len; ei++) {\\n                    if(dp[si][ei])\\n                    str_arr[si][ei] = str.substring(si, ei + 1);\\n                }\\n            }\\n        }\\n\\n        public List<List<String>> partition(String s) {\\n            rv = new ArrayList<>();\\n            fill_palindromic_arr(s);\\n            helper = new ArrayList<String>(len);\\n            fill(0);\\n            return rv;\\n        }\\n\\n        public void fill(int si) {\\n            // this function is supposed to fill the complete List for string defined from si\\n            if (si >= len) {\\n\\t\\t\\t\\t//base case\\n                rv.add(new ArrayList<String>(helper));\\n                return;\\n            }\\n            for (int ei = si; ei < len; ei++) {\\n                if (dp[si][ei]) {\\n                    // the string was a palindrome\\n\\t\\t\\t\\t\\t//consume the palindrome equivalent to doing work for own\\n                    helper.add(str_arr[si][ei]);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//having faith on recursion that it will work for the subquery\\n                    fill(ei + 1);\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t//clearing the arraylist for another call\\n\\t\\t\\t\\t\\t//this string has been explored and used, now it can not be used\\n\\t\\t\\t\\t\\t//because when we return from stack trace at that time our helper\\n\\t\\t\\t\\t\\t//arraylist should not have plaindromes from index beyond its call\\n                    helper.remove(helper.size()-1);\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668300,
                "title": "c-simple-and-clean-backtracking-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if a certain substring is a palindrome\\n    bool isSubstringPal(int start, int end) {\\n        while (start < end) {\\n            if (str[start] != str[end])\\n                return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    // The helper function is a recursive function for backtracking\\n    void backtrack(int start, vector<string> curr) {\\n        if (start >= str.size())\\n            res.push_back(curr);\\n            \\n        int end = start;\\n        while (end < str.size()) {\\n            if (isSubstringPal(start, end)) {\\n                curr.push_back(str.substr(start, end-start+1));\\n                backtrack(end+1, curr);\\n                curr.pop_back();\\n            }\\n            end++;\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        str = s;\\n        backtrack(0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> res;\\n    string str;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Helper function to check if a certain substring is a palindrome\\n    bool isSubstringPal(int start, int end) {\\n        while (start < end) {\\n            if (str[start] != str[end])\\n                return false;\\n            start++; end--;\\n        }\\n        return true;\\n    }\\n    \\n    // The helper function is a recursive function for backtracking\\n    void backtrack(int start, vector<string> curr) {\\n        if (start >= str.size())\\n            res.push_back(curr);\\n            \\n        int end = start;\\n        while (end < str.size()) {\\n            if (isSubstringPal(start, end)) {\\n                curr.push_back(str.substr(start, end-start+1));\\n                backtrack(end+1, curr);\\n                curr.pop_back();\\n            }\\n            end++;\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        str = s;\\n        backtrack(0, {});\\n        return res;\\n    }\\n    \\nprivate:\\n    vector<vector<string>> res;\\n    string str;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41995,
                "title": "swift-solution-backtracking",
                "content": "```\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        var result = [[String]]()\\n        var candidate = [String]()\\n        \\n        backtracking(&result, &candidate, Array(s.characters), 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[String]], _ candidate: inout [String], _ characters: [Character], _ start: Int) {\\n        if start == characters.count {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<characters.count {\\n                if isPalindrome(characters, start, i) {\\n                    let character = String(characters[start...i])\\n                    candidate.append(character)\\n                    backtracking(&result, &candidate, characters, i + 1)\\n                    candidate.removeLast()\\n                }\\n            }\\n        }\\n    }\\n    \\n    private func isPalindrome(_ characters: [Character], _ low: Int, _ high: Int) -> Bool {\\n        var low = low\\n        var high = high\\n        \\n        while low < high {\\n            if characters[low] != characters[high] {\\n                return false\\n            }\\n            low += 1\\n            high -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func partition(_ s: String) -> [[String]] {\\n        var result = [[String]]()\\n        var candidate = [String]()\\n        \\n        backtracking(&result, &candidate, Array(s.characters), 0)\\n        \\n        return result\\n    }\\n    \\n    private func backtracking(_ result: inout [[String]], _ candidate: inout [String], _ characters: [Character], _ start: Int) {\\n        if start == characters.count {\\n            result.append(candidate)\\n        } else {\\n            for i in start..<characters.count {\\n                if isPalindrome(characters, start, i) {\\n                    let character = String(characters[start...i])\\n                    candidate.append(character)\\n                    backtracking(&result, &candidate, characters, i + 1)\\n                    candidate.removeLast()\\n                }\\n            }\\n        }\\n    }\\n    \\n    private func isPalindrome(_ characters: [Character], _ low: Int, _ high: Int) -> Bool {\\n        var low = low\\n        var high = high\\n        \\n        while low < high {\\n            if characters[low] != characters[high] {\\n                return false\\n            }\\n            low += 1\\n            high -= 1\\n        }\\n        \\n        return true\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42158,
                "title": "shouldn-t-we-use-dp-in-addition-to-dfs",
                "content": "I understand this problem can be solved easily with DFS. The basic idea is that for each palindromic prefix, recursively obtain the palindrome partitioning of the remaining substring. As far as I am concerned, this is, to say the least,  an O(2^N) algorithm in the worst case (e.g., for strings like \"aaaaa\") since there are 2^N partitions.\\n\\nHowever, in most implementations I saw online, people use an O(N) function to compute if each prefix is a palindrome, as in the following code, which can be found [Here][1]\\n\\n    public ArrayList<ArrayList<String>> partition(String s) {\\n\\tArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\\n \\n\\tif (s == null || s.length() == 0) {\\n\\t\\treturn result;\\n\\t}\\n \\n\\tArrayList<String> partition = new ArrayList<String>();\\n\\taddPalindrome(s, 0, partition, result);\\n \\n\\treturn result;\\n    }\\n \\n    private void addPalindrome(String s, int start, ArrayList<String> partition,\\n\\t\\tArrayList<ArrayList<String>> result) {\\n\\t//stop condition\\n\\tif (start == s.length()) {\\n\\t\\tArrayList<String> temp = new ArrayList<String>(partition);\\n\\t\\tresult.add(temp);\\n\\t\\treturn;\\n\\t}\\n \\n\\tfor (int i = start + 1; i <= s.length(); i++) {\\n\\t\\tString str = s.substring(start, i);\\n\\t\\tif (isPalindrome(str)) {\\n\\t\\t\\tpartition.add(str);\\n\\t\\t\\taddPalindrome(s, i, partition, result);\\n\\t\\t\\tpartition.remove(partition.size() - 1);\\n\\t\\t}\\n\\t}\\n    }\\n \\n    private boolean isPalindrome(String str) {\\n\\tint left = 0;\\n\\tint right = str.length() - 1;\\n \\n\\twhile (left < right) {\\n\\t\\tif (str.charAt(left) != str.charAt(right)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n \\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n \\n\\treturn true;\\n    }\\n\\nSince this function \"isPalindrome\" needs to be called once for every prefix, that would make the overall time complexity O(N * 2^N).\\n\\nSo my questions is: why don't we first use DP to find out if each substring is palindromic, which takes O(N^2) time and space? This would be nothing compared to the O(2^N) possible partitions, but saves us the need to call the O(N) isPalindrome function, thus brings down the overall time complexity to O(2^N) from O(N * 2^N). \\n\\nI would really appreciate it if someone could point out if my reasoning is correct or not. Thank you!\\n\\n  [1]: http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "I understand this problem can be solved easily with DFS. The basic idea is that for each palindromic prefix, recursively obtain the palindrome partitioning of the remaining substring. As far as I am concerned, this is, to say the least,  an O(2^N) algorithm in the worst case (e.g., for strings like \"aaaaa\") since there are 2^N partitions.\\n\\nHowever, in most implementations I saw online, people use an O(N) function to compute if each prefix is a palindrome, as in the following code, which can be found [Here][1]\\n\\n    public ArrayList<ArrayList<String>> partition(String s) {\\n\\tArrayList<ArrayList<String>> result = new ArrayList<ArrayList<String>>();\\n \\n\\tif (s == null || s.length() == 0) {\\n\\t\\treturn result;\\n\\t}\\n \\n\\tArrayList<String> partition = new ArrayList<String>();\\n\\taddPalindrome(s, 0, partition, result);\\n \\n\\treturn result;\\n    }\\n \\n    private void addPalindrome(String s, int start, ArrayList<String> partition,\\n\\t\\tArrayList<ArrayList<String>> result) {\\n\\t//stop condition\\n\\tif (start == s.length()) {\\n\\t\\tArrayList<String> temp = new ArrayList<String>(partition);\\n\\t\\tresult.add(temp);\\n\\t\\treturn;\\n\\t}\\n \\n\\tfor (int i = start + 1; i <= s.length(); i++) {\\n\\t\\tString str = s.substring(start, i);\\n\\t\\tif (isPalindrome(str)) {\\n\\t\\t\\tpartition.add(str);\\n\\t\\t\\taddPalindrome(s, i, partition, result);\\n\\t\\t\\tpartition.remove(partition.size() - 1);\\n\\t\\t}\\n\\t}\\n    }\\n \\n    private boolean isPalindrome(String str) {\\n\\tint left = 0;\\n\\tint right = str.length() - 1;\\n \\n\\twhile (left < right) {\\n\\t\\tif (str.charAt(left) != str.charAt(right)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n \\n\\t\\tleft++;\\n\\t\\tright--;\\n\\t}\\n \\n\\treturn true;\\n    }\\n\\nSince this function \"isPalindrome\" needs to be called once for every prefix, that would make the overall time complexity O(N * 2^N).\\n\\nSo my questions is: why don't we first use DP to find out if each substring is palindromic, which takes O(N^2) time and space? This would be nothing compared to the O(2^N) possible partitions, but saves us the need to call the O(N) isPalindrome function, thus brings down the overall time complexity to O(2^N) from O(N * 2^N). \\n\\nI would really appreciate it if someone could point out if my reasoning is correct or not. Thank you!\\n\\n  [1]: http://www.programcreek.com/2013/03/leetcode-palindrome-partitioning-java/",
                "codeTag": "Unknown"
            },
            {
                "id": 3084373,
                "title": "java-beats-99-backtracking",
                "content": "# Intuition\\nWe are asked to return all the permutations matching the problem conditions, hence we are talking about backtracking. One can also look at the constraints and see that they are really small, so backtracking is a viable solution.\\n\\nThe idea is to keep track of the last partition index (the end index of the last substring) and to iterate from that index to the end of the array checking whether we can form a palindrome substring. If we are able to find such a substring we use recursion to continue exploring our search space. If we exhaust the whole string it means we were able to partition the string into `x` number of palindromes. Save the result and backtrack to continue exploring.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    List<List<String>> res = new ArrayList<>();\\n    \\n    public List<List<String>> partition(String s) {\\n        backtrack(0, s, new ArrayList<>());\\n        return res;\\n    }\\n\\n    private void backtrack(int i, String s, ArrayList<String> substrings) {\\n        // base case\\n        if(i == s.length()) {\\n            res.add(new ArrayList<>(substrings));\\n            return;\\n        }\\n        \\n        for(int j = i; j < s.length(); j++) {\\n            String sub = s.substring(i, j + 1);\\n            if(isPalindrome(sub)) {\\n                substrings.add(sub);\\n                backtrack(j + 1, s, substrings);\\n                substrings.remove(substrings.size() - 1);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s.charAt(i) != s.charAt(s.length() - 1 - i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<List<String>> res = new ArrayList<>();\\n    \\n    public List<List<String>> partition(String s) {\\n        backtrack(0, s, new ArrayList<>());\\n        return res;\\n    }\\n\\n    private void backtrack(int i, String s, ArrayList<String> substrings) {\\n        // base case\\n        if(i == s.length()) {\\n            res.add(new ArrayList<>(substrings));\\n            return;\\n        }\\n        \\n        for(int j = i; j < s.length(); j++) {\\n            String sub = s.substring(i, j + 1);\\n            if(isPalindrome(sub)) {\\n                substrings.add(sub);\\n                backtrack(j + 1, s, substrings);\\n                substrings.remove(substrings.size() - 1);\\n            }\\n        }\\n        \\n    }\\n\\n    private boolean isPalindrome(String s) {\\n        for(int i = 0; i < s.length() / 2; i++) {\\n            if(s.charAt(i) != s.charAt(s.length() - 1 - i)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083480,
                "title": "backtracking-c",
                "content": "# Intuition\\nUse recursion and find all possible palindrome substring\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe are using recursion here passing required arguments \\nwe are running loop throung the string and making substring out of it using string.substr() method is the substring is palindrome we will will make recursive call for finding next palindrome substring and if the length of string will be zero we will add that in to answer container\\n\\n\\nif current substring don\\'t give palindromic substring in future we will backtrack \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace complexity would be O(n^2) if we won\\'t count string.substr() function (Since length of string is too small we can ignore it)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nspace complexity is O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isP(string s)\\n    {\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void printS(vector<vector<string>>&ans,string s,vector<string>& a)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i= 0;i<s.size();i++)\\n        {\\n            string qpr= s.substr(0,i+1);\\n            string ros = s.substr(i+1);\\n            if(isP(qpr))\\n            {\\n                a.push_back(qpr);\\n                printS(ans,ros,a);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>a;\\n        printS(ans,s,a);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isP(string s)\\n    {\\n        for(int i = 0;i<s.size();i++)\\n        {\\n            if(s[i]!=s[s.size()-1-i])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void printS(vector<vector<string>>&ans,string s,vector<string>& a)\\n    {\\n        if(s.size()==0)\\n        {\\n            ans.push_back(a);\\n            return;\\n        }\\n        for(int i= 0;i<s.size();i++)\\n        {\\n            string qpr= s.substr(0,i+1);\\n            string ros = s.substr(i+1);\\n            if(isP(qpr))\\n            {\\n                a.push_back(qpr);\\n                printS(ans,ros,a);\\n                a.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>a;\\n        printS(ans,s,a);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2004437,
                "title": "python-bottom-up-dp-solution-100-faster-iterative-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = []\\n        n = len(s)\\n        \\n        for i in range(n+1):\\n            dp.append([])  # create dp of size n+1\\n            \\n        dp[-1].append([])  # because for s[n:] i.e. empty string ,  answer = [[]]\\n        \\n        # dp[i] store all possible palindrome partitions of string s[i:] \\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i+1,n+1):\\n                curr = s[i:j] # cosider each substring of s start from i-th character\\n                \\n                if curr == curr[::-1]:  # if substring is palindrome\\n                    \\n                    # Consider first element of each partition is curr then add curr in the front of all partitions of string s[j:]  , which are already stored in dp[j] \\n                    for e in dp[j]:   \\n                        dp[i].append ([curr] + e)\\n                        \\n        return dp[0]      # All palindrome partitions of s[0:] = s\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        dp = []\\n        n = len(s)\\n        \\n        for i in range(n+1):\\n            dp.append([])  # create dp of size n+1\\n            \\n        dp[-1].append([])  # because for s[n:] i.e. empty string ,  answer = [[]]\\n        \\n        # dp[i] store all possible palindrome partitions of string s[i:] \\n        \\n        for i in range(n-1,-1,-1):\\n            for j in range(i+1,n+1):\\n                curr = s[i:j] # cosider each substring of s start from i-th character\\n                \\n                if curr == curr[::-1]:  # if substring is palindrome\\n                    \\n                    # Consider first element of each partition is curr then add curr in the front of all partitions of string s[j:]  , which are already stored in dp[j] \\n                    for e in dp[j]:   \\n                        dp[i].append ([curr] + e)\\n                        \\n        return dp[0]      # All palindrome partitions of s[0:] = s\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1668696,
                "title": "c-straight-forward-solution-only-for-beginners",
                "content": "# Only for beginners\\n\\n**First of all let\\'s we forget about the PALINDROME part of the question**\\n\\nLet us suppose we have a string of ```Size = 2``` *ab*\\nWhat would be its subarrays?\\n```\\n2.1]\\t{\\'a\\',\\'b\\'}\\n2.2]\\t{\\'ab\\'}\\n```\\nSimple right?\\uD83D\\uDE01\\nNow let\\'s try for ```Size = 3``` *abc*\\nIt\\'s subarrays are\\n```\\n3.1]\\t{\\'a\\',\\'b\\',\\'c\\'}\\n3.2]\\t{\\'a\\',\\'bc\\'}\\n3.3]\\t{\\'ab\\',\\'c\\'}\\n3.4]\\t{\\'abc\\'}\\n```\\n\\nTake the list ```2.1``` then you can do **2 operations**\\n1. Add the last element **directly to the list**.  ```{\\'a\\',\\'b\\'}``` + **\\'c\\' ->**  ```{\\'a\\',\\'b\\',\\'c\\'} ```   \\uD83D\\uDC48**Boom you got list 3.1**\\n2. Add the last element **to the last element of the list**. ```{\\'a\\',\\'b+c\\'}```  **->**  ```{\\'a\\',\\'bc\\'} ```  \\uD83D\\uDC48**Got list 3.2**\\n\\nDo the same operation to get others too\\n**From list 2.2**\\t\\t```{\\'ab\\'}``` + **\\'c\\' ->**  ```{\\'ab\\',\\'c\\'} ``` \\uD83D\\uDC48**Got list 3.3**\\n**From list 2.2**\\t\\t```{\\'ab+c\\'}```  **->**  ```{\\'abc\\'} ```       \\uD83D\\uDC48**Got list 3.4**\\n\\n\\n**And this how it goes on**\\n\\n![image](https://assets.leetcode.com/users/images/5f131924-1510-4709-b6d6-325651f093c3_1641387140.2775264.png)\\n\\n\\nNow that you have generated **all the possible answers** just check whether it is a **palindrome** or not.\\n**If any of the subarray is not a palindrome then we can delete that whole vector**\\ne.g. if ```aba``` is the string then generated answers will be \\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'a\\',\\'ba\\'}    //<- \\'ba\\' is not a palindrome so we\\'ll erase this {\\'a\\',\\'ba\\'} whole vector\\n{\\'ab\\',\\'a\\'}    //<- \\'ab\\' is not a palindrome so we\\'ll erase this {\\'ab\\',\\'a\\'} whole vector\\n{\\'aba\\'}\\n```\\nSo answer will be\\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'aba\\'}\\n```\\n\\n# Let\\'s see the code Now\\n**Code May look longer , I intentionally made it longer**  \\uD83D\\uDE0E\\n```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<string>> res;  \\n\\t// <- This will contain all the generated vectors , from this we\\'ll erase the wrong ones\\n\\npublic:\\n\\t//This will check if the string is palindrome or not\\n    bool checkPalindrome(string &s)\\n    {\\n        int l = 0, r = s.size() - 1;\\n        while (l <= r)\\n            if (s[l] != s[r])\\n                return false;\\n            else\\n                l++, r--;\\n        return true;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\tThis will check a vector\\'s all content ,\\n\\tif any string of this vector is not palindrome whole vector will be removed\\n\\t*/\\n    bool checkVector(vector<string> &v)\\n    {\\n\\n\\n        for (auto &s : v)\\n            if (!checkPalindrome(s))   // just checking all the strings \\n                return true;  \\t//return true : Means this vector will be removed\\n        return false; \\t//return false : Means this vector will NOT be removed\\n    }\\n    void recur(string &s)\\n    {\\n        if (s.size() == 1)\\n        {\\n            res.push_back({s});\\n            return;\\n        }\\n        string c = \"\";\\n        c += s.back();\\n        s.pop_back();\\n        recur(s);      //To get the answer for n-length string we need answer of (n-1)th string\\n        int n = res.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            res.push_back(res[i]);\\n            res.back().back() += c;      // This is the 2nd option {\\'a\\' +\\'b + c\\'}\\n            res[i].push_back(c);       // 1st one  {\\'a\\' + \\'b\\' } +\\'c\\'\\n        }\\n    }\\n\\n    vector<vector<string>> partition(string s)\\n    {\\n        recur(s);\\n\\t\\t/*\\n\\t\\tremove_if is from STL.\\n\\t\\tIt removes elements from specified range and a specified conditions.\\n\\t\\tFor us range = whole vector = from begin() to end()\\n\\t\\tans condition = checkVector() <- Explained above\\n        */\\n\\t\\tauto it = remove_if(res.begin(), res.end(), [&](vector<string> &v)     \\n                            { return checkVector(v); });\\n        res.resize(distance(res.begin(), it));  // resizing it bcz after removing elements size will be decreased\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```Size = 2```\n```\\n2.1]\\t{\\'a\\',\\'b\\'}\\n2.2]\\t{\\'ab\\'}\\n```\n```Size = 3```\n```\\n3.1]\\t{\\'a\\',\\'b\\',\\'c\\'}\\n3.2]\\t{\\'a\\',\\'bc\\'}\\n3.3]\\t{\\'ab\\',\\'c\\'}\\n3.4]\\t{\\'abc\\'}\\n```\n```2.1```\n```{\\'a\\',\\'b\\'}```\n```{\\'a\\',\\'b\\',\\'c\\'} ```\n```{\\'a\\',\\'b+c\\'}```\n```{\\'a\\',\\'bc\\'} ```\n```{\\'ab\\'}```\n```{\\'ab\\',\\'c\\'} ```\n```{\\'ab+c\\'}```\n```{\\'abc\\'} ```\n```aba```\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'a\\',\\'ba\\'}    //<- \\'ba\\' is not a palindrome so we\\'ll erase this {\\'a\\',\\'ba\\'} whole vector\\n{\\'ab\\',\\'a\\'}    //<- \\'ab\\' is not a palindrome so we\\'ll erase this {\\'ab\\',\\'a\\'} whole vector\\n{\\'aba\\'}\\n```\n```\\n{\\'a\\',\\'b\\',\\'a\\'}\\n{\\'aba\\'}\\n```\n```\\nclass Solution\\n{\\nprivate:\\n    vector<vector<string>> res;  \\n\\t// <- This will contain all the generated vectors , from this we\\'ll erase the wrong ones\\n\\npublic:\\n\\t//This will check if the string is palindrome or not\\n    bool checkPalindrome(string &s)\\n    {\\n        int l = 0, r = s.size() - 1;\\n        while (l <= r)\\n            if (s[l] != s[r])\\n                return false;\\n            else\\n                l++, r--;\\n        return true;\\n    }\\n\\t\\n\\t\\n\\t\\n\\t/*\\n\\tThis will check a vector\\'s all content ,\\n\\tif any string of this vector is not palindrome whole vector will be removed\\n\\t*/\\n    bool checkVector(vector<string> &v)\\n    {\\n\\n\\n        for (auto &s : v)\\n            if (!checkPalindrome(s))   // just checking all the strings \\n                return true;  \\t//return true : Means this vector will be removed\\n        return false; \\t//return false : Means this vector will NOT be removed\\n    }\\n    void recur(string &s)\\n    {\\n        if (s.size() == 1)\\n        {\\n            res.push_back({s});\\n            return;\\n        }\\n        string c = \"\";\\n        c += s.back();\\n        s.pop_back();\\n        recur(s);      //To get the answer for n-length string we need answer of (n-1)th string\\n        int n = res.size();\\n        for (int i = 0; i < n; i++)\\n        {\\n            res.push_back(res[i]);\\n            res.back().back() += c;      // This is the 2nd option {\\'a\\' +\\'b + c\\'}\\n            res[i].push_back(c);       // 1st one  {\\'a\\' + \\'b\\' } +\\'c\\'\\n        }\\n    }\\n\\n    vector<vector<string>> partition(string s)\\n    {\\n        recur(s);\\n\\t\\t/*\\n\\t\\tremove_if is from STL.\\n\\t\\tIt removes elements from specified range and a specified conditions.\\n\\t\\tFor us range = whole vector = from begin() to end()\\n\\t\\tans condition = checkVector() <- Explained above\\n        */\\n\\t\\tauto it = remove_if(res.begin(), res.end(), [&](vector<string> &v)     \\n                            { return checkVector(v); });\\n        res.resize(distance(res.begin(), it));  // resizing it bcz after removing elements size will be decreased\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667660,
                "title": "python3-simple-solution-with-dp-and-recursion-beating-97-in-time",
                "content": "```\\ndef partition(self, s: str) -> List[List[str]]:\\n    # dp[i][j] = True if s[i:j] is a palindrome\\n    n = len(s)\\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\\n    for diff in range(n + 1):\\n        for i in range(n + 1 - diff):\\n            j = i + diff\\n            if diff <= 1: dp[i][j] = True\\n            elif s[i] == s[j - 1]: dp[i][j] = dp[i + 1][j - 1]\\n\\n    @cache\\n    def find_part(start: int):\\n        ans = list()\\n        for i in range(start, n):\\n            if dp[start][i + 1]: # is a palindrome\\n                if i + 1 < n: ans += [[s[start:i + 1]] + p for p in find_part(i + 1)]\\n                else: ans.append([s[start:i + 1]])\\n        return ans\\n    return find_part(0)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef partition(self, s: str) -> List[List[str]]:\\n    # dp[i][j] = True if s[i:j] is a palindrome\\n    n = len(s)\\n    dp = [[False] * (n + 1) for _ in range(n + 1)]\\n    for diff in range(n + 1):\\n        for i in range(n + 1 - diff):\\n            j = i + diff\\n            if diff <= 1: dp[i][j] = True\\n            elif s[i] == s[j - 1]: dp[i][j] = dp[i + 1][j - 1]\\n\\n    @cache\\n    def find_part(start: int):\\n        ans = list()\\n        for i in range(start, n):\\n            if dp[start][i + 1]: # is a palindrome\\n                if i + 1 < n: ans += [[s[start:i + 1]] + p for p in find_part(i + 1)]\\n                else: ans.append([s[start:i + 1]])\\n        return ans\\n    return find_part(0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 972148,
                "title": "c-dp-dfs-solution-backtracking",
                "content": "This solution relies on two parts:\\n- creating a dynamic programming table to cache whether given substrings are palindromic\\n- recursively going through all possible substring partitions if they are palindromic\\n\\nFor the first part of this solution, observe that we are building a dynamic programming table based on a recursive palindromic definition\\n- if a string is of length 1, then it is a palindrome\\n- if a string is of length 2, then it is a palindrome only if the first and last characters are equal\\n- otherwise, a string is a palindrome if its first and last characters are equal, and the remaining string when you remove the first and last characters is also a palindrome\\n\\nTo generate all palindromes and take advantage of this recursive definition, observe that we are looping by length and starting position, instead of starting and ending position. This allows us to use previously computed results in building our final answer, since any string of length `n` will use a string of length `n - 2` to determine whether or not it is a palindrome, provided we are above the base case.\\n\\nFrom here, we recursively iterate through the string, starting at the beginning position. Since we need the *entire* string to be split into valid palindromes, we go through all palindromes encountered at each position and then add that to our final result, recursively applying the same process on the remaining string. If we encounter the end of the string, that means we have partitioned the whole string into palindromes, so we add this to our final answer; otherwise, we omit that \"partititioning\" from our final answer.\\n\\nNote that we do not have to perform the traverse method in the main function call (`partition()`), but we can rather do it within the `if` statement in the `build()` `for` loop (instead of doing `if (dp[pos][curr])` we can change it to `if(traverse(s, pos, curr)`). This will save us a quadratic number of operations at the beginning, and will have faster net time complexity; however, for the purposes of clarity in the explanation, I chose to do it the displayed way.\\n\\nThe time complexity of this solution is exponential `(O(n * 2 ^ n)`, where `n` is the size of the string, and the space complexity is `O(n^2)` for our dynamic programming table. The  time complexity stems from the recursive operation that we have to perform when generating all possible answers, since the only way to do this is to backtrack and break up the string, which in the worst case goes through `n` choices at each level, creating an exponential complexity.\\n\\n```\\nvector<vector<int>> dp;\\nvector<vector<string>> result;\\nvector<string> storage;\\nbool traverse(string& s, int left, int right) {\\n\\tif (dp[left][right] >= 0) {\\n\\t\\treturn dp[left][right];\\n\\t}\\n\\tif (left == right) {\\n\\t\\treturn dp[left][right] = 1;\\n\\t}\\n\\tif (right - left == 1) {\\n\\t   return dp[left][right] = s[left] == s[right];\\n\\t}\\n\\treturn dp[left][right] = s[left] == s[right] && traverse(s, left + 1, right - 1);\\n}\\nvoid build(string& s, int pos) {\\n\\tif (pos == s.size()) {\\n\\t\\tresult.push_back(storage);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int curr = pos; curr < s.size(); curr++) {\\n\\t\\tif (dp[pos][curr]) {\\n\\t\\t\\tstorage.push_back(s.substr(pos, curr - pos + 1));\\n\\t\\t\\tbuild(s, curr + 1);\\n\\t\\t\\tstorage.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nvector<vector<string>> partition(string s) {\\n\\tdp.resize(s.size(), vector<int>(s.size(), -1));\\n\\tfor (int len = 1; len <= s.size(); len++) {\\n\\t\\tfor (int i = 0; i <= s.size() - len; i++) {\\n\\t\\t\\ttraverse(s, i, i + len - 1);\\n\\t\\t}\\n\\t}\\n\\tbuild(s, 0);\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nvector<vector<int>> dp;\\nvector<vector<string>> result;\\nvector<string> storage;\\nbool traverse(string& s, int left, int right) {\\n\\tif (dp[left][right] >= 0) {\\n\\t\\treturn dp[left][right];\\n\\t}\\n\\tif (left == right) {\\n\\t\\treturn dp[left][right] = 1;\\n\\t}\\n\\tif (right - left == 1) {\\n\\t   return dp[left][right] = s[left] == s[right];\\n\\t}\\n\\treturn dp[left][right] = s[left] == s[right] && traverse(s, left + 1, right - 1);\\n}\\nvoid build(string& s, int pos) {\\n\\tif (pos == s.size()) {\\n\\t\\tresult.push_back(storage);\\n\\t\\treturn;\\n\\t}\\n\\tfor (int curr = pos; curr < s.size(); curr++) {\\n\\t\\tif (dp[pos][curr]) {\\n\\t\\t\\tstorage.push_back(s.substr(pos, curr - pos + 1));\\n\\t\\t\\tbuild(s, curr + 1);\\n\\t\\t\\tstorage.pop_back();\\n\\t\\t}\\n\\t}\\n}\\nvector<vector<string>> partition(string s) {\\n\\tdp.resize(s.size(), vector<int>(s.size(), -1));\\n\\tfor (int len = 1; len <= s.size(); len++) {\\n\\t\\tfor (int i = 0; i <= s.size() - len; i++) {\\n\\t\\t\\ttraverse(s, i, i + len - 1);\\n\\t\\t}\\n\\t}\\n\\tbuild(s, 0);\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42188,
                "title": "classic-recursive-solution-in-java",
                "content": "The init method computes the isPal[][] array, where isPal[i][j] is true if s[i..j] is palindrome. The helper method is doing the actual recursion, where the cut[] array records the cut positions, and the construct method reconstructs the result from the cut[] array. \\n\\nCompared to the non-recursive implementation this one saves a lot of space as you do not have to store the substrings or the cut positions up to position i for all 0 <= i < s.length(). However it does perform repetitive work compared to the DP solution, e.g., if you have found two different ways of partitioning s[0..k], you still recursively search for partitioning of s[k+1,...]. So it's a typical trade-off between space and time.\\n\\n     public class Solution {\\n        \\n        private void init(boolean[][] isPal, String s) {\\n            int len = isPal.length;\\n            for (int i=0; i<len; i++) isPal[i][i] = true;\\n            for (int k=1; k<len; k++)\\n                for (int i=0; i+k<len; i++) {\\n                    if (s.charAt(i) != s.charAt(i+k)) continue;\\n                    isPal[i][i+k] = (i+1 <= i+k-1) ? isPal[i+1][i+k-1] : true;\\n                }\\n            \\n        }\\n        \\n        private void construct(String s, boolean[] cut, List<List<String>> ans) {\\n            List<String> tmp = new ArrayList<String>();\\n            int cur = 0;\\n            for (int i=0; i<cut.length; i++) {\\n                if (cut[i]) {\\n                    tmp.add(s.substring(cur,i+1));\\n                    cur = i+1;\\n                }\\n            }\\n            ans.add(tmp);\\n        }\\n        \\n        private void helper(String s, int start, int end, boolean[] cut, List<List<String>> ans, boolean[][] isPal) {\\n            if (start > end) construct(s, cut, ans);\\n            for (int i=start; i<=end; i++) {\\n                if (isPal[start][i]) {\\n                    cut[i] = true;\\n                    helper(s, i+1, end, cut, ans, isPal);\\n                    cut[i] = false;\\n                }\\n            }\\n        }\\n    \\n        public List<List<String>> partition(String s) {\\n            int len = s.length();\\n            boolean[][] isPal = new boolean[len][len];\\n            boolean[] cut = new boolean[len];\\n            \\n            init(isPal, s);\\n            List<List<String>> ans = new ArrayList<List<String>>();\\n            helper(s, 0, len-1, cut, ans, isPal);\\n            return ans;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        private void init(boolean[][] isPal, String s) {\\n            int len = isPal.length;\\n            for (int i=0; i<len; i++) isPal[i][i] = true;\\n            for (int k=1; k<len; k++)\\n                for (int i=0; i+k<len; i++) {\\n                    if (s.charAt(i) != s.charAt(i+k)) continue;\\n                    isPal[i][i+k] = (i+1 <= i+k-1) ? isPal[i+1][i+k-1] : true;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3605400,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\nExponential\\n\\n- Space complexity:\\nLinear\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void partitionHelper(int idx, string s, vector<string>& temp, vector<vector<string>>& ans) {\\n        if (idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < s.size(); i++) {\\n            if (palindrome(s, idx, i) == true) {\\n                temp.push_back(s.substr(idx, i-idx+1));\\n                partitionHelper(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n\\n    bool palindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end])\\n                return false;\\n            start++;\\n            end--;    \\n        }\\n        return true;\\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        partitionHelper(0, s, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void partitionHelper(int idx, string s, vector<string>& temp, vector<vector<string>>& ans) {\\n        if (idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        for (int i = idx; i < s.size(); i++) {\\n            if (palindrome(s, idx, i) == true) {\\n                temp.push_back(s.substr(idx, i-idx+1));\\n                partitionHelper(i+1, s, temp, ans);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n\\n    bool palindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end])\\n                return false;\\n            start++;\\n            end--;    \\n        }\\n        return true;\\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> temp;\\n        partitionHelper(0, s, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087967,
                "title": "python3-simple-dfs-659-ms-faster-than-85-12",
                "content": "https://leetcode.com/submissions/detail/883354080/   \\nRuntime: **659 ms**, faster than 85.12% of Python3 online submissions for Palindrome Partitioning.  \\nMemory Usage: 28.2 MB, less than 99.36% of Python3 online submissions for Palindrome Partitioning.  \\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions, lst, l = [], [([], 0)], len(s)\\n        while lst: ## dfs\\n            pals, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                sub = s[i:j]\\n                if sub==sub[::-1]: ## if sub is a palindrome\\n                    if j==l: ## reach the end\\n                        partitions.append(pals+[sub])\\n                    else:\\n                        lst.append((pals+[sub], j))\\n        return partitions\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions, lst, l = [], [([], 0)], len(s)\\n        while lst: ## dfs\\n            pals, i = lst.pop()\\n            for j in range(i+1, l+1):\\n                sub = s[i:j]\\n                if sub==sub[::-1]: ## if sub is a palindrome\\n                    if j==l: ## reach the end\\n                        partitions.append(pals+[sub])\\n                    else:\\n                        lst.append((pals+[sub], j))\\n        return partitions\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083702,
                "title": "c-easy-solution-backtracking-approach-heavily-commented",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/fUs6zefC/shared\" frameBorder=\"0\" width=\"800\" height=\"1000\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFBackTracking Approach || Heavily Commented**\\n# **Please Upvote as it really motivates me**\\n<iframe src=\"https://leetcode.com/playground/fUs6zefC/shared\" frameBorder=\"0\" width=\"800\" height=\"1000\"></iframe>\\n\\n\\n![image](https://assets.leetcode.com/users/images/7a02f26e-85ff-49b8-a932-503cce48097c_1674184823.1043508.png)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3001798,
                "title": "c-solution-backtracking-time-complexity-and-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMCM variation : \\n$$1$$) put cut on every index.\\n$$2$$) seperate given string in 2 parts (curr && pending). \\n$$3$$) check left is palindrome or not.\\n$$4$$) if yes push and call on pending string and remember to backtrack also\\n$$5$$) else continue\\n$$6$$) as soon size of string becomes 0 push given $$vector<string>$$ in ans \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBacktracking\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n*2^n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\nbool isParlindrome(string s){\\n    int i=0,j=s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j])return false;\\n        else {i++;j--;}\\n    }\\n    return true;\\n}\\nvoid solve(string s,vector<vector<string>>& ans,vector<string> v){\\n    if(s.size()==0){\\n        ans.push_back(v);\\n        return;\\n    }\\n    for(int i=0;i<s.size();i++){\\n        string curr = s.substr(0,i+1);\\n        string pending = s.substr(i+1);\\n        if(isParlindrome(curr)){\\n            v.push_back(curr);\\n            solve(pending,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n\\n```\\nPls Upvote:) \\uD83D\\uDE42 \\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\nbool isParlindrome(string s){\\n    int i=0,j=s.size()-1;\\n    while(i<j){\\n        if(s[i]!=s[j])return false;\\n        else {i++;j--;}\\n    }\\n    return true;\\n}\\nvoid solve(string s,vector<vector<string>>& ans,vector<string> v){\\n    if(s.size()==0){\\n        ans.push_back(v);\\n        return;\\n    }\\n    for(int i=0;i<s.size();i++){\\n        string curr = s.substr(0,i+1);\\n        string pending = s.substr(i+1);\\n        if(isParlindrome(curr)){\\n            v.push_back(curr);\\n            solve(pending,ans,v);\\n            v.pop_back();\\n        }\\n    }\\n}\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> v;\\n        solve(s,ans,v);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776013,
                "title": "palindrome-partitioning-java-solution-simple-partition-approach",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList();\\n        List<String> path = new ArrayList();\\n        help(0,s,path,ans);\\n        return ans;\\n    }\\n    void help(int index, String s, List<String> path, List<List<String>> ans)\\n    {\\n        //BASE CASE\\n        if(index==s.length())\\n        {\\n            ans.add(new ArrayList(path));\\n            return;\\n        }\\n        \\n        //recursion\\n        for(int i=index; i<s.length(); i++)\\n        {\\n            if(isPalindrome(index,i,s))\\n            {\\n                path.add(s.substring(index,i+1));\\n                help(i+1,s,path,ans);\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    boolean isPalindrome(int start, int end, String s)\\n    {\\n        while(start<=end)\\n        {\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\nTime Complexity: O( (2^n) *k*(n/2) )\\n\\nReason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList();\\n        List<String> path = new ArrayList();\\n        help(0,s,path,ans);\\n        return ans;\\n    }\\n    void help(int index, String s, List<String> path, List<List<String>> ans)\\n    {\\n        //BASE CASE\\n        if(index==s.length())\\n        {\\n            ans.add(new ArrayList(path));\\n            return;\\n        }\\n        \\n        //recursion\\n        for(int i=index; i<s.length(); i++)\\n        {\\n            if(isPalindrome(index,i,s))\\n            {\\n                path.add(s.substring(index,i+1));\\n                help(i+1,s,path,ans);\\n                path.remove(path.size()-1);\\n            }\\n        }\\n    }\\n    boolean isPalindrome(int start, int end, String s)\\n    {\\n        while(start<=end)\\n        {\\n            if(s.charAt(start)!=s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\nTime Complexity: O( (2^n) *k*(n/2) )\\n\\nReason: O(2^n) to generate every substring and O(n/2)  to check if the substring generated is a palindrome. O(k) is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737723,
                "title": "java-simple-backtracking-faster-than-99-solution-easily-explained",
                "content": "Let\\'s get to the intuition: the question has three keywords, partition, substring and palindrome.\\n\\n1. Partition: Means every answer of ours has to include full string in parts.\\n2. Substring: Since, each answer of ours need to have full string means every next partition should be continuous from the previous substring.\\n3. Palindrome: \\n\\tForget palindrome for now, and suppose we have \"abaaba\" and from our above two observations, one of the answers of ours could be [\"a\", \"ba\", \"ab\", \"a\"]. \\n\\tNow, why is this not one of the answers? Each partitions that we do need to be a palindrome(same as it\\'s reverse). Means one possible solution could be [\"a\", \"baab\", \"a\"]. \\n\\tTake a look at the below image for a better understanding.\\n\\n![image](https://assets.leetcode.com/users/images/13f670c4-e925-4bc6-8fd0-791884cdd909_1643751614.6390266.png)\\n\\n\\nLet\\'s get to the code:\\n```\\nclass Solution {\\n    \\n    ArrayList<List<String>> answer;\\n    \\n    public List<List<String>> partition(String s) {\\n        answer = new ArrayList<>();\\n        solution(s, new ArrayList<String>());\\n        \\n        return answer;\\n    }\\n\\n\\tpublic boolean isPalindrome(String str) {\\n\\t\\t\\n\\t\\tint length = str.length();\\n\\t\\tfor(int idx = 0; idx < length/2; idx++) {\\n\\t\\t\\tif(str.charAt(idx) != str.charAt(length - 1 - idx)) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n \\n\\tpublic void solution(String str, ArrayList<String> asf) {\\n\\t\\t\\n\\t\\tif(str.length() == 0) {            \\n            answer.add(new ArrayList<>(asf));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\t// Take out palindromes from the starting of the question string which is left.\\n\\t\\tfor(int idx = 0; idx < str.length(); idx++) {\\n\\t\\t\\tString sub = str.substring(0, idx + 1);\\n\\t\\t\\t\\n\\t\\t\\tif(isPalindrome(sub)) {\\n                \\n                asf.add(sub);\\n                solution(str.substring(idx + 1), asf);\\n\\t\\t\\t\\t// backtrack and remove the palindromic substring added and found the next one starting from the same letter as this one `sub`.\\n                asf.remove(asf.size() - 1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    \\n    ArrayList<List<String>> answer;\\n    \\n    public List<List<String>> partition(String s) {\\n        answer = new ArrayList<>();\\n        solution(s, new ArrayList<String>());\\n        \\n        return answer;\\n    }\\n\\n\\tpublic boolean isPalindrome(String str) {\\n\\t\\t\\n\\t\\tint length = str.length();\\n\\t\\tfor(int idx = 0; idx < length/2; idx++) {\\n\\t\\t\\tif(str.charAt(idx) != str.charAt(length - 1 - idx)) return false;\\n\\t\\t}\\n\\n\\t\\treturn true;\\n\\t}\\n \\n\\tpublic void solution(String str, ArrayList<String> asf) {\\n\\t\\t\\n\\t\\tif(str.length() == 0) {            \\n            answer.add(new ArrayList<>(asf));\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\n\\n\\t\\t// Take out palindromes from the starting of the question string which is left.\\n\\t\\tfor(int idx = 0; idx < str.length(); idx++) {\\n\\t\\t\\tString sub = str.substring(0, idx + 1);\\n\\t\\t\\t\\n\\t\\t\\tif(isPalindrome(sub)) {\\n                \\n                asf.add(sub);\\n                solution(str.substring(idx + 1), asf);\\n\\t\\t\\t\\t// backtrack and remove the palindromic substring added and found the next one starting from the same letter as this one `sub`.\\n                asf.remove(asf.size() - 1);\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t\\t\\n\\t}\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668702,
                "title": "backtracking-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPal(string &s , int low ,int high)\\n    {\\n        while(low < high)\\n        {\\n            if(s[low++] != s[high--])return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<string>> &res , string &s , int start , vector<string> curr)\\n    {\\n        if(start == s.size()) res.push_back(curr);\\n        \\n        for(int end = start ; end < s.size() ; end++)\\n        {\\n            if(isPal(s,start,end))\\n            {\\n                curr.push_back(s.substr(start,end - start + 1));\\n                dfs(res,s,end+1,curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        dfs(res,s,0,curr);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPal(string &s , int low ,int high)\\n    {\\n        while(low < high)\\n        {\\n            if(s[low++] != s[high--])return false;\\n        }\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<string>> &res , string &s , int start , vector<string> curr)\\n    {\\n        if(start == s.size()) res.push_back(curr);\\n        \\n        for(int end = start ; end < s.size() ; end++)\\n        {\\n            if(isPal(s,start,end))\\n            {\\n                curr.push_back(s.substr(start,end - start + 1));\\n                dfs(res,s,end+1,curr);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        dfs(res,s,0,curr);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668168,
                "title": "c-complete-dp-solution-without-backtracking-time-complexity-o-n-3",
                "content": "We start with the last index of the string and calculate ans for it and store it.\\nWe create substrings starting at index i and check if that is a palindrone and if it is palindrone, we already know the ans for remaining of substring as that is stored in dp, this way there is no need of backtracking.\\n```\\nclass Solution {\\nprivate:\\n    bool isPalindrome(string s){\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        vector<vector<vector<string>>>dp(n+1);\\n        dp[n]=vector<vector<string>>(0);\\n        for(int k=n-1;k>=0;k--){\\n            for(int i=k;i<s.size();i++){\\n                string sub=s.substr(k,i-k+1);\\n                if(isPalindrome(sub)){\\n                    vector<vector<string>>temp=dp[i+1];\\n                    if(temp.size()!=0){\\n                        for(int j=0;j<temp.size();j++){\\n                            temp[j].insert(temp[j].begin(),sub);\\n                            dp[k].push_back(temp[j]);\\n                        }\\n                    }\\n                    else{\\n                        dp[k].push_back({sub});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\nPlease upvote if you find this solution helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isPalindrome(string s){\\n        int i=0;\\n        int j=s.size()-1;\\n        while(i<=j){\\n            if(s[i]!=s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        vector<vector<vector<string>>>dp(n+1);\\n        dp[n]=vector<vector<string>>(0);\\n        for(int k=n-1;k>=0;k--){\\n            for(int i=k;i<s.size();i++){\\n                string sub=s.substr(k,i-k+1);\\n                if(isPalindrome(sub)){\\n                    vector<vector<string>>temp=dp[i+1];\\n                    if(temp.size()!=0){\\n                        for(int j=0;j<temp.size();j++){\\n                            temp[j].insert(temp[j].begin(),sub);\\n                            dp[k].push_back(temp[j]);\\n                        }\\n                    }\\n                    else{\\n                        dp[k].push_back({sub});\\n                    }\\n                }\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667603,
                "title": "python3-recursion-explained",
                "content": "We use a recursion function that returns all possible partitions for the string `s` starting from the `i`th index. Inside the function, we iterate over all chars starting from the index `start` and for every palindrome, we recursively call the function for a substring starting after the found palindrome. Also, we have to use memoization to avoid repeating calls for the same index. Since cached results are lists, before prepending the found palindrome, we have to copy the result.\\n\\nTime: **O(n * 2^n)** - for scans\\nSpace: **O(2^n)** - for cache\\n\\nRuntime: 692 ms, faster than **47.03%** of Python3 online submissions for Palindrome Partitioning.\\nMemory Usage: 68 MB, less than **5.18%** of Python3 online submissions for Palindrome Partitioning.\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        l = len(s)\\n        \\n        def isPalindrom(s):\\n            return s == s[::-1]\\n        \\n        @cache\\n        def rec(start):\\n            if start == l:\\n                return []\\n\\n            res = []\\n            for i in range(start + 1, l + 1):\\n                sub = s[start:i]\\n\\n                if isPalindrom(sub):\\n                    subres = rec(i)\\n                    if not subres:\\n                        res.append(deque([sub]))\\n                    else:\\n                        for arr in subres:\\n                            copy = arr.copy()\\n                            copy.appendleft(sub)\\n                            res.append(copy)\\n    \\n            return res\\n            \\n        return rec(0)\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        l = len(s)\\n        \\n        def isPalindrom(s):\\n            return s == s[::-1]\\n        \\n        @cache\\n        def rec(start):\\n            if start == l:\\n                return []\\n\\n            res = []\\n            for i in range(start + 1, l + 1):\\n                sub = s[start:i]\\n\\n                if isPalindrom(sub):\\n                    subres = rec(i)\\n                    if not subres:\\n                        res.append(deque([sub]))\\n                    else:\\n                        for arr in subres:\\n                            copy = arr.copy()\\n                            copy.appendleft(sub)\\n                            res.append(copy)\\n    \\n            return res\\n            \\n        return rec(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1619941,
                "title": "java-easy-and-clean-backtracking-solution",
                "content": "Runtime - 8ms - Faster than 83.20%\\n```\\nclass Solution {\\n    List<String> temp = new ArrayList<>();\\n    List<List<String>> ans = new ArrayList<List<String>>();\\n    public List<List<String>> partition(String s) {\\n        find(s, 0);\\n        return ans;\\n    }\\n    \\n    public void find(String s, int ptr){\\n    \\tif(ptr == s.length() && temp.size() > 0){\\n    \\t\\tans.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        for(int i = ptr; i < s.length(); i++){\\n            String str = s.substring(ptr, i + 1);\\n            if(isPalindrome(str)){\\n                temp.add(str);\\n                find(s, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String str) {\\n    \\tint i = 0;\\n    \\tint j = str.length() - 1;\\n    \\twhile(i < j) {\\n    \\t\\tif(str.charAt(i++) != str.charAt(j--))\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    List<String> temp = new ArrayList<>();\\n    List<List<String>> ans = new ArrayList<List<String>>();\\n    public List<List<String>> partition(String s) {\\n        find(s, 0);\\n        return ans;\\n    }\\n    \\n    public void find(String s, int ptr){\\n    \\tif(ptr == s.length() && temp.size() > 0){\\n    \\t\\tans.add(new ArrayList<String>(temp));\\n            return;\\n        }\\n        \\n        for(int i = ptr; i < s.length(); i++){\\n            String str = s.substring(ptr, i + 1);\\n            if(isPalindrome(str)){\\n                temp.add(str);\\n                find(s, i + 1);\\n                temp.remove(temp.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String str) {\\n    \\tint i = 0;\\n    \\tint j = str.length() - 1;\\n    \\twhile(i < j) {\\n    \\t\\tif(str.charAt(i++) != str.charAt(j--))\\n    \\t\\t\\treturn false;\\n    \\t}\\n    \\treturn true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388701,
                "title": "javascript-solution",
                "content": "**Please upvote if you find this solution useful ;)**\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let result = [];\\n    \\n    findP(0, []);\\n    return result\\n    \\n    function findP(start, arr){\\n        if(start === s.length){\\n            result.push(arr.slice());\\n            return;\\n        }\\n        \\n        for(let i=start; i<s.length; i++){\\n            let str = s.slice(start, i+1);\\n            if(isPalindrom(str)){\\n                findP(i+1, [...arr, str ])\\n            }\\n        }\\n    }\\n    \\n    function isPalindrom(str) {\\n        for(let i=0; i<str.length/2; i++){\\n            if(str[i] !== str[str.length-1-i])return false\\n        }\\n        return true\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let result = [];\\n    \\n    findP(0, []);\\n    return result\\n    \\n    function findP(start, arr){\\n        if(start === s.length){\\n            result.push(arr.slice());\\n            return;\\n        }\\n        \\n        for(let i=start; i<s.length; i++){\\n            let str = s.slice(start, i+1);\\n            if(isPalindrom(str)){\\n                findP(i+1, [...arr, str ])\\n            }\\n        }\\n    }\\n    \\n    function isPalindrom(str) {\\n        for(let i=0; i<str.length/2; i++){\\n            if(str[i] !== str[str.length-1-i])return false\\n        }\\n        return true\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350891,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<string> temp;\\n        vector<vector<string>> res;\\n        helper(s,temp,res,0);\\n        \\n        return res;\\n    }\\n    \\n    void helper(string& s,vector<string>& temp,vector<vector<string>>& res,int idx){\\n        if(idx == s.length()){\\n            res.push_back(temp);\\n            return;\\n        }\\n        string curr = \"\";\\n        for(int i = idx;i < s.length(); i++){\\n            curr.push_back(s[i]);\\n            if(isPalindrome(curr)){\\n                temp.push_back(curr);\\n                helper(s,temp,res,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string curr){\\n        int l = 0, r = curr.length()-1;\\n        \\n        while(l < r){\\n            if(curr[l++] != curr[r--])\\n                return false;\\n        }\\n        \\n        return true;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<string> temp;\\n        vector<vector<string>> res;\\n        helper(s,temp,res,0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1314559,
                "title": "python-backtracking-beats-95-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(i, j): #checks if the string s[i to j] is palindrome or not\\n            while j>i:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def palindromePart(i, parts, curpart):\\n            if i == len(s): #if parsed the entire string append the current partition list to answer\\n                parts.append(curpart)\\n                \\n            for j in range(i, len(s)): #try all strings starting at i and ending at j where j = (i, len(s))\\n                if isPalindrome(i,j): #if the substring is palindrome then\\n                    palindromePart(j+1, parts, curpart + [s[i:j+1]]) #add substring to temporary substring list repeat the same process from the index after the palindrome substring ends\\n                    \\n        parts = []\\n        palindromePart(0, parts, [])\\n        return parts\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(i, j): #checks if the string s[i to j] is palindrome or not\\n            while j>i:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def palindromePart(i, parts, curpart):\\n            if i == len(s): #if parsed the entire string append the current partition list to answer\\n                parts.append(curpart)\\n                \\n            for j in range(i, len(s)): #try all strings starting at i and ending at j where j = (i, len(s))\\n                if isPalindrome(i,j): #if the substring is palindrome then\\n                    palindromePart(j+1, parts, curpart + [s[i:j+1]]) #add substring to temporary substring list repeat the same process from the index after the palindrome substring ends\\n                    \\n        parts = []\\n        palindromePart(0, parts, [])\\n        return parts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 789971,
                "title": "simple-backtracking-python-c-java",
                "content": "Start from current position, find the next palindrome (the substring `s[strat, end)`), and backtrack.\\n\\nPython 80ms\\n```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.backtrack(s, start=0, path=[], res=res)\\n        return res\\n\\n    def backtrack(self, s, start, path, res):\\n        if start == len(s):\\n            res.append(path)\\n            return\\n\\n        for end in range(start + 1, len(s) + 1):\\n            sub = s[start: end]\\n            if sub == sub[::-1]:\\n                self.backtrack(s, end, path + [sub], res)\\n```\\n\\nC++ 12ms\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        auto res = vector<vector<string>>();\\n        auto path = vector<string>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    void backtrack(string &s, int start, vector<string> &path, vector<vector<string>> &res) {\\n        if (start == s.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.size(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                string sub = s.substr(start, end - start);\\n                path.push_back(sub);\\n                backtrack(s, end, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string_view s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\nJava 2ms\\n```java\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<String> path = new ArrayList<String>();\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> path, List<List<String>> res) {\\n        if (start == s.length()) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.length(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                String sub = s.substring(start, end);\\n                path.add(sub);\\n                backtrack(s, end, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Backtracking"
                ],
                "code": "```python\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.backtrack(s, start=0, path=[], res=res)\\n        return res\\n\\n    def backtrack(self, s, start, path, res):\\n        if start == len(s):\\n            res.append(path)\\n            return\\n\\n        for end in range(start + 1, len(s) + 1):\\n            sub = s[start: end]\\n            if sub == sub[::-1]:\\n                self.backtrack(s, end, path + [sub], res)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        auto res = vector<vector<string>>();\\n        auto path = vector<string>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    void backtrack(string &s, int start, vector<string> &path, vector<vector<string>> &res) {\\n        if (start == s.size()) {\\n            res.push_back(path);\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.size(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                string sub = s.substr(start, end - start);\\n                path.push_back(sub);\\n                backtrack(s, end, path, res);\\n                path.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string_view s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s[i] != s[j]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\n```java\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<String> path = new ArrayList<String>();\\n        List<List<String>> res = new ArrayList<List<String>>();\\n        backtrack(s, 0, path, res);\\n        return res;\\n    }\\n    \\n    private void backtrack(String s, int start, List<String> path, List<List<String>> res) {\\n        if (start == s.length()) {\\n            res.add(List.copyOf(path));\\n            return;\\n        }\\n        \\n        for (int end = start + 1; end <= s.length(); ++end) {\\n\\t\\t\\t// [start, end)\\n            if (isPalindrome(s, start, end)) {\\n                String sub = s.substring(start, end);\\n                path.add(sub);\\n                backtrack(s, end, path, res);\\n                path.remove(path.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        for (int i = start, j = end - 1; i < j; ++i, --j) {\\n            if (s.charAt(i) != s.charAt(j)) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 635944,
                "title": "c-two-solution-dp-with-backtracking-and-backtracking",
                "content": "DP + Backtracking\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        int n = s.size();\\n        vector<vector<bool>> dp( n, vector<bool>(n,false) );\\n    \\tfor( int i=0; i<n; i++ ) dp[i][i] = true;\\n\\n        for( int i=n-1; i >= 0; i-- )\\n    \\t\\tfor( int j=i+1; j < n; j++ )\\n\\t\\t    \\tif( s[i] == s[j] && ( dp[i+1][j-1] || j-i <= 2 ) )\\n\\t\\t\\t    \\tdp[i][j] = true;\\n        \\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s, dp );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s, vector<vector<bool>> &dp ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( dp[start][i] ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s, dp );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\\n\\nBackTracking\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( isPalindrome( s, start, i ) ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome( string& s, int start, int end ) {\\n        while( start < end ) {\\n            if( s[start] != s[end] ) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        int n = s.size();\\n        vector<vector<bool>> dp( n, vector<bool>(n,false) );\\n    \\tfor( int i=0; i<n; i++ ) dp[i][i] = true;\\n\\n        for( int i=n-1; i >= 0; i-- )\\n    \\t\\tfor( int j=i+1; j < n; j++ )\\n\\t\\t    \\tif( s[i] == s[j] && ( dp[i+1][j-1] || j-i <= 2 ) )\\n\\t\\t\\t    \\tdp[i][j] = true;\\n        \\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s, dp );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s, vector<vector<bool>> &dp ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( dp[start][i] ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s, dp );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition( string s ) {\\n        vector<vector<string>> result;\\n        vector<string> curr;\\n        backtrack( result, curr, 0, s );\\n        return result;\\n    }\\n    \\nprivate:\\n    void backtrack( vector<vector<string>>& result, vector<string>& curr,\\n                   int start, string& s ) {\\n        if( start == s.length() ) {\\n            result.push_back( curr );\\n            return;\\n        }\\n        for( int i=start; i < s.size(); i++ ) {\\n            if( isPalindrome( s, start, i ) ) {\\n                curr.push_back( s.substr( start, i - start + 1 ) );\\n                backtrack( result, curr, i+1, s );\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome( string& s, int start, int end ) {\\n        while( start < end ) {\\n            if( s[start] != s[end] ) return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42095,
                "title": "time-complexity-why-o-n-2",
                "content": "I'm a little confused about the time complexity of time complexity using dp to solve 'palindrome partition'.\\nSee the sample code:\\n\\n    import java.lang.reflect.Array;\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            int n = s.length();\\n            boolean[][] isPalindrome = new boolean[n][n];\\n            for (int i = 0; i < n; i++)\\n                isPalindrome[i][i] = true;\\n            for (int i = n - 1; i >= 0; i--) {\\n                for (int j = i + 1; j < n; j++) {\\n                    if (s.charAt(i) == s.charAt(j)) {\\n                        if (j - i < 2 || isPalindrome[i + 1][j - 1])\\n                            isPalindrome[i][j] = true;\\n                    }\\n                }\\n            }\\n            List<List<String>>[] palindromes = (List<List<String>>[])Array.newInstance(List.class, n + 1);\\n     \\n            palindromes[n] = (List)(new LinkedList<List<String>>());\\n            List<String> emptyList = new LinkedList<>();\\n            palindromes[n].add(emptyList);\\n            for (int i = n - 1; i >= 0; i--) {\\n                palindromes[i] = (List)(new LinkedList<List<String>>());\\n                for (int j = i; j < n; j++) {\\n                    if (isPalindrome[i][j]) {\\n                        List<List<String>> lists = palindromes[j + 1];\\n                        String substring = s.substring(i, j + 1);\\n                        for (List<String> list : lists) {\\n                            List<String> newList = new LinkedList<>();\\n                            newList.add(substring);\\n                            newList.addAll(list);\\n                            palindromes[i].add(newList);\\n                        }\\n                    }\\n                }\\n            }\\n            return palindromes[0];\\n        }\\n    }\\n\\nMany people think the time complexity of dp solution is O(n^2).\\nBut I can't agree here. For outer for loop (i) and inner for loop (j) is O(n^2), but there is another inner most for loop (List<String> list: lists) with iterate over all partitioning combinations of a substring. So what is the number of partitioning combinations in worst case? Think about a string like 'aaaaa' in worsk case, you can break up between  any two 'a's, so the number of possible partitions is O(2^n). In this case, the time complexity of the solution would be O(n^2 * 2^n). Am I wrong?",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            int n = s.length();\\n            boolean[][] isPalindrome = new boolean[n][n];\\n            for (int i = 0; i < n; i++)\\n                isPalindrome[i][i] = true;\\n            for (int i = n - 1; i >= 0; i--) {\\n                for (int j = i + 1; j < n; j++) {\\n                    if (s.charAt(i) == s.charAt(j)) {\\n                        if (j - i < 2 || isPalindrome[i + 1][j - 1])\\n                            isPalindrome[i][j] = true;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3223042,
                "title": "best-c-solution-ever-backtracking-string-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using String + Backtracking.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also]. The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output), however the output does not count towards the space complexity.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also]. The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output), however the output does not count towards the space complexity.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*2^N), The time complexity of the above code is O(N*2^N) since every index has 2\\n    choices and for all possible combinations, we\\u2019re checking the condition of being palindrome which takes\\n    linear time. Hence, the overall complexity is O(N*2^N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also].\\n    The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output),\\n    however the output does not count towards the space complexity.\\n\\n    Solved using String + Backtracking. \\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void partition(string& s, vector<vector<string>>& output, vector<string>& temp, int index){\\n        if(index == s.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(checkPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                partition(s, output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> temp; \\n        partition(s, output, temp, 0);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*2^N), The time complexity of the above code is O(N*2^N) since every index has 2\\n    choices and for all possible combinations, we\\u2019re checking the condition of being palindrome which takes\\n    linear time. Hence, the overall complexity is O(N*2^N).\\n\\n    Space Complexity : O(N), The space complexity of the above code is O(N) [considering recursive calls also].\\n    The Space will be used to store the recursion stack. Extra space is only allocated for the Array(output),\\n    however the output does not count towards the space complexity.\\n\\n    Solved using String + Backtracking. \\n\\n*/\\n\\nclass Solution {\\nprivate:\\n    bool checkPalindrome(string s, int low, int high){\\n        while(low<high){\\n            if(s[low++] != s[high--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void partition(string& s, vector<vector<string>>& output, vector<string>& temp, int index){\\n        if(index == s.size()){\\n            output.push_back(temp);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(checkPalindrome(s, index, i)){\\n                temp.push_back(s.substr(index, i-index+1));\\n                partition(s, output, temp, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> temp; \\n        partition(s, output, temp, 0);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085728,
                "title": "python3-642-ms-faster-than-94-04-of-python3-clean-and-easy-to-understand",
                "content": "```\\n    def __init__(self):\\n        self.result = collections.defaultdict(list)\\n        \\n    def partition(self, s: str) -> List[List[str]]:\\n        if not s: return [[]]\\n        if s in self.result: \\n            return self.result[s] \\n        output = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  \\n                for suf in self.partition(s[i:]):  \\n                    output.append([s[:i]] + suf)\\n        self.result[s] = output\\n        return output\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n    def __init__(self):\\n        self.result = collections.defaultdict(list)\\n        \\n    def partition(self, s: str) -> List[List[str]]:\\n        if not s: return [[]]\\n        if s in self.result: \\n            return self.result[s] \\n        output = []\\n        for i in range(1, len(s) + 1):\\n            if s[:i] == s[:i][::-1]:  \\n                for suf in self.partition(s[i:]):  \\n                    output.append([s[:i]] + suf)\\n        self.result[s] = output\\n        return output\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3084628,
                "title": "c-recursion",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> res;\\n    bool ispalindrome(string &s) \\n    {\\n        int l=0, h=s.size()-1;\\n        while(l<h)\\n        {\\n            if(s[l]!=s[h]) return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\n\\n    void find(int i, string &s, string temp, vector<string> valid)\\n    {\\n        if(i==s.size())\\n        {\\n            if(temp.empty())\\n                res.push_back(valid);\\n            return;\\n        } \\n\\n        temp += s[i];\\n        find(i+1, s, temp, valid);\\n        if(ispalindrome(temp))\\n        {\\n            valid.push_back(temp);\\n            find(i+1, s, \"\", valid);\\n        }\\n        \\n    }\\n\\n    vector<vector<string>> partition(string s) \\n    {\\n        vector<string> valid;\\n        find(0, s, \"\", valid);\\n        return res;   \\n    }\\n};\\n```\\n\\n# Please upvote if it helps...",
                "solutionTags": [
                    "C++",
                    "String",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<vector<string>> res;\\n    bool ispalindrome(string &s) \\n    {\\n        int l=0, h=s.size()-1;\\n        while(l<h)\\n        {\\n            if(s[l]!=s[h]) return false;\\n            l++;\\n            h--;\\n        }\\n        return true;\\n    }\\n\\n    void find(int i, string &s, string temp, vector<string> valid)\\n    {\\n        if(i==s.size())\\n        {\\n            if(temp.empty())\\n                res.push_back(valid);\\n            return;\\n        } \\n\\n        temp += s[i];\\n        find(i+1, s, temp, valid);\\n        if(ispalindrome(temp))\\n        {\\n            valid.push_back(temp);\\n            find(i+1, s, \"\", valid);\\n        }\\n        \\n    }\\n\\n    vector<vector<string>> partition(string s) \\n    {\\n        vector<string> valid;\\n        find(0, s, \"\", valid);\\n        return res;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084250,
                "title": "c-solution",
                "content": "# Code\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n\\n*Upvote solution after using it*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> path;\\n        partition(s, 0, path, result);//dfs calls\\n        return result;\\n    }\\nprivate: \\n    //DFS steps\\n    void partition(string& s, int start, vector<string>& path, vector<vector<string>>& result) {\\n        int n = s.length();\\n        if (start == n) {\\n            result.push_back(path);\\n        } else {\\n            for (int i = start; i < n; i++) {\\n                if (isPalindrome(s, start, i)) {\\n                    path.push_back(s.substr(start, i - start + 1));\\n                    partition(s, i + 1, path, result);\\n                    path.pop_back();\\n                }\\n            }\\n        }\\n    }\\n    //helper function to safe check whether a substr is palindrome or not\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r) {\\n            if (s[l++] != s[r--]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083569,
                "title": "python-clear-simple-backtracking-solution",
                "content": "## **Please upvote/favourite/comment if you like this solution!**\\n\\n# Code\\n```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n\\n    def backtrack(self, s, combo, partitions):\\n        temp = list(combo)\\n        if self.isPalindrome(s):\\n            if tuple(temp+[s]) not in partitions:\\n                partitions.add(tuple(temp+[s]))\\n        for i in range(1,len(s)):\\n            if self.isPalindrome(s[:i]):\\n                self.backtrack(s[i:],tuple(temp+[s[:i]]),partitions)\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = set()\\n        self.backtrack(s,(),partitions)\\n        answer = []\\n        for p in partitions:\\n            answer.append(list(p))\\n        return answer\\n```\\n\\n# Complexity\\n- Time complexity: $$O(2^N \\\\cdot N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def isPalindrome(self, s):\\n        i, j = 0, len(s)-1\\n        while i <= j:\\n            if s[i] != s[j]:\\n                return False\\n            i += 1\\n            j -= 1\\n        return True\\n\\n    def backtrack(self, s, combo, partitions):\\n        temp = list(combo)\\n        if self.isPalindrome(s):\\n            if tuple(temp+[s]) not in partitions:\\n                partitions.add(tuple(temp+[s]))\\n        for i in range(1,len(s)):\\n            if self.isPalindrome(s[:i]):\\n                self.backtrack(s[i:],tuple(temp+[s[:i]]),partitions)\\n\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = set()\\n        self.backtrack(s,(),partitions)\\n        answer = []\\n        for p in partitions:\\n            answer.append(list(p))\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021960,
                "title": "simple-and-easily-explained",
                "content": "# Intuition\\nCheck for each index till last index, whether any partition is possible where palindrome is possible, where palindrome is possible is again will be palindrome possible again in its substring.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(2^n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N^2)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int l, int r)\\n{\\n    while(l<=r)\\n    {\\n        if(s[l]!=s[r])\\n        {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n}\\nvoid f(string s, int indx, vector<string>&ans, vector<vector<string>>&res)\\n{\\n    if(indx==s.length())\\n    {\\n        res.push_back(ans);\\n        return;\\n    }\\n    for(int i=indx;i<s.length();i++)\\n    {\\n        if(isPalindrome(s, indx, i))\\n        {\\n            ans.push_back(s.substr(indx, i-indx+1));\\n            f(s, i+1, ans, res);\\n            ans.pop_back();\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string>ans;\\n        f(s, 0, ans, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isPalindrome(string s, int l, int r)\\n{\\n    while(l<=r)\\n    {\\n        if(s[l]!=s[r])\\n        {\\n            return false;\\n        }\\n        l++;\\n        r--;\\n    }\\n    return true;\\n}\\nvoid f(string s, int indx, vector<string>&ans, vector<vector<string>>&res)\\n{\\n    if(indx==s.length())\\n    {\\n        res.push_back(ans);\\n        return;\\n    }\\n    for(int i=indx;i<s.length();i++)\\n    {\\n        if(isPalindrome(s, indx, i))\\n        {\\n            ans.push_back(s.substr(indx, i-indx+1));\\n            f(s, i+1, ans, res);\\n            ans.pop_back();\\n        }\\n    }\\n}\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string>ans;\\n        f(s, 0, ans, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969507,
                "title": "go-solution-recursive",
                "content": "#### Recursive\\n\\n```\\nfunc partition(s string) [][]string {\\n    if len(s) == 0 {\\n        return [][]string{{}}\\n    }\\n    if len(s) == 1 {\\n        return [][]string{{s}}\\n    }\\n    \\n    allPartitions := make([][]string, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        candidate := s[:i+1]\\n        if palindrome(candidate) {\\n            remaining := partition(s[i+1:])\\n            for _, r := range remaining {\\n                partition := append([]string{candidate}, r...)\\n                allPartitions = append(allPartitions, partition)\\n            }\\n        }\\n    }\\n    \\n    return allPartitions\\n}\\n\\nfunc palindrome(s string) bool {\\n    if len(s) <= 1 {\\n        return true\\n    }\\n    if s[0] != s[len(s)-1] {\\n        return false\\n    }\\n    return palindrome(s[1:len(s)-1])\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\nfunc partition(s string) [][]string {\\n    if len(s) == 0 {\\n        return [][]string{{}}\\n    }\\n    if len(s) == 1 {\\n        return [][]string{{s}}\\n    }\\n    \\n    allPartitions := make([][]string, 0, len(s))\\n    for i := 0; i < len(s); i++ {\\n        candidate := s[:i+1]\\n        if palindrome(candidate) {\\n            remaining := partition(s[i+1:])\\n            for _, r := range remaining {\\n                partition := append([]string{candidate}, r...)\\n                allPartitions = append(allPartitions, partition)\\n            }\\n        }\\n    }\\n    \\n    return allPartitions\\n}\\n\\nfunc palindrome(s string) bool {\\n    if len(s) <= 1 {\\n        return true\\n    }\\n    if s[0] != s[len(s)-1] {\\n        return false\\n    }\\n    return palindrome(s[1:len(s)-1])\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2937665,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r)\\n            if (s[l++] != s[r--])\\n                return false;\\n        return true;\\n    }\\n    \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n            return;\\n        }\\n        for (int i = start; i < n; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                par.push_back(s.substr(start, i - start + 1));\\n                partition(s, i + 1, par, pars);\\n                par.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\n    \\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string& s, int l, int r) {\\n        while (l < r)\\n            if (s[l++] != s[r--])\\n                return false;\\n        return true;\\n    }\\n    \\n    void partition(string& s, int start, vector<string>& par, vector<vector<string>>& pars) {\\n        int n = s.length();\\n        if (start == n) {\\n            pars.push_back(par);\\n            return;\\n        }\\n        for (int i = start; i < n; i++) {\\n            if (isPalindrome(s, start, i)) {\\n                par.push_back(s.substr(start, i - start + 1));\\n                partition(s, i + 1, par, pars);\\n                par.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> pars;\\n        vector<string> par;\\n        partition(s, 0, par, pars);\\n        return pars;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2691427,
                "title": "my-java-code-with-short-explanations",
                "content": "Please upvote if this helped you.\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> answer = new ArrayList<>();\\n        List<String> partition = new ArrayList<>();\\n        backTrack(s, partition, answer);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (String s, List<String> partition , List<List<String>> answer){\\n        \\n        if(s.length() == 0){\\n            answer.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        else{\\n            for(int i=0; i<s.length(); i++){\\n                //cs = current sub-string\\n                String cs = s.substring(0, i+1);\\n                \\n                if(isPalindrome(cs)){\\n                    partition.add(cs);\\n                    \\n                    //moving on with next string as previous sub-string is a successfull palindrome and added into partition\\n                    //ns = new sub-string (or) next sub-string\\n                    String ns = s.substring(i+1);\\n                    backTrack(ns, partition, answer);\\n                    //removing during backtracking- only inside if block not for every for loop iteration\\n                    partition.remove(partition.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        while(l < r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> answer = new ArrayList<>();\\n        List<String> partition = new ArrayList<>();\\n        backTrack(s, partition, answer);\\n        return answer;\\n    }\\n    \\n    public static void backTrack\\n        (String s, List<String> partition , List<List<String>> answer){\\n        \\n        if(s.length() == 0){\\n            answer.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        else{\\n            for(int i=0; i<s.length(); i++){\\n                //cs = current sub-string\\n                String cs = s.substring(0, i+1);\\n                \\n                if(isPalindrome(cs)){\\n                    partition.add(cs);\\n                    \\n                    //moving on with next string as previous sub-string is a successfull palindrome and added into partition\\n                    //ns = new sub-string (or) next sub-string\\n                    String ns = s.substring(i+1);\\n                    backTrack(ns, partition, answer);\\n                    //removing during backtracking- only inside if block not for every for loop iteration\\n                    partition.remove(partition.size()-1);\\n                }\\n            }\\n        }\\n    }\\n    \\n    public static boolean isPalindrome(String s){\\n        int l = 0;\\n        int r = s.length()-1;\\n        \\n        while(l < r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2584744,
                "title": "most-optimised-c-time-and-space-complexity-solution",
                "content": "\\uD83D\\uDD25 Please **Upvote** it is **FREE** from your Side\\n\\n\\u26BD\\uFE0F **Approach:-** Partition from one character and go ahead and at each step check if it is a palindrome or not. Dry run a case you\\'ll understand\\n\\n```\\nclass Solution {\\npublic:\\n    bool checkPalin(string s){\\n        string s1 = s;\\n        reverse(s.begin(), s.end());\\n        return s==s1;\\n    }\\n    \\n    void helper(string s, vector<string> &localResult, vector<vector<string>> &result){\\n        if(s.length() == 0){\\n            result.push_back(localResult);\\n            return;\\n        }\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if(checkPalin(s.substr(0,i+1))){\\n                localResult.push_back(s.substr(0, i+1));\\n                helper(s.substr(i+1), localResult, result);\\n                localResult.pop_back();\\n            }\\n        }\\n        return;\\n\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n\\t    vector<string> localResult;\\n\\t    helper(s, localResult, result);\\n\\t    return result;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/62f04a79-3578-42f5-aa59-c1b2786c67b9_1663353697.7582333.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPalin(string s){\\n        string s1 = s;\\n        reverse(s.begin(), s.end());\\n        return s==s1;\\n    }\\n    \\n    void helper(string s, vector<string> &localResult, vector<vector<string>> &result){\\n        if(s.length() == 0){\\n            result.push_back(localResult);\\n            return;\\n        }\\n\\n        for(int i = 0; i<s.length(); i++){\\n            if(checkPalin(s.substr(0,i+1))){\\n                localResult.push_back(s.substr(0, i+1));\\n                helper(s.substr(i+1), localResult, result);\\n                localResult.pop_back();\\n            }\\n        }\\n        return;\\n\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n\\t    vector<string> localResult;\\n\\t    helper(s, localResult, result);\\n\\t    return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2129667,
                "title": "simplest-python-backtracking-beats-97",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        \\n        res = []\\n        \\n        #SOLUTION: at each recursive step, we are passing in the remaining word and a temp array\\n        def recurse(arr ,word):\\n            #if we used up all the characters for every word, we are done\\n            if not word:\\n                res.append(arr)\\n                return \\n            \\n            #we loop from 1 to len(word) + 1 in order to splice correctly\\n            for i in range(1, len(word) + 1):\\n                \\n                #for the string \\'aabb\\'\\n                    #iteration 1: curr = a\\n                    #iteration 2: curr = aa\\n                    #iteration 3: curr = aab\\n                    #iteration 4: curr = aabb\\n                curr = word[:i]\\n                \\n                #if its a palindrome, add it to the array then pass in the remaining characters to work with\\n                if curr ==curr[::-1]:\\n                    recurse(arr + [curr], word[i:])\\n                    \\n        \\n        recurse([], s)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        \\n        res = []\\n        \\n        #SOLUTION: at each recursive step, we are passing in the remaining word and a temp array\\n        def recurse(arr ,word):\\n            #if we used up all the characters for every word, we are done\\n            if not word:\\n                res.append(arr)\\n                return \\n            \\n            #we loop from 1 to len(word) + 1 in order to splice correctly\\n            for i in range(1, len(word) + 1):\\n                \\n                #for the string \\'aabb\\'\\n                    #iteration 1: curr = a\\n                    #iteration 2: curr = aa\\n                    #iteration 3: curr = aab\\n                    #iteration 4: curr = aabb\\n                curr = word[:i]\\n                \\n                #if its a palindrome, add it to the array then pass in the remaining characters to work with\\n                if curr ==curr[::-1]:\\n                    recurse(arr + [curr], word[i:])\\n                    \\n        \\n        recurse([], s)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2069656,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.helper(res, [], s)\\n        return res\\n\\n        \\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n\\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]):  \\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:])\\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        self.helper(res, [], s)\\n        return res\\n\\n        \\n    def helper(self, res, curr, s):\\n        if s == \"\":\\n            res.append(curr)\\n\\n        for i in range(len(s)):\\n            if self.isPalindrome(s[:i + 1]):  \\n                self.helper(res, curr + [s[:i + 1]], s[i + 1:])\\n    def isPalindrome(self, s):\\n        for i in range(len(s) // 2):\\n            if s[i] != s[len(s) - 1 - i]:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1890881,
                "title": "python-easy-to-understand-iterative-backtracking-with-stack",
                "content": "I found that iterative backtracking is much more easy to understand than a recursive one.\\n\\n```\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        ans = []\\n        \\n        stack = [(s,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# ds stands for decision space\\n            ds, path = stack.pop()\\n            \\n            if not ds:\\n                ans.append(path)\\n                continue\\n                      \\n            for i in range(len(ds)):\\n                if ds[:i+1] == ds[:i+1][::-1]:\\n                    path.append(ds[:i+1])\\n                    stack.append((ds[i+1:],path[:]))\\n                    path.pop()\\n                    \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    def partition(self, s: str) -> List[List[str]]:\\n        \\n        ans = []\\n        \\n        stack = [(s,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# ds stands for decision space\\n            ds, path = stack.pop()\\n            \\n            if not ds:\\n                ans.append(path)\\n                continue\\n                      \\n            for i in range(len(ds)):\\n                if ds[:i+1] == ds[:i+1][::-1]:\\n                    path.append(ds[:i+1])\\n                    stack.append((ds[i+1:],path[:]))\\n                    path.pop()\\n                    \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1668351,
                "title": "java-easy-recursion-code",
                "content": "```\\nclass Solution {\\n     List<List<String>> ans=new ArrayList<>();\\n   \\n    public boolean isPalindrome(String s){\\n        \\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    public void palpar(List<String> l,String s,int k){\\n        \\n        if(k+1==s.length()){\\n            ans.add(l);\\n            return;\\n        }\\n        \\n        for(int i=k+1;i<s.length();i++){\\n            \\n            String ns=s.substring(k+1,i+1);\\n            if(isPalindrome(ns)){\\n                List<String > nl=new ArrayList<>(l);\\n                nl.add(ns);\\n                palpar(nl,s,i);\\n                \\n                }\\n        }\\n        \\n    }\\n    public List<List<String>> partition(String s) {\\n       \\n        \\n        palpar(new ArrayList<>(),s,-1);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n     List<List<String>> ans=new ArrayList<>();\\n   \\n    public boolean isPalindrome(String s){\\n        \\n        int n=s.length();\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)!=s.charAt(n-i-1))\\n                return false;\\n        }\\n        \\n        return true;\\n        \\n    }\\n    public void palpar(List<String> l,String s,int k){\\n        \\n        if(k+1==s.length()){\\n            ans.add(l);\\n            return;\\n        }\\n        \\n        for(int i=k+1;i<s.length();i++){\\n            \\n            String ns=s.substring(k+1,i+1);\\n            if(isPalindrome(ns)){\\n                List<String > nl=new ArrayList<>(l);\\n                nl.add(ns);\\n                palpar(nl,s,i);\\n                \\n                }\\n        }\\n        \\n    }\\n    public List<List<String>> partition(String s) {\\n       \\n        \\n        palpar(new ArrayList<>(),s,-1);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1390844,
                "title": "java-solution-dfs-backtracking-explained",
                "content": "Please upvote, if you like my solution & explanation \\uD83D\\uDE0A\\n\\n**Explanation:**\\n\\nIn this solution, we will use DFS and backtracking to compute the partitions of the strings.\\n\\n1. We will iterate the string from starting to end.\\n2. During each iteration, we will divide the string like below:\\n\\t**s = prefix + suffix** (prefix should be a valid palindrome)\\n3. Collect the prefix in a list and make recursion call for suffix\\n4. During backtracking remove the prefix from the list\\n\\nDry Run: \\n1) We need to ensure that the prefix we create is a valid Palindrome\\n\\tEx. s = \"aab\"\\n\\t\\n\\t - 1st iteration for \"aab\"\\n\\t\\t\\tprefix = \"a\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"ab\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"a\"**, further do partitioning for suffix **ab** and then remove this prefix from the list.\\n\\t\\t\\t\\n\\t- 1st iteration for \"ab\"\\n\\t\\t\\tprefix = \"a\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"b\"\\n\\t\\t\\tCollect prefix **\"a\"**, further do partitioning for suffix **b** and then remove this prefix from the list.\\n\\t\\t\\n\\t- 1st iteration for \"b\"\\n\\t\\t\\tprefix = \"b\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"\"\\n\\t\\t\\tCollect prefix **\"b\"**, further do partitioning for suffix **\"\"** and then remove this prefix from the list.\\n\\t\\t\\t\\n\\t-  2nd iteration for \"aab\"\\n\\t\\t\\tprefix = \"aa\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"b\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"aa\"**, further do partitioning for suffix **\"b\"** and then remove this prefix from the list.\\n\\t\\t\\n\\t- 1st iteration for \"b\"\\n\\t\\t\\tprefix = \"b\" (Valid Palindrome)\\n\\t\\t\\tsuffix = \"\"  (Rest of the String)\\n\\t\\t\\tCollect prefix **\"b\"**, further do partitioning for suffix **\"\"** and then remove this prefix from the list.\\n\\n***Base Case**: when the s becomes empty then you can add all the collected prefix in the result list and return.*\\n\\t\\n```\\n   public List<List<String>> partition(String s) {\\n        List<List<String>> lists = new ArrayList<>();\\n        partitionHelper(s, new ArrayList<>(), lists);\\n        return lists;\\n    }\\n    \\n    public void partitionHelper(String s, ArrayList<String> list, List<List<String>> lists){\\n        if(s.length() == 0){\\n            ArrayList<String> res = new ArrayList<>();\\n            res.addAll(list);\\n            lists.add(res);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            String prefix = s.substring(0, i + 1);\\n            String ros = s.substring(i + 1);\\n            if(isPalindrome(prefix)){\\n                list.add(prefix);\\n                partitionHelper(ros, list, lists);\\n\\t\\t\\t\\t// remove the last item from the list during backtracking\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int li = 0;\\n        int ri = s.length() - 1;\\n        while(li < ri){\\n            char left = s.charAt(li);\\n            char right = s.charAt(ri);\\n            li++;\\n            ri--;\\n            if(left!=right){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```\\n\\n![image](https://assets.leetcode.com/users/images/1d23dc9b-61e6-44ca-8026-a39b7dcf4780_1628411969.8208523.png)\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\n   public List<List<String>> partition(String s) {\\n        List<List<String>> lists = new ArrayList<>();\\n        partitionHelper(s, new ArrayList<>(), lists);\\n        return lists;\\n    }\\n    \\n    public void partitionHelper(String s, ArrayList<String> list, List<List<String>> lists){\\n        if(s.length() == 0){\\n            ArrayList<String> res = new ArrayList<>();\\n            res.addAll(list);\\n            lists.add(res);\\n            return;\\n        }\\n        \\n        for(int i = 0; i < s.length(); i++){\\n            String prefix = s.substring(0, i + 1);\\n            String ros = s.substring(i + 1);\\n            if(isPalindrome(prefix)){\\n                list.add(prefix);\\n                partitionHelper(ros, list, lists);\\n\\t\\t\\t\\t// remove the last item from the list during backtracking\\n                list.remove(list.size() - 1); \\n            }\\n        }\\n    }\\n    \\n    public boolean isPalindrome(String s){\\n        int li = 0;\\n        int ri = s.length() - 1;\\n        while(li < ri){\\n            char left = s.charAt(li);\\n            char right = s.charAt(ri);\\n            li++;\\n            ri--;\\n            if(left!=right){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1352737,
                "title": "python-dp-solution-93-31",
                "content": "My approach in DP is of tabulation. So my table is a 1D table, which contains list of all possible substring combinations which forms a palindrome, upto that index (so list of list).\\n\\n3 conditions for my approach of DP:\\n1) All single character subsstrings, are palindrome.\\n2) For all lists in table[i-1] with single final character, check whether that is same as the i-th character in string. If so, then it means a 2-character palindrome. (e.g, \"aa\").\\n3) For all lists in table[i-1] with single penultimate character, check whether that is same as the i-th character in string. If so, then it means a 2+ - character palindrome. (e.g, a + <anything> + a)\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        table = [[] for _ in s]\\n        table[0].append([s[0]])\\n        for i, ch in enumerate(s[1:]):\\n            for item in table[i]:\\n                # Single character\\n                table[i+1].append(item + [ch])\\n                # palindrome of 2 chars\\n                if len(item) >= 1 and len(item[-1]) == 1 and item[-1] == ch:\\n                    temp = item[-1] + ch\\n                    table[i+1].append(item[:-1] + [temp])\\n                # Palindrome of >2 chars\\n                if len(item) >= 2 and len(item[-2]) == 1 and item[-2] == ch:\\n                    temp = item[-2] + item[-1] + ch\\n                    table[i+1].append(item[:-2] + [temp])\\n        return table[-1]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        table = [[] for _ in s]\\n        table[0].append([s[0]])\\n        for i, ch in enumerate(s[1:]):\\n            for item in table[i]:\\n                # Single character\\n                table[i+1].append(item + [ch])\\n                # palindrome of 2 chars\\n                if len(item) >= 1 and len(item[-1]) == 1 and item[-1] == ch:\\n                    temp = item[-1] + ch\\n                    table[i+1].append(item[:-1] + [temp])\\n                # Palindrome of >2 chars\\n                if len(item) >= 2 and len(item[-2]) == 1 and item[-2] == ch:\\n                    temp = item[-2] + item[-1] + ch\\n                    table[i+1].append(item[:-2] + [temp])\\n        return table[-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332296,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    bool isPal(string &s)\\n    {\\n        for(int i=0;i<s.length()/2;i++)\\n        {\\n            if(s[i]!=s[s.length()-i-1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(string &s,int index,vector<string>&curr,vector<vector<string>>&ans)\\n    {\\n        if(index==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        string tmp=\"\";\\n        for(int i=index;i<s.length();i++)\\n        {\\n            tmp.push_back(s[i]);\\n            if(isPal(tmp))\\n            {\\n                curr.push_back(tmp);\\n                helper(s,i+1,curr,ans);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<string>curr;\\n        vector<vector<string>>ans;\\n        helper(s,0,curr,ans);\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    bool isPal(string &s)\\n    {\\n        for(int i=0;i<s.length()/2;i++)\\n        {\\n            if(s[i]!=s[s.length()-i-1])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helper(string &s,int index,vector<string>&curr,vector<vector<string>>&ans)\\n    {\\n        if(index==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        string tmp=\"\";\\n        for(int i=index;i<s.length();i++)\\n        {\\n            tmp.push_back(s[i]);\\n            if(isPal(tmp))\\n            {\\n                curr.push_back(tmp);\\n                helper(s,i+1,curr,ans);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<string>curr;\\n        vector<vector<string>>ans;\\n        helper(s,0,curr,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1262398,
                "title": "python-recursion",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        self.ans=[]\\n        ds=[]\\n        self.solve(0,s,ds)\\n        return self.ans\\n    def solve(self,idx,s,ds):\\n        if idx==len(s):\\n            self.ans.append(ds[:])\\n            return\\n        for i in range(idx,len(s)):\\n            if s[idx:i+1]==s[idx:i+1][::-1]:\\n                ds.append(s[idx:i+1])\\n                self.solve(i+1,s,ds)\\n                ds.pop()\\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        self.ans=[]\\n        ds=[]\\n        self.solve(0,s,ds)\\n        return self.ans\\n    def solve(self,idx,s,ds):\\n        if idx==len(s):\\n            self.ans.append(ds[:])\\n            return\\n        for i in range(idx,len(s)):\\n            if s[idx:i+1]==s[idx:i+1][::-1]:\\n                ds.append(s[idx:i+1])\\n                self.solve(i+1,s,ds)\\n                ds.pop()\\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174542,
                "title": "java-easy-readable-code-question-answer-approach",
                "content": "**Approch :**\\nthis is a generall approch to solve lot of backtracking question make a function and pass parameter as question and answer . build answer while going up.\\n**CODE:**\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        result=new ArrayList<>();\\n        partitionHelper(s,new ArrayList<>());\\n        return result;\\n    }\\n    private List<List<String>> result;\\n    \\n    private boolean isPalindrome(String str){\\n        int low=0 , high=str.length()-1;\\n        \\n        while(low<high){\\n            if(str.charAt(low)!=str.charAt(high)) return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    private void partitionHelper(String ques,List<String> ans){\\n        if(ques.length()==0){\\n            result.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        \\n        for(int i=0;i<ques.length();i++){\\n            String prefix=ques.substring(0,i+1);\\n            if(isPalindrome(prefix)){\\n          String ros=ques.substring(i+1); //ros: rest of string\\n                ans.add(prefix);\\n                partitionHelper(ros,ans);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n    }\\n}\\n```\\n\\n**Complexity:**\\n`Time:O(2^n) and Space:O(n)` where n:length of string\\n\\n**Similar problem for Pratice:**\\n[subsets](https://leetcode.com/problems/subsets/)\\n[letter-combinations-of-a-phone-number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\\n[k-th-symbol-in-grammar/)](https://leetcode.com/problems/k-th-symbol-in-grammar/)\\ngo to pepcoding or aditya verma youtube channel to get command on this general approch .\\n\\nPlease **UPVOTE** if found it helpful and feel free to reach out to me or comment down if you have any doubt.",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        result=new ArrayList<>();\\n        partitionHelper(s,new ArrayList<>());\\n        return result;\\n    }\\n    private List<List<String>> result;\\n    \\n    private boolean isPalindrome(String str){\\n        int low=0 , high=str.length()-1;\\n        \\n        while(low<high){\\n            if(str.charAt(low)!=str.charAt(high)) return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    private void partitionHelper(String ques,List<String> ans){\\n        if(ques.length()==0){\\n            result.add(new ArrayList<>(ans));\\n            return;\\n        }\\n        \\n        for(int i=0;i<ques.length();i++){\\n            String prefix=ques.substring(0,i+1);\\n            if(isPalindrome(prefix)){\\n          String ros=ques.substring(i+1); //ros: rest of string\\n                ans.add(prefix);\\n                partitionHelper(ros,ans);\\n                ans.remove(ans.size()-1);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1125624,
                "title": "easy-and-simple-backtracking-96-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        helper(res,curr,0,s);\\n        return res;\\n    }\\n    void helper(vector<vector<string>>& res,vector<string>& curr,int i,string &s)\\n    {\\n        if(i>=s.size())\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        for(int start =i;start<s.size();start++)\\n        {\\n            if(isvalid(s,i,start))\\n            {\\n                curr.push_back(s.substr(i,start-i+1));\\n                helper(res,curr,start+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    bool isvalid(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        helper(res,curr,0,s);\\n        return res;\\n    }\\n    void helper(vector<vector<string>>& res,vector<string>& curr,int i,string &s)\\n    {\\n        if(i>=s.size())\\n        {\\n            res.push_back(curr);\\n            return;\\n        }\\n        for(int start =i;start<s.size();start++)\\n        {\\n            if(isvalid(s,i,start))\\n            {\\n                curr.push_back(s.substr(i,start-i+1));\\n                helper(res,curr,start+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    bool isvalid(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089155,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"DP.\"\"\"\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        #  Candidate substring is [begin, end), includes begin, excludes end\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                # Reverse and equal is palindrome.\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"DP.\"\"\"\\n        n = len(s)\\n        dp = [[] for _ in range(n + 1)]\\n        dp[n] = [[]]\\n        #  Candidate substring is [begin, end), includes begin, excludes end\\n        for begin in range(n - 1, -1, -1):\\n            for end in range(begin + 1, n + 1):\\n                candidate = s[begin:end]\\n                # Reverse and equal is palindrome.\\n                if candidate == candidate[::-1]:\\n                     for each in dp[end]:\\n                         new_each = [candidate]\\n                         new_each.extend(each)\\n                         dp[begin].append(new_each)\\n        return dp[0]  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1012218,
                "title": "c-dp-backtracking",
                "content": "```\\n#define vvb vector<vector<bool>>\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> finalAns;\\n    vector<string> ans;\\n    int n;\\n    \\n    // O(2^N)\\n    void findPalindromes(string &s, int st, vvb &isPalin) {\\n        \\n        if(st == n) {\\n            finalAns.push_back(ans);\\n            return;\\n        }\\n        \\n        string currString = \"\";\\n        \\n        for(int en = st ; en < n ; en++) { \\n            \\n            if( st == en or (s[st] == s[en] and (st+1==en or isPalin[st+1][en-1])) ) {\\n                isPalin[st][en] = true;\\n            }\\n            \\n            currString += s[en]; // substr not used\\n                        \\n            if(isPalin[st][en]) {\\n                ans.push_back(currString);\\n                findPalindromes(s,en+1,isPalin); \\n                ans.pop_back();\\n            } \\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        n = s.size();    \\n        vector<vector<bool>> isPalin(n, vector<bool>(n,false));\\n        findPalindromes(s,0,isPalin);\\n        return finalAns;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define vvb vector<vector<bool>>\\n\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> finalAns;\\n    vector<string> ans;\\n    int n;\\n    \\n    // O(2^N)\\n    void findPalindromes(string &s, int st, vvb &isPalin) {\\n        \\n        if(st == n) {\\n            finalAns.push_back(ans);\\n            return;\\n        }\\n        \\n        string currString = \"\";\\n        \\n        for(int en = st ; en < n ; en++) { \\n            \\n            if( st == en or (s[st] == s[en] and (st+1==en or isPalin[st+1][en-1])) ) {\\n                isPalin[st][en] = true;\\n            }\\n            \\n            currString += s[en]; // substr not used\\n                        \\n            if(isPalin[st][en]) {\\n                ans.push_back(currString);\\n                findPalindromes(s,en+1,isPalin); \\n                ans.pop_back();\\n            } \\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        n = s.size();    \\n        vector<vector<bool>> isPalin(n, vector<bool>(n,false));\\n        findPalindromes(s,0,isPalin);\\n        return finalAns;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728379,
                "title": "python-two-solutions-dp-and-backtracking",
                "content": "##### DP:\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        @lru_cache(maxsize=None)\\n        def helper(idx):\\n            if idx == len(s):\\n                return [[]]\\n            \\n            result = list()\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    sub_partitions = helper(i+1)\\n                    result += [[s[idx:i+1]] + p for p in sub_partitions]    \\n            return result\\n        \\n        return helper(0)\\n```\\n\\nTime: O(n * 2^n)\\nSpace: O(2^n)\\n\\n#### Backtracking:\\n\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def helper(idx, path):\\n            if idx == len(s):\\n                result.append(path[:])\\n                return\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    path.append(s[idx:i+1])\\n                    helper(i+1, path)\\n                    path.pop()\\n            \\n        result = list()\\n        helper(0, [])\\n        return result\\n```\\n\\nTime: O(n * 2^n)\\nSpace: O(2^n)",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        @lru_cache(maxsize=None)\\n        def helper(idx):\\n            if idx == len(s):\\n                return [[]]\\n            \\n            result = list()\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    sub_partitions = helper(i+1)\\n                    result += [[s[idx:i+1]] + p for p in sub_partitions]    \\n            return result\\n        \\n        return helper(0)\\n```\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def helper(idx, path):\\n            if idx == len(s):\\n                result.append(path[:])\\n                return\\n            \\n            for i in range(idx, len(s)):\\n                if s[idx:i+1] == s[idx:i+1][::-1]:\\n                    path.append(s[idx:i+1])\\n                    helper(i+1, path)\\n                    path.pop()\\n            \\n        result = list()\\n        helper(0, [])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525250,
                "title": "java-dfs-very-readable-solution-beat-95-67",
                "content": "If you have any trouble to understand. Don\\'t hesitate to ask.\\n```\\nclass Solution {\\n    String s;\\n    int n;\\n    List<List<String>> ans;\\n    public List<List<String>> partition(String s) {\\n        if(s==null || s.length()==0){\\n            return new ArrayList();\\n        }\\n        this.ans = new ArrayList();\\n        this.s = s;\\n        this.n = s.length();\\n        recursive(new ArrayList(), 0);\\n        return ans;\\n    }\\n    \\n    public void recursive(List<String> list,int l){\\n        if(l==n){\\n            ans.add(list);\\n            return;\\n        }\\n        \\n        int i=l;\\n        \\n        while(i<n){\\n            if(isPalindrome(l, i)){\\n                List<String> list2 = new ArrayList(list);\\n                list2.add(s.substring(l, i+1));\\n                recursive(list2, i+1);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int l, int r){\\n        while(l<r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    String s;\\n    int n;\\n    List<List<String>> ans;\\n    public List<List<String>> partition(String s) {\\n        if(s==null || s.length()==0){\\n            return new ArrayList();\\n        }\\n        this.ans = new ArrayList();\\n        this.s = s;\\n        this.n = s.length();\\n        recursive(new ArrayList(), 0);\\n        return ans;\\n    }\\n    \\n    public void recursive(List<String> list,int l){\\n        if(l==n){\\n            ans.add(list);\\n            return;\\n        }\\n        \\n        int i=l;\\n        \\n        while(i<n){\\n            if(isPalindrome(l, i)){\\n                List<String> list2 = new ArrayList(list);\\n                list2.add(s.substring(l, i+1));\\n                recursive(list2, i+1);\\n            }\\n            i++;\\n        }\\n    }\\n    \\n    private boolean isPalindrome(int l, int r){\\n        while(l<r){\\n            if(s.charAt(l) != s.charAt(r)){\\n                return false;\\n            }\\n            l++;\\n            r--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520914,
                "title": "easy-to-understand-python-backtrack-beat-80",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def ispalindrome(s):\\n            return True if s == s[::-1] else False\\n        results = []\\n        n = len(s)\\n\\t\\t#use par to store current results, cur_pos to store current index (left used and right remain)\\n        def backtrack(cur_pos, par):\\n            #the following judging methods are both correct\\n            if cur_pos == n:\\n            #if \"\".join(par) == s:\\n                results.append(par[:])\\n            else:\\n                for i in range(cur_pos+1, n+1):\\n\\t\\t\\t\\t#find a current par string, add into par then try to find more in remain elements\\n                    if ispalindrome(s[cur_pos:i]):\\n                        par.append(s[cur_pos:i])\\n                        backtrack(i,par)\\n                        par.pop()\\n        \\n        backtrack(0, [])\\n        return results\\n            \\n            \\n            \\n",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def ispalindrome(s):\\n            return True if s == s[::-1] else False\\n        results = []\\n        n = len(s)\\n\\t\\t#use par to store current results, cur_pos to store current index (left used and right remain)\\n        def backtrack(cur_pos, par):\\n            #the following judging methods are both correct\\n            if cur_pos == n:\\n            #if \"\".join(par) == s:\\n                results.append(par[:])\\n            else:\\n                for i in range(cur_pos+1, n+1):\\n\\t\\t\\t\\t#find a current par string, add into par then try to find more in remain elements\\n                    if ispalindrome(s[cur_pos:i]):\\n                        par.append(s[cur_pos:i])\\n                        backtrack(i,par)\\n                        par.pop()\\n        \\n        backtrack(0, [])\\n        return results\\n            \\n            \\n            \\n",
                "codeTag": "Java"
            },
            {
                "id": 324319,
                "title": "c-60-beat-iterative-solution-o-2-n",
                "content": "I counted the number of calls, it\\'s exactly O(2 ^ N) for worst case.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aTemp, 0);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            string aChunk = pString.substr(pIndex, aLen);\\n            if (isPally(aChunk)) {\\n                pTemp.push_back(aChunk);\\n                helper(pResult, pString, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n    \\n    bool isPally(string &s) {\\n        int aLo = 0;\\n        int aHi = s.size() - 1;\\n        while (aLo < aHi) {\\n            if (s[aLo] != s[aHi]) { return false; }\\n            aLo++;\\n            aHi--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> aResult;\\n        vector<string> aTemp;\\n        helper(aResult, s, aTemp, 0);\\n        return aResult;\\n    }\\n    \\n    void helper(vector<vector<string>> &pResult, string &pString, vector<string> &pTemp, int pIndex) {\\n        \\n        if (pIndex >= pString.size()) {\\n            pResult.push_back(pTemp);\\n            return;\\n        }\\n        \\n        for (int aLen=1;pIndex+aLen<=pString.size();aLen++) {\\n            string aChunk = pString.substr(pIndex, aLen);\\n            if (isPally(aChunk)) {\\n                pTemp.push_back(aChunk);\\n                helper(pResult, pString, pTemp, pIndex + aLen);\\n                pTemp.pop_back();\\n            }   \\n        }\\n    }\\n    \\n    bool isPally(string &s) {\\n        int aLo = 0;\\n        int aHi = s.size() - 1;\\n        while (aLo < aHi) {\\n            if (s[aLo] != s[aHi]) { return false; }\\n            aLo++;\\n            aHi--;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287345,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public IList<IList<string>> Partition(string s) {\\n        var result = new List<IList<string>>();\\n\\n        var n = s.Length;\\n        if (n == 0) return result;\\n\\n        DFS(s, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(string s, IList<string> oneResult, IList<IList<string>> result) {\\n        var n = s.Length;\\n\\n        if (n == 0) {\\n            result.Add(new List<string>(oneResult));\\n        } else {\\n            for (int count = 1; count <= n; count++) {\\n                var firstStr = s.Substring(0, count);\\n                if (isPalindrome(firstStr)) {\\n                    oneResult.Add(firstStr);\\n                    var restStr = s.Substring(count, n - count);\\n                    DFS(restStr, oneResult, result);\\n                    oneResult.RemoveAt(oneResult.Count - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private bool isPalindrome(string s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<string>> Partition(string s) {\\n        var result = new List<IList<string>>();\\n\\n        var n = s.Length;\\n        if (n == 0) return result;\\n\\n        DFS(s, new List<string>(), result);\\n        return result;\\n    }\\n\\n    private void DFS(string s, IList<string> oneResult, IList<IList<string>> result) {\\n        var n = s.Length;\\n\\n        if (n == 0) {\\n            result.Add(new List<string>(oneResult));\\n        } else {\\n            for (int count = 1; count <= n; count++) {\\n                var firstStr = s.Substring(0, count);\\n                if (isPalindrome(firstStr)) {\\n                    oneResult.Add(firstStr);\\n                    var restStr = s.Substring(count, n - count);\\n                    DFS(restStr, oneResult, result);\\n                    oneResult.RemoveAt(oneResult.Count - 1);\\n                }\\n            }\\n        }\\n    }\\n\\n    private bool isPalindrome(string s) {\\n        var left = 0;\\n        var right = s.Length - 1;\\n        while (left < right) {\\n            if (s[left] != s[right]) {\\n                return false;\\n            }\\n            left++;\\n            right--;\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187586,
                "title": "short-and-clean-python-solution-beating-98-solutions",
                "content": "Use DP array to store intermediate results, and traverse from left to right. \n\n```\nclass Solution:\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        def is_palindrome(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n            \n        ans = [[] for _ in range(len(s)+1)]\n        ans[0].append([])\n        for i in range(len(s)):\n            for start in range(i+1):\n                if is_palindrome(s, start, i):\n                    substr = s[start:i+1]\n                    for parts in ans[start]:\n                        ans[i+1].append(parts + [substr])\n        return ans[-1]\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        def is_palindrome(s, l, r):\n            while l < r:\n                if s[l] != s[r]:\n                    return False\n                l += 1\n                r -= 1\n            return True\n            \n        ans = [[] for _ in range(len(s)+1)]\n        ans[0].append([])\n        for i in range(len(s)):\n            for start in range(i+1):\n                if is_palindrome(s, start, i):\n                    substr = s[start:i+1]\n                    for parts in ans[start]:\n                        ans[i+1].append(parts + [substr])\n        return ans[-1]\n```",
                "codeTag": "Java"
            },
            {
                "id": 42069,
                "title": "share-my-25-line-java-code-with-brief-explanation-beats-87-05-run-times",
                "content": "    /*\\n        s[i...j] (isPalin[i][j])\\u662f\\u4e0d\\u662fpalindromic? \\u901a\\u8fc7(s[i]==s[j] && dp[i+1][j-1])\\u6765\\u5224\\u65ad.\\n        \\n           a  a  b\\n        a  y  y  n\\n        a     y  n\\n        b        y\\n        \\n        \\u5269\\u4e0b\\u7684\\u4e8b\\u60c5\\u5c31\\u662f\\u505a\\u4e00\\u4e2adfs.\\n    */\\n    public class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> ans = new ArrayList<>();\\n            if (s==null || s.length()==0) { return ans; }\\n            int length = s.length();\\n            boolean[][] isPalin = new boolean[length][length];\\n            for (int i=0, count=length, cont; i<length; ++i, --count) {\\n                for (int j=0; j<count; ++j) {\\n                    isPalin[j][i+j] = s.charAt(j)==s.charAt(i+j) && (j+1>=i+j-1 ? true : isPalin[j+1][i+j-1]);\\n                }\\n            }\\n            dfs(ans, new ArrayList<String>(), s, isPalin, 0);\\n            return ans;\\n        }\\n        \\n        private void dfs(List<List<String>> ans, List<String> list, String s, boolean[][] isPalin, int row) {\\n            int length = s.length();\\n            if (row == length) { ans.add(new ArrayList<String>(list)); return; }\\n            for (int i=row; i<length; ++i) {\\n                if (isPalin[row][i]) {\\n                    list.add(s.substring(row, i+1));\\n                    dfs(ans, list, s, isPalin, i+1);\\n                    list.remove(list.size()-1);\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<String>> partition(String s) {\\n            List<List<String>> ans = new ArrayList<>();\\n            if (s==null || s.length()==0) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 42140,
                "title": "my-c-solution-13ms",
                "content": "    class Solution {\\n    \\tvector<vector<string> > partitionRes;\\n    \\tvector<string> oneRes;\\n    public:\\n        \\tvoid findpartition(const string &s){\\n        \\t\\tfor(int i=1; i<=s.size(); i++){\\n        \\t\\t    int l=0, r=i-1;\\n        \\t\\t\\twhile( l <= r) {\\n        \\t\\t\\t    if(s[l] != s[r]) break;\\n        \\t\\t\\t    l++; r--;\\n        \\t\\t\\t}\\n        \\t\\t\\tif(l > r){\\n        \\t\\t\\t\\toneRes.push_back(s.substr(0 ,i));\\n        \\t\\t\\t\\tif(i == s.size())partitionRes.push_back(oneRes);\\n        \\t\\t\\t\\tfindpartition(s.substr(i));\\n        \\t\\t\\t\\toneRes.pop_back();\\n        \\t\\t\\t}\\n        \\t\\t}\\n        \\t}\\n        \\tvector<vector<string> > partition(string s) {\\n    \\t    \\tfindpartition(s);\\n    \\t\\t    return partitionRes;\\n        \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    \\tvector<vector<string> > partitionRes;\\n    \\tvector<string> oneRes;\\n    public:\\n        \\tvoid findpartition(const string &s){\\n        \\t\\tfor(int i=1; i<=s.size(); i++){\\n        \\t\\t    int l=0, r=i-1;\\n        \\t\\t\\twhile( l <= r) {\\n        \\t\\t\\t    if(s[l] != s[r]) break;\\n        \\t\\t\\t    l++; r--;\\n        \\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3684133,
                "title": "c-backtracking-solution",
                "content": "# Code\\n```\\nclass Solution {\\nprivate:\\n    int countLength(vector<string> v) {\\n        int length = 0;\\n        for(int i = 0; i < v.size(); i++) {\\n            length += v[i].size();\\n        }\\n        return length;\\n    }\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1) return true;\\n        int i = 0, j = n-1;\\n        while(i < j) {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void backTrack(vector<vector<string>>& res, vector<string>& curr, string& s, int start) {\\n        if(countLength(curr) == s.size())\\n            res.push_back(curr);\\n        \\n        for(int i = start; i < s.size(); i++) {\\n            string temp = s.substr(start, i-start+1);\\n            if(!isPalindrome(temp)) continue;\\n            curr.push_back(temp);\\n            backTrack(res, curr, s, i+1);\\n            curr.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        backTrack(res, curr, s, 0);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countLength(vector<string> v) {\\n        int length = 0;\\n        for(int i = 0; i < v.size(); i++) {\\n            length += v[i].size();\\n        }\\n        return length;\\n    }\\n    bool isPalindrome(string s) {\\n        int n = s.size();\\n        if(n == 1) return true;\\n        int i = 0, j = n-1;\\n        while(i < j) {\\n            if(s[i] != s[j])\\n                return false;\\n            i++;\\n            j--;\\n        }\\n        return true;\\n    }\\n    void backTrack(vector<vector<string>>& res, vector<string>& curr, string& s, int start) {\\n        if(countLength(curr) == s.size())\\n            res.push_back(curr);\\n        \\n        for(int i = start; i < s.size(); i++) {\\n            string temp = s.substr(start, i-start+1);\\n            if(!isPalindrome(temp)) continue;\\n            curr.push_back(temp);\\n            backTrack(res, curr, s, i+1);\\n            curr.pop_back();\\n        }\\n    }\\n\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> res;\\n        vector<string> curr;\\n        backTrack(res, curr, s, 0);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200212,
                "title": "131-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Use a backtracking approach to generate all the possible palindrome partitions.\\n- For each character of the string, consider all possible substrings starting at the current character and check if it\\'s a palindrome.\\n- If it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string.\\n- When we have traversed the whole string, add the current partition to the final result.\\n\\nAlgorithm:\\n\\n1. Create a list to store the final result.\\n2. Create an empty list to store the current partition.\\n3.  Write a recursive function to generate all the possible partitions.\\n4. In the function, check if the current partition is a valid palindrome partition or not. If it\\'s valid, add the current partition to the final result.\\n5. For each character of the string, consider all possible substrings starting at the current character and check if it\\'s a palindrome. If it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string.\\n6. When we have traversed the whole string, add the current partition to the final result.\\n7. Return the final result.\\n\\n# Complexity\\n- Time complexity:\\nO(n*(2^n)) where n is the length of the string s. In the worst case, we have 2^n possible partitions, and for each partition, we need to check if it\\'s a valid palindrome partition or not, which takes O(n) time.\\n\\n- Space complexity:\\nO(n) where n is the length of the string s. The maximum depth of the recursion tree is n. At each level of the recursion tree, we create a new partition of length n. Therefore, the space complexity is O(n).\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []  # final result to store all possible palindrome partitions\\n        curr_partition = []  # to store the current partition\\n        \\n        def is_palindrome(s, i, j):\\n            # check if substring s[i:j+1] is a palindrome or not\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def backtrack(start):\\n            # base case: if we have traversed the whole string, add the current partition to the final result\\n            if start >= len(s):\\n                res.append(curr_partition.copy())\\n                return\\n            \\n            # for each character of the string, consider all possible substrings starting at the current character\\n            for end in range(start, len(s)):\\n                # check if the substring is a palindrome or not\\n                if is_palindrome(s, start, end):\\n                    # if it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string\\n                    curr_partition.append(s[start:end+1])\\n                    backtrack(end+1)\\n                    curr_partition.pop()  # backtrack to remove the last added substring\\n        \\n        backtrack(0)  # start the recursive function from the first character of the string\\n        return res  # return the final result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []  # final result to store all possible palindrome partitions\\n        curr_partition = []  # to store the current partition\\n        \\n        def is_palindrome(s, i, j):\\n            # check if substring s[i:j+1] is a palindrome or not\\n            while i < j:\\n                if s[i] != s[j]:\\n                    return False\\n                i += 1\\n                j -= 1\\n            return True\\n        \\n        def backtrack(start):\\n            # base case: if we have traversed the whole string, add the current partition to the final result\\n            if start >= len(s):\\n                res.append(curr_partition.copy())\\n                return\\n            \\n            # for each character of the string, consider all possible substrings starting at the current character\\n            for end in range(start, len(s)):\\n                # check if the substring is a palindrome or not\\n                if is_palindrome(s, start, end):\\n                    # if it\\'s a palindrome, add it to the current partition and recursively find all partitions that can be formed from the rest of the string\\n                    curr_partition.append(s[start:end+1])\\n                    backtrack(end+1)\\n                    curr_partition.pop()  # backtrack to remove the last added substring\\n        \\n        backtrack(0)  # start the recursive function from the first character of the string\\n        return res  # return the final result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086542,
                "title": "java-backtracking-explained",
                "content": "# Please Upvote :D\\n---\\nRecursion tree for a string say `aabb`.\\n\\n![image.png](https://assets.leetcode.com/users/images/f487cc11-070e-437a-9ae6-61b424c8007f_1674400154.1327956.png)\\n\\n---\\n*Read the comments carefully to understand the solution.*\\n#### Code:\\n\\n``` java []\\nclass Solution {\\n    // Globally initialise a list to store our answers\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        // call the recursive function which takes the sring s, index 0 as the start\\n        // and an empty list to store the partitions\\n        help(s, 0, new ArrayList<>());  \\n        return ans;     // return our answer list\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        // BASE CASE:\\n        // If we see that we are trying to put a partition at the end of string\\n        // we stop and return\\n        // but before that we add our current partitioned string (stored in currParts) to ans\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        // if we are at an index say i, \\n        // we will try to put partitions at every index after i\\n        // and see which one of the substrings from i to the partition is a palindrome \\n        for (int i = idx; i < s.length(); i++) {\\n            // we check using this method if the substring is a palindrome\\n            if (isPalindrome(s, idx, i)) {\\n                // if it is, we add the subtring to currParts \\n                currParts.add(s.substring(idx, i + 1));\\n                // we will call the recursion from the next index of i\\n                // by fixing the current state of partitions so far, \\n                // we will see how we can make more partitions in the remaining substring\\n                // Say we have \"a|abb\", we will try to make partitions on \"abb\" by keeping \"a|\" fixed\\n                // the function will go to the depth and make partitions and come back\\n                help(s, i + 1, currParts);\\n                // as \"a|\" was fixed, we will remove it from currParts\\n                // i will move to next index and we will fix \"aa|\" that time \\n                // and check possible partitions after \"aa|\"\\n                // this is how the whole thing will work everytime,  \\n                // Try -> Add (if potential) -> Discard -> Try new\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    // Simple method to check if a string is palidrome or not\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n\\n#### Clean solution: \\n``` java []\\nclass Solution {\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        help(s, 0, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            if (isPalindrome(s, idx, i)) {\\n                currParts.add(s.substring(idx, i + 1));\\n                help(s, i + 1, currParts);\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\\n---\\n#### Time Complexity: $$O(2^n * k * n/2)$$\\n\\n$$O(2^n)$$ to generate every substring and $$O(n/2)$$  to check if the substring generated is a palindrome. $$O(k)$$ is for inserting the palindromes in another data structure, where k  is the average length of the palindrome list.\\n\\n---\\n\\n##### Space Complexity: $$O(k * x)$$\\n\\nThe space complexity can vary depending upon the length of the answer. `k` is the average length of the list of palindromes and if we have `x` such list of palindromes in our final answer. The depth of the recursion tree is `n`, so the auxiliary space required is equal to the $$O(n)$$.",
                "solutionTags": [
                    "Java",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "``` java []\\nclass Solution {\\n    // Globally initialise a list to store our answers\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        // call the recursive function which takes the sring s, index 0 as the start\\n        // and an empty list to store the partitions\\n        help(s, 0, new ArrayList<>());  \\n        return ans;     // return our answer list\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        // BASE CASE:\\n        // If we see that we are trying to put a partition at the end of string\\n        // we stop and return\\n        // but before that we add our current partitioned string (stored in currParts) to ans\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        // if we are at an index say i, \\n        // we will try to put partitions at every index after i\\n        // and see which one of the substrings from i to the partition is a palindrome \\n        for (int i = idx; i < s.length(); i++) {\\n            // we check using this method if the substring is a palindrome\\n            if (isPalindrome(s, idx, i)) {\\n                // if it is, we add the subtring to currParts \\n                currParts.add(s.substring(idx, i + 1));\\n                // we will call the recursion from the next index of i\\n                // by fixing the current state of partitions so far, \\n                // we will see how we can make more partitions in the remaining substring\\n                // Say we have \"a|abb\", we will try to make partitions on \"abb\" by keeping \"a|\" fixed\\n                // the function will go to the depth and make partitions and come back\\n                help(s, i + 1, currParts);\\n                // as \"a|\" was fixed, we will remove it from currParts\\n                // i will move to next index and we will fix \"aa|\" that time \\n                // and check possible partitions after \"aa|\"\\n                // this is how the whole thing will work everytime,  \\n                // Try -> Add (if potential) -> Discard -> Try new\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    // Simple method to check if a string is palidrome or not\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    private List<List<String>> ans = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        help(s, 0, new ArrayList<>());\\n        return ans;\\n    }\\n\\n    private void help(String s, int idx, List<String> currParts) {\\n        if (idx == s.length()) {\\n            ans.add(new ArrayList<>(currParts));\\n            return;\\n        }\\n        for (int i = idx; i < s.length(); i++) {\\n            if (isPalindrome(s, idx, i)) {\\n                currParts.add(s.substring(idx, i + 1));\\n                help(s, i + 1, currParts);\\n                currParts.remove(currParts.size() - 1);\\n            }\\n        }\\n    }\\n\\n    private boolean isPalindrome(String s, int l, int r) {\\n        while (l < r) {\\n            if (s.charAt(l++) != s.charAt(r--)) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085947,
                "title": "java-c-100-solution-with-explanation-using-backtracking-palindrome-partitioning",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe aim is to partition the string into all possible palindrome combinations. To achieve this, we must generate all possible substrings of a string by partitioning at every index until we reach the end of the string. Example, abba can be partitioned as [\"a\",\"ab\",\"abb\",\"abba\"]. Each generated substring is considered as a potential candidate if it a palindrome.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to generate all possible substrings of a given string and expand each possibility if it is a potential candidate. The first thing that comes to mind is Depth First Search. In Depth First Search, we recursively expand potential candidates until the defined goal is achieved. After that, we backtrack to explore the next potential candidate.\\n\\nBacktracking incrementally build the candidates for the solution and discards the candidates (backtrack) if they doesn\\'t satisfy the condition.\\n\\nThe backtracking algorithms consists of the following steps:\\n\\n- Choose: Choose the potential candidate. Here, our potential candidates are all substrings that could be generated from the given string.\\n\\n- Constraint: Define a constraint that must be satisfied by the chosen candidate. In this case, the constraint is that the string must be a palindrome.\\n\\n- Goal: We must define the goal that determines if have found the required solution and we must backtrack. Here, our goal is achieved if we have reached the end of the string.\\n\\n# Complexity\\n- Time complexity: $$O(n*2^n)$$ where $$n$$ is the length of string s. This is the worst-case time complexity when all the possible substrings are palindrome.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, where $$n$$ is the length of the string s. This space will be used to store the recursion stack.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    List<List<String>> ans = new ArrayList<>();\\n    List<String> curr = new ArrayList<>();\\n    boolean isPalindrome(String s, int low, int high) {\\n        while (low < high)\\n            if (s.charAt(low++) != s.charAt(high--)) return false;\\n\\n        return true;\\n    }\\n    void genrate(String s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.add(new ArrayList<>(curr));\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.add(s.substring(start,i+1));\\n                genrate(s,i+1);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\nvector<vector<string>> ans;\\nvector<string> curr;\\n    bool isPalindrome(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    void genrate(string &s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.push_back(curr);\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.push_back(s.substr(start,i-start+1));\\n                genrate(s,i+1);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Backtracking"
                ],
                "code": "```Java []\\nclass Solution {\\n    List<List<String>> ans = new ArrayList<>();\\n    List<String> curr = new ArrayList<>();\\n    boolean isPalindrome(String s, int low, int high) {\\n        while (low < high)\\n            if (s.charAt(low++) != s.charAt(high--)) return false;\\n\\n        return true;\\n    }\\n    void genrate(String s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.add(new ArrayList<>(curr));\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.add(s.substring(start,i+1));\\n                genrate(s,i+1);\\n                curr.remove(curr.size()-1);\\n            }\\n        }\\n    }\\n    public List<List<String>> partition(String s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\nvector<vector<string>> ans;\\nvector<string> curr;\\n    bool isPalindrome(string &s, int low, int high) {\\n        while (low < high) {\\n            if (s[low++] != s[high--]) return false;\\n        }\\n        return true;\\n    }\\n    void genrate(string &s,int start)\\n    {\\n        if(start >=s.length())\\n            ans.push_back(curr);\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s,start,i))\\n            {\\n                curr.push_back(s.substr(start,i-start+1));\\n                genrate(s,i+1);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        genrate(s,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3085574,
                "title": "dp-solution-c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nFirst We Store The Status whether a substring is pallindrome or not.\\nAfter That We Use The Concept of Longest Increasing Subsequence but here we are storing the vector of partitioned (valid ones)strings in vector at that index.....which means till that index we find the possible partitions that could be done and are valid then if the next substring that is to be added is pallindrome too, then we push that substr and push the vector at that index at \"partitionspossibletillhere\".\\nWe Can do Recursion and Backtracking but I haven\\'t tried that coz if it might give me TLE.\\nIf someone tried that plz share the statusd.\\n\\n# Complexity\\n- Time complexity:\\nO(N^3*max(string size))\\n\\n- Space complexity:\\nO(N^3*max(string size))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<vector<string>>>partitionspossibletillhere;\\n    vector<bool>zeros;\\n    vector<vector<bool>>ispallindrome;\\n    string str;\\n    void assign(string &s)\\n    {\\n        zeros.assign(s.size(),false);\\n        ispallindrome.assign(s.size(),zeros);\\n        partitionspossibletillhere.assign(s.size(),{});\\n        int i,j;\\n        ispallindrome[0][0]=true;\\n        for(i=1;i<s.size();i++)\\n        {\\n            ispallindrome[i][i]=true;\\n            if(s[i]==s[i-1])\\n            {\\n                ispallindrome[i-1][i]=true;\\n            }\\n        }\\n        for(j=2;j<=s.size()-1;j++)\\n        {\\n            for(i=j;i<s.size();i++)\\n            {\\n                if((s[i]==s[i-j])&&(ispallindrome[i-j+1][i-1]==1))\\n                {\\n                    ispallindrome[i-j][i]=true;\\n                }\\n            }\\n        }\\n        str=s;\\n        return;\\n    }\\n    void partitioning(int index)\\n    {\\n        if(index==str.size())\\n        {\\n            return;\\n        }\\n        if(ispallindrome[0][index])\\n        {\\n            partitionspossibletillhere[index].push_back({str.substr(0,index+1)});\\n        }\\n        for(int i=0;i<index;i++)\\n        {\\n            if(ispallindrome[i+1][index])\\n            {\\n                string topush=str.substr(i+1,index-i);\\n                for(auto j:partitionspossibletillhere[i])\\n                {\\n                    j.push_back(topush);\\n                    partitionspossibletillhere[index].push_back(j);\\n                }\\n            }\\n        }\\n        partitioning(index+1);\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) \\n    {\\n        assign(s);\\n        partitioning(0);\\n        return partitionspossibletillhere.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<vector<string>>>partitionspossibletillhere;\\n    vector<bool>zeros;\\n    vector<vector<bool>>ispallindrome;\\n    string str;\\n    void assign(string &s)\\n    {\\n        zeros.assign(s.size(),false);\\n        ispallindrome.assign(s.size(),zeros);\\n        partitionspossibletillhere.assign(s.size(),{});\\n        int i,j;\\n        ispallindrome[0][0]=true;\\n        for(i=1;i<s.size();i++)\\n        {\\n            ispallindrome[i][i]=true;\\n            if(s[i]==s[i-1])\\n            {\\n                ispallindrome[i-1][i]=true;\\n            }\\n        }\\n        for(j=2;j<=s.size()-1;j++)\\n        {\\n            for(i=j;i<s.size();i++)\\n            {\\n                if((s[i]==s[i-j])&&(ispallindrome[i-j+1][i-1]==1))\\n                {\\n                    ispallindrome[i-j][i]=true;\\n                }\\n            }\\n        }\\n        str=s;\\n        return;\\n    }\\n    void partitioning(int index)\\n    {\\n        if(index==str.size())\\n        {\\n            return;\\n        }\\n        if(ispallindrome[0][index])\\n        {\\n            partitionspossibletillhere[index].push_back({str.substr(0,index+1)});\\n        }\\n        for(int i=0;i<index;i++)\\n        {\\n            if(ispallindrome[i+1][index])\\n            {\\n                string topush=str.substr(i+1,index-i);\\n                for(auto j:partitionspossibletillhere[i])\\n                {\\n                    j.push_back(topush);\\n                    partitionspossibletillhere[index].push_back(j);\\n                }\\n            }\\n        }\\n        partitioning(index+1);\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) \\n    {\\n        assign(s);\\n        partitioning(0);\\n        return partitionspossibletillhere.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084759,
                "title": "c-begineer-friendly-easy-understanding-backtrack-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=9puyFLBesS4/\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(2^n.n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n // to store the ans.\\n     vector<vector<string>> ans;\\n     bool palindrome(string s,int start,int end ){\\n         while(start<end){\\n             if(s[start++] != s[end--]){return false;}\\n         }\\n         return true;\\n     }\\n\\n     void recursion(string s,vector<string>&temp,int index ){\\n\\n        //  base case\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        // loop and do partition based on if palindrome string from 0 to index.\\n        for(int i=index;i<s.size();i++){\\n            // if it is palindrome\\n            if(palindrome(s,index,i)){\\n                temp.push_back(s.substr(index,i-index+1));\\n                recursion(s,temp,i+1);\\n                // pop out value in backtracking for new seq if possible.\\n                temp.pop_back();\\n            }\\n        }\\n     }\\n\\n    vector<vector<string>> partition(string s) {\\n       vector<string> temp;\\n\\n        recursion(s,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n // to store the ans.\\n     vector<vector<string>> ans;\\n     bool palindrome(string s,int start,int end ){\\n         while(start<end){\\n             if(s[start++] != s[end--]){return false;}\\n         }\\n         return true;\\n     }\\n\\n     void recursion(string s,vector<string>&temp,int index ){\\n\\n        //  base case\\n        if(index == s.size()){\\n            ans.push_back(temp);\\n            return;\\n        }\\n\\n        // loop and do partition based on if palindrome string from 0 to index.\\n        for(int i=index;i<s.size();i++){\\n            // if it is palindrome\\n            if(palindrome(s,index,i)){\\n                temp.push_back(s.substr(index,i-index+1));\\n                recursion(s,temp,i+1);\\n                // pop out value in backtracking for new seq if possible.\\n                temp.pop_back();\\n            }\\n        }\\n     }\\n\\n    vector<vector<string>> partition(string s) {\\n       vector<string> temp;\\n\\n        recursion(s,temp,0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084617,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Backtracking\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    string st;\\n\\n    bool isPalindrome(int i,int j) {\\n        while(i < j) {\\n            if(st[i] != st[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    void solve(int id, vector<string> &v) {\\n        if(st.size() == id) {\\n            ans.push_back(v); \\n            return;\\n        }\\n        for(int i=id; i<st.length(); i++) {\\n            if(isPalindrome(id, i)) {\\n                v.push_back(st.substr(id, i - id + 1));\\n                solve(i+1, v);\\n                v.pop_back();\\n            }\\n        }   \\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        st = s;\\n        vector<string> v;\\n        solve(0, v);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    string st;\\n\\n    bool isPalindrome(int i,int j) {\\n        while(i < j) {\\n            if(st[i] != st[j]) return false;\\n            i++, j--;\\n        }\\n        return true;\\n    }\\n\\n    void solve(int id, vector<string> &v) {\\n        if(st.size() == id) {\\n            ans.push_back(v); \\n            return;\\n        }\\n        for(int i=id; i<st.length(); i++) {\\n            if(isPalindrome(id, i)) {\\n                v.push_back(st.substr(id, i - id + 1));\\n                solve(i+1, v);\\n                v.pop_back();\\n            }\\n        }   \\n    }\\n\\n    vector<vector<string>> partition(string s) {\\n        st = s;\\n        vector<string> v;\\n        solve(0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084595,
                "title": "easy-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool issafe(int index,int i,string s){\\n        while(index<=i){\\n            if(s[index++]!=s[i--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void part(vector<string>&path,vector<vector<string>>&ans,string s,int index){\\n        if(index==s.size()){\\n            ans.push_back(path);\\n            return;\\n        }\\n        for(int i=index;i<s.size();i++)\\n        {\\n        if(issafe(index,i,s)){\\n        path.push_back(s.substr(index,i-index+1));\\n        part(path,ans,s,i+1);\\n        path.pop_back();\\n        }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>path;\\n        part(path,ans,s,0);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool issafe(int index,int i,string s){\\n        while(index<=i){\\n            if(s[index++]!=s[i--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void part(vector<string>&path,vector<vector<string>>&ans,string s,int index){\\n        if(index==s.size()){\\n            ans.push_back(path);\\n            return;\\n        }\\n        for(int i=index;i<s.size();i++)\\n        {\\n        if(issafe(index,i,s)){\\n        path.push_back(s.substr(index,i-index+1));\\n        part(path,ans,s,i+1);\\n        path.pop_back();\\n        }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>ans;\\n        vector<string>path;\\n        part(path,ans,s,0);\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084121,
                "title": "proper-explanation-included",
                "content": "# Intuition\\nThe problem is to partition a given string s into a list of substrings such that each substring is a palindrome. The goal is to return all possible partitions of the string s.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solving this problem is to use backtracking. The idea is to iterate through the characters of the string and for each character, check if the substring from that character to the end of the string is a palindrome. If it is, we add that substring to the current partition and recursively call the function for the remaining substring. Once we reach the end of the string, we add the current partition to the final list of partitions.\\n\\n# Algorithm\\n1. Create an empty list `partitions` to store the final partitions\\n2. Create a helper function `backtrack(start, partition)` that takes the current starting index and the current partition as input\\n3. Within the helper function, check if the current starting index is equal to the length of the string. If it is, add the current partition to the `partitions` list and return\\n4. Iterate through the characters from the current starting index to the end of the string\\n5. For each character, check if the substring from that character to the end of the string is a palindrome. If it is, add that substring to the current partition and recursively call the `backtrack()` function for the remaining substring\\n6. Return the `partitions` list\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n)$$ where n is the length of the input string. This is because for each character, we are calling the function recursively and at each level, we are iterating through all the characters from the current starting index to the end of the string. This results in a worst-case time complexity of $$O(2^n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$ because we are storing the partitions in a list and the maximum number of partitions can be n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = []  # create an empty list to store the final partitions\\n        \\n        def backtrack(start, partition):\\n            if start == len(s):  # check if the current starting index is equal to the length of the string\\n                partitions.append(partition)  # if it is, add the current partition to the final list\\n                return\\n            \\n            for i in range(start, len(s)):  # iterate through the characters from the current starting index to the end of the string\\n                if s[start:i+1] == s[start:i+1][::-1]:  # check if the substring is a palindrome\\n                    backtrack(i+1, partition + [s[start:i+1]])  # if it is, add that substring to the current partition and recursively call the function for the remaining substring\\n        \\n        backtrack(0, [])  # call the helper function with starting index 0 and an empty partition\\n        return partitions  # return the final list of partitions\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        partitions = []  # create an empty list to store the final partitions\\n        \\n        def backtrack(start, partition):\\n            if start == len(s):  # check if the current starting index is equal to the length of the string\\n                partitions.append(partition)  # if it is, add the current partition to the final list\\n                return\\n            \\n            for i in range(start, len(s)):  # iterate through the characters from the current starting index to the end of the string\\n                if s[start:i+1] == s[start:i+1][::-1]:  # check if the substring is a palindrome\\n                    backtrack(i+1, partition + [s[start:i+1]])  # if it is, add that substring to the current partition and recursively call the function for the remaining substring\\n        \\n        backtrack(0, [])  # call the helper function with starting index 0 and an empty partition\\n        return partitions  # return the final list of partitions\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084040,
                "title": "c-easiest-soln",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(2^n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkPalindrome(string str, int startIndex, int lastIndex){\\n        while(startIndex <= lastIndex){\\n            if(str[startIndex] != str[lastIndex])\\n                return false;\\n            startIndex++;\\n            lastIndex--;\\n        }\\n        return true;\\n    }\\n    void palindromePartition(int index, vector<string>& ds, vector<vector<string>>& output, string str){\\n        if(index == str.length()){\\n            output.push_back(ds);\\n            return;\\n        }\\n        for(int i = index; i < str.length(); i++){\\n            if(checkPalindrome(str, index, i)){\\n                ds.push_back(str.substr(index, i - index + 1));\\n                palindromePartition(i+1, ds, output, str);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> output;\\n        vector<string> ds;\\n        palindromePartition(0, ds, output, s);\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083686,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/pdh4_26-_6k\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let isPalindrome = (str) =>{\\n        let left = 0;\\n        let right = str.length-1;\\n        while(left<right){\\n            if(str[left] != str[right]) return false;\\n            left++\\n            right--\\n        }\\n        return true;\\n    }\\n    let result = []\\n    let iterate = (str,temp) =>{\\n        if(str.length ==0){\\n            result.push(temp)\\n            return;\\n        }\\n\\n        for(let i =1; i<=str.length; i++){\\n            let value = str.slice(0,i);\\n            if(isPalindrome(value)){\\n                iterate(str.slice(i),[...temp,value])\\n            }\\n        }\\n    }\\n    iterate(s,[])\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string[][]}\\n */\\nvar partition = function(s) {\\n    let isPalindrome = (str) =>{\\n        let left = 0;\\n        let right = str.length-1;\\n        while(left<right){\\n            if(str[left] != str[right]) return false;\\n            left++\\n            right--\\n        }\\n        return true;\\n    }\\n    let result = []\\n    let iterate = (str,temp) =>{\\n        if(str.length ==0){\\n            result.push(temp)\\n            return;\\n        }\\n\\n        for(let i =1; i<=str.length; i++){\\n            let value = str.slice(0,i);\\n            if(isPalindrome(value)){\\n                iterate(str.slice(i),[...temp,value])\\n            }\\n        }\\n    }\\n    iterate(s,[])\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3083599,
                "title": "python-backtracking-beats-91-1-in-runtime-78-51-in-memory",
                "content": "![Screenshot (97).png](https://assets.leetcode.com/users/images/b146496d-edd1-4087-81c3-bc293d304fcd_1674353637.8267994.png)\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe partition method of the Solution class is solving the problem of finding all possible partitions of a given input string s into palindromes.\\nIt first creates a 2D boolean array isPalindrome of the same length as the input string s, to keep track of whether a substring of s is a palindrome or not.\\nIt then uses a nested loop to fill in the isPalindrome array by checking if a substring from start to end is a palindrome or not.\\nThe outer loop iterates over all possible substring lengths, starting from 2 and ending at the length of the input string. The inner loop iterates over all possible starting positions for the substring.\\n\\nIt then uses a recursive helper function helper to explore all possible partitions of the input string s. The function takes the current index of the string, the current partition path, and the overall results as input.\\nIt then loops over all possible end positions of the current partition, checking if the substring from the current index to the end position is a palindrome. If it is, it adds the substring to the current partition path and recursively calls the helper function with the updated index and partition path.\\nOnce the index reaches the end of the input string, it adds the current partition path to the overall results.\\n\\nFinally, the partition method initializes an empty list results and calls the helper function with the initial index of 0 and an empty partition path, returning the results list containing all possible partitions of the input string s into palindromes.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the partition method of the Solution class is a backtracking approach. It uses a recursive helper function to explore all possible partitions of the input string s into palindromes.\\n\\nThe method starts by creating a 2D boolean array isPalindrome of the same length as the input string s, to keep track of whether a substring of s is a palindrome or not.\\nIt then uses a nested loop to fill in the isPalindrome array by checking if a substring from start to end is a palindrome or not.\\nThe outer loop iterates over all possible substring lengths, starting from 2 and ending at the length of the input string. The inner loop iterates over all possible starting positions for the substring.\\n\\nNext, it uses a recursive helper function helper to explore all possible partitions of the input string s.\\nThe function takes the current index of the string, the current partition path, and the overall results as input.\\nIt then loops over all possible end positions of the current partition, checking if the substring from the current index to the end position is a palindrome (by checking the isPalindrome array).\\nIf it is, it adds the substring to the current partition path and recursively calls the helper function with the updated index and partition path.\\nOnce the index reaches the end of the input string, it adds the current partition path to the overall results.\\n\\nFinally, the partition method initializes an empty list results and calls the helper function with the initial index of 0 and an empty partition path, returning the results list containing all possible partitions of the input string s into palindromes.\\n\\nThe backtracking approach allows us to explore all possible partitions of the input string s into palindromes by generating all possible partitions recursively, and then backtracking when a partition doesn\\'t meet the requirements (i.e. a substring is not a palindrome). This allows us to generate all possible partitions without having to check all possible partitions in advance which would be an exponential time complexity.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the partition method of the Solution class is O(n^2) where n is the length of the input string s.\\n\\nThe first step of the method is to fill the isPalindrome array, which takes O(n^2) time.\\nThe nested loop iterates over all possible substrings of s and checks if they are palindromes, which takes O(n^2) time in total.\\n\\nThe next step is to use the recursive helper function helper to explore all possible partitions of the input string s.\\nIn the worst case, the function is called for all possible partitions of the input string, which would take O(n^2) time.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the partition method is O(n^2) as well.\\nThe isPalindrome array takes O(n^2) space to store the information about all possible substrings of s being palindrome or not.\\nThe recursive calls in the helper function also takes O(n^2) space in the worst case, where all possible partitions are stored in the results list.\\n\\nTherefore, the time complexity of the partition method is O(n^2) and the space complexity is also O(n^2) where n is the length of the input string s.\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.isPalindrome = None\\n    \\n    def helper(self, s: str, index: int, path: List[str], results: List[List[str]]):\\n        if index == len(s):\\n            results.append(path)\\n            return\\n        \\n        for end in range(index, len(s)):\\n            if self.isPalindrome[index][end]:\\n                newPath = path[:]\\n                newPath.append(s[index:end+1])\\n                self.helper(s, end + 1, newPath, results)\\n    \\n    def partition(self, s: str) -> List[List[str]]:\\n        self.isPalindrome = [[False for i in range(len(s))] for j in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            self.isPalindrome[i][i] = True\\n        \\n        for length in range(2, len(s) + 1):\\n            for start in range(len(s) - length + 1):\\n                end = start + length - 1\\n                if s[start] == s[end]:\\n                    if length == 2:\\n                        self.isPalindrome[start][end] = True\\n                    else:\\n                        self.isPalindrome[start][end] |= self.isPalindrome[start + 1][end - 1]\\n        \\n        results = []\\n        self.helper(s, 0, [], results)\\n        return results\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.isPalindrome = None\\n    \\n    def helper(self, s: str, index: int, path: List[str], results: List[List[str]]):\\n        if index == len(s):\\n            results.append(path)\\n            return\\n        \\n        for end in range(index, len(s)):\\n            if self.isPalindrome[index][end]:\\n                newPath = path[:]\\n                newPath.append(s[index:end+1])\\n                self.helper(s, end + 1, newPath, results)\\n    \\n    def partition(self, s: str) -> List[List[str]]:\\n        self.isPalindrome = [[False for i in range(len(s))] for j in range(len(s))]\\n        \\n        for i in range(len(s)):\\n            self.isPalindrome[i][i] = True\\n        \\n        for length in range(2, len(s) + 1):\\n            for start in range(len(s) - length + 1):\\n                end = start + length - 1\\n                if s[start] == s[end]:\\n                    if length == 2:\\n                        self.isPalindrome[start][end] = True\\n                    else:\\n                        self.isPalindrome[start][end] |= self.isPalindrome[start + 1][end - 1]\\n        \\n        results = []\\n        self.helper(s, 0, [], results)\\n        return results\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083533,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isPalindrome(string s){//This function returns true if the string is Palindrome else returns false\\n        int n=s.size();\\n        for(int i=0;i<=s.size()/2;i++){\\n            if(s[i]!=s[n-1-i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,string s,vector<string>& ds){\\n        if(idx==s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=idx;i<s.size();i++){\\n            string temp=s.substr(idx,i-idx+1);\\n            if(isPalindrome(temp)){//if the string starting from index idx to i is Palindrome then\\n\\t\\t\\t//we can push that string to ds and check for palindromes from index i+1\\n                ds.push_back(temp);\\n                solve(i+1,s,ds);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        solve(0,s,ds);\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/65075f44-2b96-4c66-8984-b0732bd2fee6_1674350894.9909735.png)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> ans;\\n    bool isPalindrome(string s){//This function returns true if the string is Palindrome else returns false\\n        int n=s.size();\\n        for(int i=0;i<=s.size()/2;i++){\\n            if(s[i]!=s[n-1-i]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void solve(int idx,string s,vector<string>& ds){\\n        if(idx==s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=idx;i<s.size();i++){\\n            string temp=s.substr(idx,i-idx+1);\\n            if(isPalindrome(temp)){//if the string starting from index idx to i is Palindrome then\\n\\t\\t\\t//we can push that string to ds and check for palindromes from index i+1\\n                ds.push_back(temp);\\n                solve(i+1,s,ds);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        solve(0,s,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083438,
                "title": "python-backtracking",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n\\n        def extend(i, cur):\\n            if i >= len(s):\\n                res.append(cur[::])\\n            p = \\'\\'\\n            for j in range(i, len(s)):\\n                p += s[j]\\n                if p == p[::-1]:\\n                    extend(j + 1, cur + [p])\\n        \\n        extend(0, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083424,
                "title": "daily-leetcoding-challenge-january-day-22",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 22.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2957699,
                "title": "c-simple-backtracking-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<string>>ans;\\n    vector<string>v;\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        permutation(0,s,\"\");\\n        return ans;\\n    }\\n    void permutation(int pos, string s, string val) {\\n        if(pos>=s.length()) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = pos; i<s.length(); i++) {\\n            val+=s[i];\\n            if(is_palindrome(val)) {\\n                v.push_back(val);\\n                permutation(i+1, s, \"\");\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool is_palindrome(string s) {\\n        int n = s.length();\\n        for(int i=0; i<n/2; i++) {\\n            if(s[i] != s[n-1-i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<string>>ans;\\n    vector<string>v;\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        permutation(0,s,\"\");\\n        return ans;\\n    }\\n    void permutation(int pos, string s, string val) {\\n        if(pos>=s.length()) {\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(int i = pos; i<s.length(); i++) {\\n            val+=s[i];\\n            if(is_palindrome(val)) {\\n                v.push_back(val);\\n                permutation(i+1, s, \"\");\\n                v.pop_back();\\n            }\\n        }\\n    }\\n    bool is_palindrome(string s) {\\n        int n = s.length();\\n        for(int i=0; i<n/2; i++) {\\n            if(s[i] != s[n-1-i]) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2614054,
                "title": "simple-understanding-c-clean-code-using-backtracking",
                "content": "**Important Points:**\\n* Let **`start`** and **`end`** be the index where the string is to be partioned.\\n* `substr(i,j)` in c++ works as start from `i` and **add** `j` steps(`jth` step is exclusive). \\n\\t* Eg:`str = 01234567`, substr(1,3) = `s[1] to s[1 + 3] = s[4] (exclusive)`. =  `123`.\\n\\n**Understanding recursive steps:**\\n1. Try partioning a substring from `start` till  `end`.\\n2. Check if the partioned substring `( s.substr(start, end -start + 1) )` is a `palindrome or not`.\\n\\n\\t2.1) If **yes**, include into the answer, try searching for next string where the **new start =  end + 1** (repeat step 1: Recursion called).\\n\\t\\n\\t2.2) Also try to backtrack as from one index(`ie: start`) there can be multiple indexes `ie(end)`, which can generate a palindrome substring. So its important to backtrack and check for other string too.\\n\\n**Example Explaining Point 2.2:**\\n\\nstring = `aaa`. lets say `start = 0, end = 1`. ie(substring = `aa`) makes a palindrome.\\n**BUT**\\n`start = 0, end = 3` ie(substring `aaa`) **ALSO MAKES** a new palindrome. Thus, its important to backtrack the last inserted substring into the answer so in order to try new combinations.\\n\\n**Algo/Idea:**\\n1. Start trying to check every substring from  `[start- end] till end == s.size() (ie. The end of string)`.\\n2. Loop from `start` to `s.size()` and check which substring is a `paindrome` partition.\\n3. If the substring is a palindrome, insert it into the `ds` and call the next recrusive function with now **`(start = end + 1)`, so that it can start partioning again with the next index with the help of recursive function.**.\\n4. Remove the last inserted string in order to try other partitions too.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int low , int high){\\n        while(low < high){\\n            if(s[low] != s[high])\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(int start, string s, vector<vector<string>> &ans, vector<string> &ds){\\n        \\n        if(start == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int end = start; end < s.size(); end++){\\n            \\n            if(isPalindrome(s,start,end)){\\n                string str = s.substr(start, end - start + 1);\\n                ds.push_back(str);\\n                solve(end + 1, s, ans, ds); // Note: Here solve(end+1) and not \"start + 1\" as \"end\" will be the latest index where the new palindome string is found and inserted.\\n                ds.pop_back(); // Backtracking it, so that we can try the last palindrome inserted with other next indexes too.\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> ds;\\n        int start = 0;\\n        solve(start,s,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool isPalindrome(string s, int low , int high){\\n        while(low < high){\\n            if(s[low] != s[high])\\n                return false;\\n            low++;\\n            high--;\\n        }\\n        return true;\\n    }\\n    \\n    void solve(int start, string s, vector<vector<string>> &ans, vector<string> &ds){\\n        \\n        if(start == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        \\n        for(int end = start; end < s.size(); end++){\\n            \\n            if(isPalindrome(s,start,end)){\\n                string str = s.substr(start, end - start + 1);\\n                ds.push_back(str);\\n                solve(end + 1, s, ans, ds); // Note: Here solve(end+1) and not \"start + 1\" as \"end\" will be the latest index where the new palindome string is found and inserted.\\n                ds.pop_back(); // Backtracking it, so that we can try the last palindrome inserted with other next indexes too.\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> ans;\\n        vector<string> ds;\\n        int start = 0;\\n        solve(start,s,ans,ds);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490846,
                "title": "c-100-fastest-solution-detailed-explanation-easy-understand",
                "content": "**Read the below approach to understand the logic.**\\n\\n***Please upvote if you like it!!!!!***\\n\\n**Approach:-**\\nThe initial idea will be to make partitions to generate substring and check if the substring generated out of the partition will be a palindrome. Partitioning means we would end up generating every substring and checking for palindrome at every step. Since this is a repetitive task being done again and again, at this point we should think of recursion. The recursion continues until the entire string is exhausted. After partitioning, every palindromic substring is inserted in a data structure When the base case has reached the list of palindromes generated during that recursion call is inserted in a vector of vectors/list of list.\\n\\n**Dry Run:-**\\n\\n![image](https://assets.leetcode.com/users/images/dbedad9b-a814-417f-b23a-ba9cdf252259_1661613943.4511516.jpeg)\\n\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    //fuction to check given range is palindrome or not?\\n    bool isPalindrome(string s,int st,int ed){\\n        while(st<ed){\\n            if(s[st++]!=s[ed--]) return false;\\n        }\\n        return true;\\n    }\\n    //Recursive fuction \\n    void solve(int ind,int n,string s,vector<vector<string>>& ans,vector<string>& temp){\\n        // if ind is equal to n it means string exhausted then push temp string inside ans vector\\n        if(ind==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        //looping for all char in string which make palindrome sub string\\n        for(int i=ind;i<n;i++){\\n            //check if substring will make palindrome, then push that stirng inside the temp and call recursive for further check\\n            if(isPalindrome(s,ind,i)){\\n                temp.push_back(s.substr(ind,i-ind+1));\\n                solve(i+1,n,s,ans,temp);\\n                // when you back from current call, then pop last inseted string\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        //For storing ans substring\\n        vector<vector<string>> ans;\\n        //For temperary inserting and poping substring\\n        vector<string> temp;\\n        // Call solve fucntion\\n        solve(0,s.length(),s,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //fuction to check given range is palindrome or not?\\n    bool isPalindrome(string s,int st,int ed){\\n        while(st<ed){\\n            if(s[st++]!=s[ed--]) return false;\\n        }\\n        return true;\\n    }\\n    //Recursive fuction \\n    void solve(int ind,int n,string s,vector<vector<string>>& ans,vector<string>& temp){\\n        // if ind is equal to n it means string exhausted then push temp string inside ans vector\\n        if(ind==n){\\n            ans.push_back(temp);\\n            return;\\n        }\\n        //looping for all char in string which make palindrome sub string\\n        for(int i=ind;i<n;i++){\\n            //check if substring will make palindrome, then push that stirng inside the temp and call recursive for further check\\n            if(isPalindrome(s,ind,i)){\\n                temp.push_back(s.substr(ind,i-ind+1));\\n                solve(i+1,n,s,ans,temp);\\n                // when you back from current call, then pop last inseted string\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        //For storing ans substring\\n        vector<vector<string>> ans;\\n        //For temperary inserting and poping substring\\n        vector<string> temp;\\n        // Call solve fucntion\\n        solve(0,s.length(),s,ans,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2263662,
                "title": "easy-python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res, part = [], []\\n        \\n        def dfs(i):\\n            if i >= len(s):\\n                res.append(part.copy())\\n                return\\n            for j in range(i, len(s)):\\n                if isPali(s, i, j):\\n                    part.append(s[i:j+1])\\n                    dfs(j + 1)\\n                    part.pop()\\n        dfs(0)\\n        return res\\n    \\ndef isPali( s, l, r):\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l, r = l + 1, r - 1\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res, part = [], []\\n        \\n        def dfs(i):\\n            if i >= len(s):\\n                res.append(part.copy())\\n                return\\n            for j in range(i, len(s)):\\n                if isPali(s, i, j):\\n                    part.append(s[i:j+1])\\n                    dfs(j + 1)\\n                    part.pop()\\n        dfs(0)\\n        return res\\n    \\ndef isPali( s, l, r):\\n        while l < r:\\n            if s[l] != s[r]:\\n                return False\\n            l, r = l + 1, r - 1\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187611,
                "title": "c-easy-explanation-to-recursive-palindrome-partitioning",
                "content": "**Approach: -** \\n![image](https://assets.leetcode.com/users/images/878b057e-25b8-4916-9de0-bd600e279093_1655992962.6974993.png)\\n\\n**Notations: -** \\n1. Red line shows the partition of the strings that we will be performing.\\n2. **Note: -** one very important thing to keep in mind is that anything before a red line or a part of a string in between two red lines (highlighted by green underline) should be a palindrome or else the partition cannot take place.\\n3. Orange cross shows that we reached the end of string and palindrome at last portion was not discovered so we kill the branch.\\n\\n**Intuition: -** \\nWe will need two additional functions: - a recursive helper function and a boolean isPalindrome functrion to verify whether our substring in question is a palindrome or not.\\n1. isPalindrome(): - which uses a two pointer approach to check whether a substring is palindrome or not.\\n2. helperFunc(): - \\n\\ta) base case :- if we reach the end of string then we push our ds array into the ans 2-d array.\\n\\tb) recursive function: - in recursive function we call and check whether if a substr is palindrome or not if it is we push it onto the ds and recursive do this until we reach the end of string s.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string sh, int start, int end){\\n        while(start <= end){\\n            if(sh[start++] != sh[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helperFunc(int index, vector<string> &ds, vector<vector<string>> &ans, string s){\\n        if(index == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                ds.push_back(s.substr(index, i-index+1));\\n                helperFunc(i+1, ds, ans, s);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        vector<vector<string>> ans;\\n        helperFunc(0, ds, ans, s);\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote, it helps :}",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string sh, int start, int end){\\n        while(start <= end){\\n            if(sh[start++] != sh[end--]){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    void helperFunc(int index, vector<string> &ds, vector<vector<string>> &ans, string s){\\n        if(index == s.size()){\\n            ans.push_back(ds);\\n            return;\\n        }\\n        for(int i=index; i<s.size(); i++){\\n            if(isPalindrome(s, index, i)){\\n                ds.push_back(s.substr(index, i-index+1));\\n                helperFunc(i+1, ds, ans, s);\\n                ds.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<string> ds;\\n        vector<vector<string>> ans;\\n        helperFunc(0, ds, ans, s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166251,
                "title": "simple-python-solution",
                "content": "I hope it\\'s helpful.\\nif you have some advices please let me know.\\nI have a lot to learn. \\nUpvote if you like solution and feel free to ask If you have any question.\\n```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        def dfs(i,curr) :\\n            if i >= len(s) :\\n                res.append(curr.copy())\\n                return\\n\\n            for j in range(i,len(s)) :\\n                if s[i:j+1] ==  s[i:j+1][::-1]:\\n                    curr.append(s[i:j+1])\\n                    dfs(j+1,curr)\\n                    curr.pop()\\n\\n        dfs(0,[])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        res = []\\n        def dfs(i,curr) :\\n            if i >= len(s) :\\n                res.append(curr.copy())\\n                return\\n\\n            for j in range(i,len(s)) :\\n                if s[i:j+1] ==  s[i:j+1][::-1]:\\n                    curr.append(s[i:j+1])\\n                    dfs(j+1,curr)\\n                    curr.pop()\\n\\n        dfs(0,[])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667875,
                "title": "backtracking-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> ans;\\n    vector<string> curr;\\n    \\n    bool check(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void find(int i,string &s)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        string tmp;\\n        \\n        for(int j=i;j<s.length();j++)\\n        {\\n            tmp+=s[j];\\n            \\n            if(check(tmp))\\n            {\\n                curr.push_back(tmp);\\n                find(j+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) \\n    {\\n        find(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<string>> ans;\\n    vector<string> curr;\\n    \\n    bool check(string &s)\\n    {\\n        int i=0,j=s.length()-1;\\n        \\n        while(i<=j)\\n        {\\n            if(s[i]!=s[j])\\n            {\\n                return false;\\n            }\\n            i++,j--;\\n        }\\n        return true;\\n    }\\n    \\n    void find(int i,string &s)\\n    {\\n        if(i==s.length())\\n        {\\n            ans.push_back(curr);\\n            return;\\n        }\\n        \\n        string tmp;\\n        \\n        for(int j=i;j<s.length();j++)\\n        {\\n            tmp+=s[j];\\n            \\n            if(check(tmp))\\n            {\\n                curr.push_back(tmp);\\n                find(j+1,s);\\n                curr.pop_back();\\n            }\\n        }\\n    }\\n    \\n    vector<vector<string>> partition(string s) \\n    {\\n        find(0,s);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667868,
                "title": "c-easy-to-understand-backtracking-recursion",
                "content": "**Please upvote if you find helpful!**\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str, int start, int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(str[start]!=str[end])\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    void generateall(string s, int curridx, int n, vector<vector<string>>&v, vector<string>&curr)\\n    {\\n        if(curridx>=n)\\n        {\\n            v.push_back(curr);\\n            return;\\n        }\\n        for(int i=curridx; i<n; i++)\\n        {\\n            if(isPalindrome(s, curridx, i)) {\\n                curr.push_back(s.substr(curridx, i-curridx+1));\\n                generateall(s, i+1, n, v, curr);\\n                curr.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>v;\\n        vector<string>curr;\\n        generateall(s, 0, s.length(), v, curr);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string str, int start, int end)\\n    {\\n        while(start<=end)\\n        {\\n            if(str[start]!=str[end])\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n    void generateall(string s, int curridx, int n, vector<vector<string>>&v, vector<string>&curr)\\n    {\\n        if(curridx>=n)\\n        {\\n            v.push_back(curr);\\n            return;\\n        }\\n        for(int i=curridx; i<n; i++)\\n        {\\n            if(isPalindrome(s, curridx, i)) {\\n                curr.push_back(s.substr(curridx, i-curridx+1));\\n                generateall(s, i+1, n, v, curr);\\n                curr.pop_back();\\n            }\\n        }\\n        return;\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>>v;\\n        vector<string>curr;\\n        generateall(s, 0, s.length(), v, curr);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1310312,
                "title": "c-easy-solution-using-backtracking-and-recursion-faster",
                "content": "Hi,\\nAs we need all palindromes so we need to first keep track of indexes that will tell us if substring ```l to r``` is palindrome or not.\\nSo for this we will create matrix say ```dp``` of ``` n*n``` where ``` n = s.size() ```. And in this matrix each entry ```dp[i][j]``` will tell us is ```substring( i to j )``` palindrome or not. \\n\\nNote : Matrix is not necessarily needed its here for easy understanding. You can remove matrix and can put palindrome check function ```ispalin(i,j-i+1)``` in place of ```dp[i][j]``` in solve function.\\n\\nLets see an example \\n- We have ```s = \"aab\"```.\\n- Matrix for this will be (here string is not stored in matrix its illustration to understand)\\n\\t![image](https://assets.leetcode.com/users/images/47bffff1-71b0-4800-9e0e-719316ccda1c_1625195409.9045327.png)\\n\\n- here 1 denotes that ```substr(i,j)``` is palindrome and 0 denotes not a palindrome.\\n- now we need to go from ```i=0``` to ```i=n-1``` and push substrings if corresponding entry is 1 else break.\\n- We will traverse in the following way\\n- 1. i=0 , j=0\\n- 2. at this point we have 3 choices either we can take ```substr(0 to 0) ```or ```substr (0 to 1)``` or ```substr (0 to 2)```\\n\\t-  1.  we can take  ```substr( 0 to 0)``` because ```dp[0][0] =1```. so if we take it then ```i = 1``` and ```j = 1```\\n\\t- 2. now again we have two choices either we take ```substr( 1 to 1)``` or ```substr(1 to 2)```.\\n\\t\\t- 1. Lets take ```substr(1 to 1)```.Since ```dp[1][1] =1``` so we can take it and ```i=2``` and ```j=2```.\\n\\t\\t- 2. Now we have only one choice ```substr(2 to 2)``` and ```dp[2][2]=1``` so we will take it too. Now ```i and j``` reaches to maximum length so our one answer would be ``` [ \"a\", \"a\" , \"b\" ]```.\\n\\t\\t- 1. Now lets choose ```substr(1 to 2)``` after 2nd step instead of ```substr(1 to 1)``` then we can see that ```dp[1][2]=0``` its not 1 that means this is not a palindrome so we cant consider it.\\n\\t- 1. Choose ```substr(0 to 1)``` instead of ```substr(0 to 0)``` in 2nd step. Since ```dp[0][1]=1``` we can take it and ```i=2 and j=2```.\\n\\t\\t- 1. for ```i=2 and j=2``` we have only one choice ```substr(2 to 2)``` and ```dp[2][2]=1``` so we can take it too. Now ```i and j``` reaches to maximum length again so our another answer would be ``` [ \"aa\" , \"b\" ]```.\\n\\t- 1. now we are left with one more choice in step 2 that is ```substr(0 to 2)``` but again ```dp[0][2]=0``` that means its not a palindrome ans we cant consider it.\\n- So we covered all choices and we have answer as ``` [ \"a\", \"a\" , \"b\" ] , [ \"aa\" , \"b\" ]```.\\n### Code with Matrix\\n\\n```\\nclass Solution {\\npublic:\\n// define matrix to check palindrome from i to j\\n    vector<vector<bool>> dp;\\n\\t\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(dp[i][j]){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,vector<bool>(n+1,0));\\n        \\n        // initializing and filling all entries of matrix\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) dp[i][j]=1;\\n                else if(ispalin(s.substr(i,j-i+1))){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n### Code without Matrix\\n```\\nclass Solution {\\npublic:\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(ispalin(i,j-i+1){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Dynamic Programming",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```l to r```\n```dp```\n``` n*n```\n``` n = s.size() ```\n```dp[i][j]```\n```substring( i to j )```\n```ispalin(i,j-i+1)```\n```dp[i][j]```\n```s = \"aab\"```\n```substr(i,j)```\n```i=0```\n```i=n-1```\n```substr(0 to 0) ```\n```substr (0 to 1)```\n```substr (0 to 2)```\n```substr( 0 to 0)```\n```dp[0][0] =1```\n```i = 1```\n```j = 1```\n```substr( 1 to 1)```\n```substr(1 to 2)```\n```substr(1 to 1)```\n```dp[1][1] =1```\n```i=2```\n```j=2```\n```substr(2 to 2)```\n```dp[2][2]=1```\n```i and j```\n``` [ \"a\", \"a\" , \"b\" ]```\n```substr(1 to 2)```\n```substr(1 to 1)```\n```dp[1][2]=0```\n```substr(0 to 1)```\n```substr(0 to 0)```\n```dp[0][1]=1```\n```i=2 and j=2```\n```i=2 and j=2```\n```substr(2 to 2)```\n```dp[2][2]=1```\n```i and j```\n``` [ \"aa\" , \"b\" ]```\n```substr(0 to 2)```\n```dp[0][2]=0```\n``` [ \"a\", \"a\" , \"b\" ] , [ \"aa\" , \"b\" ]```\n```\\nclass Solution {\\npublic:\\n// define matrix to check palindrome from i to j\\n    vector<vector<bool>> dp;\\n\\t\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(dp[i][j]){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        dp.resize(n+1,vector<bool>(n+1,0));\\n        \\n        // initializing and filling all entries of matrix\\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                if(i==j) dp[i][j]=1;\\n                else if(ispalin(s.substr(i,j-i+1))){\\n                    dp[i][j]=1;\\n                }\\n            }\\n        }\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\t// answer vector\\n    vector<vector<string>> ans;\\n\\t\\n\\t//palindrome function return true if s is palindrome else returns false\\n    bool ispalin(string s){\\n        int n=s.size();\\n        for(int i=0;i<=n/2;i++){\\n            if(s[i]!=s[n-1-i]) return false;\\n        }\\n        return true;\\n    }\\n    \\n\\t// temporary answer for each choice\\n    vector<string> v;\\n\\t\\n\\t//recursive function to implement backtracking\\n    void solve(string s,int i,int j,int n){\\n\\t\\n\\t// if i reaches to maximum length that is n then push temporary answer to final answer\\n        if(i==n){\\n            ans.push_back(v);\\n            return;\\n        }\\n        for(;j<n;j++){\\n            if(ispalin(i,j-i+1){\\n                v.push_back(s.substr(i,j-i+1));\\n                solve(s,j+1,j+1,n);\\n                v.pop_back();\\n            }\\n        }\\n\\n        return;\\n        \\n    }\\n    \\n    vector<vector<string>> partition(string s) {\\n        int n=s.size();\\n        solve(s,0,0,n);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223318,
                "title": "lessons-learned",
                "content": "* **Pattern**: Loop + Recursion (backtrack to be precise) combo\\nThis is a **classic problem from Elements of Programming** under Recursion chapter. The problems under this pattern are solved in **O(2^n) time** without DP (where the paths are required). In some problems where DP could be applied (where paths are not required, like just check if an answer/path is possible), can be solved in O(n^2) (or O(n^3), depends on funtions like .substring() etc)\\n\\t\\n* **Time complexity analysis** of this pattern problems - O(2^n): https://leetcode.com/problems/word-break/discuss/889885/Lessons-learned\\n\\n* **DP or not**:\\nThough this can be solved by DP (the real DP), you could first confirm with interviewer about poterntial effect in time complexity.\\n\\t* LC DP: The **DP approach mentioned in LC is actually not DP** (my opinion). What it does is it **chaches the palindromic computation** of subproblems (which is good from interview perspective, and I would prefer implementing this as an optimization after implementing the recursive approach) and reuses it. But the original problem\\'s result (here path) is not obtained from its subproblems. instead is **re-computed** (same as the simple bactrack one). \\n\\t* Why the **real DP approach of O(n^2)** is **not beneficial** here is because here its actually not O(n^2), instead is **O(n^2 + 2^n)**. \\n**Reason**: \\nThere are **O(n(n+1)/2) prefixSubstrings** for a string s, which equates to the time complezity of total recursions. \\nEach prefixSubstring has to add itself with the partitioning combinations (the cache items) of its suffixSubstring. And there are **O(2^n) partitioning combinations for all the suffixStrings in total** in worst case (eg: suffixSubstring = \"aaaa..\") (Refer image at bottom)\\n**Links**: https://leetcode.com/problems/palindrome-partitioning/discuss/42095/Time-complexity:-why-O(n2) and https://leetcode.com/problems/palindrome-partitioning/discuss/42095/Time-complexity:-why-O(n2)/945251\\n\\n* **Variations** of problem in this pattern: \\n\\t* is a path possible: dfs + dp OR bfs (word break, concatenated words, partition 2 equal sum subsets, partition k equal sum subsets). Bfs for Partition 2 equal is not yet discovered. Also, right now Partition k equal is oy solvable via backtracking.\\n\\t* shortest path length: dfs + dp OR bfs (palindrome partion 2)\\n\\t* return valid paths: backtrack (ie dfs) (palindrome partition, word break 2). Applying dp is not beneficial in time and space.\\n\\n**Code**:\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<>();\\n        recurse(0, s, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void recurse(int start, String s, List<List<String>> ans, List<String> list) {\\n        if (start >= s.length()) {\\n            ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int end = start; end < s.length(); ++end) {\\n            if (isPalindrome(s, start, end)) {\\n                list.add(s.substring(start, end + 1));\\n                recurse(end + 1, s, ans, list);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```\\n\\nThe string input \\'abcde\\' in image can be considered as \\'aaaaa\\'.\\n![image](https://assets.leetcode.com/users/images/021cf80f-cfab-4484-b4e2-4c2597705251_1621706267.8458343.jpeg)\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> ans = new ArrayList<>();\\n        recurse(0, s, ans, new ArrayList<>());\\n        return ans;\\n    }\\n    \\n    private void recurse(int start, String s, List<List<String>> ans, List<String> list) {\\n        if (start >= s.length()) {\\n            ans.add(new ArrayList<>(list));\\n            return;\\n        }\\n        \\n        for (int end = start; end < s.length(); ++end) {\\n            if (isPalindrome(s, start, end)) {\\n                list.add(s.substring(start, end + 1));\\n                recurse(end + 1, s, ans, list);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int left, int right) {\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1201634,
                "title": "backtracking-in-a-nutshell-relating-all-the-famous-backtracking-problems",
                "content": "Tried to refine @issac3\\'s article and used CPP here\\n\\n\\n 78. Subsets\\n\\nGiven an integer array nums of unique elements, return all possible subsets (the power set).\\n\\nThe solution set must not contain duplicate subsets. Return the solution in any order.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [1,2,3]\\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\nExample 2:\\n\\nInput: nums = [0]\\nOutput: [[],[0]]\\nConstraints:\\n\\n1 <= nums.length <= 10\\n-10 <= nums[i] <= 10\\nAll the numbers of nums are unique\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            temp.push_back(in[i]);\\n            helper(out,temp,in,i+1);//for exploring all possible ways set i+1 here and if you want to traverse array just once then use index+1 here, in most cases we use i\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) \\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\\n90. Subsets II (when given array may contain duplicates)\\n\\nGiven an integer array nums that may contain duplicates, return all possible subsets (the power set).\\n\\nThe solution set must not contain duplicate subsets. Return the solution in any order.\\n\\n \\n\\nExample 1:\\n\\nInput: nums = [1,2,2]\\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\\nExample 2:\\n\\nInput: nums = [0]\\nOutput: [[],[0]]\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 10\\n-10 <= nums[i] <= 10\\n```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            if(i>index)//try to visualize a tree and notice in which branches can duplicates occur, break that branch\\n            {\\n            if(in[i]==in[i-1])continue;\\n            }\\n            temp.push_back(in[i]);\\n        helper(out,temp,in,i+1);//important its not index +1 its i+1 \\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums)\\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());//very important here to remove dupicates\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\\n46. Permutations\\nMedium\\n\\nGiven an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\\n\\nExample 1:\\n\\nInput: nums = [1,2,3]\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\nExample 2:\\n\\nInput: nums = [0,1]\\nOutput: [[0,1],[1,0]]\\nExample 3:\\n\\nInput: nums = [1]\\nOutput: [[1]]\\n \\n\\nConstraints:\\n\\n1 <= nums.length <= 6\\n-10 <= nums[i] <= 10\\nAll the integers of nums are unique.\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > permute(vector<int> &num) {\\n\\t    vector<vector<int> > result;\\n\\t    \\n\\t    permuteRecursive(num, 0, result);\\n\\t    return result;\\n    }\\n    \\n\\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n\\t\\tif (begin == num.size()) {\\n\\t\\t    // one permutation instance\\n\\t\\t    result.push_back(num);\\n\\t\\t    return;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = begin; i < num.size(); i++) {\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t    permuteRecursive(num, begin + 1, result);\\n\\t\\t    // reset\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t}\\n    }\\n};\\n```\\n47. Permutations II\\n\\nGiven a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\\n\\nExample 1:\\n\\nInput: nums = [1,1,2]\\nOutput:\\n[[1,1,2],\\n [1,2,1],\\n [2,1,1]]\\nExample 2:\\n\\nInput: nums = [1,2,3]\\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\\n ```\\n class Solution {\\n\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};      \\n```\\n39. Combination Sum\\n\\nGiven an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\\n\\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\\n\\nIt is guaranteed that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\\n\\n\\nExample 1:\\n\\nInput: candidates = [2,3,6,7], target = 7\\nOutput: [[2,2,3],[7]]\\nExplanation:\\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\\n7 is a candidate, and 7 = 7.\\nThese are the only two combinations.\\nExample 2:\\n\\nInput: candidates = [2,3,5], target = 8\\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\\nExample 3:\\n\\nInput: candidates = [2], target = 1\\nOutput: []\\nExample 4:\\n\\nInput: candidates = [1], target = 1\\nOutput: [[1]]\\nExample 5:\\n\\nInput: candidates = [1], target = 2\\nOutput: [[1,1]]\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i);//we can take same item multiple times so we did\\'nt do i+1\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\\n40. Combination Sum II\\nGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\\n\\nEach number in candidates may only be used once in the combination.\\n\\nNote: The solution set must not contain duplicate combinations.\\n\\n \\n\\nExample 1:\\n\\nInput: candidates = [10,1,2,7,6,1,5], target = 8\\nOutput: \\n[\\n[1,1,6],\\n[1,2,5],\\n[1,7],\\n[2,6]\\n]\\nExample 2:\\n\\nInput: candidates = [2,5,2,1,2], target = 5\\nOutput: \\n[\\n[1,2,2],\\n[5]\\n]\\n \\n\\nConstraints:\\n\\n1 <= candidates.length <= 100\\n1 <= candidates[i] <= 50\\n1 <= target <= 30\\n\\n\\nSolution:\\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                if(i>index&&A[i]==A[i-1])continue;\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\\n131. Palindrome Partitioning\\nGiven a string s, partition s such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of s.\\n\\nA palindrome string is a string that reads the same backward as forward.\\n\\n \\nExample 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\nExample 2:\\n\\nInput: s = \"a\"\\nOutput: [[\"a\"]]\\n \\n\\nConstraints:\\n\\n1 <= s.length <= 16\\ns contains only lowercase English letters.\\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int low, int high)\\n    {\\n     while(low <high)\\n        if(s[low++]!=s[high--]) return false;\\n    return true;\\n    } \\n    void helper(vector<vector<string>> &out, string A, vector<string> temp, int index)\\n    {\\n        if(index==A.size())\\n            out.push_back(temp);\\n        for(int i=index;i<A.size();i++)\\n        {            \\n            if(isPalindrome(A,index,i))\\n            {\\n                temp.push_back(A.substr(index,i-index+1));\\n                helper(out,A,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<vector<string>> out;\\n        helper(out,s,{},0);\\n        return out;\\n    }\\n};                                              \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            temp.push_back(in[i]);\\n            helper(out,temp,in,i+1);//for exploring all possible ways set i+1 here and if you want to traverse array just once then use index+1 here, in most cases we use i\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) \\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp, vector<int> in,int index)\\n    {\\n        out.push_back(temp);\\n        for(int i=index;i<in.size();i++)\\n        {\\n            if(i>index)//try to visualize a tree and notice in which branches can duplicates occur, break that branch\\n            {\\n            if(in[i]==in[i-1])continue;\\n            }\\n            temp.push_back(in[i]);\\n        helper(out,temp,in,i+1);//important its not index +1 its i+1 \\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsetsWithDup(vector<int>& nums)\\n    {\\n        vector<vector<int>> out;\\n        sort(nums.begin(),nums.end());//very important here to remove dupicates\\n        helper(out,{},nums,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int> > permute(vector<int> &num) {\\n\\t    vector<vector<int> > result;\\n\\t    \\n\\t    permuteRecursive(num, 0, result);\\n\\t    return result;\\n    }\\n    \\n\\tvoid permuteRecursive(vector<int> &num, int begin, vector<vector<int> > &result)\\t{\\n\\t\\tif (begin == num.size()) {\\n\\t\\t    // one permutation instance\\n\\t\\t    result.push_back(num);\\n\\t\\t    return;\\n\\t\\t}\\n\\t\\t\\n\\t\\tfor (int i = begin; i < num.size(); i++) {\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t    permuteRecursive(num, begin + 1, result);\\n\\t\\t    // reset\\n\\t\\t    swap(num[begin], num[i]);\\n\\t\\t}\\n    }\\n};\\n```\n```\\n class Solution {\\n\\nprivate:\\n    vector<vector<int>> permutations;\\n    \\n    void permute(vector<int>& nums, int start)\\n    {\\n        if (start == nums.size() - 1) { permutations.push_back(nums); }\\n            \\n        unordered_set<int> seen;  \\n        for (int i = start; i < nums.size(); ++i)\\n        {\\n            if (seen.find(nums[i]) == seen.end())\\n            {\\n                swap(nums[start], nums[i]);\\n                permute(nums, start+1);\\n                swap(nums[start], nums[i]);  // backtrack\\n                seen.insert(nums[i]);\\n            }\\n        }     \\n    }\\n    \\npublic:\\n    vector<vector<int>> permuteUnique(vector<int>& nums)\\n    {\\n        if (nums.size() < 2) { return {nums}; }\\n        permute(nums, 0);\\n        return permutations;\\n    }\\n};      \\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i);//we can take same item multiple times so we did\\'nt do i+1\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void helper(vector<vector<int>> &out,vector<int> temp,vector<int> A,int remain,int index)\\n    {\\n        if(remain<0)return;\\n        else if(remain==0)out.push_back(temp);\\n        else\\n        {\\n            for(int i=index;i<A.size();i++)\\n            {\\n                if(i>index&&A[i]==A[i-1])continue;\\n                temp.push_back(A[i]);\\n                helper(out,temp,A,remain-A[i],i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<int>> combinationSum2(vector<int>& candidates, int target)\\n    {\\n        //target is to be reached\\n        vector<vector<int>> out;\\n        sort(candidates.begin(),candidates.end());\\n        helper(out,{},candidates,target,0);\\n        return out;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPalindrome(string s, int low, int high)\\n    {\\n     while(low <high)\\n        if(s[low++]!=s[high--]) return false;\\n    return true;\\n    } \\n    void helper(vector<vector<string>> &out, string A, vector<string> temp, int index)\\n    {\\n        if(index==A.size())\\n            out.push_back(temp);\\n        for(int i=index;i<A.size();i++)\\n        {            \\n            if(isPalindrome(A,index,i))\\n            {\\n                temp.push_back(A.substr(index,i-index+1));\\n                helper(out,A,temp,i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s)\\n    {\\n        vector<vector<string>> out;\\n        helper(out,s,{},0);\\n        return out;\\n    }\\n};                                              \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089142,
                "title": "python-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"Backtracking.\"\"\"\\n        def depth_first_search(rest: str):\\n            if not rest:\\n                result.append(current[:])\\n            for end in range(1, len(rest) + 1):\\n                # Reverse and equal is palindrome. You can save result for\\n                # each substring in a dp[n][n] to avoid repeating check in the\\n                # future.\\n                if rest[:end] == rest[end-1::-1]:\\n                    current.append(rest[:end])\\n                    depth_first_search(rest[end:])\\n                    current.pop()\\n        result = []\\n        current = []\\n        depth_first_search(s)\\n        return result        \\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        \"\"\"Backtracking.\"\"\"\\n        def depth_first_search(rest: str):\\n            if not rest:\\n                result.append(current[:])\\n            for end in range(1, len(rest) + 1):\\n                # Reverse and equal is palindrome. You can save result for\\n                # each substring in a dp[n][n] to avoid repeating check in the\\n                # future.\\n                if rest[:end] == rest[end-1::-1]:\\n                    current.append(rest[:end])\\n                    depth_first_search(rest[end:])\\n                    current.pop()\\n        result = []\\n        current = []\\n        depth_first_search(s)\\n        return result        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 971924,
                "title": "python-simple-recursive-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def recur(s,part,res):\\n            if not s:\\n                res.append(part)\\n            n=len(s)\\n            for i in range(1,n+1):\\n                if s[:i]==s[:i][::-1]:\\n                    recur(s[i:],part+[s[:i]],res)\\n        res=[]\\n        recur(s,[],res)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def recur(s,part,res):\\n            if not s:\\n                res.append(part)\\n            n=len(s)\\n            for i in range(1,n+1):\\n                if s[:i]==s[:i][::-1]:\\n                    recur(s[i:],part+[s[:i]],res)\\n        res=[]\\n        recur(s,[],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 870547,
                "title": "python-easy-to-understand-solution-using-backtracking",
                "content": "````\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(s):\\n            left = 0\\n            right = len(s) - 1\\n            while(left<=right):\\n                if s[left] != s[right]:\\n                    return False\\n                left += 1\\n                right -= 1\\n            return True\\n        \\n        def helper(palindromes, start, end):\\n            nonlocal result\\n\\t\\t\\t# will only happen when the string is divided correctly into palindromes\\n            if start >= len(s): \\n                result.append(palindromes)\\n                return\\n\\t\\t\\t# end overflow, so return\\n            if end >=len(s):\\n                return\\n\\t\\t\\t# check if the values of start and end make a palindrome\\n            if isPalindrome(s[start:end+1]):\\n                helper(palindromes+[s[start:end+1]], end+1, end+1)\\n            # keep going with the same value of start and increment end by 1\\n            helper(palindromes, start, end+1)\\n        \\n        result = []\\n        helper([], 0, 0)\\n        return result\\n            \\n````\\nIf N is length of s:\\n- Space complexity: O(N)  (i.e. recursion stack max length)\\n- Time Complexity: O(N*2^N) \\n\\t-  How? form a recursion tree, for any index i we will call palindrome at most 2 times",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "````\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        def isPalindrome(s):\\n            left = 0\\n            right = len(s) - 1\\n            while(left<=right):\\n                if s[left] != s[right]:\\n                    return False\\n                left += 1\\n                right -= 1\\n            return True\\n        \\n        def helper(palindromes, start, end):\\n            nonlocal result\\n\\t\\t\\t# will only happen when the string is divided correctly into palindromes\\n            if start >= len(s): \\n                result.append(palindromes)\\n                return\\n\\t\\t\\t# end overflow, so return\\n            if end >=len(s):\\n                return\\n\\t\\t\\t# check if the values of start and end make a palindrome\\n            if isPalindrome(s[start:end+1]):\\n                helper(palindromes+[s[start:end+1]], end+1, end+1)\\n            # keep going with the same value of start and increment end by 1\\n            helper(palindromes, start, end+1)\\n        \\n        result = []\\n        helper([], 0, 0)\\n        return result\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 852283,
                "title": "c-with-recursion-backtracking",
                "content": "With the use of backtracking use can get the solution easily. Just check the left subpart and then if it is palindrome, check whether it\\'s right subpart is palindrome or not and if yes then it\\'s left and so on....\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        findAll(s,result,temp);\\n        \\n        return result;\\n    }\\n    \\n    void findAll(string s,vector<vector<string>> &result, vector<string> temp){\\n            if(s.length()==0)\\n                result.push_back(temp);\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            string leftpar = s.substr(0,i+1);\\n            if(isPalindrome(leftpar)){\\n                temp.push_back(leftpar);\\n                findAll(s.substr(i+1),result,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string st){\\n        int left=0;\\n        int right = st.size()-1;\\n        if(left==right) return true;\\n        \\n        while(left < right){\\n            if(st[left]!=st[right]) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    } ```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> temp;\\n        findAll(s,result,temp);\\n        \\n        return result;\\n    }\\n    \\n    void findAll(string s,vector<vector<string>> &result, vector<string> temp){\\n            if(s.length()==0)\\n                result.push_back(temp);\\n        \\n        \\n        for(int i=0;i<s.length();i++){\\n            string leftpar = s.substr(0,i+1);\\n            if(isPalindrome(leftpar)){\\n                temp.push_back(leftpar);\\n                findAll(s.substr(i+1),result,temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string st){\\n        int left=0;\\n        int right = st.size()-1;\\n        if(left==right) return true;\\n        \\n        while(left < right){\\n            if(st[left]!=st[right]) return false;\\n            left++;\\n            right--;\\n        }\\n        return true;\\n    } ```",
                "codeTag": "Java"
            },
            {
                "id": 829241,
                "title": "c-backtracking-alternative-approach-faster-than-100-with-explanation",
                "content": "The approach I took to solve this problem is a little different than what I\\'ve seen in the discussion board (correct me if I\\'m wrong).\\n\\nMost backtracking solutions iterate through every substring, check if it\\'s a palindrome and call a DFS function recursively. What I ended up doing is generating an array of palindrome combinations per index. The inspiration for this solution came from [Palindromic Substrings](https://leetcode.com/problems/palindromic-substrings/). We can iterate through the string and for each *S[i]* use 2 pointers (namely left and right) and keep expanding them for as long as they form a palindrome. The left pointer will eventual point to the beginning index (the palindrome\\'s starting point).\\n\\nFor example, for the string `aab`, the combinations array looks like this:\\n```\\npalindromes[0] => \"a\", \"aa\"\\npalindromes[1] => \"a\"\\npalindromes[2] => \"b\"\\n```\\n\\nOnce the array was generated, I used backtracing by advancing the index based on the size of the current palindrome combination.\\n\\nThis is my last run:\\n\\n**Runtime:** 4 ms, faster than 100.00% of C++ online submissions for Palindrome Partitioning.\\n**Memory Usage:** 9 MB, less than 92.26% of C++ online submissions for Palindrome Partitioning.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string str) {\\n        vector<vector<string>> palindromes(size(str));\\n        for (int i = 0; i < size(str); ++i) {\\n            int left = i, right = i;\\n            \\n            // single char palindrome\\n            palindromes[left].emplace_back(str.substr(i, 1));\\n            \\n            // expand to the right if possible (each expansion is a new palindrome)\\n            while (i < size(str) - 1 && str[right + 1] == str[right]) {\\n                ++right;\\n                palindromes[left].emplace_back(str.substr(i, right - left + 1));\\n            }\\n            \\n            // expand from the center if possible (each expansion is a new palindrome)\\n            while (left > 0 && right < size(str) - 1 && str[left - 1] == str[right + 1]) {\\n                ++right, --left;\\n                palindromes[left].emplace_back(str.substr(left, right - left + 1));\\n            }\\n        }\\n\\n        vector<vector<string>> output;\\n        vector<string> curr;\\n        generatePalindromePermutations(output, palindromes, curr, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePalindromePermutations(vector<vector<string>>& output, const vector<vector<string>>& palindromes, vector<string>& curr, int idx) {\\n        if (idx >= size(palindromes)) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (int i = 0; i < size(palindromes[idx]); ++i) {\\n            curr.emplace_back(palindromes[idx][i]);\\n            generatePalindromePermutations(output, palindromes, curr, idx + size(palindromes[idx][i]));\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npalindromes[0] => \"a\", \"aa\"\\npalindromes[1] => \"a\"\\npalindromes[2] => \"b\"\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string str) {\\n        vector<vector<string>> palindromes(size(str));\\n        for (int i = 0; i < size(str); ++i) {\\n            int left = i, right = i;\\n            \\n            // single char palindrome\\n            palindromes[left].emplace_back(str.substr(i, 1));\\n            \\n            // expand to the right if possible (each expansion is a new palindrome)\\n            while (i < size(str) - 1 && str[right + 1] == str[right]) {\\n                ++right;\\n                palindromes[left].emplace_back(str.substr(i, right - left + 1));\\n            }\\n            \\n            // expand from the center if possible (each expansion is a new palindrome)\\n            while (left > 0 && right < size(str) - 1 && str[left - 1] == str[right + 1]) {\\n                ++right, --left;\\n                palindromes[left].emplace_back(str.substr(left, right - left + 1));\\n            }\\n        }\\n\\n        vector<vector<string>> output;\\n        vector<string> curr;\\n        generatePalindromePermutations(output, palindromes, curr, 0);\\n        return output;\\n    }\\nprivate:\\n    void generatePalindromePermutations(vector<vector<string>>& output, const vector<vector<string>>& palindromes, vector<string>& curr, int idx) {\\n        if (idx >= size(palindromes)) {\\n            output.emplace_back(curr);\\n            return;\\n        }\\n        for (int i = 0; i < size(palindromes[idx]); ++i) {\\n            curr.emplace_back(palindromes[idx][i]);\\n            generatePalindromePermutations(output, palindromes, curr, idx + size(palindromes[idx][i]));\\n            curr.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690701,
                "title": "python-very-simple-dfs-backtracking-solution",
                "content": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(2 ^ N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2 ^ N) ##\\n\\n        def isPalindrome(string):\\n            start = 0;\\n            end = len(string)-1\\n            while(start < end):\\n                if(string[start] != string[end]):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n        \\n        def makePartitions(curr, s):\\n            \\n            if(len(s) == 0): \\n                result.append(curr[:])\\n                return\\n            \\n            for i in range(1,len(s)+1):\\n                if(isPalindrome(s[:i])):\\n                    makePartitions(curr + [s[:i]], s[i:])\\n              \\n        result = []\\n        makePartitions([], s)\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partition(self, s: str) -> List[List[str]]:\\n        ## RC ##\\n        ## APPROACH : BACKTRACKING ##\\n        \\n\\t\\t## TIME COMPLEXITY : O(2 ^ N) ##\\n\\t\\t## SPACE COMPLEXITY : O(2 ^ N) ##\\n\\n        def isPalindrome(string):\\n            start = 0;\\n            end = len(string)-1\\n            while(start < end):\\n                if(string[start] != string[end]):\\n                    return False\\n                start += 1\\n                end -= 1\\n            return True\\n        \\n        def makePartitions(curr, s):\\n            \\n            if(len(s) == 0): \\n                result.append(curr[:])\\n                return\\n            \\n            for i in range(1,len(s)+1):\\n                if(isPalindrome(s[:i])):\\n                    makePartitions(curr + [s[:i]], s[i:])\\n              \\n        result = []\\n        makePartitions([], s)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 672300,
                "title": "java-1-ms-faster-than-100-00-backtracking",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        if (s == null || \"\".equals(s)) {\\n            res.add(new ArrayList<>());\\n            return res;\\n        }\\n        \\n        dfs(s, 0, new ArrayList<>(), res);\\n        \\n        return res;\\n    }\\n    \\n    private void dfs(String s, int offSet, List<String> pal, List<List<String>> res) {\\n        if (offSet == s.length()) {\\n            res.add(new ArrayList<>(pal));\\n            return;\\n        }\\n        \\n        int currLength = pal.size();\\n        for (int i = offSet; i < s.length(); i++) {\\n            if (isPalindrome(s, offSet, i)) {\\n                pal.add(s.substring(offSet, i + 1));\\n                dfs(s, i + 1, pal, res);\\n                pal.remove(currLength);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int start, int end) {\\n        while (start < end) {\\n            if (s.charAt(start) != s.charAt(end))\\n                return false;\\n            start++;\\n            end--;\\n        }\\n        \\n        return true;\\n    }\\n}\\n",
                "solutionTags": [
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        if (s == null || \"\".equals(s)) {\\n            res.add(new ArrayList<>());\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 647796,
                "title": "java-1ms-beats-100",
                "content": "Recursive Approach: Create a list of list of integers, and for each index, store the next index, between which(both inclusive) the string will be a pallindrome.\\nNext use recursive approach to find all possible paths to reach the end of the string, while add pallindrominc substrings to a list, and if the end is reached, add that list to the result.\\nFor example: for input \"aabaab\", the list of list of integers having pallindrome substring information would be:\\n[ [0,1,4] , [1,3] , [2,5] , [3,4] , [4] , [5]]\\nFor each index, there is a list of indices.\\nLike, at index 0, the list is [0,1,4], which means that\\n1.the substring between index 0, and the list index 0, i.e., \"a\" is a pallindrome\\n2.1.the substring between index 0, and the list index 1, i.e., \"aa\" is a pallindrome\\n3.1.the substring between index 0, and the list index 4, i.e., \"aabaa\" is a pallindrome\\n\\nAfter we have creeated this list of lists, we will use recursion to find all possible exclusive substrings which constitute to form the whole string, and add it to the result.\\nFor example: index 0 to index 1, then index 2 to index 5\\nor index 0 to index 0, then index 1 to index 3, then index 4 to index 4, then index 5 to index 5\\nand many more.\\n\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        int len = str.length();\\n        List<List<Integer>> entries = new ArrayList<>();\\n        entries.add(new ArrayList<Integer>());\\n        entries.get(0).add(0);\\n        for(int i=1; i<len; i++){  //In this loop we will create the list of list of integers which will keep information about all possible substrings of the string as described above.\\n            entries.add(new ArrayList<Integer>());\\n            int j=0;\\n            while(i-j>=0 && i+j<len){ //for odd length substrings, we expand equally towards left and right\\n                if(str.charAt(i-j)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j).add(i+j);\\n                j++;\\n            }\\n            j=0;\\n            while(i-j-1>=0 && i+j<len){ //for even length substring we expand one extra to the left, than to the right\\n                if(str.charAt(i-j-1)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j-1).add(i+j);\\n                j++;\\n            }\\n        }\\n        addPallindromes(entries, res, new ArrayList<String>(), 0, str);\\n        return res;\\n    }\\n    \\n    public void addPallindromes(List<List<Integer>> entries, List<List<String>> res, List<String> pallindrome, int index, StringBuilder str){\\n        if(index==str.length()){ //If we have reached the end of the string, then all exclusive substrings have constituted to complete the string, hence we can add it to the result\\n            res.add(pallindrome);\\n            return;\\n        }\\n        int target;\\n        for(int i=0; i<entries.get(index).size(); i++){  //for each index, we would travers the list of indices, pairing which, the substring would be pallindromic.\\n            target = entries.get(index).get(i);\\n            List<String> pal = new ArrayList<>(pallindrome);\\n            pal.add(str.substring(index, target+1)); //then we will do the same for the index, ahead of the current pallindromic substring.\\n            addPallindromes(entries, res, pal, target+1, str);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        StringBuilder str = new StringBuilder();\\n        str.append(s);\\n        int len = str.length();\\n        List<List<Integer>> entries = new ArrayList<>();\\n        entries.add(new ArrayList<Integer>());\\n        entries.get(0).add(0);\\n        for(int i=1; i<len; i++){  //In this loop we will create the list of list of integers which will keep information about all possible substrings of the string as described above.\\n            entries.add(new ArrayList<Integer>());\\n            int j=0;\\n            while(i-j>=0 && i+j<len){ //for odd length substrings, we expand equally towards left and right\\n                if(str.charAt(i-j)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j).add(i+j);\\n                j++;\\n            }\\n            j=0;\\n            while(i-j-1>=0 && i+j<len){ //for even length substring we expand one extra to the left, than to the right\\n                if(str.charAt(i-j-1)!=str.charAt(i+j))\\n                    break;\\n                entries.get(i-j-1).add(i+j);\\n                j++;\\n            }\\n        }\\n        addPallindromes(entries, res, new ArrayList<String>(), 0, str);\\n        return res;\\n    }\\n    \\n    public void addPallindromes(List<List<Integer>> entries, List<List<String>> res, List<String> pallindrome, int index, StringBuilder str){\\n        if(index==str.length()){ //If we have reached the end of the string, then all exclusive substrings have constituted to complete the string, hence we can add it to the result\\n            res.add(pallindrome);\\n            return;\\n        }\\n        int target;\\n        for(int i=0; i<entries.get(index).size(); i++){  //for each index, we would travers the list of indices, pairing which, the substring would be pallindromic.\\n            target = entries.get(index).get(i);\\n            List<String> pal = new ArrayList<>(pallindrome);\\n            pal.add(str.substring(index, target+1)); //then we will do the same for the index, ahead of the current pallindromic substring.\\n            addPallindromes(entries, res, pal, target+1, str);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 483424,
                "title": "go-golang-clean-solution",
                "content": ">Runtime: 16 ms, faster than 100.00% of Go online submissions for Palindrome Partitioning.\\nMemory Usage: 9.2 MB, less than 100.00% of Go online submissions for Palindrome Partitioning.\\n\\n```go\\nfunc partition(s string) [][]string {\\n    res := [][]string{}\\n    helper(s, 0, []string{}, &res)\\n    return res\\n}\\n\\nfunc helper(s string, index int, S []string, res *[][]string) {\\n    if index == len(s) {\\n        *res = append(*res, append([]string{}, S...))\\n        return \\n    }\\n    for i := index + 1; i <= len(s); i++ {\\n        if isPalindrome(s[index:i]) {\\n            S = append(S, s[index:i])\\n            helper(s, i, S, res)\\n            S = S[:len(S)-1]\\n        }\\n    }\\n}\\n\\nfunc isPalindrome(s string) bool {\\n    a := 0\\n    b := len(s) - 1\\n    for a < b {\\n        if s[a] != s[b] { return false }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc partition(s string) [][]string {\\n    res := [][]string{}\\n    helper(s, 0, []string{}, &res)\\n    return res\\n}\\n\\nfunc helper(s string, index int, S []string, res *[][]string) {\\n    if index == len(s) {\\n        *res = append(*res, append([]string{}, S...))\\n        return \\n    }\\n    for i := index + 1; i <= len(s); i++ {\\n        if isPalindrome(s[index:i]) {\\n            S = append(S, s[index:i])\\n            helper(s, i, S, res)\\n            S = S[:len(S)-1]\\n        }\\n    }\\n}\\n\\nfunc isPalindrome(s string) bool {\\n    a := 0\\n    b := len(s) - 1\\n    for a < b {\\n        if s[a] != s[b] { return false }\\n        a++\\n        b--\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 356285,
                "title": "java-concise-backtracking-solution",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new LinkedList<>();\\n        List<String> cur = new LinkedList<>();\\n        dfs(0,s.length()-1,s,cur,res);\\n        return res;\\n        \\n    }\\n    private void dfs(int start, int end, String s, List<String> cur, List<List<String>> res){\\n        if(start > end){ \\n            res.add(new LinkedList<>(cur));\\n            return;\\n        }\\n        for(int i = start; i <= end; i ++){\\n            if(isPalindrome(s, start, i)){\\n                cur.add(s.substring(start,i+1));\\n                dfs(i+1,end,s,cur,res);\\n                cur.remove(cur.size()-1);\\n            }\\n        }\\n    }\\n    private boolean isPalindrome(String s, int start, int end){\\n        while(start < end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new LinkedList<>();\\n        List<String> cur = new LinkedList<>();\\n        dfs(0,s.length()-1,s,cur,res);\\n        return res;\\n        \\n    }\\n    private void dfs(int start, int end, String s, List<String> cur, List<List<String>> res){\\n        if(start > end){ \\n            res.add(new LinkedList<>(cur));\\n            return;\\n        }\\n        for(int i = start; i <= end; i ++){\\n            if(isPalindrome(s, start, i)){\\n                cur.add(s.substring(start,i+1));\\n                dfs(i+1,end,s,cur,res);\\n                cur.remove(cur.size()-1);\\n            }\\n        }\\n    }\\n    private boolean isPalindrome(String s, int start, int end){\\n        while(start < end){\\n            if(s.charAt(start)!=s.charAt(end)){\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 349012,
                "title": "c-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPalin(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i <= j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\n    void generate(vector<vector<string>>&ans, vector<string> temp, string s, int idx) {\\n        if(idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string t;\\n        for(int i = idx; i < s.size(); i++) {\\n            t += s[i];\\n            if(isPalin(t)) {\\n                temp.push_back(t);\\n                generate(ans, temp, s, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector< vector<string >> ans;\\n        generate(ans, {}, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPalin(string s) {\\n        int i = 0, j = s.size() - 1;\\n        while(i <= j) {\\n            if(s[i++] != s[j--]) return false;\\n        }\\n        return true;\\n    }\\n    void generate(vector<vector<string>>&ans, vector<string> temp, string s, int idx) {\\n        if(idx == s.size()) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        string t;\\n        for(int i = idx; i < s.size(); i++) {\\n            t += s[i];\\n            if(isPalin(t)) {\\n                temp.push_back(t);\\n                generate(ans, temp, s, i+1);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector< vector<string >> ans;\\n        generate(ans, {}, s, 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 296690,
                "title": "backtracking-solution-for-slow-learners-like-myself-2ms",
                "content": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> partitions = new ArrayList<>();\\n        if (s == null || s.length() == 0) \\n\\t\\t\\treturn partitions;\\n        addPalindromePartitions(partitions, new ArrayList<>(), s);\\n        return partitions;\\n    }\\n    \\n    private void addPalindromePartitions(List<List<String>> partitions, List<String> partition, String s) {\\n\\t    //base case -- we recurse until the substring given is empty string\\n\\t    //if it means its empty string it implies we cannot backtrack anymore so add the current list to the solution\\n        if (s.length() == 0) {\\n            partitions.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n\\t\\t    //check if the current prefix from 0 to i is a palindrome. If it happens to be a palindrome, add the\\n\\t\\t\\t//current prefix to the recursion list, and recurse further with the suffix as a substring\\n\\t\\t\\t//discard the current add once we are done with the current backtrack call\\n            if (isPalindrome(s, i - 1)) {\\n                partition.add(s.substring(0, i));\\n                addPalindromePartitions(partitions, partition, s.substring(i));\\n                partition.remove(partition.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int right) {\\n        int left = 0;\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> partitions = new ArrayList<>();\\n        if (s == null || s.length() == 0) \\n\\t\\t\\treturn partitions;\\n        addPalindromePartitions(partitions, new ArrayList<>(), s);\\n        return partitions;\\n    }\\n    \\n    private void addPalindromePartitions(List<List<String>> partitions, List<String> partition, String s) {\\n\\t    //base case -- we recurse until the substring given is empty string\\n\\t    //if it means its empty string it implies we cannot backtrack anymore so add the current list to the solution\\n        if (s.length() == 0) {\\n            partitions.add(new ArrayList<>(partition));\\n            return;\\n        }\\n        \\n        for (int i = 1; i <= s.length(); i++) {\\n\\t\\t    //check if the current prefix from 0 to i is a palindrome. If it happens to be a palindrome, add the\\n\\t\\t\\t//current prefix to the recursion list, and recurse further with the suffix as a substring\\n\\t\\t\\t//discard the current add once we are done with the current backtrack call\\n            if (isPalindrome(s, i - 1)) {\\n                partition.add(s.substring(0, i));\\n                addPalindromePartitions(partitions, partition, s.substring(i));\\n                partition.remove(partition.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean isPalindrome(String s, int right) {\\n        int left = 0;\\n        while (left < right) {\\n            if (s.charAt(left++) != s.charAt(right--)) \\n\\t\\t\\t\\treturn false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291914,
                "title": "java-dfs-dp-with-detailed-explanation-easy-to-understand",
                "content": "\\nBy observing, we can use DFS to solve the problem. DFS is extremely useful on problems like permutation combination etc..\\n\\nWhen we trying to solve a problem with Depth First Search (backtracking), it is useful for us to generate a recursion tree and speaks out the meaning of each level and each branches.\\n\\nIn this particular problem, each level representing a particular subproblems where s[0...level - 1] has already formed valid palindrome partition. The subproblem becomes solving the following s[level...end] subproblems. In the subproblems, we iterate index i from the current level index to the end of the string, if we see s[level...i] is a palindrome, then we can add the current substring s[level...i] to the list and going to the next subproblems s[i+1...end] by recursive call with updated parameter. \\n\\nFollowing the analysis, we can see that there are O(n!) levels of node in the recursive tree, and there are at most n level of recursion on the call stack. \\n\\nThen, the problem becomes how to check a string is palindrome. A Naive but working solution is to iterate the string with two pointers walking in the opposite direction:\\n\\n```\\nboolean isPalindrome(String s, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tif (s.charAt(start++) != s.charAt(end--)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```\\n\\nBy taking this method we need O(n) time to check whether a substring s[i...j] is palindrome by calling isPalindrome(s, i, j).\\nThe total time complexity is O(n!*n).\\nSince there are at most O(n) recursive calls on the call stack and no extra data structure is allocated, space complexity O(n).\\n\\nHowever, I noticed that the palindrome problem can be solved by dynamic programming by the following observation:\\n1. The big problem (string) can be divided into smaller problem (substring or even characters)\\n2. The minimum sized problems (a single character) have identical or similar properties. \\n\\nAbove observation implies that using dynamic programming would be a choice. All we need to do is to figure out the base case and induction rules of the problem.\\n\\nbase case: dp[i][i] -> true (a single character is palindrome)\\ninduction rule: \\n\\t\\tdp[i][j] representing whether s[i...j] is a palindrome\\n\\t\\tdp[i][j] = true if s[i] == s[j] and s[i], s[j] is next to each other (i - j < 2), \\n\\t\\t\\t\\t\\t\\tor s[i] == s[j] and the subproblem s[i+1...j-1] is a valid palindrome (dp[i+1][j-1])\\n\\nwith the following dp relation we can take O(n^2) time and O(n^2) space to build up the memory:\\n\\n```\\nprivate boolean[][] generateMap(String s) {\\n\\tboolean[][] map = new boolean[s.length()][s.length()];\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tmap[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n\\t\\t}\\n\\t}\\n\\treturn map;\\n}\\n\\n```\\n\\nWith the memory we can know isPalindrome(s, i, j) in O(1) time by looking at the memory.\\nTotal time complexity is O(n!). If we count for the substring API of java, it would take O(n) time worse cases. A better approach might be using char[] array as input and use the String(char[] array, int offset, int length) constructor.\\nTotal space complexity is O(n^2)\\n               \\nAttached is the full code.\\n\\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (s == null || s.isEmpty()) {\\n            return result;\\n        }\\n        boolean[][] isPalindrome = generateMap(s);\\n        DFS(0, s, new ArrayList<>(), result, isPalindrome);\\n        return result;\\n    }\\n    \\n    private void DFS(int index, String input, List<String> curr, List<List<String>> result, boolean[][] isPalindrome) {\\n        if (index == input.length()) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for (int i = index; i < input.length(); i++) {\\n            if (isPalindrome[index][i]) {\\n                curr.add(input.substring(index, i + 1));\\n                DFS(i + 1, input, curr, result, isPalindrome);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean[][] generateMap(String s) {\\n        boolean[][] map = new boolean[s.length()][s.length()];\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            for (int j = i; j < s.length(); j++) {\\n                map[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```\\n\\nI wrote down these words to help myself better understand the problem, and hopefully it would helps other.\\nAnd please tell me if any mistake is made! Thanks a lot.",
                "solutionTags": [],
                "code": "```\\nboolean isPalindrome(String s, int start, int end) {\\n\\twhile (start < end) {\\n\\t\\tif (s.charAt(start++) != s.charAt(end--)) {\\n\\t\\t\\treturn false;\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nprivate boolean[][] generateMap(String s) {\\n\\tboolean[][] map = new boolean[s.length()][s.length()];\\n\\tfor (int i = s.length() - 1; i >= 0; i--) {\\n\\t\\tfor (int j = i; j < s.length(); j++) {\\n\\t\\t\\tmap[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n\\t\\t}\\n\\t}\\n\\treturn map;\\n}\\n\\n```\n```\\nclass Solution {\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> result = new ArrayList<>();\\n        if (s == null || s.isEmpty()) {\\n            return result;\\n        }\\n        boolean[][] isPalindrome = generateMap(s);\\n        DFS(0, s, new ArrayList<>(), result, isPalindrome);\\n        return result;\\n    }\\n    \\n    private void DFS(int index, String input, List<String> curr, List<List<String>> result, boolean[][] isPalindrome) {\\n        if (index == input.length()) {\\n            result.add(new ArrayList<>(curr));\\n            return;\\n        }\\n        for (int i = index; i < input.length(); i++) {\\n            if (isPalindrome[index][i]) {\\n                curr.add(input.substring(index, i + 1));\\n                DFS(i + 1, input, curr, result, isPalindrome);\\n                curr.remove(curr.size() - 1);\\n            }\\n        }\\n    }\\n    \\n    private boolean[][] generateMap(String s) {\\n        boolean[][] map = new boolean[s.length()][s.length()];\\n        for (int i = s.length() - 1; i >= 0; i--) {\\n            for (int j = i; j < s.length(); j++) {\\n                map[i][j] = (s.charAt(i) == s.charAt(j) && (j - i <= 2 || map[i + 1][j - 1]));\\n            }\\n        }\\n        return map;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42008,
                "title": "clean-6ms-c-solution-using-dp-backtracking",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        std::vector<std::vector<std::string>> ans;\\n        int length = s.length();\\n        if (length == 0) {\\n            return ans;\\n        }\\n\\n        // Construct the palindrome lookup table.\\n        std::vector<std::vector<bool>> isPalin(length, std::vector<bool>(length));\\n\\n        for (int i = 0 ; i < length ; ++i) {\\n            isPalin[i][i] = true;\\n        }\\n        for (int i = 0, j = 1 ; i < length - 1 ; ++i, ++j) {\\n            isPalin[i][j] = s[i] == s[j];\\n        }\\n        for (int l = 2 ; l < length ; ++l) {\\n            for (int i = 0 ; i < length - l ; ++i) {\\n                int j = i + l;\\n                isPalin[i][j] = (s[i] == s[j]) && isPalin[i + 1][j - 1];\\n            }\\n        }\\n\\n        // Apply backtracking to discover all the palindrome partitions.\\n        std::vector<std::vector<std::pair<int, int>>> records;\\n        std::vector<std::pair<int, int>> partition;\\n        backtrack(0, length, isPalin, partition, records);\\n\\n        for (const auto& partition : records) {\\n            std::vector<std::string> palin;\\n            for (const auto& pair : partition) {\\n                int bgn = pair.first;\\n                int length = pair.second - bgn + 1;\\n                palin.push_back(s.substr(bgn, length));\\n            }\\n            ans.push_back(std::move(palin));\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void backtrack(int bgn, int bound, const std::vector<std::vector<bool>>& isPalin, \\n            std::vector<std::pair<int, int>>& partition, \\n            std::vector<std::vector<std::pair<int, int>>>& records) {\\n\\n        if (bgn == bound) {\\n            records.push_back(partition);\\n            return;\\n        }\\n\\n        for (int end = bgn ; end < bound ; ++end) {\\n            if (!isPalin[bgn][end]) {\\n                continue;\\n            }\\n\\n            partition.push_back(std::make_pair(bgn, end));\\n            backtrack(end + 1, bound, isPalin, partition, records);\\n            partition.pop_back();\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        std::vector<std::vector<std::string>> ans;\\n        int length = s.length();\\n        if (length == 0) {\\n            return ans;\\n        }\\n\\n        // Construct the palindrome lookup table.\\n        std::vector<std::vector<bool>> isPalin(length, std::vector<bool>(length));\\n\\n        for (int i = 0 ; i < length ; ++i) {\\n            isPalin[i][i] = true;\\n        }\\n        for (int i = 0, j = 1 ; i < length - 1 ; ++i, ++j) {\\n            isPalin[i][j] = s[i] == s[j];\\n        }\\n        for (int l = 2 ; l < length ; ++l) {\\n            for (int i = 0 ; i < length - l ; ++i) {\\n                int j = i + l;\\n                isPalin[i][j] = (s[i] == s[j]) && isPalin[i + 1][j - 1];\\n            }\\n        }\\n\\n        // Apply backtracking to discover all the palindrome partitions.\\n        std::vector<std::vector<std::pair<int, int>>> records;\\n        std::vector<std::pair<int, int>> partition;\\n        backtrack(0, length, isPalin, partition, records);\\n\\n        for (const auto& partition : records) {\\n            std::vector<std::string> palin;\\n            for (const auto& pair : partition) {\\n                int bgn = pair.first;\\n                int length = pair.second - bgn + 1;\\n                palin.push_back(s.substr(bgn, length));\\n            }\\n            ans.push_back(std::move(palin));\\n        }\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    void backtrack(int bgn, int bound, const std::vector<std::vector<bool>>& isPalin, \\n            std::vector<std::pair<int, int>>& partition, \\n            std::vector<std::vector<std::pair<int, int>>>& records) {\\n\\n        if (bgn == bound) {\\n            records.push_back(partition);\\n            return;\\n        }\\n\\n        for (int end = bgn ; end < bound ; ++end) {\\n            if (!isPalin[bgn][end]) {\\n                continue;\\n            }\\n\\n            partition.push_back(std::make_pair(bgn, end));\\n            backtrack(end + 1, bound, isPalin, partition, records);\\n            partition.pop_back();\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 42051,
                "title": "recursion-with-memorization-java-solution-easy-to-understand",
                "content": "This problem is very similar to **Word Break 2**.\\nFor example, a string of length **n** can be partitioned into **n** pairs:\\n\\n* \"\" + s1s2...sn\\n* s1 + s2...sn\\n* s1s2 + s3...sn\\n* s1s2...s(n-1) + sn\\n\\nThe first part we call it a **word**, the second part we call it a **sentence**. Firtly, we check if the **word** is  a palindrome, if true, we do recursion on the **sentence**. To reduce redundant computation, we use a HashMap to store intermediate results, and here is the AC java code:\\n```\\nprivate Map<String, List<List<String>>> map = new HashMap<>();\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<List<String>> lists = new ArrayList<>();\\n        if (isPalindrome(s)) {\\n            lists.add(new ArrayList<>(Arrays.asList(s)));\\n        }\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            String word = s.substring(0, i);\\n            if (isPalindrome(word)) {\\n                List<List<String>> right = partition(s.substring(i));\\n                for (List<String> list : right) {\\n                    List<String> list1 = new ArrayList<>();\\n                    list1.add(word);\\n                    list1.addAll(list);\\n                    lists.add(list1);\\n                }\\n            }\\n        }\\n        map.put(s, lists);\\n        return lists;\\n    }\\n````",
                "solutionTags": [],
                "code": "```\\nprivate Map<String, List<List<String>>> map = new HashMap<>();\\n\\n    public boolean isPalindrome(String s) {\\n        int i = 0, j = s.length() - 1;\\n        while (i < j) {\\n            if (s.charAt(i++) != s.charAt(j--)) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<List<String>> partition(String s) {\\n        if (map.containsKey(s)) {\\n            return map.get(s);\\n        }\\n        List<List<String>> lists = new ArrayList<>();\\n        if (isPalindrome(s)) {\\n            lists.add(new ArrayList<>(Arrays.asList(s)));\\n        }\\n        int n = s.length();\\n        for (int i = 1; i < n; i++) {\\n            String word = s.substring(0, i);\\n            if (isPalindrome(word)) {\\n                List<List<String>> right = partition(s.substring(i));\\n                for (List<String> list : right) {\\n                    List<String> list1 = new ArrayList<>();\\n                    list1.add(word);\\n                    list1.addAll(list);\\n                    lists.add(list1);\\n                }\\n            }\\n        }\\n        map.put(s, lists);\\n        return lists;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 42055,
                "title": "java-easy-follow-recursive-solution-can-convert-to-dp-easily-what-is-complexity-o-n-2",
                "content": "    public class Solution {\\n        \\n        public boolean isPalindrom(String s) {\\n            int start = 0;\\n            int end = s.length()-1;\\n            while(start<end) {\\n                if(s.charAt(start)!=s.charAt(end))\\n                    return false;\\n                start++;\\n                end--;\\n            }\\n            return true;\\n        }\\n        \\n        public List<List<String>> partition(String s) {\\n            List<List<String>> res = new ArrayList<List<String>>();\\n            if(s.length()==0) {\\n                res.add(new ArrayList<String>());\\n                return res;\\n            }\\n            if(s.length()==1) {\\n                List<String> subLs = new ArrayList<String>();\\n                subLs.add(s);\\n                res.add(subLs);\\n                return res;\\n            }\\n            for(int i=0; i<s.length(); i++) {\\n                String subS = s.substring(0,i+1);\\n                if(isPalindrom(subS)) {\\n                    List<List<String>> subRes = partition(s.substring(i+1));\\n                    for(List<String> l : subRes) {\\n                        l.add(0,subS);\\n                        res.add(l);\\n                    }\\n                }\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        \\n        public boolean isPalindrom(String s) {\\n            int start = 0;\\n            int end = s.length()-1;\\n            while(start<end) {\\n                if(s.charAt(start)!=s.charAt(end))\\n                    return false;\\n                start++;\\n                end--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 42067,
                "title": "fast-dp-solutions-in-python-with-storing-palindromes-in-memo-beat-99",
                "content": "    class Solution(object):\\n        def partition(self, s, set_pal=set(), memo={}):\\n            if not len(s):\\n                return []\\n            if s in memo:\\n                return memo[s]\\n            ret_list, flag = [], False\\n            for i in range(1, len(s) + 1):\\n                left = s[:i]\\n                if left in set_pal or left == left[::-1]:\\n                    set_pal.add(left)\\n                    list_rec = self.partition(s[i:], set_pal, memo)\\n                    if list_rec is not None:\\n                        flag = True\\n                        for this_list in list_rec:\\n                            ret_list.append([left] + this_list)\\n                        if not list_rec:\\n                            ret_list.append([left])\\n            \\n            memo[s] = ret_list if flag else None\\n            return memo[s]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution(object):\\n        def partition(self, s, set_pal=set(), memo={}",
                "codeTag": "Java"
            },
            {
                "id": 42071,
                "title": "c-dfs-dp-16ms-solution",
                "content": "    class Solution {\\n    public:\\n      \\n      vector<vector<string>> partition(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        //   build dp : if i through j (inclusive) makes a palindrome, dp[i][j] = true;\\n        for(int l = 1; l <=n; l++){\\n          for(int i = 0; i < n; i++){\\n            int j = i + l - 1;\\n            if(j >= n) break;\\n            dp[i][j] = (i + 1 > j - 1 || dp[i + 1][j - 1]) && s[i] == s[j];\\n          }\\n        }\\n        \\n        //  dfs\\n        vector<string> path;\\n        vector<vector<string>> result;\\n        dfs(s, 0, path, result, dp);\\n    \\n        return result;\\n      }\\n      \\n      void dfs(string& s, int start, vector<string>& path, vector<vector<string>>& result, vector<vector<bool>>& dp){\\n        int n = s.size();\\n        if(start == n){\\n          result.push_back(path);\\n          return;\\n        } \\n        \\n        for(int i = start; i < n; i++){\\n          if(!dp[start][i]) continue;\\n          \\n          path.push_back(s.substr(start, i - start + 1));\\n          dfs(s, i + 1, path, result, dp);\\n          path.pop_back();\\n        } \\n      }\\n    };",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n      \\n      vector<vector<string>> partition(string s) {\\n        int n = s.size();\\n        vector<vector<bool>> dp(n, vector<bool>(n, false));\\n        //   build dp : if i through j (inclusive) makes a palindrome, dp[i][j] = true;\\n        for(int l = 1; l <=n; l++){\\n          for(int i = 0; i < n; i++){\\n            int j = i + l - 1;\\n            if(j >= n) break;\\n            dp[i][j] = (i + 1 > j - 1 || dp[i + 1][j - 1]) && s[i] == s[j];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 42070,
                "title": "easiest-4ms-java-solution-95-99",
                "content": "This is a standard backtracking problem. At first I used dp, surprisingly the followings are nearly `2X` faster than dp. The key to performance is to use  `toCharArray` instead of `substring`:\\n\\n    String s = new String(c, pos, i - pos + 1);\\n\\nHope it helps!\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(res, new ArrayList<String>(), s.toCharArray(), 0);\\n        return res;\\n    }\\n\\n    void dfs(List<List<String>> res, ArrayList<String> list, char[] c, int pos) {\\n        if (pos == c.length) res.add(new ArrayList<>(list));\\n        for (int i = pos; i < c.length; i++) {\\n            if (isPal(c, pos, i)){\\n                list.add(new String(c, pos, i - pos + 1)); \\n                dfs(res, list, c, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n\\n    boolean isPal(char[] c, int lo, int hi) {\\n        while (lo < hi) if (c[lo++] != c[hi--]) return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is a standard backtracking problem. At first I used dp, surprisingly the followings are nearly `2X` faster than dp. The key to performance is to use  `toCharArray` instead of `substring`:\\n\\n    String s = new String(c, pos, i - pos + 1);\\n\\nHope it helps!\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> res = new ArrayList<>();\\n        dfs(res, new ArrayList<String>(), s.toCharArray(), 0);\\n        return res;\\n    }\\n\\n    void dfs(List<List<String>> res, ArrayList<String> list, char[] c, int pos) {\\n        if (pos == c.length) res.add(new ArrayList<>(list));\\n        for (int i = pos; i < c.length; i++) {\\n            if (isPal(c, pos, i)){\\n                list.add(new String(c, pos, i - pos + 1)); \\n                dfs(res, list, c, i + 1);\\n                list.remove(list.size() - 1);\\n            }\\n        }\\n    }\\n\\n    boolean isPal(char[] c, int lo, int hi) {\\n        while (lo < hi) if (c[lo++] != c[hi--]) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1724406,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724409,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1707027,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1565576,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1567207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1574685,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1767651,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768675,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1769287,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724406,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1724409,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768589,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1707027,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1565576,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1567207,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1574685,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1767651,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1768675,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1769287,
                "content": [
                    {
                        "username": "mohamed_waseela",
                        "content": "If you still dont understand the problem check these examples:\\n\\ns = \"aaab\"\\noutput = [[\"a\",\"a\",\"a\",\"b\"],[\"a\",\"aa\",\"b\"],[\"aa\",\"a\",\"b\"],[\"aaa\",\"b\"]]\\n\\ns = \"abcaa\"\\noutput = [[\"a\",\"b\",\"c\",\"a\",\"a\"],[\"a\",\"b\",\"c\",\"aa\"]]\\n\\ns = \"abbab\"\\noutput = [[\"a\",\"b\",\"b\",\"a\",\"b\"],[\"a\",\"b\",\"bab\"],[\"a\",\"bb\",\"a\",\"b\"],[\"abba\",\"b\"]]\\n\\ns = \"abaca\"\\noutput = [[\"a\",\"b\",\"a\",\"c\",\"a\"],[\"a\",\"b\",\"aca\"],[\"aba\",\"c\",\"a\"]]\\n\\ns = \"aaa\"\\noutput = [[\"a\",\"a\",\"a\"],[\"a\",\"aa\"],[\"aa\",\"a\"],[\"aaa\"]]\\n\\nPlease Upvote if this was helpful\\n"
                    },
                    {
                        "username": "VladislavBuldakov",
                        "content": "thanks!"
                    },
                    {
                        "username": "Memberberry",
                        "content": "you rule. These examples is so much better than the originally provided loool"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "If you get this question, they dont want to hire you"
                    },
                    {
                        "username": "tifandotme",
                        "content": "Why?"
                    },
                    {
                        "username": "jch2000",
                        "content": "[@nekoaoi](/nekoaoi) backtracking"
                    },
                    {
                        "username": "candypop8724",
                        "content": "its not that bad tbh"
                    },
                    {
                        "username": "nekoaoi",
                        "content": "[@geekyshark](/geekyshark) what is the name of this topic?"
                    },
                    {
                        "username": "geekyshark",
                        "content": "Bruh this topic is way too common"
                    },
                    {
                        "username": "shahpathan",
                        "content": "why do you say that?"
                    },
                    {
                        "username": "loko2434",
                        "content": "Leetcode really wants us to understand backtracking lol\\n\\nNot that I hate it though. In fact I like how Leetcode has been giving out series of daily problems of same topic back-to-back, helps me understand the topic a lot better"
                    },
                    {
                        "username": "ishita_gupta21",
                        "content": "backtracking and recursion really send me to my knees though goddamn\\n"
                    },
                    {
                        "username": "ayoubprog61",
                        "content": "been thinking about the same thing"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "Problem Description and the first example can be explained better."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for January, Day 5.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/palindrome-partitioning/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Backtracking\n\n  \n**Approach 2:** Backtracking with Dynamic Programming\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Leetcpp",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t\"efe\"\\nOutput:\\t[[\"e\",\"f\",\"e\"]]\\nExpected:\\t[[\"e\",\"f\",\"e\"],[\"efe\"]]\\n\\nIt said:\\n\"Given a string s, partition s such that every substring of the partition is a palindrome.\"\\n\\n\\nIs every substring of \"efe\" a palindrome? for example: the \"ef\" ?\\nI'm very confuse about it."
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \n\n>  I have concluded this from the problem statement and sample test cases\n\nThere are only two samples (\"aab, \"a\").  You can not make a conclusion about \"efe\".\nSo you are confusing your assumption with the real information about the problem that you can get from the description.\n\n> In that case why [\"e\",\"fe\"] is be a valid one?\n\n\"fe\" is not valid, because it's not a palindrome."
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "[@DmitryGM](/DmitryGM) In that case why [\"e\",\"fe\"]  is be a valid one?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) I have concluded this from the problem statement and sample test cases"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\n> because according to question, every valid partition must contain all the elements of the original string.\\n\\nWhy? Where did you read it? "
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, we cannot call p0 a partition, p1 a partition, etc because according to question, every valid partition must contain all the elements of  the original string.\n\nA partition of s having substrings p0, p1, p2, p3 is valid only if p0 concat p1 concat p2 concat p3 equals original string and p0, p1, p2, p3 are substrings of original string in order.\n\nHope you understand.\n\nFeel free to comment if you need more clarity.\nPlease upvote if it helps.\n\nThanks:)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \\nThanks for the answer.\\nDo you agree, that if you have p0, p1, p2, p3, then you can call each of them partition too? So p0 is partition, p1 is partition, etc.?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DmitryGM](/DmitryGM) No, The phrase \"every substring of the partition is a palindrome\" means that if I have a partition which contains the substrings p0, p1, p2, p3 of original string then all p0, p1, p2, p3 must be palindrome not every substrings of p0, p1, p2 and p3 must be palindrome.\n\nEvery Substrings of p0, p1, p2, p3 is palindrome or not that we dont have to check.\n\nHope it helps.\n\nThanks :)"
                    },
                    {
                        "username": "DmitryGM",
                        "content": "[@strive_hard](/strive_hard) \nI don't agree. It is an incorrect description.\nThe phrase \"every substring of the partition is a palindrome\" means that if I have a partition (like 'a' or 'aaa'), then any substring of my partition should be a palindrome. Therefore, all letters in any partition should be the same. And yes, the whole partition is a substring too, so it is a palindrome. But not all palindromes are appropriate.\n\nThe word partition might mean one string in the list of parts. Or it might mean the whole list of parts. It's not clear from description."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Leetcpp](/Leetcpp) No, every substring of \"efe\" is not a palindrome. I think you have not understood the question correctly. Question states that find all the partitions of string s such that in every partition all strings are palindrome. Lets understand this statement with the help of input example \"efe\".\\n\\nInput : \"efe\"\\nall possible partitions are: \\n1. [\"e\", \"f\", \"e\"]\\n2. [\"ef\", \"e\"]\\n3. [\"efe\"]\\n\\nIn first and third partitions you can see that all strings are palindrome. So first and third partition will be the expected answer.\\n\\nPlease upvote if you are able to understand now.\\nIf you need more clarifications feel free to comment.\\n\\nThanks :)"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I think LeetCode has a bug in this question for Python3.\\nSolutions which apparently ran in 70ms before, now runs in 600~700ms.\\nThat could happen if they increased the size of test cases, but it seems like they did not reset the runtime history.\\nTherefore new submissions are unfairly treated as bottom 10 % even though they might be using good algorithms...\\n\\n![image](https://assets.leetcode.com/users/images/a6907010-2363-433b-891c-d6d057238d8c_1607960964.5503876.png)\\n"
                    },
                    {
                        "username": "coderEmigrant",
                        "content": "for non-English native speakers, partition is a verb in \"partition s such that every \nsubstring....\""
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coderEmigrant](/coderEmigrant) No point for the tip, non-english speakers anyway won\\'t be able to dodge  these problems that are getting less explanatory day by day. Leetcode is still fine (not the best), but problem setters now a days want us to solve considering every edge case but they themselves don\\'t want to explain about every case in clear English. More often than not, we have to check sample test cases to see what the actual problem expects"
                    },
                    {
                        "username": "alpharomeo99",
                        "content": "This one shouldn\\'t be a big problem if you did yesterday\\'s question. \\n\\nIn the previous question you were to check for the constraints for next 1, 2 or 3 places to ensure the integer you\\'re adding is in the range. \\nHere you can go on till the end of the input string to check if the substring you make in the partition is a valid pallindrome"
                    },
                    {
                        "username": "the_leetcode_guy",
                        "content": "Simple explanation here: https://youtu.be/_qn_P0-NoOM"
                    },
                    {
                        "username": "TraySoek",
                        "content": "helpful"
                    }
                ]
            },
            {
                "id": 1570734,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1770095,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1574342,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1571282,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1811680,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1771865,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1770204,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1769865,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1769657,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 1768700,
                "content": [
                    {
                        "username": "PHOENIX2000",
                        "content": "Is there any other way to solve this problem.\\nwithout backtracking.\\n\\n\\ncan i use palindrome substring dp for this solution?"
                    },
                    {
                        "username": "HorridBear",
                        "content": "You can refer to my solution:\\nhttps://leetcode.com/problems/palindrome-partitioning/solutions/3085996/solved-without-backtracking-just-dp-and-bit-manipulation/"
                    },
                    {
                        "username": "huangqianchen2021",
                        "content": "dp + dfs"
                    },
                    {
                        "username": "denkochev",
                        "content": "Recursive is hard..."
                    },
                    {
                        "username": "number42",
                        "content": "What I don\\'t understand in any of the given answers is how this condition is met:\\n\\n> every substring of the partition is a palindrome\\n\\nConsider `abcd` and split at index `1`. Not every substring of `bcd` is a palindrome, `bc` isn\\'t, `cd` isn\\'t. However, single character substrings `b`, `c`, and `d` are palindromes. According to the question, `[a, b, c, d]` shouldn\\'t be a solution because partitioning after `a` doesn\\'t produce two partitions all of which substrings are palindromes, but according to all the given answers, `[a, b, c, d]` is a solution."
                    },
                    {
                        "username": "muralivr8_",
                        "content": "Let\\'s assume your input is \"abcd\". Now you need to split them in such a way that all the splits is a substring... Now \\'a\\',\\'b\\',\\'c\\',\\'d\\' if we split this way each and every individual string is a palindrome. See : https://leetcode.com/problems/palindrome-partitioning/solutions/3083743/recursive-backtracking-fastest-solution-c-98-faster-in-runtime-and-memory/ for solution"
                    },
                    {
                        "username": "louisye",
                        "content": "anyone come up with c solutions?????"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "1. Write palindrome checking function, https://leetcode.com/problems/valid-palindrome/\\n2. Loop to generate all possible substrings and check if each is palindrome simultaneously in the recursive function.\\n3. solution: https://leetcode.com/problems/palindrome-partitioning/solutions/3220893/java-explained-with-recursive-tree/"
                    },
                    {
                        "username": "kirsty",
                        "content": "Still need to get around to reading this so I can properly analyze the runtime complexity!\\nhttps://leetcode.com/discuss/interview-question/3055778/How-to-calculate-runtime-of-backtracking-algorithm-in-interview"
                    },
                    {
                        "username": "adrian_puscu",
                        "content": "Can someone please explain why my code dosent work? Used print statements and it seems to spit out the right result, yet somehow cant get it out of the recursive function.\\n\\n    class Solution:\\n        def partition(self, s: str) -> List[List[str]]:\\n\\n            def is_palindrome(word):\\n                palindrome = True\\n                for i in range(len(word)):\\n                    if word[i] != word[-(i+1)]:\\n                        palindrome = False\\n                \\n                return palindrome\\n\\n\\n\\n            def backtracking(o_string, partitions, res):\\n                \\n                \\n                for i in range(len(o_string)):\\n\\n                    sub_string = o_string[:i+1]\\n\\n                    if is_palindrome(sub_string):\\n                        partitions.append(sub_string)\\n\\n                        if o_string[i+1:] == \"\":\\n                            print(\"exe\", partitions)\\n                            res.append(partitions)\\n                            partitions.pop()\\n                        \\n                        else:\\n                            backtracking(o_string[i+1:], partitions, res)\\n                            partitions.pop()\\n\\n                return res     \\n            \\n            res = backtracking(s, [], [])\\n            print(res)\\n            return res\\n\\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "On line 27, use tuple()   ->   res.append(tuple(partitions)) instead.\nList by default is supposed to be extended and not appended.\n\nAnd on the side note a more pythonic and efficient way of checking for palindrome is ->\ndef checkPalindrome(word):\n  return word == word[ : : -1]"
                    },
                    {
                        "username": "goswami_vineet1463",
                        "content": "i have a very easy way of solving it through backtracking here it is:\\n\\n\\nclass Solution {\\npublic:\\n    bool ispalindrone(string virat)\\n    {\\n        int i=0;\\n        int j=virat.size()-1;\\n        while(i<j)\\n        {\\n            if(virat[i++]!=virat[j--])\\n            {\\n                return false;\\n            }\\n        }\\n        return true;\\n}\\n    void findpalindrone(vector<vector<string>> &result,string s,vector<string> temp)\\n    {\\n        if(s.size()==0)\\n        {\\n            result.push_back(temp);\\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string vineet = s.substr(0,i+1);\\n            if(ispalindrone(vineet))\\n            {\\n                temp.push_back(vineet);\\n                findpalindrone(result,s.substr(i+1),temp);\\n                temp.pop_back();\\n            }\\n        }\\n    }\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;vector<string> temp;\\n        findpalindrone(result,s,temp);\\n        return result;\\n    }\\n};"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Those who are getting bad \\'Beats %\\' should not worry as some \\'deleted_user\\' posted in discussion that bigger test cases have been added now and they are being compared with previous submissions that had low runtime. So newer submissions are getting unfair \\'Beats %\\'"
                    },
                    {
                        "username": "dhananjaysarathe26",
                        "content": "no matching member function for call to \\'push_back\\'\\nWHY PUSHBACK IS NOT WORKING PLSSSS HELP  @"
                    },
                    {
                        "username": "muralivr8_",
                        "content": "If it is vector of vector<vector<string>> and your temporary answer forming is with help of a vector<string> you should be able to do push_back().. Check why is it telling push_back() is not member function and what data type you are using..."
                    }
                ]
            },
            {
                "id": 2026530,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 2019630,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1986595,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1984638,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1941163,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1878417,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1846527,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1796212,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1774308,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1770101,
                "content": [
                    {
                        "username": "SuriyaT",
                        "content": "i cant come up with soln is this my basics weak or  its happened for everyone  I am new to this patterns before that i solved subsets , combinations like that .. \n\nPlease please do comment and let me know what i was missed while learning basics of recursion\n\nThanks in advance"
                    },
                    {
                        "username": "pt33",
                        "content": "why am I getting wrong answer for this input ?\\nInput\\ns =\"aab\"\\nOutput\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"a\",\"b\"]](wrong ans)\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]](correct ans)\\n\\nclass Solution {\\n    boolean palindrome(String s,int i,int j){\\n        int start=i,end=j;\\n        while(start<end)\\n        {\\n            if(s.charAt(start)==s.charAt(end))\\n            {\\n                start++;\\n                end--;\\n            }\\n            else\\n            return false;\\n        }\\n        return true;\\n    }\\nvoid f(int ind,String s,List<String> al,List<List<String>> list){\\n    if(ind>=s.length())\\n    {\\n        list.add(new ArrayList<>(al));\\n        return;\\n    \\n    }\\n    for(int i=ind;i<s.length();i++)\\n    {\\n        if(palindrome(s,ind,i)){\\n        al.add(s.substring(ind,i+1));\\n        f(ind+1,s,al,list);\\n        al.remove((al.size()-1));\\n        }\\n\\n    }\\n}\\n\\n    public List<List<String>> partition(String s) {\\n        List<List<String>> list=new ArrayList<>();\\n        List<String> al=new ArrayList<>();\\n        f(0,s,al,list);\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "radhikatoravi15",
                        "content": "Can anyone help on what\\'s wrong with this solution- \\n\\nclass Solution(object):\\n    def partition(self, s):\\n        result=[]\\n        if len(s)==1:\\n            result.append(s)\\n            return result\\n\\n        def palindrome(start,end,s):\\n            while(start<=end):\\n                if s[start]!=s[end]:\\n                    return False\\n                start=start+1\\n                end=end-1\\n            return True\\n        for i in range(len(s)):\\n            if i==len(s)-1:\\n                if palindrome(0,i,s):\\n                    result.append(s)\\n                    #print(result)\\n\\n            else:\\n                if palindrome(0,i,s) and palindrome(i+1,len(s)-1,s):\\n                    result.append([s[0:i+1],s[i+1:]])\\n                    print(\"here\")\\n                    #print(result)\\n                \\n        if list(s) not in result:\\n              result.append(list(s))\\n        print(result)\\n        return result"
                    },
                    {
                        "username": "nemo4458",
                        "content": "I have a general question about recursion and backtracking. When do we use a two way recursion and when do we use a multiway recursion (using a for loop)? \\n\\nFor instance, here I had solved this problem by having 2 recursive calls each time - either to split or not split at current index. Whereas the solution checks in a loop whether to split at all possible indices. \\n\\nI had a similar confusion in the subset questions where one approach checked at each stage whether to include current element or not, while another approach fixed a prefix and tried to append all possible characters to the prefix in a loop. Which is the better approach and does it depend on the problem?"
                    },
                    {
                        "username": "zdjiang20001225",
                        "content": "For this problem, I made a mistake where I added an additional return statement which caused my solution to be wrong. My question is then for backtracking solutions, do you only return after you hit a base case? Is there any exceptions to this rule? Sorry if my question seems noobish I\\'m just getting starting with leetcode. "
                    },
                    {
                        "username": "Aman1112",
                        "content": "Can someone tell me all possible answer of \"abbaa\"?\\nI am getting total 6 possibilities but in solution it\\'s only give 5\\nhere they are [a,b,b,a,a],[a,b,b,aa],[a,bb,a,a],[a,bb,aa],[abba,a],[a,bbaa]"
                    },
                    {
                        "username": "Reinisha_Sarojini_P",
                        "content": "JAVA\\n\\n\\nclass Solution {\\n    List<List<String>> result = new ArrayList<>();\\n    public List<List<String>> partition(String s) {\\n        dfs(s,0,new ArrayList<String>());\\n        return result;\\n    }\\n\\n    public void dfs(String s,int start,List<String> list)\\n    {\\n        if(start == s.length())\\n        {\\n            result.add(new ArrayList<>(list));\\n            return;\\n        }\\n        for(int i=start;i<s.length();i++)\\n        {\\n            if(isPalindrome(s.substring(start,i+1)))\\n            {\\n                list.add(s.substring(start,i+1));\\n                dfs(s,i+1,list);\\n                list.remove(list.size()-1);\\n            }\\n        }\\n    }\\n\\n    public boolean isPalindrome(String s)\\n    {\\n        for(int i=0,j=s.length()-1;i<j;i++,j--)\\n            if(s.charAt(i)!=s.charAt(j))\\n                return false;\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "user3882os",
                        "content": "Example 1:\\n\\nInput: s = \"aab\"\\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\nhere \"b\" is repeating in List.\\n\\nI think answer should be  [[\"a\",\"a\",\"b\"],[\"aa\"]].\\n\\ncan anyone help me to understand?"
                    },
                    {
                        "username": "mahan20120",
                        "content": "My code has error in test case 21 with input string of \"ababbbabbaba\". Furthermore, both expected and my output has length of 94. Could anyone help me, how should I find the bug ?"
                    },
                    {
                        "username": "jawaharsrinivas77",
                        "content": "Can any one Explain how the substrings are generated ?\\nMy doubt is in 1st Example :\\n             why [\"a\",\"ab\"] is not a valid one?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@jawaharsrinivas](/jawaharsrinivas77)In your partition, the first string i.e \"a\" is a palindrome, but second string \"ab\" is NOT a palindrome. We only need those partitions of a string where in each substring is a palindrome"
                    }
                ]
            },
            {
                "id": 1770088,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769856,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769814,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769625,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769570,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769426,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769378,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1769132,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1768981,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            },
            {
                "id": 1768753,
                "content": [
                    {
                        "username": "cwooldridge",
                        "content": "Trickier then yesterdays?"
                    },
                    {
                        "username": "Dynamo_360",
                        "content": "C++ SOLUTION WITH THE HELP OF BACKTRACKING\\nWe can start by iterating through the string s, checking if each substring from the current index to the end of the string is a palindrome. If it is, we add it to our current partition and recursively call the partition function on the remaining substring. Once we reach the end of the string and have found all possible partitions, we can add them to our final result.\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<string>> partition(string s) {\\n        vector<vector<string>> result;\\n        vector<string> partition;\\n        backtrack(s, partition, result, 0);\\n        return result;\\n    }\\n    \\n    void backtrack(string s, vector<string> &partition, vector<vector<string>> &result, int start) {\\n        if (start == s.length()) {\\n            result.push_back(partition);\\n            return;\\n        }\\n        for (int i = start; i < s.length(); i++) {\\n            if (isPalindrome(s, start, i)) {\\n                partition.push_back(s.substr(start, i-start+1));\\n                backtrack(s, partition, result, i+1);\\n                partition.pop_back();\\n            }\\n        }\\n    }\\n    \\n    bool isPalindrome(string s, int start, int end) {\\n        while (start < end) {\\n            if (s[start] != s[end]) {\\n                return false;\\n            }\\n            start++;\\n            end--;\\n        }\\n        return true;\\n    }\\n};\\n"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/131_Palindrome_Partitioning.cpp"
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation : https://youtu.be/eDnN4Lu74kk"
                    },
                    {
                        "username": "coff33poweredcode",
                        "content": "Why are the answers expected in a particular order?\\nS=\"aab\"\\nOutput:\\n[[\"b\",\"a\",\"a\"],[\"b\",\"aa\"]]\\nExpected:\\n[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\\n\\n\\ns=\"screwed\"\\noutput:\\n[ [\"d\",\"e\",\"w\",\"e\",\"r\",\"c\",\"s\"] ,[\"d\",\"ewe\",\"r\",\"c\",\"s\"] ]\\nExpected:\\n[ [\"s\",\"c\",\"r\",\"e\",\"w\",\"e\",\"d\"] ,[\"s\",\"c\",\"r\",\"ewe\",\"d\"] ]\\n\\nThe order of the vectors has correctly ignored, but the expected answer still wants a particular order of the strings *within* each vector,  this should be changed?\\n\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@coff33poweredcode](/coff33poweredcode) The order of partitions does not matter, the the order within a partition does matter, how else will we know that for a string, the partition has been done properly from left to right without using one character more than once."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "I may be wrong here but in the example it states :\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nShouldn't [\"aba\"] be part of the solution considering it uses all the characters?\nWhen it specifies \"be a substring\" does that mean that its chars have to be length -1 to be valid?\n\nAnd if that is the case why given the input\n s =\"aaaa\"\n[[\"a\",\"a\",\"a\",\"a\"],[\"a\",\"a\",\"aa\"],[\"a\",\"aa\",\"a\"],[\"a\",\"aaa\"],[\"aa\",\"a\",\"a\"],[\"aa\",\"aa\"],[\"aaa\",\"a\"],[\"aaaa\"]]\nthe output contains the \"aaaa\" ?\n"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "Order of substring is to be maintained."
                    },
                    {
                        "username": "silverdagger21",
                        "content": "[@strive_hard](/strive_hard)  That does not explain why the string \"aaaa\" is a valid answer when the input is the same string"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@silverdagger21](/silverdagger21) yes, in every partition, all obtained strings must be a substring of the original string. \\nSince \\u201Caba\\u201D is not a substring of \\u201Caab\\u201D, hence it\\u2019s not a valid partition.\\n\\nHope it helps.\\nFeel free to comment if you need more clarity.\\n\\nPlease upvote if it helps.\\n\\nThanks:)"
                    },
                    {
                        "username": "shubhanshu_jha",
                        "content": "Simple approach: https://youtu.be/vgrg-BXsB5k"
                    },
                    {
                        "username": "SrB30",
                        "content": "The problem statement is not clear. Test cases should also be explained clearly."
                    },
                    {
                        "username": "vietnha1999",
                        "content": "A week of NP hard =(( All of my solutions is very slow, although they are still passed."
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Nguyen Huu Anh Viet](/vietnha1999) How much slow? The beats % does not matter in these exponential problems here since every submission has a low runtime because of small size test cases, and a fair comparison cannot be done in such cases. How can we compare 20 ms and 30 ms when the leetcode judge gives highly varying time in each submission. I think the beats % is accurate only when the average runtime is greater than 100 ms. In yesterday\\'s problem I got 7 ms runtime and a big chunk of submissions were at 6 ms runtime. Had I submitted multiple times, it could have very probably given 5 ms runtime making it better than most."
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "another day of backtracking. \\nOverkilling my brain on this."
                    }
                ]
            }
        ]
    },
    {
        "title": "Power of Two",
        "question_content": "<p>Given an integer <code>n</code>, return <em><code>true</code> if it is a power of two. Otherwise, return <code>false</code></em>.</p>\n\n<p>An integer <code>n</code> is a power of two, if there exists an integer <code>x</code> such that <code>n == 2<sup>x</sup></code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>0</sup> = 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 16\n<strong>Output:</strong> true\n<strong>Explanation: </strong>2<sup>4</sup> = 16\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 3\n<strong>Output:</strong> false\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>-2<sup>31</sup> &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Could you solve it without loops/recursion?",
        "solutions": [
            {
                "id": 1638707,
                "title": "python-c-java-detailly-explain-why-n-n-1-works-1-line-100-faster-easy",
                "content": "**Please UPVOTE if you LIKE!** \\uD83D\\uDE01\\n* Key Idea\\n\\t* the binary form of every power of two likes `0b100...0`, because `pow(2, n) == 1 << n`\\n\\t```\\n\\t1 = 0b1\\n\\t2 = 0b10\\n\\t4 = 0b100\\n\\t8 = 0b1000\\n\\t...\\n\\t```\\n\\t* the binary form of every` pow(2, n) - 1` likes` 0b11..1`\\n\\t```\\n\\t1 - 1 = 0 = 0b0        =>  1 & 0 = 0b1    & 0b0    = 0\\n\\t2 - 1 = 1 = 0b1        =>  2 & 1 = 0b10   & 0b1    = 0\\n\\t4 - 1 = 3 = 0b11       =>  4 & 3 = 0b100  & 0b11   = 0\\n\\t8 - 1 = 7 = 0b111      =>  8 & 7 = 0b1000 & 0b111  = 0\\n\\t...\\n\\t```\\n\\t* so we can find `pow(2, n) & (pow(2, n) - 1) == 0`\\n\\t\\t* for example, `num = 4 = 0b100`\\n\\t\\t\\t* `4 - 1 = 3 = 0b11`\\n\\t\\t\\t* `4 & 3 = 0b100 & 0b11 = 0`\\n\\t\\t\\t* Amazing, right?\\n\\t* **But that\\'s not enough!** We need to expain that if `n` is not a power of two then `n & n - 1 != 0`\\n\\t\\t* If m is not a power of two, then the binary form of m contains more than one `1`, that is `0b1x..x10..0`, `x` represents `0` or `1`\\n\\t\\t\\t* so` m - 1 = 0b1x..x10..0 - 1 = 0b1x..x01..1`, that is the first `1` in `m` is still in the binary form of `m - 1`, so that `m & (m - 1) = 0b1x..x0..0 > 0`\\n\\t\\t\\t* for example, `m = 6 =` 0b**1**10\\n\\t\\t\\t\\t* `6 - 1 = 5 = `0b**1**01\\n\\t\\t\\t\\t* `6 & 5 = 4 = `0b**1**00 `> 0`\\n\\t\\t\\t\\t* Did you find it? The bold **1** is still there!!!\\n\\t* More generally, for any number `n > 0`\\n\\t\\t* **`n & n - 1` removes the last `1` in the binary form of `n`**\\n\\t\\t* **if and only if `n` is a power of two, there is only one `1` in the binary form of `n`**\\n\\t\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**\\t\\n\\n**Python 98.05% Faster**\\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        return n and not (n & n - 1)\\n```\\n\\n**Java 99.97% Faster**\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```\\n\\n**C++ 100% Faster**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && not (n & n - 1);\\n    }\\n};\\n```\\n\\n**If you have any question, feel free to ask. If you like the solution or the explanation, Please UPVOTE!**",
                "solutionTags": [],
                "code": "```\\n\\t1 = 0b1\\n\\t2 = 0b10\\n\\t4 = 0b100\\n\\t8 = 0b1000\\n\\t...\\n\\t```\n```\\n\\t1 - 1 = 0 = 0b0        =>  1 & 0 = 0b1    & 0b0    = 0\\n\\t2 - 1 = 1 = 0b1        =>  2 & 1 = 0b10   & 0b1    = 0\\n\\t4 - 1 = 3 = 0b11       =>  4 & 3 = 0b100  & 0b11   = 0\\n\\t8 - 1 = 7 = 0b111      =>  8 & 7 = 0b1000 & 0b111  = 0\\n\\t...\\n\\t```\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        return n and not (n & n - 1)\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && not (n & n - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638704,
                "title": "c-easy-to-solve-all-interview-approaches-with-detailed-explanations",
                "content": "**Intuition:**\\nWell well, the question is quite the tough one today. So make your focus lasersharp and let\\'s jump in. The question is return true or false if the given `n` is power of two or not. The simple approach that comes to mind after reading this, *is our classsic reminder and divident menthod that we used for finding odd and even* . The question is easy but can be solved in tooo many ways .Try to understand all the solution as it may help in interviews where there can be restriction of using certain methods\\n\\n**Codes:-**\\n\\n**1. Using Reminder-divident method:-**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        while(n%2==0) n/=2;\\n        return n==1;\\n    }\\n};\\n```\\n**Time Complexity:** *`O(logn)`*\\n**Space Complexity:** *`O(1)`*\\n\\n**2. Using Reminder-divident method via Recursion:-**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return ((n==1) || (n%2==0 && isPowerOfTwo(n/2)));\\n    }\\n};\\n```\\n**Time Complexity** : *`O(logn)`*\\n**Space Complexity :** *`O(logn) [Rcursive stack is counted]`*\\n\\n**3. Bit manipulation :-**\\n*`Tip: Always remember that bit manipulation techniques are usually based on observations from multiple examples`*\\n```\\nLet\\'s take some good exampes :\\nnumber->binary form\\n3->0000 0011\\n4->0000 0100\\n5->0000 0101\\n6->0000 0110\\n7->0000 0111\\n8->0000 1000\\n```\\n*The observation we can conclude is that the number which is a power of two has always compulsoryily 1 true bit.*\\n```\\nNow consider :-\\nbit representation of 7  -> 0111\\nbit representation of 8  -> 1000\\nbitwise AND of 7 and 8 -> 0000\\nwe are gonna use this property for for all numbers which are powers of two\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return ((n&(n-1))==0);\\n    }\\n};\\n```\\n**Time Complexity :** *`O(1)`*\\n**Space Complexity :** *` O(1)`*\\n\\n**4. Using ceil-floor method**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        return ceil(log2(n)) == floor(log2(n));\\n    }\\n};\\n```\\n**Time Complexity :** *`O(logn)`*\\n**Space Complexity :** *`O(1)`*\\n\\n**5. Using C++ STL method** #Thanks to @rajab1691 :)\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<0)return false;\\n        \\n        int bits=__builtin_popcount(n);\\n        \\n        if(bits==1)\\n            return true;\\n        return false;\\n    }\\n};\\n```\\n**6. LMAO method**\\nWe are literally gonna take the advantage of the constraints. I  dont recommend you all to use this method during your interviews. It\\'s a fun method . Do this on your own, you will enjoy it ;)) \\n* *Hint:Constraints [-2^31 <= n <= 2^31 - 1] also 2^30 is 1073741824*\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return (n>0)&&(1073741824%n==0);\\n    }\\n};\\n```\\n**Time Complexity :** *`O(1)`*\\n**Space Complexity :** *`O(1)`*\\n\\n***\\nHere\\'s my [github link](https://github.com/Jatin-Shihora) where I keep my solutions.\\n*** \\n**Feel free to comment if you have some suggestion or upvote if you liked my post ;)**\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        while(n%2==0) n/=2;\\n        return n==1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return ((n==1) || (n%2==0 && isPowerOfTwo(n/2)));\\n    }\\n};\\n```\n```\\nLet\\'s take some good exampes :\\nnumber->binary form\\n3->0000 0011\\n4->0000 0100\\n5->0000 0101\\n6->0000 0110\\n7->0000 0111\\n8->0000 1000\\n```\n```\\nNow consider :-\\nbit representation of 7  -> 0111\\nbit representation of 8  -> 1000\\nbitwise AND of 7 and 8 -> 0000\\nwe are gonna use this property for for all numbers which are powers of two\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return ((n&(n-1))==0);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        return ceil(log2(n)) == floor(log2(n));\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<0)return false;\\n        \\n        int bits=__builtin_popcount(n);\\n        \\n        if(bits==1)\\n            return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        return (n>0)&&(1073741824%n==0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1638961,
                "title": "c-python-simple-solutions-w-explanation-all-possible-solutions-explained",
                "content": "We need to return if the given number `n` is a power of two or not.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Recursive)***\\n\\n* If a number is power of two, it can be recursively divided by 2 till it becomes 1\\n* If the start number is `0` or if any intermediate number is not divisible by 2, we return false\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(!n) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 and isPowerOfTwo(n / 2);\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        if n == 0: return False\\n        return n == 1 or (n % 2 == 0 and self.isPowerOfTwo(n // 2))\\n```\\n\\n***Time Complexity :*** <code>O(logn)</code>, where `n` is the given input number\\n***Space Complexity :*** `O(logn)`, required for recursive stack\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Iterative)***\\n\\nThe same solution as above but done iteratively\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return 0;\\n        while(n % 2 == 0) \\n            n /= 2;\\n        return n == 1;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        if n == 0: return False\\n        while n % 2 == 0:\\n            n /= 2\\n        return n == 1\\n```\\n\\n***Time Complexity :*** <code>O(logn)</code>, where `n` is the given input number\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\n\\u2714\\uFE0F ***Solution - III (Log<sub>2</sub> n)***\\n\\nIf `n` is power of 2, `log2(n)` will always be integer, or more specifically, the power to which `2` must be raised to get `n`.  Thus we only need to check if result of `log2(n)` is an integer or not.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n && log2(n) == trunc(log2(n));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and log2(n) == trunc(log2(n))\\n```\\n\\n***Time Complexity :*** <code>O(logn)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - IV (Pattern in Power of 2)***\\n\\nIf a number is a power of 2, we can observe that it will always have just a **single set bit** in its binary representation. So, we can just count number of set bits and determine if `n` is power of 2 or not from that.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && __builtin_popcount(n) == 1;\\n\\t\\t// or: return  n > 0 && popcount(n) == 1;       // since C++20\\n\\t\\t// or: return n > 0 && has_single_bit(n);       // since C++20\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and bin(n).count(\\'1\\') == 1\\n```\\n\\n***Time Complexity :*** <code>O(logn)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - V (Bit-Trick)***\\n\\nThere\\'s a nice bit-trick that can be used to check if a number is power of 2 efficiently. As already seen above, `n` will only have 1 set bit if it is power of 2. Then, we can AND (&) `n` and `n-1` and if the result is 0, it is power of 2. This works because if `n` is power of 2 with `i`th bit set, then in `n-1`, `i` will become unset and all bits to right of `i` will become set. Thus the result of AND will be 0.\\n\\n```python\\nIf n is a power of 2:\\nn    = 8 (1000)\\nn-1  = 7 (0111)\\n----------------\\n&    = 0 (0000)         (no set bit will be common between n and n-1)\\n\\nIf n is not a power of 2:\\nn    = 10 (1010)\\nn-1  =  9 (1001)\\n-----------------\\n&    =  8 (1000)         (atleast 1 set bit will be common between n and n-1)\\n```\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && !(n & (n-1));\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and n & (n-1) == 0\\n```\\n\\n***Time Complexity :*** <code>O(1)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VI (Math)***\\n\\nOnly a power of 2 will be able to divide a larger power of 2. Thus, we can take the largest power of 2 for our given range and check if `n` divides it\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 and (1 << 31) % n == 0;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and (1 << 31) % n == 0\\n```\\n\\n***Time Complexity :*** <code>O(1)</code>\\n***Space Complexity :*** `O(1)`\\n\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - VII (Pre-Compute all powers of 2)***\\n\\nWe can simply precompute all powers of 2, store it in hashset and check if `n` is present in it.\\n\\n**C++**\\n```cpp\\nunordered_set<int> powOf2;\\nauto _ = [](){\\n    for(int i = 0, n = 1; i < 31; i++, n <<= 1) powOf2.insert(n);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return powOf2.count(n);\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\npow_of_2 = set(2**i for i in range(31))\\nclass Solution:    \\n    def isPowerOfTwo(self, n):\\n        return n in pow_of_2\\n```\\n\\n***Time Complexity :*** <code>O(1)</code>\\n***Space Complexity :*** `O(1)`\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(!n) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 and isPowerOfTwo(n / 2);\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        if n == 0: return False\\n        return n == 1 or (n % 2 == 0 and self.isPowerOfTwo(n // 2))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return 0;\\n        while(n % 2 == 0) \\n            n /= 2;\\n        return n == 1;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        if n == 0: return False\\n        while n % 2 == 0:\\n            n /= 2\\n        return n == 1\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n && log2(n) == trunc(log2(n));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and log2(n) == trunc(log2(n))\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && __builtin_popcount(n) == 1;\\n\\t\\t// or: return  n > 0 && popcount(n) == 1;       // since C++20\\n\\t\\t// or: return n > 0 && has_single_bit(n);       // since C++20\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and bin(n).count(\\'1\\') == 1\\n```\n```python\\nIf n is a power of 2:\\nn    = 8 (1000)\\nn-1  = 7 (0111)\\n----------------\\n&    = 0 (0000)         (no set bit will be common between n and n-1)\\n\\nIf n is not a power of 2:\\nn    = 10 (1010)\\nn-1  =  9 (1001)\\n-----------------\\n&    =  8 (1000)         (atleast 1 set bit will be common between n and n-1)\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && !(n & (n-1));\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and n & (n-1) == 0\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 and (1 << 31) % n == 0;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and (1 << 31) % n == 0\\n```\n```cpp\\nunordered_set<int> powOf2;\\nauto _ = [](){\\n    for(int i = 0, n = 1; i < 31; i++, n <<= 1) powOf2.insert(n);\\n    return 0;\\n}();\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return powOf2.count(n);\\n    }\\n};\\n```\n```python\\npow_of_2 = set(2**i for i in range(31))\\nclass Solution:    \\n    def isPowerOfTwo(self, n):\\n        return n in pow_of_2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63974,
                "title": "using-n-n-1-trick",
                "content": "Power of 2 means only one bit of n is '1', so use the trick n&(n-1)==0 to judge whether that is the case\\n \\n\\n    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            if(n<=0) return false;\\n            return !(n&(n-1));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            if(n<=0) return false;\\n            return !(n&(n-1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 63966,
                "title": "4-different-ways-to-solve-iterative-recursive-bit-operation-math",
                "content": "This question is not an difficult one, and there are many ways to solve it. \\n\\n**Method 1: Iterative**\\n\\ncheck if ```n``` can be divided by 2. If yes, divide ```n``` by 2 and check it repeatedly.\\n\\n    if (n <= 0) return false;\\n    while (n%2 == 0) n/=2;\\n    return n == 1;\\n\\nTime complexity = ```O(log n)```\\n\\n**Method 2: Recursive**\\n\\n    return n > 0 && (n == 1 || (n%2 == 0 && isPowerOfTwo(n/2)));\\n\\nTime complexity = ```O(log n)```\\n        \\n**Method 3: Bit operation**\\n\\nIf ```n``` is the power of two:\\n\\n - n = 2 ^ 0 = 1 = 0b0000...00000001, and (n - 1) = 0 = 0b0000...0000.\\n - n = 2 ^ 1 = 2 = 0b0000...00000010, and (n - 1) = 1 = 0b0000...0001.\\n - n = 2 ^ 2 = 4 = 0b0000...00000100, and (n - 1) = 3 = 0b0000...0011.\\n - n = 2 ^ 3 = 8 = 0b0000...00001000, and (n - 1) = 7 = 0b0000...0111.\\n\\nwe have n & (n-1) == 0b0000...0000 == 0\\n\\nOtherwise, n & (n-1) != 0. \\n\\nFor example,  n =14 = 0b0000...1110, and (n - 1) = 13 = 0b0000...1101.\\n\\n    return n > 0 && ((n & (n-1)) == 0);\\n\\nTime complexity = ```O(1)```\\n        \\n**Method 4: Math derivation**\\n\\nBecause the range of an integer = -2147483648 (-2^31) ~ 2147483647 (2^31-1), the max possible power of two = 2^30 = 1073741824.\\n\\n(1) If ```n``` is the power of two, let ```n = 2^k```, where ```k``` is an integer.\\n\\nWe have 2^30 = (2^k) * 2^(30-k), which means (2^30 % 2^k) == 0.\\n\\n(2) If ```n``` is not the power of two, let ```n = j*(2^k)```, where ```k``` is an integer and ```j``` is an odd number.\\n\\nWe have (2^30 % j*(2^k)) == (2^(30-k) % j) != 0. \\n\\n    return n > 0 && (1073741824 % n == 0);\\n\\nTime complexity = ```O(1)```\\n\\n--\\nUpdate:\\nThanks for everyone\\'s comment. Following are some other solutions metioned in comments.\\n\\n**Method 5: Bit count**\\n\\nVery intuitive. If ```n``` is the power of 2, the bit count of ```n``` is 1. \\nNote that ```0b1000...000``` is ```-2147483648```, which is not the power of two, but the bit count is 1.\\n```\\nreturn n > 0 && Integer.bitCount(n) == 1;\\n```\\nTime complexity = ```O(1)```\\nThe time complexity of ```bitCount()``` can be done by a fixed number of operations. \\nMore info in https://stackoverflow.com/questions/109023.\\n\\n**Method 6: Look-up table**\\nThere are only 31 numbers in total for an 32-bit integer. \\n```\\nreturn new HashSet<>(Arrays.asList(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)).contains(n);\\n```\\ntime complexity = ```O(1)```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```n```\n```n```\n```O(log n)```\n```O(log n)```\n```n```\n```O(1)```\n```n```\n```n = 2^k```\n```k```\n```n```\n```n = j*(2^k)```\n```k```\n```j```\n```O(1)```\n```n```\n```n```\n```0b1000...000```\n```-2147483648```\n```\\nreturn n > 0 && Integer.bitCount(n) == 1;\\n```\n```O(1)```\n```bitCount()```\n```\\nreturn new HashSet<>(Arrays.asList(1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824)).contains(n);\\n```\n```O(1)```",
                "codeTag": "Unknown"
            },
            {
                "id": 63972,
                "title": "one-line-java-solution-using-bitcount",
                "content": "This is kind of cheating, but the idea is that a power of two in binary form has and only has one \"1\".\\n\\n    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n>0 && Integer.bitCount(n) == 1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n>0 && Integer.bitCount(n) == 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 676737,
                "title": "python-oneliner-o-1-bit-manipulation-trick-explained",
                "content": "This is classical bit manipulation problem for `n & (n-1)` trick, which removes the last non-zero bit from our number\\n\\n**example**: \\n1.`n = 100000`, then `n - 1 = 011111` and `n & (n-1) = 000000`, so if it is power of two, result is zero\\n2.`n = 101110`, then `n - 1 = 101101` and  `n & (n-1) = 101100`, number is not power of two and result is not zero.\\n\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and not (n & n-1)\\n```\\n\\n**Update** there is another `O(1)` solution using math: number is power of `2` if it is divisor of the biggest possible power of `2`:\\n\\n```return n > 0 and (1<<32) % n == 0```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and not (n & n-1)\\n```\n```return n > 0 and (1<<32) % n == 0```",
                "codeTag": "Java"
            },
            {
                "id": 63993,
                "title": "one-line-of-c",
                "content": "I used n&(n-1), but, attention the 0.\\n\\n\\n    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && !(n&(n-1));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && !(n&(n-1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64027,
                "title": "python-one-line-solution",
                "content": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: bool\\n            \"\"\"\\n            return n > 0 and not (n & n-1)",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            \"\"\"\\n            :type n: int\\n            :rtype: bool\\n            \"\"\"\\n            return n > 0 and not (n & n-1)",
                "codeTag": "Java"
            },
            {
                "id": 1741696,
                "title": "my-java-code-is-faster-than-99-56-with-detail-explanation-by-using-recursion-easy-to-understand",
                "content": "# Power of Two\\n\\n\\n![image](https://assets.leetcode.com/users/images/42baaf60-a0d6-4e44-a466-e6e3aa127640_1643886890.2685964.jpeg)\\n\\n\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic boolean isPowerOfTwo(int n) {\\n\\t\\t\\tif(n==1){ return true; }\\n\\t\\t\\tif(n==0){ return false; }\\n\\t\\t\\tif(n%2!=0){return false; }\\n\\t\\t\\telse{ return isPowerOfTwo(n/2); }\\n\\n\\t\\t}\\n\\t}\\n\\n**IF YOU LIKE THE EXPLANATION THEN PLEASE UPVOTE THIS**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tpublic boolean isPowerOfTwo(int n) {\\n\\t\\t\\tif(n==1){ return true; }",
                "codeTag": "Java"
            },
            {
                "id": 1638564,
                "title": "3-lines-easy-java-solution-with-explanation",
                "content": "**Upvote if you LIKE** \\uD83D\\uDE42\\n\\nExplaination: If number equals or less than 0 then it cant be any power of 2. Now for positive numbers, it should have only one binary bit as 1 (becaus power of 2 will come as 2^0,2^1,2^2.......). \\nfor example,\\n1 -> 2^0 -> 0000001\\n2 -> 2^1 -> 0000010\\n4 -> 2^2 -> 0000100\\n8 -> 2^3 -> 0001000\\n16-> 2^4 -> 0010000\\n....... and so on.\\nSo here we can take a bitwise and (&) operation between the number and a number less than it, if it equal to 0 then it means that no other position has high bit, except at one place. Thus return true, else false.\\n\\n**for ex: take the number, n=16**\\n\\nn (in bits)     -> 1 0 0 0 0   (16 is a power of 2 and thus has only one high bit)\\nn-1 (in bits) ->  0 1 1 1 1 ( n-1 i.e. 15 will make all bits high excpet the 5th bit)\\nn & n-1        ->  0 0 0 0 0  (& operation will make all the bits to 0, thus its power of 2)\\n\\n**Code**\\nclass Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        return ((n&(n-1))==0);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        return ((n&(n-1))==0);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 369024,
                "title": "100-fastest-0ms-one-line-solution-with-explanation-binary-trick",
                "content": "Just a binary trick:\\n\\n**2^*n*** = 1{000...0 - *n* times}, binary.\\n**2^*2*** = 4 (decimial) = 1**00** binary - two zeros.\\n**2^*5*** = 32 (decimial) = 1**00000** binary - five zeros.\\n\\n**2^*n* *- 1*** = {111...1 - *n times*}\\n**2^*3* *- 1*** = 8 - 1 = 7 (decimial) = **111** = *three* ones.\\n**2^*5* *- 1*** = 32 - 1 = 31 (decimial) = **11111** = *five* ones.\\n\\nBased on this two rules, if ***n*** is power of two (2^n) if we apply **bitwise AND** all corresponding bits will be different and we\\'ll receive zero, for example:\\n\\n**1) n = 2^5**\\n32 & (32 - 1) = 32 & 31:\\n\\n```\\n-- 100000\\n--- 11111\\n--- 00000 == 0\\n```\\n\\n\\n\\n**2) n = 2^3**\\n8 & (8 - 1) = 8 & 7:\\n\\n```\\n-- 1000\\n--- 111\\n--- 000 == 0\\n```\\n\\n\\n\\n**3) 25?**\\n25 & (25 - 1) = 25 & 24:\\n\\n```\\n-- 11001\\u202C\\n-- 11000\\n-- 11000 != 0\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 ? !(n & n-1) : false;\\n    }\\n};\\n```\\n\\nAnd **JS** solution:\\n\\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nlet isPowerOfTwo = n => n > 0 ? !(n & n-1) : false;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n-- 100000\\n--- 11111\\n--- 00000 == 0\\n```\n```\\n-- 1000\\n--- 111\\n--- 000 == 0\\n```\n```\\n-- 11001\\u202C\\n-- 11000\\n-- 11000 != 0\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 ? !(n & n-1) : false;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nlet isPowerOfTwo = n => n > 0 ? !(n & n-1) : false;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375156,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution (Recursive Approach):**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Power of Two.\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // Base cases as \\'1\\' is the only odd number which is a power of 2 i.e. 2^0...\\n        if(n==1)\\n            return true;\\n        // All other odd numbers are not powers of 2...\\n        else if (n % 2 != 0 || n == 0)\\n            return false;\\n        // Recursive function call\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```\\n\\n# **C++ Solution (Bit-Manipulation):**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        // If n <= 0 that means its a negative hence not a power of 2...\\n        if (n <= 0){\\n            return false;\\n        }\\n        // Check if x & (x \\u2013 1) is equal to zero...\\n        // If yes, the number is a power of 2...\\n        else if ((n & (n - 1)) == 0){\\n            return true;\\n        }\\n        // Otherwise, The integer is not a power of 2...\\n        else {\\n            return false;\\n        }\\n    }\\n};\\n```\\n\\n# **Python Solution (Trival):**\\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        # If n <= 0 that means its a negative hence not a power of 2...\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        # Keep dividing the number by \\u20182\\u2019 until it is not divisible by \\u20182\\u2019 anymore.\\n        while (n % 2 == 0):\\n            n /= 2\\n        # If n is equal to 1, The integer is a power of two otherwise false...\\n        return n == 1\\n```\\n                \\n# **JavaScript Solution:**\\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 0)\\n        return 0;\\n    while (n != 1) {\\n        if (n%2 != 0)\\n            return 0;\\n        n = n/2;\\n    }\\n    return 1;\\n};\\n```\\n\\n# **C Language:**\\n```\\nbool isPowerOfTwo(int n){\\n    if(n == 1)\\n        return true;\\n    else if(n == 0)\\n        return false;\\n    else if(n % 2 != 0)\\n        return false;\\n    return isPowerOfTwo(n/2);\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        # If n <= 0 that means its a negative hence not a power of 2...\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        # Keep dividing the number by \\u20182\\u2019 until it is not divisible by \\u20182\\u2019 anymore.\\n        while (n % 2 == 0):\\n            n /= 2\\n        # If n is equal to 1, The integer is a power of two otherwise false...\\n        return n == 1\\n```\\n**I am working hard for you guys...\\nPlease upvote if you find any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // Base cases as \\'1\\' is the only odd number which is a power of 2 i.e. 2^0...\\n        if(n==1)\\n            return true;\\n        // All other odd numbers are not powers of 2...\\n        else if (n % 2 != 0 || n == 0)\\n            return false;\\n        // Recursive function call\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        // If n <= 0 that means its a negative hence not a power of 2...\\n        if (n <= 0){\\n            return false;\\n        }\\n        // Check if x & (x \\u2013 1) is equal to zero...\\n        // If yes, the number is a power of 2...\\n        else if ((n & (n - 1)) == 0){\\n            return true;\\n        }\\n        // Otherwise, The integer is not a power of 2...\\n        else {\\n            return false;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        # If n <= 0 that means its a negative hence not a power of 2...\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        # Keep dividing the number by \\u20182\\u2019 until it is not divisible by \\u20182\\u2019 anymore.\\n        while (n % 2 == 0):\\n            n /= 2\\n        # If n is equal to 1, The integer is a power of two otherwise false...\\n        return n == 1\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 0)\\n        return 0;\\n    while (n != 1) {\\n        if (n%2 != 0)\\n            return 0;\\n        n = n/2;\\n    }\\n    return 1;\\n};\\n```\n```\\nbool isPowerOfTwo(int n){\\n    if(n == 1)\\n        return true;\\n    else if(n == 0)\\n        return false;\\n    else if(n % 2 != 0)\\n        return false;\\n    return isPowerOfTwo(n/2);\\n}\\n```\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        # If n <= 0 that means its a negative hence not a power of 2...\\n        if n <= 0:\\n            return False\\n        if n == 1:\\n            return True\\n        # Keep dividing the number by \\u20182\\u2019 until it is not divisible by \\u20182\\u2019 anymore.\\n        while (n % 2 == 0):\\n            n /= 2\\n        # If n is equal to 1, The integer is a power of two otherwise false...\\n        return n == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64127,
                "title": "one-line-java-solution",
                "content": "     public boolean isPowerOfTwo(int n) {\\n        return ((n & (n-1))==0 && n>0);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "     public boolean isPowerOfTwo(int n) {\\n        return ((n & (n-1))==0 && n>0);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 948641,
                "title": "python-o-1-solution",
                "content": "**O(1)**\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and n&(n-1)==0\\n```\\n\\n\\n**O(n)**    \\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and sum(list(map(int,bin(n)[2:])))==1\\n```\\n\\n**O(1) Solution Explanation:**\\n\\nIt\\'s figuring out if `n` is either 0 or an exact power of two.\\n\\nIt works because a binary power of two is of the form `1000...000` and subtracting one will give you `111...111`. Then, when you AND those together, you get zero, such as with:\\n\\n      1000 0000 0000 0000\\n    &  111 1111 1111 1111\\n      ==== ==== ==== ====\\n    = 0000 0000 0000 0000\\n\\nAny non-power-of-two input value (other than zero) will *not* give you zero when you perform that operation.\\n\\nFor example, let\\'s try all the 4-bit combinations:\\n\\n         <----- binary ---->\\n     n      n    n-1   n&(n-1)\\n    --   ----   ----   -------\\n     0   0000   0111    0000 *\\n     1   0001   0000    0000 *\\n     2   0010   0001    0000 *\\n     3   0011   0010    0010\\n     4   0100   0011    0000 *\\n     5   0101   0100    0100\\n     6   0110   0101    0100\\n     7   0111   0110    0110\\n     8   1000   0111    0000 *\\n     9   1001   1000    1000\\n    10   1010   1001    1000\\n    11   1011   1010    1010\\n    12   1100   1011    1000\\n    13   1101   1100    1100\\n    14   1110   1101    1100\\n    15   1111   1110    1110\\n\\nYou can see that only `0` and the powers of two (`1`, `2`, `4` and `8`) result in a `0000/false` bit pattern, all others are non-zero or `true`.\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and n&(n-1)==0\\n```\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and sum(list(map(int,bin(n)[2:])))==1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676869,
                "title": "n-n-n-working-explained-in-detail",
                "content": "**remove last set BIT**\\n```\\nlets see how computer stores a number in its memory bits \\n\\nlet x = 13 , \\nthen its binary representation is  \\n#\\t\\t64 32 16 8 4 2 1\\n#\\t   ( 0   0 0 1 1 0 1 ) == ( 00001101 ) { 8+4+1 = 13}\\nnow lest see how  ( -13 )  is stored in binary\\n-> in order to store negative numbers , computer first flips all bits in its binary resentation of its absolute value\\n so 00001101 becomes 11110010\\n-> then computer adds a bit \\nso   11110010 + 00000001 = 11110011\\n\\nthis process of adding 1 bit by computer , lets us extract last set bit\\nlets see again in steps : \\n-> task : store -13 \\n#step 1 : abs | -13 |  = | 13 |  =  00001101\\n#step 2 : flip all bits          =  11110010\\n#step 3 : add one bit            =  11110010 + 00000001\\n#result :                        =  11110011\\n\\nNOW the question arises how do we use this FACT ? to extract last set bit \\nwe extract the last set bit and removes that bit in its binary rep\\n\\nto extract last set bit we do X bitwiseAND -X\\n13        = 00001101\\n-13       = 11110011\\n13&(-13)  = 00000001 \\n\\nnow we remove this from X (here 13)\\n13 = 00001101\\n - = 00000001\\n   = 00001100\\nso far so good , we have sucessfully removed last set bit\\n\\nnow you might have guessed the answer, lets denote 2 , 4, 64 in binary\\n     ( 64 32 16 8 4 2 1 )  this is what set bit in binary represents \\n   2 = 0  0\\t 0  0 0 1 0\\n   4 = 0  0  0  0 1 0 0\\n  64 = 1  0  0  0 0 0 0  \\n  \\n  so in case a no is power of two then the only one bit must be set in its binary representation . wallah ! we got the answer\\n  -> remove the last set bit\\n  -> look if no becomes zero\\n  -> if zero then it must be having only one set bit ie - it must have been the power of 2\\n\\nrecap :   x&(-x) : tells the last set bit\\n\\t  : x  = x - x&-x removes the last set bit\\n```\\nnow lets code \\n```\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)    return false;\\n        n-=(n&-n);\\n        return n==0;\\n    }\\n```\\nWelcome",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nlets see how computer stores a number in its memory bits \\n\\nlet x = 13 , \\nthen its binary representation is  \\n#\\t\\t64 32 16 8 4 2 1\\n#\\t   ( 0   0 0 1 1 0 1 ) == ( 00001101 ) { 8+4+1 = 13}\\nnow lest see how  ( -13 )  is stored in binary\\n-> in order to store negative numbers , computer first flips all bits in its binary resentation of its absolute value\\n so 00001101 becomes 11110010\\n-> then computer adds a bit \\nso   11110010 + 00000001 = 11110011\\n\\nthis process of adding 1 bit by computer , lets us extract last set bit\\nlets see again in steps : \\n-> task : store -13 \\n#step 1 : abs | -13 |  = | 13 |  =  00001101\\n#step 2 : flip all bits          =  11110010\\n#step 3 : add one bit            =  11110010 + 00000001\\n#result :                        =  11110011\\n\\nNOW the question arises how do we use this FACT ? to extract last set bit \\nwe extract the last set bit and removes that bit in its binary rep\\n\\nto extract last set bit we do X bitwiseAND -X\\n13        = 00001101\\n-13       = 11110011\\n13&(-13)  = 00000001 \\n\\nnow we remove this from X (here 13)\\n13 = 00001101\\n - = 00000001\\n   = 00001100\\nso far so good , we have sucessfully removed last set bit\\n\\nnow you might have guessed the answer, lets denote 2 , 4, 64 in binary\\n     ( 64 32 16 8 4 2 1 )  this is what set bit in binary represents \\n   2 = 0  0\\t 0  0 0 1 0\\n   4 = 0  0  0  0 1 0 0\\n  64 = 1  0  0  0 0 0 0  \\n  \\n  so in case a no is power of two then the only one bit must be set in its binary representation . wallah ! we got the answer\\n  -> remove the last set bit\\n  -> look if no becomes zero\\n  -> if zero then it must be having only one set bit ie - it must have been the power of 2\\n\\nrecap :   x&(-x) : tells the last set bit\\n\\t  : x  = x - x&-x removes the last set bit\\n```\n```\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)    return false;\\n        n-=(n&-n);\\n        return n==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64130,
                "title": "share-my-one-line-c",
                "content": "    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n>0 && !(n&(n-1));\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n>0 && !(n&(n-1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64110,
                "title": "1-line-python-solution",
                "content": "    def isPowerOfTwo(self, n):\\n        return (n>0) and (n & (n-1))==0",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def isPowerOfTwo(self, n):\\n        return (n>0) and (n & (n-1))==0",
                "codeTag": "Python3"
            },
            {
                "id": 64156,
                "title": "my-1-line-c-code",
                "content": "bool isPowerOfTwo(int n) {\\n  \\n    return (n>0) &&!(n&(n-1));\\n}",
                "solutionTags": [],
                "code": "bool isPowerOfTwo(int n) {\\n  \\n    return (n>0) &&!(n&(n-1));\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 64060,
                "title": "1ms-99-java-bitwise-solution",
                "content": "Example n = 8, bin(8) = 1000, bin(8-1) = 0111 \\n1000 & 0111 is 0 and powers of 2 are always 10(2), 100(4), 1000(8), 10000(16) and so on \\n\\n     public boolean isPowerOfTwo(int n) {\\n            if(n < 1) return false;\\n            return (0 == ((n - 1) & n));\\n        }",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "Example n = 8, bin(8) = 1000, bin(8-1) = 0111 \\n1000 & 0111 is 0 and powers of 2 are always 10(2), 100(4), 1000(8), 10000(16) and so on \\n\\n     public boolean isPowerOfTwo(int n) {\\n            if(n < 1) return false;\\n            return (0 == ((n - 1) & n));\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 64121,
                "title": "one-line-java-solution",
                "content": "    public class Solution {\\n    public boolean isPowerOfTwo(int n) {//if n is power  of  2 ,n just has one bit is 1\\n        return n>0 && (n&(n-1))==0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPowerOfTwo(int n) {//if n is power  of  2 ,n just has one bit is 1\\n        return n>0 && (n&(n-1))==0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1490703,
                "title": "simple-solution-with-explanation",
                "content": "If a number is in power of 2 it will have only 1 set bit i.e., the most significant bit\\n**Example:** \\n*  64: 1000000\\n*  16: 10000\\n\\nand when the number is subtracted by 1 results in all 1s. \\n**Example**:\\n*   8 - 1: 0111\\n*   2 - 1: 01\\n\\nNow we can use the property if bitwise and operator, which gives 0 if the set bits are opposite and while returning we just return ! (not) of the result.\\n\\nSuppose 8 is in power of 2 so 8 & 8-1 will result 0, so return 1 (true)\\n 1000 & 0111= 0000\\n \\n and consider a number not in power of 2, lets say 7\\n 7 & 7-1 will result in 1\\n 111 & 110 = 1, so just return !1 which is false\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        return !(n & (n-1));\\n    }\\n};\\n```\\n\\nIf you liked the solution please consider upvote.",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        return !(n & (n-1));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676826,
                "title": "java-easiest-solution-newbie-can-understand",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        long num=1;\\n        while(num<n){\\n            num*=2;\\n        }\\n          return num==n;  \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        long num=1;\\n        while(num<n){\\n            num*=2;\\n        }\\n          return num==n;  \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64004,
                "title": "5-lines-o-1-space-time-c-solution-no-hash",
                "content": "    class Solution { \\n    public: \\n        bool isPowerOfTwo(int n) { \\n            if (n <= 0) {\\n                return false;\\n            }\\n            n &= (n - 1);\\n            return n == 0;\\n        } \\n    };\\n\\nthe basic idea is that if n is a power of two, its binary form contains only one \"1\"\\nwelcome to visit more answers on github.com/fanfank/leetcode",
                "solutionTags": [],
                "code": "class Solution { \\n    public: \\n        bool isPowerOfTwo(int n) { \\n            if (n <= 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64076,
                "title": "one-line-c-solution",
                "content": "The number has to be greater than zero, and just one of its bits is set. Given `n`, computing `n - 1` flips all the trailing 0s and the last 1. So computing `n & (n - 1)` effectively clears the last 1 bit. And in this case that should give us zero if `n` is a power of 2. \\n\\n    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && !(n & (n - 1));\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && !(n & (n - 1));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 535221,
                "title": "js-one-liner-faster-than-98",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    return (Math.log2(n) % 1 === 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    return (Math.log2(n) % 1 === 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1474439,
                "title": "5-different-approaches-iterative-recursive-bitwise-two-1-liners",
                "content": "#### Solutions are sorted according to difficulty (ascending)\\n\\n##### Method 1: Iterative Solution (Runtime : 4ms , memory = 5.8 mb)\\n\\n```\\nbool isPowerOfTwo(int n) {\\n        if(n==0)\\n            return false;\\n        while(n!=1)\\n        {\\n            if(n%2!=0)\\n                return false;\\n            n = n/2;\\n        }\\n        return true;\\n    }\\n```\\n\\n##### Method 2: Recursive Solution (Runtime : 0ms , memory = 5.9 mb)\\n\\n```\\nbool isPowerOfTwo(int n) {\\n        if(n==1)\\n            return true;\\n        if(n%2!=0 || n==0)\\n            return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n```\\n\\n##### Method 3: Bitwise Solution (Runtime : 12ms , memory = 6 mb)\\n```\\nbool isPowerOfTwo(int n) {\\n    int count=0; \\n    while(n>0)\\n    {\\n        if((n & 1) == 1)\\n            count++;\\n        n = n >> 1;\\n    }\\n    return count == 1 ? true : false;\\n}\\n```\\n\\n##### Method 4: One Liner 1.0 (Runtime : 0ms , memory = 5.9 mb)\\n```\\nbool isPowerOfTwo(int n) {\\n        return n > 0 && !(n & (n-1));\\n```\\n\\n##### Method 5: One Liner 2.0 (Runtime : 0ms , memory = 6.2 mb)\\n```\\nbool isPowerOfTwo(int n) {\\n        return floor(log2(n)) == ceil(log2(n)) && n!=0 ? true : false;\\n    }\\n```\\n\\nUpvotes are appreciated!!",
                "solutionTags": [
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nbool isPowerOfTwo(int n) {\\n        if(n==0)\\n            return false;\\n        while(n!=1)\\n        {\\n            if(n%2!=0)\\n                return false;\\n            n = n/2;\\n        }\\n        return true;\\n    }\\n```\n```\\nbool isPowerOfTwo(int n) {\\n        if(n==1)\\n            return true;\\n        if(n%2!=0 || n==0)\\n            return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n```\n```\\nbool isPowerOfTwo(int n) {\\n    int count=0; \\n    while(n>0)\\n    {\\n        if((n & 1) == 1)\\n            count++;\\n        n = n >> 1;\\n    }\\n    return count == 1 ? true : false;\\n}\\n```\n```\\nbool isPowerOfTwo(int n) {\\n        return n > 0 && !(n & (n-1));\\n```\n```\\nbool isPowerOfTwo(int n) {\\n        return floor(log2(n)) == ceil(log2(n)) && n!=0 ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64073,
                "title": "java-solution-one-line",
                "content": "    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n        /**\\n         * There is two accepted answers,the former is better.\\n         */\\n        return n <= 0 ? false : (n & (n - 1)) == 0;\\n        // return n <= 0 ? false : n == Math.pow(2, (int) (Math.log(n) / Math.log(2)));\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n        /**\\n         * There is two accepted answers,the former is better.\\n         */\\n        return n <= 0 ? false : (n & (n - 1)) == 0;\\n        // return n <= 0 ? false : n == Math.pow(2, (int) (Math.log(n) / Math.log(2)));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2726139,
                "title": "js-bit-manipulation-with-explanation",
                "content": "To solve this problem, we can use the bitwise **\"&\"** operator. Performs an **AND** operation on each pair of bits.\\n\\nThe result of a & b is only one when both bits a and b are both one.\\n\\n![image](https://assets.leetcode.com/users/images/df7ff5b3-c161-4a54-8f1f-8454ecab84e1_1666279717.4933476.png)\\n\\nYou can also look at the picture below to understand the essence in more detail)\\n\\n![image](https://assets.leetcode.com/users/images/7877cc71-960f-40cb-b52b-86a48d8d853d_1666279789.3218956.png)\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 && (n & n - 1) === 0;\\n};\\n```\\n\\nI hope I was able to explain clearly.\\n**Happy coding!** \\uD83D\\uDE43\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 && (n & n - 1) === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2076471,
                "title": "java-simple-solution-with-explanation-brian-kernighan-s-algorithm",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return (n>0) && (n & n-1)==0;\\n    }\\n}\\n```\\n\\n# **See below for Explanation !!**\\n\\nAny number would be the power of two if it has only one 1 bit in binary representation.\\nFor example :\\n**2 -> 10\\n4 -> 100\\n8 -> 1000**\\n\\nNow ***Brian Kernighan\\u2019s*** Algorithm: \\n\\n*Subtracting 1 from a decimal number flips all the bits after the rightmost set bit(which is 1) hincluding the rightmost set bit. *\\n\\n**So if take example 8 (1000)**\\nnow 8-1= 7 (0111)\\nif we do 8 & 7\\n\\t1000\\n\\t0111\\n=0000\\n\\n**Now take example 6 (110)**\\nnow 6-1= 5 (101)\\nif we do 6 & 5\\n\\t110\\n\\t101\\n  =100\\n\\n**So we can say if  n & n-1==0 then it is the power of two**\\n\\n**Please like and upvote if you were able to get help from this explanation**",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return (n>0) && (n & n-1)==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 486497,
                "title": "python-3-one-line-code-bitwise-operation-98-53-100",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return not n&n-1 if n else False\\n```\\nNo need to say \\'if n>0\\' since \\'n&n-1\\' is also True for n < 0.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return not n&n-1 if n else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64173,
                "title": "one-line-java-solution",
                "content": "    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return ((n & n - 1) == 0 && n > 0);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return ((n & n - 1) == 0 && n > 0);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1199271,
                "title": "c-3-different-solutions",
                "content": "##### Solution 1: Bit Manipulation Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPowerOfTwo(int n) {\\n\\t\\t\\tif(n <= 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn (n & (n - 1)) == 0;\\n\\t\\t}\\n\\t};\\n\\n##### Solution 2: Recursive Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPowerOfTwo(int n) {\\n\\t\\t\\tif(n <= 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\tif(n == 1){\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tif(n % 2 != 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn isPowerOfTwo(n / 2);\\n\\t\\t}\\n\\t};\\n##### Solution 3: Log base 2 Solution\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isPowerOfTwo(int n) {\\n\\t\\t\\tif(n <= 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t\\treturn log2(n) == int(log2(n));\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isPowerOfTwo(int n) {\\n\\t\\t\\tif(n <= 0){\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 919981,
                "title": "python3-c-faster-than-99-93-100-count-1",
                "content": "If a number is power of 2, there exists 1 and only 1 bit-1 in the binary of this number, such as 0b10, 0b100, 0b1000.\\nCode in python 3:\\n**str.count(sub, start= 0,end=len(string))**: calculate the number of 1 in n(in binary form).\\nIt is also OK to use str.count() in python.\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and bin(n).count(\\'1\\') == 1\\n```\\n```\\nRuntime: 16 ms\\nMemory Usage: 14.1 MB\\n```\\n\\nCode in c++:\\n**__builtin_popcount**(n): calculate the number of 1 in n(in binary form).\\nNote that there are TWO _ before builtin and ONE _ after biultin.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 and __builtin_popcount(n) == 1;\\n    }\\n};\\n```\\n```\\nRuntime: 0 ms\\nMemory Usage: 6.2 MB\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and bin(n).count(\\'1\\') == 1\\n```\n```\\nRuntime: 16 ms\\nMemory Usage: 14.1 MB\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 and __builtin_popcount(n) == 1;\\n    }\\n};\\n```\n```\\nRuntime: 0 ms\\nMemory Usage: 6.2 MB\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998677,
                "title": "java-simple-solution-in-1-line-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\n\\n```java\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\n    return n > 0 && (n & (n - 1)) == 0;\\n    }\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       if(n <= 0) return false;\\n\\n       while(n > 1 && (n % 2) == 0 ) {\\n            n /= 2;\\n        }\\n\\n        return (n == 1 || n % 2 == 0)? true : false;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/30b93e96-e447-4ca5-ac70-814d3ac56a60_1693771365.7543771.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\n    return n > 0 && (n & (n - 1)) == 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       if(n <= 0) return false;\\n\\n       while(n > 1 && (n % 2) == 0 ) {\\n            n /= 2;\\n        }\\n\\n        return (n == 1 || n % 2 == 0)? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3441725,
                "title": "o-1-bit-manipulation-recursive-easy-solution-approaches",
                "content": "# Complexity\\n- Time Complexity : O(1)\\n- Space complexity : O(1)\\n```\\npublic boolean isPowerOfTwo(int n) {\\n        // Check if n is less than or equal to 0\\n        if (n <= 0) {\\n            return false; // n is not a power of two\\n        }\\n    \\n        // Check if n and (n-1) have no common set bits\\n        // A power of two will have only one bit set, and (n-1) will have all bits before it set\\n        if ((n & (n-1)) == 0) {\\n            return true; // n is a power of two\\n        } else {\\n            return false; // n is not a power of two\\n        } \\n    }\\n```\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/9a99e490-8d02-4c92-b945-bcebe2a34c3d_1687889450.482289.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(log n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // Check if n is 0, in which case it cannot be a power of 2, so return false\\n        if (n == 0) {\\n            return false;\\n        }\\n        \\n        // Check if n is 1, in which case it is a power of 2, so return true\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        // Check if n is odd, in which case it cannot be a power of 2, so return false\\n        if (n % 2 != 0) {\\n            return false;\\n        }\\n        \\n        // If n is even, recursively call the function with n/2 until n becomes 1 or an odd number\\n        return isPowerOfTwo(n / 2);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isPowerOfTwo(int n) {\\n        // Check if n is less than or equal to 0\\n        if (n <= 0) {\\n            return false; // n is not a power of two\\n        }\\n    \\n        // Check if n and (n-1) have no common set bits\\n        // A power of two will have only one bit set, and (n-1) will have all bits before it set\\n        if ((n & (n-1)) == 0) {\\n            return true; // n is a power of two\\n        } else {\\n            return false; // n is not a power of two\\n        } \\n    }\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // Check if n is 0, in which case it cannot be a power of 2, so return false\\n        if (n == 0) {\\n            return false;\\n        }\\n        \\n        // Check if n is 1, in which case it is a power of 2, so return true\\n        if (n == 1) {\\n            return true;\\n        }\\n        \\n        // Check if n is odd, in which case it cannot be a power of 2, so return false\\n        if (n % 2 != 0) {\\n            return false;\\n        }\\n        \\n        // If n is even, recursively call the function with n/2 until n becomes 1 or an odd number\\n        return isPowerOfTwo(n / 2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123088,
                "title": "bhai-dekho-hindi-mai-explain-kiya-hu-aur-easy-solution-hai-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBhaisahab yaha hmlog yeh jogar lga rahe hai ki agar koi number n hai aur\\n**2*2*2*2......=n** exist krta hai toh true return krna hai wrna false\\n\\n(example 1)\\nn=16\\n2^4=16 then\\noutput= TRUE\\n\\n(example 2)\\nn=5\\nthen their is no power of 2 that is equal to 5\\nisiliye\\noutput= FALSE\\n\\ntoh hmlog ek while loop lgaenge jisme check karenge ki kya number\\ndivisible by 2 hai agar hai toh loop mai number ko / 2 krdenge.\\ntoh agar wh number 2 ke power mai exist krta hai toh n ki last value 1\\nmilega jaise smjho \\nn=8 hai\\n8%2==0 hai so n = 8/2 hence n ki value 4 hogae\\nagain 4%2==0 hai so n=4/2 hence n ki value 2 hogae\\nagain 2%2==0 hai so n=2/2 hence n ki value 1 hogya\\n\\nab jb number n=1 hogya iska mtlb hai ki jo number hai usko 2 ke power mai\\nlikh sakte hai hence TRUE return krna hai\\n\\nyeh last example dekh lo pkka----\\n30%2==0 hai so n = 30/2 hence n ki value 15 hogae\\nab 15%2 !=0  hence loop se exit ho jaega\\n\\naur ab n!==1 kyo ki n ki last value toh 15 hai hence return FALSE\\n\\n \\n\\n\\n# Approach\\n\\nJo bhi tha Intution mai explain krdiye hai,like jarur krdena\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n    o (log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    o(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n<=0) return false;\\n        while(n%2==0){\\n            n/=2;\\n        }\\n        return n==1;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n<=0) return false;\\n        while(n%2==0){\\n            n/=2;\\n        }\\n        return n==1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1343715,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n      // do n/2 repeatedly and check n%2 == 0 for each recursive call\\n        \\n       \\n        \\n        if(n<=0)\\n            return false;\\n        \\n        if(n==1)\\n            return true;\\n        \\n        \\n       return (n%2==0 && isPowerOfTwo(n/2));\\n        \\n     \\n    }\\n}\\n```\\n\\n**Please Upvote if this solution helped you !**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n      // do n/2 repeatedly and check n%2 == 0 for each recursive call\\n        \\n       \\n        \\n        if(n<=0)\\n            return false;\\n        \\n        if(n==1)\\n            return true;\\n        \\n        \\n       return (n%2==0 && isPowerOfTwo(n/2));\\n        \\n     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230095,
                "title": "231-solution-with-strep-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem asks us to determine if an integer n is a power of two, meaning if there exists an integer x such that n == 2^x.\\n\\nThe function isPowerOfTwo takes an integer n as input and returns True if it is a power of two, and False otherwise.\\n\\nThe first line of the function checks if n is negative. If it is, then n cannot be a power of two and the function returns False.\\n\\nThe second line converts the integer n to a binary string using the bin function. For example, bin(16) returns \\'0b10000\\'.\\n\\nThe third line counts the number of \\'1\\'s in the binary string using the count method. If there is only one \\'1\\', then n is a power of two and the function returns True. Otherwise, n is not a power of two and the function returns False.\\n\\nOverall, this solution has a time complexity of O(log n) due to the conversion to binary string, and a space complexity of O(1).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def isPowerOfTwo(self, n: int) -> bool:\\n    return False if n < 0 else bin(n).count(\\'1\\') == 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n  def isPowerOfTwo(self, n: int) -> bool:\\n    return False if n < 0 else bin(n).count(\\'1\\') == 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64145,
                "title": "one-line-4ms-c-solution",
                "content": "    bool isPowerOfTwo(int n) {\\n     return (int)log2(n)==log2(n);\\n    }",
                "solutionTags": [],
                "code": "    bool isPowerOfTwo(int n) {\\n     return (int)log2(n)==log2(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64171,
                "title": "possible-solutions",
                "content": "I had been asked this question twice during the recrutation to two different companies.\\n\\nIt can be solved with couple possible ways:\\n\\n----------\\n\\nO(lg N) solution \\n\\nSimply divide the input number as long as it's dividable by 2.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n    \\n            while(n > 1) {\\n                if(n % 2 != 0) {\\n                    return false;\\n                }\\n                n /= 2;\\n            }\\n            return n == 1;\\n    }\\n\\n----------\\n\\nO(1) solution\\n\\nThis uses a bit of binary math and simple observation that if you have a power of 2 in binary then when you substract 1 from it you will have all lower order bits set to 1. ex. 8 in binary 1000 - 1 = 0111 so by doing AND of both values (N & (N - 1)) you should expect the result to be 0. This is only true for values that are the power of two.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n               \\n                return n > 0 && (n & n - 1) == 0;\\n    }\\n\\n----------\\n\\nO(1) - this can be considered constant, although it will vary on the actual type size and generally offer worse performance then both above solutions - (well we have to distinguish worse and best case - the base case is when the number is not power of 2, but the worse case is the oposite and we have to check all the bits of the input to verify that)\\n\\nAnother possibility is shifting and counting the number of ones.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n    \\n            int count = 0;\\n            for(int ind = 0; ind < 32; ind++) {\\n                if((n & (1 << ind)) != 0) {\\n                    count++;\\n                }\\n            }\\n            return n > 0 && count == 1;\\n    }",
                "solutionTags": [],
                "code": "I had been asked this question twice during the recrutation to two different companies.\\n\\nIt can be solved with couple possible ways:\\n\\n----------\\n\\nO(lg N) solution \\n\\nSimply divide the input number as long as it's dividable by 2.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n    \\n            while(n > 1) {\\n                if(n % 2 != 0) {\\n                    return false;\\n                }\\n                n /= 2;\\n            }\\n            return n == 1;\\n    }\\n\\n----------\\n\\nO(1) solution\\n\\nThis uses a bit of binary math and simple observation that if you have a power of 2 in binary then when you substract 1 from it you will have all lower order bits set to 1. ex. 8 in binary 1000 - 1 = 0111 so by doing AND of both values (N & (N - 1)) you should expect the result to be 0. This is only true for values that are the power of two.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n               \\n                return n > 0 && (n & n - 1) == 0;\\n    }\\n\\n----------\\n\\nO(1) - this can be considered constant, although it will vary on the actual type size and generally offer worse performance then both above solutions - (well we have to distinguish worse and best case - the base case is when the number is not power of 2, but the worse case is the oposite and we have to check all the bits of the input to verify that)\\n\\nAnother possibility is shifting and counting the number of ones.\\n\\n----------\\n\\n    public boolean isPowerOfTwo(int n) {\\n    \\n            int count = 0;\\n            for(int ind = 0; ind < 32; ind++) {\\n                if((n & (1 << ind)) != 0) {\\n                    count++;\\n                }\\n            }\\n            return n > 0 && count == 1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64184,
                "title": "c-solution-with-bitset",
                "content": "    if(n < 0) return false;\\n    bitset<32> b(n);\\n    return b.count() == 1;",
                "solutionTags": [],
                "code": "    if(n < 0) return false;\\n    bitset<32> b(n);\\n    return b.count() == 1;",
                "codeTag": "Unknown"
            },
            {
                "id": 64185,
                "title": "one-line-java-solution-using-n-n-1",
                "content": "n & (n-1) will turn off the rightmost bit of a integer.\\n(see http://www.catonmat.net/blog/low-level-bit-hacks-you-absolutely-must-know/)\\n\\nActually I met this one in the onsite interview of Teradyne...\\n\\n    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n > 0 && (n & (n - 1)) == 0;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n > 0 && (n & (n - 1)) == 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3286637,
                "title": "beats-100-1ms-one-line-solution-detailed-explanation-with-examples-java-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem of determining whether a given integer is a power of two or not can be solved using the binary representation of the integer.\\n\\nA power of two can be represented as a binary number that has only one bit set to 1. For example, 2^3 = 8 is represented as 0b1000, which has only one bit set to 1.\\n\\nOn the other hand, a non-power of two integer will have more than one bit set to 1 in its binary representation. For example, 6 is represented as 0b0110, which has two bits set to 1.\\n\\nUsing this insight, we can develop an algorithm to determine whether a given integer is a power of two or not. The algorithm involves checking whether the given integer has only one bit set to 1 in its binary representation. We can do this by performing a bitwise AND operation between the integer and its decrement (i.e., n-1), which clears the rightmost set bit of the number. If the result of the bitwise AND operation is 0, then the original number was a power of two.\\n\\nOverall, the problem of determining whether an integer is a power of two or not can be solved efficiently using bitwise operations and the binary representation of the integer.\\n\\n# Approach\\nThe approach used in the code is based on the fact that a power of two has only one bit set in its binary representation. For example, 2^3 = 8 is represented as 0b1000 (in binary) which has only one bit set to 1.\\n\\nHere\\'s how the code works:\\n\\n- First, it checks if the given integer n is greater than 0. If n is not greater than 0, it cannot be a power of two.\\n- Next, it checks if the bitwise AND operation between n and n-1 is equal to 0. This operation clears the rightmost 1 bit in n. If the result is 0, then it means that there was only one bit set in n (i.e., n was a power of 2).\\n\\nFor example, let\\'s take n = 8 (which is 2^3). The binary representation of 8 is 0b1000. If we subtract 1 from 8, we get 7 which is represented as 0b0111. Now, if we do the bitwise AND operation between 8 and 7, we get 0b0000 which is equal to 0. This means that 8 is a power of 2.\\n\\nSimilarly, let\\'s take n = 6. The binary representation of 6 is 0b0110. If we subtract 1 from 6, we get 5 which is represented as 0b0101. Now, if we do the bitwise AND operation between 6 and 5, we get 0b0100 which is not equal to 0. This means that 6 is not a power of 2.\\n\\nTherefore, the code returns true if n is a power of 2, and false otherwise.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- The code consists of a single line, which involves two operations: a comparison and a bitwise AND.\\n- Both of these operations take constant time, regardless of the size of the input.\\n- Therefore, the time complexity of the code is O(1), which is constant time complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The code only uses a single integer variable to store the input value n.\\n- Therefore, the space complexity of the code is O(1), which is constant space complexity.\\n\\n# Code\\n\\n```python3 []\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return (n>0) and (n & n-1 == 0)\\n```\\n\\n```java []\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n         return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/eb0272a3-e9e4-4592-84a8-16353e35b407_1678595390.6430748.png)\\n\\n---\\n\\n# Connect\\nLinkedIn : www.linkedin.com/in/akashjana\\n\\n---\\n#### Please consider upvoting if you find this helpful. Thank You :)\\n![image.png](https://assets.leetcode.com/users/images/f36a288e-bdb7-4264-b2d5-8d7275e29330_1678259367.2213438.png)",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return (n>0) and (n & n-1 == 0)\\n```\n```java []\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n         return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079713,
                "title": "javascript-simple-upvote-if",
                "content": "```\\nvar isPowerOfTwo = function(n) {\\n    let x = 0;\\n    while (2**x < n) {\\n        x++;\\n    }\\n    return 2**x === n;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPowerOfTwo = function(n) {\\n    let x = 0;\\n    while (2**x < n) {\\n        x++;\\n    }\\n    return 2**x === n;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2579875,
                "title": "100-fastest-0ms-one-line-solution",
                "content": "\\n    bool isPowerOfTwo(int n) {\\n        if(n<1) return 0;\\n        if((n&(n-1))==0) return 1;\\n        return 0;\\n    }\\n\\n**Explanation:**\\n/*\\t\\n4 100\\n3 011\\n000 ans =true\\n \\n16 10000\\n15 01111   \\n   00000 ans =true\\n   \\n3 011\\n2 010\\n  010   ans=False\\n*/",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "\\n    bool isPowerOfTwo(int n) {\\n        if(n<1) return 0;\\n        if((n&(n-1))==0) return 1;\\n        return 0;\\n    }\\n\\n**Explanation:**\\n/*\\t\\n4 100\\n3 011\\n000 ans =true\\n \\n16 10000\\n15 01111   \\n   00000 ans =true\\n   \\n3 011\\n2 010\\n  010   ans=False\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 1639304,
                "title": "c-two-simple-and-short-solutions-explained",
                "content": "**Solution I - Recursive**\\n```\\nclass Solution {\\npublic:\\n    // function to do the same - just that can accept floats\\n    bool double_isPowerOfTwo(double n){\\n        if (n == 1) return true;\\n        else if ((n < 1) || (n != int(n))) return false;\\n        return double_isPowerOfTwo(n/2);\\n    }\\n    \\n    bool isPowerOfTwo(int n) {\\n        return double_isPowerOfTwo(n);\\n    }\\n};\\n```\\n**Solution II - Bit Manipulation**\\n```\\nclass Solution {\\npublic:\\n    // a number that is a power of two, bitwise representation is 100...0\\n    // the number before it will always be 011...1\\n    // so if we use AND between them, it will always come out zero.\\n    // if n >= 0 the trick won\\'t work, but it\\'s always false anyways.\\n    bool isPowerOfTwo(int n) {\\n        return (n > 0) && !(n & n-1);\\n    }\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // function to do the same - just that can accept floats\\n    bool double_isPowerOfTwo(double n){\\n        if (n == 1) return true;\\n        else if ((n < 1) || (n != int(n))) return false;\\n        return double_isPowerOfTwo(n/2);\\n    }\\n    \\n    bool isPowerOfTwo(int n) {\\n        return double_isPowerOfTwo(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    // a number that is a power of two, bitwise representation is 100...0\\n    // the number before it will always be 011...1\\n    // so if we use AND between them, it will always come out zero.\\n    // if n >= 0 the trick won\\'t work, but it\\'s always false anyways.\\n    bool isPowerOfTwo(int n) {\\n        return (n > 0) && !(n & n-1);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639231,
                "title": "possible-approaches-worst-to-best",
                "content": "# Approach 1 (Primality)\\nTo ensure a number is Power of 2, it should have 2 as the only Prime factor. If we can assure this, we can ensure that our Number is Power of 2. This might not work for bigger numbers as we would have to get all factors and check for primality, resulting in very bad time and space complexities.\\n\\n# Approach 2 (Divisibility)\\nNumbers that are Power of 2 will be divisible by two unless it reaches 1. So we can keep dividing the number by 2 unless we get 1. If we encounter an remainder in the process, it makes our assumption void and the number isn\\'t a power of 2.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        while(n>1){\\n            if(n%2==1){\\n                return false;\\n            }\\n            else{\\n                n/=2;\\n            }\\n        }\\n        return (n==1);\\n    }\\n};\\n```\\n# Approach 3 (Math)\\nPowers of 2, give whole number result on calculating their Logarithm with base 2. So we can use this for our case.\\nWe already rule out cases where n<=0, to avoid mathematical errors.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return log2(n)== (int)log2(n);\\n    }\\n};\\n```\\n# Approach 4 ( Bit Manipulation - I )\\nBit Manipulation refers to using the Binary equivalent of a number to get our result. For powers of 2 , we can infer that their Binary representation will always have only one 1. (i.e. one set-bit).\\nSo, we may find the binary and count the number of 1s in the form.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)return false; // base condition\\n        int set_bits=0;\\n        while(n){\\n            int r=n%2;\\n            if(r)set_bits++;\\n            n/=2;\\n        }\\n        return (set_bits==1);\\n    }\\n};\\n```\\n# Approach 5 (Bit Manipulation II - C++ One liner)\\nWe can use **builtin_popcount()** method given with C++ compiler to directly get the number of set-bits from a given input number.\\nUsing Ternary operator makes it even lesser to code **;-)** \\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return (n>0?__builtin_popcount(n)==1:false);\\n    }\\n};\\n```\\n# Approach 6 (Bit Manipulation - III )\\nConsider any Power of 2, say 8. \\nBinary representation of 8 is **1000** .\\nNow lets see Binary representation of n-1, i.e 7 , which is **0111**\\nSo, on performing N & (N-1), we should have Zero as output if our N is a power of 2.\\nFor any non-power of 2, we will always get a value other than Zero (i.e. 5 & 4 = 4).\\nSo it is a valid test .\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        return ((n & (n-1)) == 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math",
                    "Bit Manipulation",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        while(n>1){\\n            if(n%2==1){\\n                return false;\\n            }\\n            else{\\n                n/=2;\\n            }\\n        }\\n        return (n==1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return log2(n)== (int)log2(n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)return false; // base condition\\n        int set_bits=0;\\n        while(n){\\n            int r=n%2;\\n            if(r)set_bits++;\\n            n/=2;\\n        }\\n        return (set_bits==1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return (n>0?__builtin_popcount(n)==1:false);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        return ((n & (n-1)) == 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677042,
                "title": "rust-3-solutions-explained-one-o-log-n-and-two-o-1-one-liners-0-ms-faster-than-100",
                "content": "### Brute force\\n\\nWe compute all powers of two until we have found one greater than or equal to `n`.\\nIf it is equal, then `n` is a power of two, otherwise, it isn\\'t.\\nN.B.: this solution works for negative values of `n` as `n <= 0 < 1 = 2^0`. \\n\\n```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        let mut i = 0;\\n        while 2_i32.pow(i) < n {\\n            i += 1;\\n        }\\n        2_i32.pow(i) == n\\n    }\\n}\\n```\\n\\n##### Performance\\n\\nWhile the above `O(log(n))` solution is accepted in other languages (e.g. Python), in Rust, it fails with:\\n\\n> Time Limit Exceeded\\n\\nLet\\'s try to optimise this.\\n\\n### Counting bits\\n\\nWe can observe that if the bitwise representation of a _positive_ integer only has one bit set to 1, then it is a power of two, e.g.:\\n\\n```\\n8 = 1000\\n4 = 0100\\n2 = 0010\\n1 = 0001\\n```\\n\\nNote that negative integers have an additional bit set to 1 to encode their sign, so we need to check for that explicitly. This yields the following `O(1)` solution:\\n\\n```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        n > 0 && n.count_ones() == 1\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 0 ms, faster than 100.00% of Rust online submissions for Power of Two.\\n\\n### Bitwise AND\\n\\nWe can observe that a power of two and its previous value have no bit in common, hence `&`-ing them should yield zero, e.g.:\\n\\n```\\n8 = 1000\\n7 = 0111\\n  & ----\\n    0000\\n```\\n\\nThis yields the following `O(1)` solution:\\n\\n```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        n > 0 && (n & (n - 1)) == 0\\n    }\\n}\\n```\\n\\n##### Performance\\n\\n> Runtime: 0 ms, faster than 100.00% of Rust online submissions for Power of Two.\\n",
                "solutionTags": [
                    "Rust",
                    "Bit Manipulation"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        let mut i = 0;\\n        while 2_i32.pow(i) < n {\\n            i += 1;\\n        }\\n        2_i32.pow(i) == n\\n    }\\n}\\n```\n```\\n8 = 1000\\n4 = 0100\\n2 = 0010\\n1 = 0001\\n```\n```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        n > 0 && n.count_ones() == 1\\n    }\\n}\\n```\n```\\n8 = 1000\\n7 = 0111\\n  & ----\\n    0000\\n```\n```rust\\nimpl Solution {\\n    pub fn is_power_of_two(n: i32) -> bool {\\n        n > 0 && (n & (n - 1)) == 0\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64062,
                "title": "one-line-python-solution-use-bitcount",
                "content": "    class Solution(object):\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and bin(n).count('1') == 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def isPowerOfTwo(self, n):\\n        return n > 0 and bin(n).count('1') == 1",
                "codeTag": "Java"
            },
            {
                "id": 64099,
                "title": "java-solution-with-explanation",
                "content": "public class Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0){ return false;}\\n        int m = -n; \\n// m is completely different with n except the last position of 1. \\n\\n// For example if n = 5, i.e., 0000 0101, m would be 1111 1011\\n\\n        m &= n;// m only have the last digit of n to be 1.\\n        return m == n; \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0){ return false;}",
                "codeTag": "Java"
            },
            {
                "id": 3466309,
                "title": "bitwise-manipulation-approach-o-1",
                "content": "# Approach\\n- The first line of the method checks if the input integer \"n\" is less than or equal to 0. If it is, the method immediately returns \"false\" because 0 and negative numbers cannot be powers of two.\\n\\n- If \"n\" is greater than 0, the method proceeds to the next line. This line performs a bitwise AND operation between \"n\" and \"n-1\". The bitwise AND operator (&) compares the binary representation of the two operands and returns a new binary number where each bit is 1 only if the corresponding bits in both operands are also 1.\\n\\n- If \"n\" is a power of two, it will only have a single 1 bit in its binary representation. For example, 2 (10 in binary) and 8 (1000 in binary) are both powers of two. In contrast, 3 (11 in binary) and 5 (101 in binary) are not powers of two.\\n\\n- When we subtract 1 from a power of two, we get a binary number with all 1\\'s up to the position of the original 1, and then all 0\\'s after that. For example, if we subtract 1 from 8 (1000 in binary), we get 7 (111 in binary).\\n\\n- When we perform a bitwise AND operation between a power of two and one less than it, we get a result that has all 0\\'s except for the bit that represents the power of two. For example, if we perform the operation (8 & 7), we get 0 (0000 in binary) because all the bits except for the one that represents 8 are 0.\\n\\n- Therefore, if the result of the bitwise AND operation between \"n\" and \"n-1\" is equal to 0, then \"n\" must be a power of two. If the result is not 0, then \"n\" is not a power of two.\\n\\nThe method returns \"true\" if \"n\" is a power of two and \"false\" otherwise.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }\\n        return (n & (n - 1)) == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }\\n        return (n & (n - 1)) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468428,
                "title": "javascript-solution-faster-and-less-than-85",
                "content": "```\\nconst isPowerOfTwo = n => {\\n    while(n > 1){\\n        n /= 2\\n    }\\n    \\n    return n === 1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isPowerOfTwo = n => {\\n    while(n > 1){\\n        n /= 2\\n    }\\n    \\n    return n === 1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1638963,
                "title": "power-of-two-2-approach-100-java",
                "content": "**Approach 1 : Bit Manipulation**\\nclass Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }\\n\\n        return (n & n - 1) == 0;\\n    }\\n}\\n\\n**Approach 2 : Logarithmic Property**\\n*explain property* -\\ny = 2^x\\ntake log on both sides\\nlog(y) = log(2^x) -> log(y) = x log(2)\\nthen, x = log(y) / log(2)\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n      \\n        if(n <= 0)\\n            return false;\\n\\t\\t\\t\\n\\t\\t# find x value by dividing log of n and log 2.\\n\\t\\t\\n        double x = Math.log(n)/ Math.log(2);\\n\\t\\t\\n\\t\\t# Once we get the x, we can calculate the exact power of it and see if that matches input.\\n\\t\\t# If it does, return true, else return false.\\n\\t\\t# converting to int, because it\\'ll give float value. So to round it off, we are type casting it to int.\\n\\t\\n        return Math.pow(2,(int)x) == n;\\n    }\\n}\\n\\n**Please help to UPVOTE if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\nHAPPY CODING :)\\nLOVE CODING :)**",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\n\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1338827,
                "title": "simple-python-solution-for-power-of-two",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if (n == 0):\\n            return False\\n        while (n != 1):\\n            if (n % 2 != 0):\\n                return False\\n            n = n // 2\\n\\n        return True",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if (n == 0):\\n            return False\\n        while (n != 1):\\n            if (n % 2 != 0):\\n                return False\\n            n = n // 2\\n\\n        return True",
                "codeTag": "Java"
            },
            {
                "id": 3858949,
                "title": "bit-minuplation-beats-99-9-submissions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe first thought is just by keep dividing the number by 2 until we cannot and check if the number is 1. If the number at the last is 1 return True otherwise false. This takes O(logn) time complexity.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can minimize the solution by using bitwise operators.\\nLet\\'s assume that n is power of two, it will have 1 only at the most significant bit and all others are 0. The number n-1 will have 1 digit less than n.\\nSo if we perform AND operation of n and n-1 we will get answer as 0 as the only digit in n which is 1 will ANDed with 0.\\n\\n![PowerOfTwo.png](https://assets.leetcode.com/users/images/72c41513-0318-4cf8-b193-75937e93e61e_1691077712.4423854.png)\\n\\n\\n# Complexity\\n- Time complexity: O(1)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```python []\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and n & (n - 1) == 0\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return n > 0 && (n & (n - 1)) == 0;\\n    }\\n}\\n```\\n\\n```C++ []\\nclass Solution {\\n    public:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && (n & (n - 1)) == 0;\\n    }\\n};\\n```\\n\\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function isPowerOfTwo($n) {\\n        return $n > 0 && ($n & ($n - 1)) === 0;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "PHP",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```python []\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and n & (n - 1) == 0\\n```\n```Java []\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return n > 0 && (n & (n - 1)) == 0;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\n    public:\\n    bool isPowerOfTwo(int n) {\\n        return n > 0 && (n & (n - 1)) == 0;\\n    }\\n};\\n```\n```PHP []\\nclass Solution {\\n\\n    /**\\n     * @param Integer $n\\n     * @return Boolean\\n     */\\n    function isPowerOfTwo($n) {\\n        return $n > 0 && ($n & ($n - 1)) === 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1987363,
                "title": "simple-recursion-python",
                "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        if n == 1:\\n            return True\\n        \\n        if n < 1:\\n            return False\\n        \\n        return self.isPowerOfTwo(n/2)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        if n == 1:\\n            return True\\n        \\n        if n < 1:\\n            return False\\n        \\n        return self.isPowerOfTwo(n/2)",
                "codeTag": "Java"
            },
            {
                "id": 1302254,
                "title": "java-1ms-solution",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 0)\\n            return false;\\n        if(n==1)\\n            return true;\\n        if(n%2 == 1)\\n            return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 0)\\n            return false;\\n        if(n==1)\\n            return true;\\n        if(n%2 == 1)\\n            return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676942,
                "title": "java-n-n-1-explained-2-line-solution",
                "content": "( n & ( n - 1 ) ) Flips the right-most Set bit of the number n\\nif there is only 1 set bit than  ( n & ( n - 1 ) ) = 0;\\n\\n```\\nExamples :\\n* represents the numbers which are power of 2\\n ---------- binary-------- \\n\\tn    n     n-1   n&(n-1)\\n\\t--  ----   ----   -------\\n*   0   0000   0111    0000 *\\n*   1   0001   0000    0000 *\\n*   2   0010   0001    0000 *\\n\\t3   0011   0010    0010\\n*   4   0100   0011    0000 *\\n\\t5   0101   0100    0100\\n\\t6   0110   0101    0100\\n\\t7   0111   0110    0110\\n*   8   1000   0111    0000 *\\n\\t9   1001   1000    1000\\n\\t10   1010   1001    1000\\n\\t11   1011   1010    1010\\n\\t12   1100   1011    1000\\n\\t13   1101   1100    1100\\n\\t14   1110   1101    1100\\n\\t15   1111   1110    1110\\n```\\n\\nDO UPVOTE IF THIS HELPS\\n\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return (n & (n-1)) == 0;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nExamples :\\n* represents the numbers which are power of 2\\n ---------- binary-------- \\n\\tn    n     n-1   n&(n-1)\\n\\t--  ----   ----   -------\\n*   0   0000   0111    0000 *\\n*   1   0001   0000    0000 *\\n*   2   0010   0001    0000 *\\n\\t3   0011   0010    0010\\n*   4   0100   0011    0000 *\\n\\t5   0101   0100    0100\\n\\t6   0110   0101    0100\\n\\t7   0111   0110    0110\\n*   8   1000   0111    0000 *\\n\\t9   1001   1000    1000\\n\\t10   1010   1001    1000\\n\\t11   1011   1010    1010\\n\\t12   1100   1011    1000\\n\\t13   1101   1100    1100\\n\\t14   1110   1101    1100\\n\\t15   1111   1110    1110\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        return (n & (n-1)) == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184262,
                "title": "java-simple-solution-with-detailed-explaination",
                "content": "Originially I wanted to use logs to solve this like so:\\n\\n```java\\n        double val = Math.log(n) / Math.log(2);\\n        return (val == Math.floor(val));\\n```\\n\\n but as n get\\'s larger there ends up being too large of a precision error such as where `n = 536870912`\\n\\n```sh\\njshell> Math.log(536870912) / Math.log(2)\\n$5 ==> 29.000000000000004\\n```\\n\\nTherefore you need to use a bit trick to solve this:\\n\\n```\\n    public boolean isPowerOfTwo(int n) {\\n        if (n == 0 || n == Integer.MIN_VALUE) return false;\\n        return (n & (n - 1)) == 0;\\n    }\\n```\\n\\nThe reason why this works is because all powers of two in binary have the form of a 1 followed by any number of zeros and this minus one will be a number of 1\\'s equal to the number of zeros EXCEPT in the case that n is zero or the minimum value:\\n```\\n1: 1              0:   0\\n2: 10             1:   1\\n4: 100            3:   11\\n8: 1000           7:   111\\n16: 10000        15:   1111\\n```\\n\\n`&-ing` these numbers will always end up with zero:\\n```\\n10000\\n01111 &\\n______\\n00000\\n```",
                "solutionTags": [],
                "code": "```java\\n        double val = Math.log(n) / Math.log(2);\\n        return (val == Math.floor(val));\\n```\n```sh\\njshell> Math.log(536870912) / Math.log(2)\\n$5 ==> 29.000000000000004\\n```\n```\\n    public boolean isPowerOfTwo(int n) {\\n        if (n == 0 || n == Integer.MIN_VALUE) return false;\\n        return (n & (n - 1)) == 0;\\n    }\\n```\n```\\n1: 1              0:   0\\n2: 10             1:   1\\n4: 100            3:   11\\n8: 1000           7:   111\\n16: 10000        15:   1111\\n```\n```\\n10000\\n01111 &\\n______\\n00000\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64080,
                "title": "short-and-simple-java-solution",
                "content": "    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            if (n <= 0){\\n                return false;\\n            }\\n            else if ((n & (n - 1)) == 0){\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            if (n <= 0){\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64144,
                "title": "one-line-python-solution",
                "content": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            return n > 0 and (n & (n - 1)) == 0",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            return n > 0 and (n & (n - 1)) == 0",
                "codeTag": "Java"
            },
            {
                "id": 3460941,
                "title": "python3-solutions-with-explanation-bit-manipulation-iterative",
                "content": "Relying on the fact that the binary representation of a power of two contains **only one \\'1\\' bit** followed by zeros. Counting the number of \\'1\\' bits in a binary string gives us the ability to determine whether the number is a power of two or not.\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return bin(n).count(\\'1\\') == 1 if n > 0 else False\\n```\\nThe same logic, but instead of bin().count() we use **bitwise AND operation**: result of the bitwise AND operation between a number and its complement will always be 0. If the result is not 0, then the number is not a power of 2 because it has at least one bit set to \\'1\\' that is not the least significant bit.\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n & (n - 1) == 0 and n > 0\\n```\\nAnd one could say brute force **iterative** solution:\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n:\\n            if n == 1:\\n                return True\\n            elif n % 2 == 0:\\n                n /= 2\\n            else:\\n                return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return bin(n).count(\\'1\\') == 1 if n > 0 else False\\n```\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n & (n - 1) == 0 and n > 0\\n```\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n:\\n            if n == 1:\\n                return True\\n            elif n % 2 == 0:\\n                n /= 2\\n            else:\\n                return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229794,
                "title": "best-c-3-solution-bit-manipulation-iterative-recursive-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question using Multiple Approaches. (Here I have explained all the possible solutions of this problem).\\n\\n1. Solved using Recursive Approach.\\n2. Solved using Iterative Approach.\\n3. Solved using Bit Manipulation.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the all the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is given in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is given in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN).\\n    \\n    Solved using Recursive Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        else if(n==1){\\n            return true;\\n        }\\n        return n%2==0 && isPowerOfTwo(n/2);   \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Iterative Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n%2 == 0){\\n            n /= 2;\\n        }\\n        return n==1;   \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return (n > 0) && (n & (n-1)) == 0;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(logN).\\n    \\n    Solved using Recursive Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        else if(n==1){\\n            return true;\\n        }\\n        return n%2==0 && isPowerOfTwo(n/2);   \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(logN).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Iterative Approach.\\n\\n*/\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n%2 == 0){\\n            n /= 2;\\n        }\\n        return n==1;   \\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(1).\\n\\n    Space Complexity : O(1).\\n    \\n    Solved using Bit Manipulation.\\n\\n*/\\n\\n\\n/***************************************** Approach 3 *****************************************/\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        return (n > 0) && (n & (n-1)) == 0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826450,
                "title": "the-most-comprehensive-explanation-javascript-o-1",
                "content": "Hey there,\\n\\nI would like to share multiple ways to approach this problem:\\n\\n### **1. Using bit manipulation**\\nFirst of all, If we check how powers of 2 are represented in the binary format, we can quickly notice that:\\n```\\n1 = 1\\n2 = 10\\n4 = 100\\n8 = 1000\\n16 = 10000\\n```\\n\\nThey all have **1 bit** of the left side and the **rest are zeros.**\\n\\nGiven that, we can assume that if we **substract 1**  from that number, the leftmost **1 bit** will become **0** and the **rest** will become **1**.\\nFor example:\\n**1**0000 will become\\n**0**1111\\n\\nSo, they look sort of **inverted**\\nNow, if we just try to find any **common bits (&)** between them, there should be **none**.\\n\\nE.g:\\n`10000` \\n&\\n`01111`\\nwil be\\n`00000`\\n\\nIf there is no **common bits**, it means it\\'s a power of 2, otherwise not.\\n\\nIn JavaScript, implementation might look like this:\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 0) {\\n        return false;\\n    }\\n    \\n    return (n & (n -1)) === 0\\n};\\n```\\n\\nHere is little nuance, 32-bits (`01111111111111111111111111111111`) can represend up-to `2147483647`.\\nTo hold larger numbers we have to use data-structures that uses more bits, like `long`\\nIn JavaScript, we have **[BigInt](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt)**\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    n = BigInt(n)\\n    if (n == 0) {\\n        return false;\\n    }\\n    \\n    return (n & (n - BigInt(1))) === BigInt(0)\\n};\\n```\\n\\nTime: O(1)\\nSpace: O(1)\\n\\n### **2. Using logarithm**\\n\\nIn mathematics, the logarithm is the inverse function to exponentiation.\\nIt\\'s essentially tells to which **power** we needs to put the **base** to get the **target** number.\\n\\n**Examples:**\\nLog2(4) means to which **power** we need to put 2(base) to get 4 (target) which is 2\\nLog2(8) means to which **power** we need to put 2(base) to get 8 (target) which is 3\\n\\nSo, base on it, we can assume, if `Log2(N)` returns an **interger** number, it\\'s a power of 2.\\nIf it returns rational number, it means it\\'s not.\\n\\nJavaScript implementation might look like this:\\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 1) {\\n        return true;\\n    }\\n   let power = Math.log2(n)\\n   return power === parseInt(power, 10)\\n};\\n```\\nTime: O(1) - assuming that log2 uses a hardcoded table of values\\nSpace: O(1)\\n\\n\\nI hope it was helpful.\\nI would appreciate if you could upvote it if you find this useful.\\nThanks!",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "```\\n1 = 1\\n2 = 10\\n4 = 100\\n8 = 1000\\n16 = 10000\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 0) {\\n        return false;\\n    }\\n    \\n    return (n & (n -1)) === 0\\n};\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n    n = BigInt(n)\\n    if (n == 0) {\\n        return false;\\n    }\\n    \\n    return (n & (n - BigInt(1))) === BigInt(0)\\n};\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n    if (n == 1) {\\n        return true;\\n    }\\n   let power = Math.log2(n)\\n   return power === parseInt(power, 10)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1621364,
                "title": "using-recursion-100-0ms-90-5-8mb",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==1 || n==2 ) return true;\\n        if(n==0) return false;\\n        if(n%2!=0) return false;\\n        \\n        return isPowerOfTwo(n/2);\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==1 || n==2 ) return true;\\n        if(n==0) return false;\\n        if(n%2!=0) return false;\\n        \\n        return isPowerOfTwo(n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322411,
                "title": "python-one-liner-soln",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        return n!=0 and (n<<1)-1 == (n^(n-1))\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        return n!=0 and (n<<1)-1 == (n^(n-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 229001,
                "title": "javascript",
                "content": "**\\u65B9\\u6CD51:** \\u4E0D\\u65AD\\u5BF92\\u6C42\\u4F59\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u4E0D\\u65AD\\u5BF92\\u8FDB\\u884C\\u6C42\\u4F59, \\u5982\\u679C\\u4E0D\\u7B49\\u4E8E0, \\u5219\\u5224\\u65AD\\u503C\\u662F\\u5426\\u4E3A1. \\u4E0D\\u4E3A1\\u5219false.\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar isPowerOfTwo = function(n) {\\n  if (n <= 0) return false;\\n  while (n % 2 === 0) n /= 2;\\n  return n === 1;\\n};\\n```\\n\\n**\\u65B9\\u6CD52:** \\u4E0E\\u8FD0\\u7B97\\n**\\u89E3\\u9898\\u601D\\u8DEF:**\\n1. \\u6D88\\u9664\\u6700\\u540E\\u4E00\\u4E2A1\\u7684\\u516C\\u5F0F: n & (n - 1).\\n\\n**\\u4EE3\\u7801:**\\n```\\nvar isPowerOfTwo = function(n) {\\n  return n > 0 && (n & (n - 1)) === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar isPowerOfTwo = function(n) {\\n  if (n <= 0) return false;\\n  while (n % 2 === 0) n /= 2;\\n  return n === 1;\\n};\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n  return n > 0 && (n & (n - 1)) === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63977,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func isPowerOfTwo(_ n: Int) -> Bool {\\n        if n <= 0 {\\n            return false\\n        }\\n        \\n        return (n & (n - 1)) == 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    func isPowerOfTwo(_ n: Int) -> Bool {\\n        if n <= 0 {\\n            return false\\n        }\\n        \\n        return (n & (n - 1)) == 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64002,
                "title": "java-o-1-one-liner",
                "content": "    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n        \\t/**\\n        \\t * 3: 0011, -4: 1100, -3: 1101\\n        \\t * 6: 0110, -7: 1001, -6: 1010\\n        \\t * num & -num: least significant non-zero digit\\n        \\t */\\n            return n > 0 && n == (n & -n);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n        \\t/**\\n        \\t * 3: 0011, -4: 1100, -3: 1101\\n        \\t * 6: 0110, -7: 1001, -6: 1010\\n        \\t * num & -num: least significant non-zero digit\\n        \\t */\\n            return n > 0 && n == (n & -n);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64131,
                "title": "share-one-line-java",
                "content": "    public class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        return n<=0?false:((n&(n-1))==0)?true:false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        return n<=0?false:((n&(n-1))==0)?true:false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 64140,
                "title": "one-line-accepted-solution-with-bit-manipulation",
                "content": "    public class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n > 0 && (n & (n - 1)) == 0; \\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isPowerOfTwo(int n) {\\n            return n > 0 && (n & (n - 1)) == 0; \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64175,
                "title": "share-my-one-line-java-solution",
                "content": "    public class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return (n<=0)?false:(n & (n-1))==0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        return (n<=0)?false:(n & (n-1))==0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3818094,
                "title": "easy-c-solution",
                "content": "# PLS UPVOTE MY SOLUTION IF YOPU LIKE AND COMMENT FOR ANY DISCUSSION\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIterative Approach:\\n\\nThe function isPowerOfTwo uses a for loop to iterate from i = 0 to i = 30 (inclusive).\\nFor each iteration, it calculates the value of ans as 2 raised to the power of i using the pow function from the <cmath> library.\\nIt then compares ans with the input number n.\\nIf ans is equal to n, it means n is a power of 2, and the function returns true.\\nIf the loop completes without finding a match, the function returns false.\\nTime Complexity:\\nThe time complexity of this approach is O(31), which is equivalent to O(1) since the loop iterates for a fixed number of times (31 times).\\n\\nQuestion: Power of 2:\\nThe problem is to determine whether a given integer n is a power of two or not. A positive integer is considered a power of two if it can be written as 2^k for some integer k. For example, 1, 2, 4, 8, 16, etc., are all powers of two.\\n\\nOutput:\\nThe function isPowerOfTwo returns true if n is a power of two, and false otherwise.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i =0;i<=30;i++)\\n        {\\n            int ans = pow(2,i);\\n            if(ans==n)\\n            return true;\\n            \\n        }\\n    return false;;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i =0;i<=30;i++)\\n        {\\n            int ans = pow(2,i);\\n            if(ans==n)\\n            return true;\\n            \\n        }\\n    return false;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3512017,
                "title": "java-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        if(n==1) return true;\\n        if(n%2==0) return isPowerOfTwo(n/2);\\n        else return false;\\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/6aa6f8ce-120a-454e-ba81-ed004161d22e_1683800198.3876867.png)",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0) return false;\\n        if(n==1) return true;\\n        if(n%2==0) return isPowerOfTwo(n/2);\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430397,
                "title": "simplest-c-solution-99-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the number is power of 2, then it only has one bit set (1\\'s) in it\\'s binary form, remaining will be unset (0\\'s)\\nex: 8 -> 1000\\n\\nSo, if we perform \"bitwise and\" on \\'n\\' and \\'n-1\\' it should result in value 0\\nex: 8 -> 1000 and 7 -> 0111 => (8 & 7) == 0\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPerform \"bitwise and\" on the given n with (n-1)\\nif the given number if power of 2, then the above operation should result in 0\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n### Please upvote if you like the approach and it\\'s explaination\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPowerOfTwo(int n) {\\n        if (n <= 0)\\n            return false;\\n        \\n        return ((n & (n-1)) == 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Bit Manipulation"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPowerOfTwo(int n) {\\n        if (n <= 0)\\n            return false;\\n        \\n        return ((n & (n-1)) == 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227821,
                "title": "beats-100-bit-manipulation0-1-o-log-n-c",
                "content": "# Intuition\\nWe know that numbers like *2, 4, 8, 16, 32, 64*... (those who can be represented by *2^n* ) have a single \\'1\\' in thier 1st, 2nd, 3rd, 4th, 5th, 6th bit respectively in their ***Binary Represtation***\\n# Approach\\nIf we can eleminate all the 0\\'s and identify only a single \\'1\\' at any position, then we are sure the number is a power of 2.\\n\\n1. first we can eleminate all the odd numbers(>1) as they can never be a power of 2.\\n2. When the input is even, it has atleast one \\'0\\' from the right most bit. So we are **right shifting** the zeros till we get a \\'1\\' in the right most bit. If it is the only \\'1\\' and everything previous to it is \\'0\\', then definitly the original number can be represented by *2^n*.\\n3. input = 1 is a special cases, we will handle it separately.\\n# Complexity\\n- Time complexity: *O(log N)*\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 != 0)\\n            return false;\\n        while(n != 0){\\n            if(n%2 != 0){\\n                n = n>>1;\\n                if(n == 0)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n              n = n>>1;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n*Please Upvote if the code and explanation is helpful to you*",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 != 0)\\n            return false;\\n        while(n != 0){\\n            if(n%2 != 0){\\n                n = n>>1;\\n                if(n == 0)\\n                    return true;\\n                else\\n                    return false;\\n            }\\n            else\\n              n = n>>1;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3227310,
                "title": "without-using-any-loop-java-faster-than-100",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe Know that Zero Can Never be Power of Two And -2147483648 is the Smallest Integer so We cannot get it\\'s (n-1)th term . so we set these conditions false. \\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n    if(n==-2147483648 || n == 0) return false;\\n    return (n&(n-1)) == 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n    if(n==-2147483648 || n == 0) return false;\\n    return (n&(n-1)) == 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2993497,
                "title": "java-easy-solution-one-line-code-bit-manipulation",
                "content": "\\n\\n# Approach: \\nUsing Bit Manipulation-\\nAs we know, if a number is power of 2 then, binary AND operation of the number n and its previous number (n-1) is equal to zero.\\nExample- \\nFor n= 4 , it\\'s binary representation is 0100 , \\nand for n-1 = 3 is 0011, \\nPerforming Binary AND operation of \"0100\" and \"0011\" gives us 0000 which is equal to 0 in decimal number system. \\nFollowing holds true for all the positive numbers which are power of 2.\\n\\nHope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return (n>0) && ((n & (n-1)) == 0); //returns true if the number(n) is greater than 0 and binary AND operation of n and n-1 is equal to zero  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return (n>0) && ((n & (n-1)) == 0); //returns true if the number(n) is greater than 0 and binary AND operation of n and n-1 is equal to zero  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955171,
                "title": "c-100-faster-easy-recursive-2-line-solution-best-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        if(n==1)\\n            return true;\\n        if(n==0 || n%2 != 0)\\n            return false;\\n\\n        return isPowerOfTwo(n/2);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        if(n==1)\\n            return true;\\n        if(n==0 || n%2 != 0)\\n            return false;\\n\\n        return isPowerOfTwo(n/2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937566,
                "title": "easy-java-solution-using-bit-manipulation-beats-100",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBit Manipulation\\n\\nHope this helps.\\nDo Upvote if you like it !!\\n\\nThanks :)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return(n>0  && (n & (n-1))==0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return(n>0  && (n & (n-1))==0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579472,
                "title": "python-codes-using-recursion-and-bit-manipulation-in-o-1-time-with-explanation",
                "content": "**Bit Manipulation Method: \\nTime : O(1), Space: O(1)**\\n\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and n&(n-1)==0\\n```\\n\\nBit manipulation techniques are usually based on observations from multiple examples.\\n3 -> 011\\n4 -> 100\\n\\n7 -> 0111\\n8 -> 1000\\n\\n15 -> 01111\\n16 -> 10000\\n\\nIf we do **n & (n-1)** for all these cases of n (which are all powers of 2) the result is **False**\\nHence this method works.\\n\\n\\n**Simple Recursive approach:\\nTime: log(n), Space: log(n)**\\n\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n == 1:\\n            return True\\n        if n < 1:\\n            return False\\n        return self.isPowerOfTwo(n/2)\\n```\\n\\nIf n is a power of 2, repeatedly dividing it by 2 will finally give 1 i.e. 2^0.\\n\\nIf it helped or you learned a new way, kindly upvote. Thanks :)",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n>0 and n&(n-1)==0\\n```\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n == 1:\\n            return True\\n        if n < 1:\\n            return False\\n        return self.isPowerOfTwo(n/2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483843,
                "title": "c-3-lines-code-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        if(n==0) return 0;        \\n        if(ceil(log2(n)) == floor(log2(n))) return 1;\\n        else return 0;\\n            \\n        }   \\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        if(n==0) return 0;        \\n        if(ceil(log2(n)) == floor(log2(n))) return 1;\\n        else return 0;\\n            \\n        }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350301,
                "title": "c-different-approaches-beginner-friendly-easy-solution",
                "content": "**Approach 1: Naive\\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return false;\\n        while( n!= 1){\\n            if(n %2 != 0){\\n                return false;\\n            }\\n            n = n/2;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Approach 2: Naive(Bits) \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return false;\\n        while( n!= 1){\\n            // Checking if n is odd\\n            if(n & 1){\\n                return false;\\n            }\\n            // Dividing n by 2\\n            n = n >> 1;\\n        }\\n        return true;\\n    }\\n};\\n```\\n**Approach 3: Recursion \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(!n) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 and isPowerOfTwo(n / 2);\\n    }\\n};\\n```\\n**Approach 4: Bit Manipulation \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(long long n) {\\n        if(n == 0) return false;\\n       return (!(n & (n-1)));\\n    }\\n};\\n\\n**One Liner C++**\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(long long n) {\\n       return (n != 0) && (!(n & (n-1)));\\n    }\\n};\\n```\\n**Do not forget to upvote if you like the post**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return false;\\n        while( n!= 1){\\n            if(n %2 != 0){\\n                return false;\\n            }\\n            n = n/2;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 0) return false;\\n        while( n!= 1){\\n            // Checking if n is odd\\n            if(n & 1){\\n                return false;\\n            }\\n            // Dividing n by 2\\n            n = n >> 1;\\n        }\\n        return true;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(!n) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 and isPowerOfTwo(n / 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(long long n) {\\n        if(n == 0) return false;\\n       return (!(n & (n-1)));\\n    }\\n};\\n\\n**One Liner C++**\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(long long n) {\\n       return (n != 0) && (!(n & (n-1)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1662640,
                "title": "using-bit-manipulation-to-achieve-it-in-the-lowest-complexity",
                "content": "i thought that if a number is a proper square of 2 then its binary number will contain only one 1 in the number for example , if we convert 4 in to binary then it is 0100 , it has only one 1 in it , lets take 16 , 16  is 1000 , so it is clear that if a number is a perfect sqaure of 2 then it should contain only one in its binary form . i have attached the code below for the more clarification.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(uint32_t n) {\\n        int count=0;\\n        if(n==INT_MIN || n<0){\\n            return false;\\n        }\\n        \\n        while(n!=0){\\n           int bit=n&1;\\n           n=n>>1;\\n           if(bit)\\n              count++;\\n            if(count>1)\\n                return false;\\n        }\\n        if(count==1)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```\\ni have also checked for the negative numbers and the program wont get submitted if we only put the n<0 condition in the if condition , we have to include n==INT_MIN to make our code eligible for submission.",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(uint32_t n) {\\n        int count=0;\\n        if(n==INT_MIN || n<0){\\n            return false;\\n        }\\n        \\n        while(n!=0){\\n           int bit=n&1;\\n           n=n>>1;\\n           if(bit)\\n              count++;\\n            if(count>1)\\n                return false;\\n        }\\n        if(count==1)\\n            return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1639446,
                "title": "easy-python-solution",
                "content": "```\\ndef isPowerOfTwo(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%2==0: n/=2\\n        return n==1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef isPowerOfTwo(self, n: int) -> bool:\\n        if n<=0: return False\\n        while n%2==0: n/=2\\n        return n==1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1635272,
                "title": "using-binary-bit-concept-c-easy-without-any-recursion-loop",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\t//This is the edge case, as values less then or equal to 0 cannot be formed as power of 2\\n        if(n <= 0){\\n            return false;\\n        }\\n\\t\\t//if you don\\'t understand use pen and paper and try with some examples, then you\\'ll understand this\\n       if((n & n-1) == 0){\\n           return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\t//This is the edge case, as values less then or equal to 0 cannot be formed as power of 2\\n        if(n <= 0){\\n            return false;\\n        }\\n\\t\\t//if you don\\'t understand use pen and paper and try with some examples, then you\\'ll understand this\\n       if((n & n-1) == 0){\\n           return true;\\n       }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629941,
                "title": "1-line-python-code-using-bit-manupulation",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return not (n & (n-1)) if n >= 1 else False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return not (n & (n-1)) if n >= 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615799,
                "title": "super-clean-and-easy-understand-c-solution-100-fast",
                "content": "Appreciate your upvote :)\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 1) return true;\\n        while(n > 2){\\n            if(n%2 != 0) return false;\\n            n = n/2;\\n        }\\n        return (n == 2);\\n    }\\n};\\n```\\n\\nAnother approach\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n==0) return false;\\n        double m = log2(n);\\n        if(floor(m) == m){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n == 1) return true;\\n        while(n > 2){\\n            if(n%2 != 0) return false;\\n            n = n/2;\\n        }\\n        return (n == 2);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n==0) return false;\\n        double m = log2(n);\\n        if(floor(m) == m){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1610647,
                "title": "most-easy-solution-in-c-100-faster",
                "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0)\\n            return false;\\n        if(n<0)\\n            return false;\\n        int r=n&n-1;\\n        if(r==0)\\n        {\\n            return true;\\n        }\\n        else\\n            return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n==0)\\n            return false;\\n        if(n<0)\\n            return false;\\n        int r=n&n-1;\\n        if(r==0)\\n        {\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1573152,
                "title": "runtime-1-ms-faster-than-99-99-of-java-online-submissions-for-power-of-two",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        if(n==1) return true;\\n        \\n        if((n&1)==1) return false;\\n        \\n        int numBit=0;\\n        \\n        while(n>0 && numBit<=1){\\n              if((n&1)==1) numBit++;\\n            n=n>>1;\\n        }\\n        \\n        if(numBit==1)\\n        return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        if(n==1) return true;\\n        \\n        if((n&1)==1) return false;\\n        \\n        int numBit=0;\\n        \\n        while(n>0 && numBit<=1){\\n              if((n&1)==1) numBit++;\\n            n=n>>1;\\n        }\\n        \\n        if(numBit==1)\\n        return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524659,
                "title": "one-line-without-recursion-and-loop-only-binary-math",
                "content": "```\\nfunc isPowerOfTwo(n int) bool {\\n    return n != 0 && (n & (n - 1) == 0)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPowerOfTwo(n int) bool {\\n    return n != 0 && (n & (n - 1) == 0)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499566,
                "title": "easy-java-solution",
                "content": "**Time Complexity: O(1)**\\n\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return ((n&(n-1))==0 && n>0);\\n    }\\n}\\n```\\n**Time Complexity: O(logn)**\\n\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        while(n%2 == 0 && n!=0)    n /= 2;\\n        return n == 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n       return ((n&(n-1))==0 && n>0);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        while(n%2 == 0 && n!=0)    n /= 2;\\n        return n == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465300,
                "title": "python-bit-manipulation",
                "content": "If a number is the power of two, its binary form will always be 1 follow with 0, e.g. 16: 10000, 64: 1000000.\\nIf a number is the power of two, `n-1`\\'s binary form will aways be one bit less than `n`, with all 1, e.g. 15: 01111, 63: 0111111\\nOperator `&` means compare two numbers\\' binary form bit by bit, if both bits equal to 1, then set it to 1.\\nSo if a number is the power of two, `n & (n-1)` should always be 0.\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and n & (n-1) == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        return n > 0 and n & (n-1) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327901,
                "title": "power-of-2-3-types-java-sol-brute-better-optimal",
                "content": "Power of 3 -> https://leetcode.com/problems/power-of-three/discuss/1327935/power-of-3-3-types-java-sol-brute-better-optimal-0ms100-superfast\\n\\nPower of 4 ->https://leetcode.com/problems/power-of-four/discuss/1327939/Power-of-4-greater-3-Types-%3A%3A%3A-Java-sol-greater-Recursion-%2B-Iterative-0ms100-superfast\\n\\n// Brute -> Better -> Optimal\\n\\n/*\\n1). Brute ->  o(logn), o(n)-stack -> Recursion \\n\\n2.1). Better -> o(logn), o(1) -> Multiply By 2 -> Math(i*2)  /  Iterative(while loops)\\n\\n2.2). Better -> o(logn), o(1) -> Divide   By 2 ->  Math(n/2) /  Iterative(while loops)  \\n\\n***both-dividing/multiply - o(logn)***\\n\\n3). Optimal -> o(1),o(1) -> Bit Manipulation(SET-BIT)::::\\n* All calculation done in -> BITS(\"1/0\") -> o(1),o(1)\\n* Bit Manipulation -> assume everythning in BITS(\"1/0\") -> 1 & (10000...BITS...etc..) == 0 \\n* Cover/Pass all test case -> max bit(32bit)-> try all bits from -> 0 to 32 -> if found(even-true), else(odd-false)\\n**Question Input -> If (n) -> even / odd**\\n\\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47          \\uD83D\\uDC47\\n* Even/Odd -> even(==0), odd(!=0) \\n* (>>) - skip 1/dividing, (<<) - add 0/multiplying\\n\\n4). Optimal -> o(1), o(1) -> Bit Manipulation(SET-BIT)::::::::\\n* All calculation done in -> BITS(\"1/0\") -> o(1),o(1)\\n* Bit Manipulation -> assume everythning in BITS(\"1/0\") -> 1 & (10000...BITS...etc..) == 0 \\n**Question Input -> If (n) -> Power of 2**\\n\\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47          \\uD83D\\uDC47\\n* Power of 2(1\\'s compliment ~n / n-1) -> n*(~n) / n*(n-1)\\n* If, power-of-2 have -> ONLY-1-SET-BIT (1 is present - 1 time only), eg, 2(0010),4(0100),8(1000)\\n* Else, #Power-of-2 have -> MORE-THAN-1-SET_BIT (1 is present - more than 1 time), eg, 3(0011),5(0101)\\n*/\\n\\n/* **1). Brute ->   o(logn), o(n)-stack -> Recursion** -> [f(n) -> f(n+1)] (or) Recursion -> (n -> n/2)\\n// return -> boolean, not int\\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        // if(n % 2 == 0) return isPowerOfTwo(n/2);     // (or) if(n % 2 != 0) return false;\\n        // else return false;                           // else return isPowerOfTwo(n/2);\\n        if(n % 2 != 0) return false;                          \\n        else return isPowerOfTwo(n/2);                  // o(logn - dividing),o(n)-stack\\n    }\\n}\\n*/\\n```\\n\\n\\n\\n/* Prakash Shukla\\n// **2.2). Better -> o(logn), o(1)  -> multiply by 2** -> Math(i*2) / Iterative(while loops)\\n// return -> boolean, not int\\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        long i = 1;                                     // long Integer -> cuz there may be large value\\n        while( i < n )                                  \\n        {\\n            i = i * 2;                                  // o(logn - multiply),o(1) \\n                                                        // ***both-dividing/multiply - o(logn)***\\n        }\\n        if( i == n ) return true;\\n        else return false;\\n    }\\n}\\n*/\\n```\\n\\n\\n/* **2.2). Better -> o(logn), o(1)  -> Divide By 2** -> Math(n/2) / Iterative(while loops)\\n// return -> boolean, not int\\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        while(n > 1||n < 0) //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n        {\\n            if(n % 2 != 0)          \\n                return false;\\n            n = n / 2;              // o(logn - dividing),o(1)\\n        }\\n        return true;\\n        //isPowerOfTwo(n, x+1);\\n    }\\n}\\n*/\\n```\\n\\n\\n//                                      (OR)(OR)(OR)(OR)(OR)(OR)\\n\\n/*\\n```\\nclass Solution \\n{\\n    public boolean help(int n)\\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        while(n > 1||n < 0) //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n        {\\n            if(n % 2 != 0)                      \\n                return false;\\n            n = n / 2;                          // o(logn - dividing),o(1)\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return help(n);\\n    }\\n}\\n*/\\n```\\n\\n\\n\\n/* **3). Optimal -> o(1),o(1) -> Bit Manipulation(SET-BIT)**::::\\n* All calculation done in -> BITS(\"1/0\") -> o(1),o(1)\\n* Bit Manipulation -> assume everythning in BITS(\"1/0\") -> 1 & (10000...BITS...etc..) == 0 \\n* Cover/Pass all test case -> max bit(32bit)-> try all bits from -> 0 to 32 -> if found(even-true), else(odd-false)\\n**Question Input -> If (n) -> even / odd**\\n\\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47          \\uD83D\\uDC47\\n* Even/Odd -> even(==0), odd(!=0) \\n* (>>) - skip 1/dividing, (<<) - add 0/multiplying\\n*/\\n\\n/*\\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        \\n        int cnt = 0;\\n        for(int i=0;i<32;i++)  //max bit(32bit)-> try all bits from -> 0 to 32 -> if found(even-true), else(odd-false)\\n        {\\n            cnt = cnt + (1 & (n >> i));         // If (1 & (x >> i)) != 0(odd-false) -> increase count -> cnt = cnt +1                                                // Else (1 & (x >> i)) ==0(even-true) -> count remains same \\n        }\\n        if( cnt == 1) return true;            // cnt(1) == 1 -> even-true\\n        else return false;                    // cnt(0) == 0 -> odd-false  \\n        \\n        //n=5, i=0 -> 1 & (5 >> i=0) -> 1 & (5 >> 0) -> 1(0001) & 5(0101) -> 0001 -> 1 !=0 (odd-falsse)\\n        //n=5, i=1 -> 1 & (5 >> i=1) -> 1 & (5 >> 1) -> 1(0001) & 2(0010) -> 0000 -> 0 ==0 (even-true)\\n        //n=5, i=2 -> 1 & (5 >> i=2) -> 1 & (5 >> 2) -> 1(0001) & 1(0001) -> 0001 -> 1 !=0 (odd-falsse)\\n        \\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```\\n\\n\\n\\n\\n\\n/* **4). Optimal -> o(1),o(1) -> Bit Manipulation(SET-BIT)**::::\\n* All calculation done in -> BITS(\"1/0\") -> o(1),o(1)\\n* Bit Manipulation -> assume everythning in BITS(\"1/0\") -> 1 & (10000...BITS...etc..) == 0 \\n* Cover/Pass all test case -> max bit(32bit)-> try all bits from -> 0 to 32 -> if found(even-true), else(odd-false)\\n**Question Input -> If (n) -> Power of 2**  \\n\\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47      \\uD83D\\uDC47          \\uD83D\\uDC47\\n* Power of 2(1\\'s compliment ~n / n-1) -> n*(~n) / n*(n-1)\\n* If, power-of-2 have -> ONLY-1-SET-BIT (1 is present - 1 time only), eg, 2(0010),4(0100),8(1000)\\n* Else, #Power-of-2 have -> MORE-THAN-1-SET_BIT (1 is present - more than 1 time), eg, 3(0011),5(0101)\\n*/\\n\\n                                         ---------- binary-------- \\n                                            n    n     n-1   n&(n-1)\\n                                            --  ----   ----   -------\\n                                        *   0   0000   0111    0000 *\\n                                        *   1   0001   0000    0000 *\\n                                        *   2   0010   0001    0000 *\\n                                            3   0011   0010    0010\\n                                        *   4   0100   0011    0000 *\\n                                            5   0101   0100    0100\\n                                            6   0110   0101    0100\\n                                            7   0111   0110    0110\\n                                        *   8   1000   0111    0000 *\\n                                            9   1001   1000    1000\\n                                            10   1010   1001    1000\\n                                            11   1011   1010    1010\\n                                            12   1100   1011    1000\\n                                            13   1101   1100    1100\\n                                            14   1110   1101    1100\\n                                            15   1111   1110    1110\\n    \\n// n & (n-1) => (n-1 == compliment -> all 0 will become 1 & all 1 will became)\\n// n > 0 -> n =8 (1000), n-1=7 (0111), n & (n-1) = 1000 & 0111 = 0 -> 0==0(yes-even-true), else(no-odd-false)\\n// return -> boolean, not int\\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n          \\n        if((n > 0) && (n & (n-1)) == 0) return true;    // o(1),o(1)\\n        return false;\\n        //n > 0 -> n =8 (1000), n-1=7 (0111), n & (n-1) = 1000 & 0111 = 0 -> 0==0(yes-even-true), else(no-odd-false)\\n        //n > 0 -> n =3 (0011), n-1=2 (0010), n & (n-1) = 0011 & 0010 = 1 -> 1!=0(no-odd-false)\\n\\t\\t\\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```\\n\\n\\n//                                      (OR)(OR)(OR)(OR)(OR)(OR)\\n\\n\\n/*\\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        \\n        return n > 0 && (n & (n-1)) == 0;               // o(1),o(1)\\n        //n > 0 -> n =8 (1000), n-1=7 (0111), n & (n-1) = 1000 & 0111 = 0 -> 0==0(yes-even-true), else(no-odd-false)\\n        //n > 0 -> n =3 (0011), n-1=2 (0010), n & (n-1) = 0011 & 0010 = 1 -> 1!=0(no-odd-false)\\n\\t\\t\\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        // if(n % 2 == 0) return isPowerOfTwo(n/2);     // (or) if(n % 2 != 0) return false;\\n        // else return false;                           // else return isPowerOfTwo(n/2);\\n        if(n % 2 != 0) return false;                          \\n        else return isPowerOfTwo(n/2);                  // o(logn - dividing),o(n)-stack\\n    }\\n}\\n*/\\n```\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        long i = 1;                                     // long Integer -> cuz there may be large value\\n        while( i < n )                                  \\n        {\\n            i = i * 2;                                  // o(logn - multiply),o(1) \\n                                                        // ***both-dividing/multiply - o(logn)***\\n        }\\n        if( i == n ) return true;\\n        else return false;\\n    }\\n}\\n*/\\n```\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        while(n > 1||n < 0) //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n        {\\n            if(n % 2 != 0)          \\n                return false;\\n            n = n / 2;              // o(logn - dividing),o(1)\\n        }\\n        return true;\\n        //isPowerOfTwo(n, x+1);\\n    }\\n}\\n*/\\n```\n```\\nclass Solution \\n{\\n    public boolean help(int n)\\n    {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n            \\n        while(n > 1||n < 0) //except n=1(odd=true), but others satisfy -> n=16 -> even(yes=true), n=3 -> odd(no=false)\\n        {\\n            if(n % 2 != 0)                      \\n                return false;\\n            n = n / 2;                          // o(logn - dividing),o(1)\\n        }\\n        return true;\\n    }\\n    \\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return help(n);\\n    }\\n}\\n*/\\n```\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        \\n        int cnt = 0;\\n        for(int i=0;i<32;i++)  //max bit(32bit)-> try all bits from -> 0 to 32 -> if found(even-true), else(odd-false)\\n        {\\n            cnt = cnt + (1 & (n >> i));         // If (1 & (x >> i)) != 0(odd-false) -> increase count -> cnt = cnt +1                                                // Else (1 & (x >> i)) ==0(even-true) -> count remains same \\n        }\\n        if( cnt == 1) return true;            // cnt(1) == 1 -> even-true\\n        else return false;                    // cnt(0) == 0 -> odd-false  \\n        \\n        //n=5, i=0 -> 1 & (5 >> i=0) -> 1 & (5 >> 0) -> 1(0001) & 5(0101) -> 0001 -> 1 !=0 (odd-falsse)\\n        //n=5, i=1 -> 1 & (5 >> i=1) -> 1 & (5 >> 1) -> 1(0001) & 2(0010) -> 0000 -> 0 ==0 (even-true)\\n        //n=5, i=2 -> 1 & (5 >> i=2) -> 1 & (5 >> 2) -> 1(0001) & 1(0001) -> 0001 -> 1 !=0 (odd-falsse)\\n        \\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n          \\n        if((n > 0) && (n & (n-1)) == 0) return true;    // o(1),o(1)\\n        return false;\\n        //n > 0 -> n =8 (1000), n-1=7 (0111), n & (n-1) = 1000 & 0111 = 0 -> 0==0(yes-even-true), else(no-odd-false)\\n        //n > 0 -> n =3 (0011), n-1=2 (0010), n & (n-1) = 0011 & 0010 = 1 -> 1!=0(no-odd-false)\\n\\t\\t\\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution\\n{\\n      public boolean isPowerOfTwo(int n) \\n      {\\n        if(n < 0) return false;                         // -ve number\\n        if(n == 0) return false;                        // == 0 \\n        if(n == 1) return true;                         // == 1\\n        \\n        return n > 0 && (n & (n-1)) == 0;               // o(1),o(1)\\n        //n > 0 -> n =8 (1000), n-1=7 (0111), n & (n-1) = 1000 & 0111 = 0 -> 0==0(yes-even-true), else(no-odd-false)\\n        //n > 0 -> n =3 (0011), n-1=2 (0010), n & (n-1) = 0011 & 0010 = 1 -> 1!=0(no-odd-false)\\n\\t\\t\\n        //base condi -> n ==1 -> n =1 (0001), n-1=0 (0000), n & (n-1) = 0001 & 0000 = 0 -> 0==0(yes-even-true)\\n        //base condi -> n ==0 -> n =0 (0000), n-1=0 (0000), n & (n-1) = 0001 & 0000 =  -> 0==0(no-false)\\n        //base condi -> n==-1 -> n =-1(-1), n-1=-2(-10), n & (n-1) = 0001 & 0000 = 0 -> 0==0(no-[-ve]-false)\\n    }\\n}\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237879,
                "title": "weeb-does-python-one-liner",
                "content": "![image](https://assets.leetcode.com/users/images/8f0b682c-5803-4bdd-85a7-b2de081310e1_1622275736.0492783.png)\\n\\n\\tclass Solution:\\n\\t\\tdef isPowerOfTwo(self, n: int) -> bool:\\n\\t\\t\\treturn n>0 and log2(n) == int(log2(n))\\n\\t\\t\\t\\nAnime time, try watching **Wonder Egg Priority**\\n\\n# Episodes: 12\\n# Genres: Fantasy; Psychological horror\\n\\nTrust me, the name of this show is weird but it makes sense once you watch it",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/8f0b682c-5803-4bdd-85a7-b2de081310e1_1622275736.0492783.png)\\n\\n\\tclass Solution:\\n\\t\\tdef isPowerOfTwo(self, n: int) -> bool:\\n\\t\\t\\treturn n>0 and log2(n) == int(log2(n))\\n\\t\\t\\t\\nAnime time, try watching **Wonder Egg Priority**\\n\\n# Episodes: 12\\n# Genres: Fantasy; Psychological horror\\n\\nTrust me, the name of this show is weird but it makes sense once you watch it",
                "codeTag": "Java"
            },
            {
                "id": 1033719,
                "title": "faster-than-98-69-javascript-easy-solution-recursive",
                "content": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    //Runtime: 84 ms, faster than 98.69% of JavaScript online submissions for Power of Two.\\n    //Memory Usage: 40.2 MB, less than 9.53% of JavaScript online submissions for Power of Two.\\n    \\n    if(n === 1){\\n        return true;\\n    }else if(n <= 0){\\n        return false;\\n    }\\n    \\n    if(n%2 !== 0){\\n        return false;\\n    }else{\\n        return isPowerOfTwo(Math.floor(n/2));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    //Runtime: 84 ms, faster than 98.69% of JavaScript online submissions for Power of Two.\\n    //Memory Usage: 40.2 MB, less than 9.53% of JavaScript online submissions for Power of Two.\\n    \\n    if(n === 1){\\n        return true;\\n    }else if(n <= 0){\\n        return false;\\n    }\\n    \\n    if(n%2 !== 0){\\n        return false;\\n    }else{\\n        return isPowerOfTwo(Math.floor(n/2));    \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 886604,
                "title": "python-with-bit-manipulation-with-explanation",
                "content": "**Idea** : In power of two numbers, only one 1 bit exist \\n  if we substract one from n and & it with n it must give 0\\n  **** If you found it helpful please upvote** **\\n*                 2  00010  & 1  00001  --> 0\\n*                 4  00100  & 3  00011  --> 0\\n*                 8  01000  & 7  00111   --> 0\\n*                 16 10000  & 15 01111  --> 0\\n\\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif n !=0:\\n            return n-1 & n == 0\\n        else:\\n            return False\\n        \\n\\t\\t#one-line version \\n\\t\\t#return n & (n-1) == 0 if n!= 0 else False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n\\t\\tif n !=0:\\n            return n-1 & n == 0\\n        else:\\n            return False\\n        \\n\\t\\t#one-line version \\n\\t\\t#return n & (n-1) == 0 if n!= 0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638083,
                "title": "4-lines-c-100-speed-memory-easy-explanation",
                "content": "**Logic:** We are simply computing every power of 2 while it is smaller than n. It returns true if i is equal to n else returns false.\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       long i=1;\\n        while(i<n)\\n        {\\n            i*=2;\\n        }\\n        return i==n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       long i=1;\\n        while(i<n)\\n        {\\n            i*=2;\\n        }\\n        return i==n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624954,
                "title": "python-solution-99-fast-20-ms-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n>0:\\n            if n == 1:\\n                return True\\n            elif n%2==0:\\n                n=n/2\\n            else:\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n <= 0:\\n            return False\\n        while n>0:\\n            if n == 1:\\n                return True\\n            elif n%2==0:\\n                n=n/2\\n            else:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298519,
                "title": "javascript-bit-manipulation-one-liner",
                "content": "```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 ? !(n & (n - 1)) : false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 ? !(n & (n - 1)) : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 136246,
                "title": "c-one-line-trick-of-n-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\t\\n        return (n <= 0) ? false : (n == (n & (-n))); //n & -n returns the number with only the last 1 bit to be 1\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\t\\n        return (n <= 0) ? false : (n == (n & (-n))); //n & -n returns the number with only the last 1 bit to be 1\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64003,
                "title": "python-bitwise-shift-iteration",
                "content": "The idea is to count the amount of 1's that appear in the binary representation of n. If c is anything other than 1, then n is not a power of 2. All powers of 2 in a binary representation will have exactly one 1 in it.\\n\\n2^0 = 0001\\n2^1 = 0010\\n2^2 = 0100\\n2^3 = 1000\\n...\\n```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        c = 0\\n        while n > 0:\\n            if n & 1:\\n                c += 1\\n            n >>= 1\\n        return True if c == 1 else False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        c = 0\\n        while n > 0:\\n            if n & 1:\\n                c += 1\\n            n >>= 1\\n        return True if c == 1 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 64081,
                "title": "python-count-1-in-binary-1-line",
                "content": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            return n > 0 and bin(n).count('1') == 1\\n\\nMore readable than n & (n - 1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def isPowerOfTwo(self, n):\\n            return n > 0 and bin(n).count('1') == 1\\n\\nMore readable than n & (n - 1)",
                "codeTag": "Java"
            },
            {
                "id": 64094,
                "title": "a-java-one-line-implementation",
                "content": "    public boolean isPowerOfTwo(int n) {\\n            return (n > 0) && ((n & n-1) == 0);\\n     }",
                "solutionTags": [],
                "code": "    public boolean isPowerOfTwo(int n) {\\n            return (n > 0) && ((n & n-1) == 0);\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 64085,
                "title": "how-about-this-trick",
                "content": "    bool isPowerOfTwo(int n) {\\n        if(n<1) return false;\\n        return 4294967296%n==0 ? 1: 0;\\n    }",
                "solutionTags": [],
                "code": "    bool isPowerOfTwo(int n) {\\n        if(n<1) return false;\\n        return 4294967296%n==0 ? 1: 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64143,
                "title": "two-lines-code-with-bit-and-operation-o-1",
                "content": "    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            if(n <= 0)  return false;\\n            return (n &= (n-1)) == 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            if(n <= 0)  return false;\\n            return (n &= (n-1)) == 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 4044866,
                "title": "simple-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\nThis problem can be solved using recursion \\n\\nCheck if number < 0  just return false\\n\\nCheck if number%2 != 0 (which is Odd) return false\\n\\nCheck if number equals 1 return true as 2^0 = 1\\n\\nElse call recurively by reducing number by 2\\n```\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==1) return true;\\n        if(n==0 || n%2!=0) return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nThis problem can be solved using recursion \\n\\nCheck if number < 0  just return false\\n\\nCheck if number%2 != 0 (which is Odd) return false\\n\\nCheck if number equals 1 return true as 2^0 = 1\\n\\nElse call recurively by reducing number by 2\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==1) return true;\\n        if(n==0 || n%2!=0) return false;\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767915,
                "title": "one-line-solution",
                "content": "# Intuition\\n![5kej8w.jpg](https://assets.leetcode.com/users/images/b1c4da33-231e-40a4-9624-76a49e1a5a41_1689412767.7066672.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        boolean ans = (n & (n - 1)) == 0;\\n        return ans;\\n        }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        boolean ans = (n & (n - 1)) == 0;\\n        return ans;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3765068,
                "title": "optimized-solution-beats-100-two-intuitions",
                "content": "# Please upvote if you feel it easy \\uD83D\\uDE0A\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // ========= O(log n base 2) =============\\n        // while(n>=2){\\n        //     if(n%2!=0) return false;\\n        //     n/=2;\\n        // }\\n        // return n==1;\\n        //=========================================\\n\\n        if(n<=0) return false;\\n        return ((n&(n-1))==0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        // ========= O(log n base 2) =============\\n        // while(n>=2){\\n        //     if(n%2!=0) return false;\\n        //     n/=2;\\n        // }\\n        // return n==1;\\n        //=========================================\\n\\n        if(n<=0) return false;\\n        return ((n&(n-1))==0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3551076,
                "title": "easiest-java-solution-beats-100-runtime-1ms",
                "content": "# Approach\\nThe given code is a Java implementation of a method called `isPowerOfTwo` which determines whether a given integer `n` is a power of two or not. Let\\'s break down the code and explain it step by step:\\n\\n1. The code declares a class named `Solution`, which typically contains the solution or implementation of a specific problem or task.\\n\\n2. Inside the `Solution` class, there is a public method called `isPowerOfTwo` that takes an integer `n` as a parameter and returns a boolean value.\\n\\n3. The first `if` statement checks if `n` is equal to 1. If it is, then it means that `n` is a power of two (specifically 2^0 = 1), and thus the method returns `true`.\\n\\n4. The second `else if` statement checks if `n` is equal to 0. If it is, then `n` is not a power of two because any power of two is greater than zero. Therefore, the method returns `false`.\\n\\n5. The third `else if` statement checks if `n` is odd, i.e., `n % 2` is not equal to 0. If `n` is odd, it cannot be a power of two because powers of two are always even. In this case, the method returns `false`.\\n\\n6. If none of the above conditions are met, it means that `n` is even and greater than 1. In such cases, the code recursively calls the `isPowerOfTwo` method with the value of `n/2`. This recursive call continues until one of the base cases (n=1 or n=0) is reached.\\n\\n7. The recursion essentially divides `n` by 2 repeatedly until it either becomes 1 (which indicates that it was a power of two) or reaches 0 (which indicates that it was not a power of two). The recursive call helps in checking the divisibility of `n` by 2 and ensuring that the number is continuously reduced until a base case is encountered.\\n\\n8. If the recursive call eventually returns `true`, it means that `n` was a power of two, and the method will propagate this `true` value back through the chain of recursive calls.\\n\\n9. If the recursive call returns `false`, it means that `n` was not a power of two, and this `false` value will propagate back through the recursive calls until reaching the original call.\\n\\n10. Finally, the last `else` statement serves as a catch-all to handle any unexpected cases. In this case, it is not strictly necessary because the previous conditions already cover all possible scenarios.\\n\\nIn summary, the code uses recursion to check if a given integer `n` is a power of two by dividing it by 2 repeatedly until it reaches 1 or 0. If it reaches 1, the method returns `true`, indicating that `n` was a power of two. Otherwise, it returns `false`.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1){\\n            return true;\\n        }\\n        else if(n == 0){\\n            return false;\\n        }\\n        else if(n%2 != 0){\\n            return false;\\n        }\\n        else{\\n            return isPowerOfTwo(n/2);\\n        }\\n    }\\n}\\n```\\n**Please upvote if you like the solution.\\nHappy Coding!** \\uD83D\\uDE0A",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1){\\n            return true;\\n        }\\n        else if(n == 0){\\n            return false;\\n        }\\n        else if(n%2 != 0){\\n            return false;\\n        }\\n        else{\\n            return isPowerOfTwo(n/2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540831,
                "title": "best-o-1-solution",
                "content": "# Approach\\nBrute-Force\\n\\n# Complexity\\n- Time complexity:\\n$$O(1)$$\\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            if (ans == n)\\n                return true;\\n            if (ans < INT_MAX / 2)\\n                ans = ans * 2;    \\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans = 1;\\n        for (int i = 1; i <= 31; i++) {\\n            if (ans == n)\\n                return true;\\n            if (ans < INT_MAX / 2)\\n                ans = ans * 2;    \\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226450,
                "title": "faster-solution-100-speed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc isPowerOfTwo(n int) bool {\\n  if n<=0{\\n      return false \\n  }  \\n    if n==1{\\n        return true\\n    }\\n    if n%2==1{\\n        return false\\n    }\\n    n=n/2\\n    res:= isPowerOfTwo(n)\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc isPowerOfTwo(n int) bool {\\n  if n<=0{\\n      return false \\n  }  \\n    if n==1{\\n        return true\\n    }\\n    if n%2==1{\\n        return false\\n    }\\n    n=n/2\\n    res:= isPowerOfTwo(n)\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135086,
                "title": "easiest-solution-c-beats-100",
                "content": "# Intuition\\nPower of 2 does not have more than a single bit in their binary form\\n\\n# Approach\\n1. if n is 0 or negative *return false.*\\n2. else just use the ***__builtin_popcount*** to calculate the number of bits in the number.\\n3. return *true* if bit count is 1 , *else false*\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        //power of two do not have no more than a single bit in them\\n\\n        if(n <= 0)\\n            return false;\\n\\n        int bits = __builtin_popcount(n);\\n\\n        return bits == 1;\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        //power of two do not have no more than a single bit in them\\n\\n        if(n <= 0)\\n            return false;\\n\\n        int bits = __builtin_popcount(n);\\n\\n        return bits == 1;\\n    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128974,
                "title": "python-solution-best-to-remeber",
                "content": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n==0:\\n            return False\\n\\t\\t\\t\\n\\t\\t#example\\n        # n= 16 (ie 10000)  ,  n-1= 15 (ie 01111)\\n\\t\\t\\n\\t\\t#   10000(16)\\n\\t\\t# & 01111(15)\\n\\t\\t#  -------\\n\\t\\t# = 00000\\n        return (n&(n-1)) ==0\\n```\\n\\n\\nIt is commanly used, better to remember it.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        if n==0:\\n            return False\\n\\t\\t\\t\\n\\t\\t#example\\n        # n= 16 (ie 10000)  ,  n-1= 15 (ie 01111)\\n\\t\\t\\n\\t\\t#   10000(16)\\n\\t\\t# & 01111(15)\\n\\t\\t#  -------\\n\\t\\t# = 00000\\n        return (n&(n-1)) ==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104352,
                "title": "best-2-lines-of-code-and-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n            if(n<=0) return false;\\n            return (n&(n-1))==0;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n            if(n<=0) return false;\\n            return (n&(n-1))==0;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3060078,
                "title": "using-bitwise-easy-solution-in-java-power-of-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0)\\n        {\\n            return false;\\n        }\\n        boolean ans= (n&(n-1))==0;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n<=0)\\n        {\\n            return false;\\n        }\\n        boolean ans= (n&(n-1))==0;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2629397,
                "title": "fast-and-simple-javascript-solution-65-ms-top-99-speed",
                "content": "### Solution:\\n```js\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    return Math.log2(n) % 1 == 0;\\n};\\n```\\n\\n### LeetCode Output:\\nRuntime: **65 ms**, faster than **99.06%** of JavaScript online submissions for Power of Two.\\nMemory Usage: **43.3 MB**, less than **76.98%** of JavaScript online submissions for Power of Two.\\n[Link to submission](https://leetcode.com/submissions/detail/809590661/)",
                "solutionTags": [
                    "JavaScript",
                    "Math"
                ],
                "code": "```js\\n/**\\n * @param {number} n\\n * @return {boolean}\\n */\\nvar isPowerOfTwo = function(n) {\\n    return Math.log2(n) % 1 == 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2157831,
                "title": "java-easy-solution-recursion",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\t//base cases\\n        if(n==1) return true;\\n        if(n==0) return false;\\n        if(n%2!=0) return false;\\n\\t//recursion\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```\\n**Please UPVOTE if you understand my code and comment your best approach**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\t//base cases\\n        if(n==1) return true;\\n        if(n==0) return false;\\n        if(n%2!=0) return false;\\n\\t//recursion\\n        return isPowerOfTwo(n/2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682310,
                "title": "js-bitwise-operation",
                "content": "if n is power of 2:\\nthe binary number has one and only one bit on.\\nn-1 is a binary number with all his bits are on - so it is a mask fot the right zeros\\n\\n(exception: n = 1 & n-1 = 0, but logic still works here)\\n\\ni.e:\\n0000 0001 = 1  \\n0000 0010 = 2           n-1 = 0000 0001\\n0000 0100 = 4           n-1 = 0000 0011\\n0000 1000 = 8           n-1 = 0000 0111\\n0001 0000 = 16         n-1 = 0000 1111\\n0010 0000 = 32         n-1 = 0001 1111\\n\\nusing n-1 as a mask\\nso if n & n-1 ==0 that means n is power of 2\\n\\nalso adding a check is n > 0, 0 or negative numbers will never be a power of 2\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 && (n & (n-1)) == 0;    \\n};",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation"
                ],
                "code": "if n is power of 2:\\nthe binary number has one and only one bit on.\\nn-1 is a binary number with all his bits are on - so it is a mask fot the right zeros\\n\\n(exception: n = 1 & n-1 = 0, but logic still works here)\\n\\ni.e:\\n0000 0001 = 1  \\n0000 0010 = 2           n-1 = 0000 0001\\n0000 0100 = 4           n-1 = 0000 0011\\n0000 1000 = 8           n-1 = 0000 0111\\n0001 0000 = 16         n-1 = 0000 1111\\n0010 0000 = 32         n-1 = 0001 1111\\n\\nusing n-1 as a mask\\nso if n & n-1 ==0 that means n is power of 2\\n\\nalso adding a check is n > 0, 0 or negative numbers will never be a power of 2\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    return n > 0 && (n & (n-1)) == 0;    \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1641935,
                "title": "c-one-liner-solution-explained",
                "content": "* If a number is a power of two then it will have only one set bit and that bit will also be its least significant bit.\\n* Suppose x=n&(n-1) then x will be the number formed after removing the least significant bit of n.\\n* Therefore x should be 0 if there was only one set bit in n otherwise non-zero.\\n```\\nbool isPowerOfTwo(int n) {\\n        return n>0 and !(n&(n-1));\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nbool isPowerOfTwo(int n) {\\n        return n>0 and !(n&(n-1));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1610046,
                "title": "one-line-c-without-loops-recusion-and-faster-than-100",
                "content": "Enjoy  and Upvote\\n\\t\\t // n has to be greater than 0 \\n\\t\\t // and the AND operation of n and n-1  when 0 results  in power of 2 \\n\\t\\t return (n>0) && ((n&(n-1))==0);\\n\\t\\t",
                "solutionTags": [
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "Enjoy  and Upvote\\n\\t\\t // n has to be greater than 0 \\n\\t\\t // and the AND operation of n and n-1  when 0 results  in power of 2 \\n\\t\\t return (n>0) && ((n&(n-1))==0);\\n\\t\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1595943,
                "title": "c-solution-bit-manipulation-faster-than-100-00",
                "content": "Simple bit manipulation to generate power of 2 till 2^30 and checking if the input is equal to power or not.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 0; i < 30; i++) {\\n            \\n            if(ans == n)\\n                return true;\\n            \\n            ans = ans << 1;\\n            \\n        }\\n        \\n        if(ans == n)\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        for(int i = 0; i < 30; i++) {\\n            \\n            if(ans == n)\\n                return true;\\n            \\n            ans = ans << 1;\\n            \\n        }\\n        \\n        if(ans == n)\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590469,
                "title": "using-log2-simple-maths-no-loops",
                "content": "**Simple Quick Maths:**\\n We know: 2^x  == n \\n taking log2 (log to the base 2) on both sides\\n  log2(2^x) = log2(n) \\n solving using log property\\n **x = log2(n)** \\n \\nNow for n to be a power of 2, x should be a number with no decimals.\\nex:\\nfor n=4 ; x would be 2.0 i.e power of two 2^2\\nfor n=3 ; x would be 1.584 i.e not a power of natural power of 2\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) \\n            return false;\\n\\t\\t\\t\\n        double x = log2(n);\\n        if(abs(x-int(x))>0)  //checks if power is natural number or decimal number\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) \\n            return false;\\n\\t\\t\\t\\n        double x = log2(n);\\n        if(abs(x-int(x))>0)  //checks if power is natural number or decimal number\\n\\t\\t\\treturn false;\\n\\t\\t\\t\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568801,
                "title": "c-solution-easy-0ms-explained-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        // negative numbers or 0 cannot be powers of \\'2\\'\\n\\t\\t// so we return false if we find them\\n        if (n<=0) return false;\\n        \\n\\t\\t\\n\\t\\t// binary representation of some powers of two:\\n\\t\\t// 1 -> 000001, 2 -> 000010, 4 -> 000100\\n\\t\\t// 8 -> 001000, 16-> 010000, 32-> 100000\\n\\t\\t//\\n\\t\\t// We notice that, in powers of two, only 1 bit is set\\n\\t\\t// i.e. the number of 1\\'s in binary representation of powers of 2 is equal to one.\\n\\t\\t// so we use this to solve our problem\\n\\t\\t//\\n\\t\\t//  A trick to remove the rightmost set bit (ie. \\'1\\')\\n        //  n = ( n & (n-1) )\\n        // NOTE: make sure the number \\'n\\' is non-zero\\n        //\\n        // if after removing only 1 set bit, the number \\'n\\' becomes zero\\n        // then it is a power of 2\\n\\t\\t\\n        if (!(n & (n-1)))\\n            return true;\\n\\t\\t\\n        // more than 1 set bits\\n        return false;\\n        \\n    }\\n};\\n```\\n\\n**If you like this solution, please upvote.**\\n\\n***Any critics are welcome.***",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        // negative numbers or 0 cannot be powers of \\'2\\'\\n\\t\\t// so we return false if we find them\\n        if (n<=0) return false;\\n        \\n\\t\\t\\n\\t\\t// binary representation of some powers of two:\\n\\t\\t// 1 -> 000001, 2 -> 000010, 4 -> 000100\\n\\t\\t// 8 -> 001000, 16-> 010000, 32-> 100000\\n\\t\\t//\\n\\t\\t// We notice that, in powers of two, only 1 bit is set\\n\\t\\t// i.e. the number of 1\\'s in binary representation of powers of 2 is equal to one.\\n\\t\\t// so we use this to solve our problem\\n\\t\\t//\\n\\t\\t//  A trick to remove the rightmost set bit (ie. \\'1\\')\\n        //  n = ( n & (n-1) )\\n        // NOTE: make sure the number \\'n\\' is non-zero\\n        //\\n        // if after removing only 1 set bit, the number \\'n\\' becomes zero\\n        // then it is a power of 2\\n\\t\\t\\n        if (!(n & (n-1)))\\n            return true;\\n\\t\\t\\n        // more than 1 set bits\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1504350,
                "title": "100-bit-wise-one-line-solution-without-loops-recursion",
                "content": "```\\nfunc isPowerOfTwo(n int) bool {\\n    return n > 0 && n & (n - 1) == 0\\n}\\n```\\n### Explanation\\nSolution based on thinking about possible nonnegative ```n```\\'s values in a binary way.\\nFor example:\\n```\\n\"\"\"\\ndec  bin\\n 1 :    1\\n 2 :   10\\n 3 :   11\\n 4 :  100\\n 5 :  101\\n 6 :  110\\n 7 :  111\\n 8 : 1000\\n\"\"\"\\n```\\nThere are two important things:\\n1. Power-of-two number consists of only one ```1``` digit followed by some amount of ```0``` digits\\n2. Power-of-two number one digit longer than previous non-power-of-two number\\nThat is why the binary ANDing (```&``` operator) of every power-of-two number with the previous one will always equal 0.\\n```\\n\"\"\"\\n   100     // bitwise of \\'4\\'\\n & 011     // bitwise of previous number - \\'3\\'\\n = 000     // is equal 0\\n \\n   011     // bitwise of \\'3\\'\\n & 010     // bitwise of previous number - \\'2\\'\\n = 010     // is not equal 0\\n \\n   110     // bitwise of \\'6\\'\\n & 101     // bitwise of previous number - \\'5\\'\\n = 010     // is not equal 0\\n \\n\"\"\"\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Bit Manipulation"
                ],
                "code": "```\\nfunc isPowerOfTwo(n int) bool {\\n    return n > 0 && n & (n - 1) == 0\\n}\\n```\n```n```\n```\\n\"\"\"\\ndec  bin\\n 1 :    1\\n 2 :   10\\n 3 :   11\\n 4 :  100\\n 5 :  101\\n 6 :  110\\n 7 :  111\\n 8 : 1000\\n\"\"\"\\n```\n```1```\n```0```\n```&```\n```\\n\"\"\"\\n   100     // bitwise of \\'4\\'\\n & 011     // bitwise of previous number - \\'3\\'\\n = 000     // is equal 0\\n \\n   011     // bitwise of \\'3\\'\\n & 010     // bitwise of previous number - \\'2\\'\\n = 010     // is not equal 0\\n \\n   110     // bitwise of \\'6\\'\\n & 101     // bitwise of previous number - \\'5\\'\\n = 010     // is not equal 0\\n \\n\"\"\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1503264,
                "title": "c-power-of-two-power-of-four",
                "content": "![image](https://assets.leetcode.com/users/images/3ff191d8-2877-4d10-8e3b-1d8297f58745_1633367216.9328914.png)\\n\\n\\n * [***Power Of Two :***](https://leetcode.com/problems/power-of-two/)\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        //idx must be less than 31 beacuse 2^31 is greater than range of int\\n        for(int idx = 0; idx <= n/2 && idx < 31; idx++){\\n            int mul = pow(2,idx);\\n            if(mul == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\n\\n* [***Power Of Four :***](https://leetcode.com/problems/power-of-four/)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        \\n        // 31/2 = 15.5 in case of four\\n        //idx must be less than 31 beacuse 4^15.5 is greater than range of int\\n        for(int idx = 0; idx <= n/2 && idx < 15.5; idx++){\\n            int mul = pow(4,idx);\\n            if(mul == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        //idx must be less than 31 beacuse 2^31 is greater than range of int\\n        for(int idx = 0; idx <= n/2 && idx < 31; idx++){\\n            int mul = pow(2,idx);\\n            if(mul == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfFour(int n) {\\n        \\n        // 31/2 = 15.5 in case of four\\n        //idx must be less than 31 beacuse 4^15.5 is greater than range of int\\n        for(int idx = 0; idx <= n/2 && idx < 15.5; idx++){\\n            int mul = pow(4,idx);\\n            if(mul == n)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497116,
                "title": "java-recursion",
                "content": "Since this was tagged as a recursion problem so here you go\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 ? isPowerOfTwo(n / 2) : false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0) return false;\\n        if(n == 1) return true;\\n        return n % 2 == 0 ? isPowerOfTwo(n / 2) : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1479152,
                "title": "simple-c-solution-0ms-one-line-code",
                "content": "There\\'s a simple trick for this problem:\\nLink: [https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2](https://stackoverflow.com/questions/600293/how-to-check-if-a-number-is-a-power-of-2)\\n\\n```\\nbool isPowerOfTwo(long long int x) {\\n        return (x != 0) && ((x & (x - 1)) == 0);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isPowerOfTwo(long long int x) {\\n        return (x != 0) && ((x & (x - 1)) == 0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1395466,
                "title": "0-ms-faster-than-100-00-of-c-online-submissions-2-methods-recursion-and-bit-manipulation",
                "content": "RECURSION : \\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=1)\\n            return n==1;\\n        return (n%2==0 && isPowerOfTwo(n/2));\\n    }\\n};\\n```\\nBIT MANIPULATION :\\n```\\nbool isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        else\\n            return (n&(n-1))?false:true;\\n\\t\\t\\t}\\n```\\nPLEASE UPVOTE IF IT HELPS!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=1)\\n            return n==1;\\n        return (n%2==0 && isPowerOfTwo(n/2));\\n    }\\n};\\n```\n```\\nbool isPowerOfTwo(int n) {\\n        if(n<=0)\\n            return false;\\n        else\\n            return (n&(n-1))?false:true;\\n\\t\\t\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324918,
                "title": "simple-bit-manipulation-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        else if (n&(n-1)) return false;\\n        else return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        else if (n&(n-1)) return false;\\n        else return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297618,
                "title": "easy-to-understand-by-using-n-n-1-trick",
                "content": "**Solution 1 : Without using loop**\\n\\n```\\nclass Solution\\n{\\n    public boolean isPowerOfTwo(int n)\\n    {\\n        return n > 0 && ( n & ( n - 1 ) ) == 0 ;\\n    }\\n}\\n```\\n\\n**Solution 2 : By using loop**\\n\\n```\\nclass Solution\\n{\\n    public boolean isPowerOfTwo(int n)\\n    {\\n        long i = 1;\\n        while( i < n )\\n        {\\n            i  = i << 1 ;\\n        }\\n        return i == n ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean isPowerOfTwo(int n)\\n    {\\n        return n > 0 && ( n & ( n - 1 ) ) == 0 ;\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public boolean isPowerOfTwo(int n)\\n    {\\n        long i = 1;\\n        while( i < n )\\n        {\\n            i  = i << 1 ;\\n        }\\n        return i == n ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819107,
                "title": "recursive-python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef isPowerOfTwo(self, n: int) -> bool:\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif n % 2 != 0 or n == 0:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn self.isPowerOfTwo(n/2)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isPowerOfTwo(self, n: int) -> bool:\\n\\t\\t\\tif n == 1:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tif n % 2 != 0 or n == 0:\\n\\t\\t\\t\\treturn False\\n\\t\\t\\treturn self.isPowerOfTwo(n/2)",
                "codeTag": "Java"
            },
            {
                "id": 740206,
                "title": "swift-nonzerobitcount-property",
                "content": "\\n```\\n    func isPowerOfTwo(_ n: Int) -> Bool {\\n        return n.nonzeroBitCount == 1\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func isPowerOfTwo(_ n: Int) -> Bool {\\n        return n.nonzeroBitCount == 1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 469168,
                "title": "python-js-java-c-go-o-log-n-by-bit-manipulation-explanation",
                "content": "O( log n ) sol. based on bit-manipulation\\n\\n---\\n\\n**Python**:\\n\\n```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        if n <= 0:\\n            return False    \\n        \\n        # note:\\n        # power of 2 in binary         = b\\' 1000 ... 0\\n        # power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        # bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n-1 ) ) == 0\\n```\\n\\n---\\n\\n**Javascript**:\\n\\n```\\nvar isPowerOfTwo = function(n) {\\n    \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) ) == 0;\\n};\\n```\\n\\n---\\n\\n**Java**:\\n\\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) ) == 0;\\n    }\\n}\\n```\\n\\n---\\n\\n**C++**:\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) )== 0;\\n    }\\n};\\n```\\n\\n---\\n\\n**Go**:\\n\\n```\\nfunc isPowerOfTwo(n int) bool {\\n    \\n    // Corner case\\n    if( n <= 0 ){\\n        return false;\\n    }\\n\\n\\n    // General cases:\\n\\n    //// note:\\n    // power of 2 in binary         = b\\' 1000 ... 0\\n    // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n    // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n\\n    return ( n & ( n - 1 ) )== 0;\\n}\\n```\\n\\n---\\n\\nRelative leetcode challenge:\\n[Leetcode #342 Power of Four](https://leetcode.com/problems/power-of-four/)\\n\\n[Leetcode #326 Power of Three](https://leetcode.com/problems/power-of-three/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        \\n        if n <= 0:\\n            return False    \\n        \\n        # note:\\n        # power of 2 in binary         = b\\' 1000 ... 0\\n        # power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        # bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n-1 ) ) == 0\\n```\n```\\nvar isPowerOfTwo = function(n) {\\n    \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) ) == 0;\\n};\\n```\n```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) ) == 0;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        // Corner case\\n        if( n <= 0 ){\\n            return false;\\n        }\\n        \\n        \\n        // General cases:\\n        \\n        //// note:\\n        // power of 2 in binary         = b\\' 1000 ... 0\\n        // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n        // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n        \\n        return ( n & ( n - 1 ) )== 0;\\n    }\\n};\\n```\n```\\nfunc isPowerOfTwo(n int) bool {\\n    \\n    // Corner case\\n    if( n <= 0 ){\\n        return false;\\n    }\\n\\n\\n    // General cases:\\n\\n    //// note:\\n    // power of 2 in binary         = b\\' 1000 ... 0\\n    // power of 2 minus 1 in binary = b\\' 0111 ... 1\\n    // bitwise AND of n and (n-1) must be 0 if n is power of 2\\n\\n    return ( n & ( n - 1 ) )== 0;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 379320,
                "title": "constant-time-and-memory-complexity-one-line-easy-solution-with-explanation",
                "content": "```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n > 0 and 1073741824 % n == 0\\n```\\n\\n\\nIn particular, n is of type int. This means it is a 4 byte, signed integer [ref]. The maximum value of this data type is 2147483647. \\nKnowing the limitation of n, we can now deduce that the maximum value of n that is also a power of two is 1073741824. We calculate this as:\\n\\n```\\nmath.log(2147483647, 2) = 30.999999999328196  \\n30.999999999328196  // 1 = 30\\n```\\n\\nTherefore, the possible values of n where we should return true are 2^0 ... 2^30, therefore all we need to do is divide 2^30 by n. A remainder of 0 means n is a divisor of 2^30 and therefore a power of 2.\\n\\nComplexity Analysis\\n\\nTime complexity : O(1). We are only doing one operation.\\n\\nSpace complexity : O(1). We are not using any additional memory.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution(object):\\n    def isPowerOfTwo(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: bool\\n        \"\"\"\\n        return n > 0 and 1073741824 % n == 0\\n```\n```\\nmath.log(2147483647, 2) = 30.999999999328196  \\n30.999999999328196  // 1 = 30\\n```",
                "codeTag": "Java"
            },
            {
                "id": 377771,
                "title": "ruby-one-liner",
                "content": "```\\ndef is_power_of_two(n)\\n    return n <= 0 ? false : (2**63 % n == 0)\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef is_power_of_two(n)\\n    return n <= 0 ? false : (2**63 % n == 0)\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 262543,
                "title": "my-java-solution-one-liner",
                "content": "```\\npublic boolean isPowerOfTwo(int n) {\\n\\treturn n > 0 && (n & (n-1)) == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPowerOfTwo(int n) {\\n\\treturn n > 0 && (n & (n-1)) == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 235895,
                "title": "java-solution",
                "content": "**Solution 1: Flip Least-Significant Set Bit**\\n\\n- The operation `n & (n - 1)` flips the least-significant bit in `n`. For example. `1010` will become `1000`\\n- If `n` is a power of `2` then only one bit of `n` is set. If we clear this least-significant only set bit of `n`, then it will become `0`.\\nFor example- \\n```\\nLet n  =  8  =  1 0 0 0\\nn - 1  =  7  =  0 1 1 1\\nthen,\\nn & (n - 1) will result in zero.\\n```\\n\\nTime complexity: `O(1)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```\\n\\n**Solution 2: Count Number of Set Bits**\\n\\n- All power of two numbers have only one bit set. So count the number of set bits and if we get `1` then number is a power of `2`\\n\\nTime complexity: `O(1)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return n > 0 && Integer.bitCount(n) == 1;    \\n    }\\n}\\n```\\n\\n**Solution 3: Repeated Division by Two**\\n\\n- Here the idea is to keep dividing the number iteratively by two. In any iteration, if `n` becomes `odd` and `n` is not `1` then `n` is not a power of `2`. If `n` becomes `1` then it is a power of `2`.\\n\\nTime complexity: `O(log n)`\\nSpace Complexity: `O(1)`\\n\\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n == 0)\\n            return false;\\n        \\n        while(n % 2 == 0)\\n            n /= 2;\\n        \\n        return n == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nLet n  =  8  =  1 0 0 0\\nn - 1  =  7  =  0 1 1 1\\nthen,\\nn & (n - 1) will result in zero.\\n```\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return n > 0 && (n & n - 1) == 0;\\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        return n > 0 && Integer.bitCount(n) == 1;    \\n    }\\n}\\n```\n```\\nclass Solution \\n{\\n    public boolean isPowerOfTwo(int n) \\n    {\\n        if(n == 0)\\n            return false;\\n        \\n        while(n % 2 == 0)\\n            n /= 2;\\n        \\n        return n == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193862,
                "title": "java-bit-solution-beat-100",
                "content": "```\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }\\n        return (n & (n-1)) == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if (n <= 0) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 131364,
                "title": "my-binary-java-solution",
                "content": "```\\npublic boolean isPowerTwo(int n) {\\n    return (n > 0) && (n & (n - 1)) == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPowerTwo(int n) {\\n    return (n > 0) && (n & (n - 1)) == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 64059,
                "title": "five-efficient-yet-different-solutions-in-c-well-commented",
                "content": "    //AC - 8ms - using dictionary to check the limited possibility;\\n    bool isPowerOfTwo(int n)\\n    {\\n        int arr[] = {1,\\n        2,4,8,16,32,64,128,256,512,1024,\\n        2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,\\n        2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824};\\n        for(int i = 0; i < sizeof(arr)/sizeof(int); i++)\\n            if(n == arr[i])\\n                return true;\\n        return false;\\n    }\\n\\n\\n----------\\n\\n\\n    \\n    //AC - 4ms - using division to check;\\n    bool isPowerOfTwo(int n)\\n    {\\n        while(n)\\n        {\\n            if(n == 1) return true;\\n            if(n%2) return false;\\n            n /= 2;\\n        }\\n        return false;\\n    }\\n    \\n\\n\\n----------\\n\\n\\n    //AC - 4ms - count the 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        if(n < 1) return false;\\n        int count = 0;\\n        while(n)\\n        {\\n            if(n & 1) count++;\\n            n >>= 1;\\n        }\\n        return count>1? false : true;\\n    }\\n    \\n\\n\\n----------\\n\\n> Bit manipulation -> always the coolest!\\n\\n\\n    //AC - 4ms - using n&n-1 to ensure there is only one 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        return n>0 && !(n&(n-1));\\n    }\\n\\n    \\n    //AC - 4ms - using n&-n to get the last 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        return n>0 && n==(n&-n); \\n    }",
                "solutionTags": [],
                "code": "    //AC - 8ms - using dictionary to check the limited possibility;\\n    bool isPowerOfTwo(int n)\\n    {\\n        int arr[] = {1,\\n        2,4,8,16,32,64,128,256,512,1024,\\n        2048,4096,8192,16384,32768,65536,131072,262144,524288,1048576,\\n        2097152,4194304,8388608,16777216,33554432,67108864,134217728,268435456,536870912,1073741824};\\n        for(int i = 0; i < sizeof(arr)/sizeof(int); i++)\\n            if(n == arr[i])\\n                return true;\\n        return false;\\n    }\\n\\n\\n----------\\n\\n\\n    \\n    //AC - 4ms - using division to check;\\n    bool isPowerOfTwo(int n)\\n    {\\n        while(n)\\n        {\\n            if(n == 1) return true;\\n            if(n%2) return false;\\n            n /= 2;\\n        }\\n        return false;\\n    }\\n    \\n\\n\\n----------\\n\\n\\n    //AC - 4ms - count the 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        if(n < 1) return false;\\n        int count = 0;\\n        while(n)\\n        {\\n            if(n & 1) count++;\\n            n >>= 1;\\n        }\\n        return count>1? false : true;\\n    }\\n    \\n\\n\\n----------\\n\\n> Bit manipulation -> always the coolest!\\n\\n\\n    //AC - 4ms - using n&n-1 to ensure there is only one 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        return n>0 && !(n&(n-1));\\n    }\\n\\n    \\n    //AC - 4ms - using n&-n to get the last 1-bit;\\n    bool isPowerOfTwo(int n)\\n    {\\n        return n>0 && n==(n&-n); \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64074,
                "title": "231-power-of-two-cpp-solution",
                "content": "    //231. Power of Two\\n    //https://leetcode.com/problems/power-of-two/\\n    //http://www.cnblogs.com/grandyang/p/4623394.html\\n    #include <iostream>\\n    using namespace std;\\n    class Solution {\\n    public:\\n    \\tbool isPowerOfTwo(int n) {\\n    \\t\\treturn n > 0 && !(n & (n - 1));\\n    \\t}\\n    };\\n    int main(int argc, char** argv) {\\n    \\tSolution solution;\\n    \\tgetchar();\\n    \\treturn 0;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tbool isPowerOfTwo(int n) {\\n    \\t\\treturn n > 0 && !(n & (n - 1));\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 64075,
                "title": "one-line-ruby-solution",
                "content": "    def is_power_of_two(n)\\n      return n > 0 && n.to_s(2).count(\"1\") == 1\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    def is_power_of_two(n)\\n      return n > 0 && n.to_s(2).count(\"1\") == 1\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 64082,
                "title": "c-1-line-solution",
                "content": "\"Please provide more information - at least 30 characters\"\\n\\n        return n<=0? false: !(n&(n-1));\\n\\nover",
                "solutionTags": [],
                "code": "\"Please provide more information - at least 30 characters\"\\n\\n        return n<=0? false: !(n&(n-1));\\n\\nover",
                "codeTag": "Unknown"
            },
            {
                "id": 64108,
                "title": "my-one-line-c-solution",
                "content": "    bool isPowerOfTwo(int n) {\\n        return (n > 0) && (!(2147483648%n)); //2147483648 = 2^31\\n    }",
                "solutionTags": [],
                "code": "    bool isPowerOfTwo(int n) {\\n        return (n > 0) && (!(2147483648%n)); //2147483648 = 2^31\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 64125,
                "title": "it-is-funny-that-log-function-is-not-accurate-for-a-power-of-2-number-536870912",
                "content": "I was using a solution like:\\n\\n    var log2 = Math.Log(n, 2);\\n    return (int)log2 == log2;\\n\\nFunny is, it's false for n=536870912, which should be true.\\nThe log2 should be 29, but actually inaccurately 29.000000000000004.\\n\\nAnyway, a not that pretty solution can do all but slow:\\n\\n    return Math.Pow(2, (int)Math.Log(n, 2));\\n\\nMaybe those bit operation solutions are more dependable than math funcionts in accuracy.",
                "solutionTags": [],
                "code": "I was using a solution like:\\n\\n    var log2 = Math.Log(n, 2);\\n    return (int)log2 == log2;\\n\\nFunny is, it's false for n=536870912, which should be true.\\nThe log2 should be 29, but actually inaccurately 29.000000000000004.\\n\\nAnyway, a not that pretty solution can do all but slow:\\n\\n    return Math.Pow(2, (int)Math.Log(n, 2));\\n\\nMaybe those bit operation solutions are more dependable than math funcionts in accuracy.",
                "codeTag": "Unknown"
            },
            {
                "id": 64124,
                "title": "4ms-c-solution-that-uses-std-bitset",
                "content": "    #include <bitset>\\n    \\n    class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && std::bitset<sizeof(n) * 8>(n).count() == 1;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool isPowerOfTwo(int n) {\\n            return n > 0 && std::bitset<sizeof(n) * 8>(n).count() == 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 64180,
                "title": "8ms-c-solution",
                "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n            while(n!=0&&n%2 == 0)\\n            {\\n                n = n/2;\\n            }\\n           return (n==1);\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n            while(n!=0&&n%2 == 0)\\n            {\\n                n = n/2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 64170,
                "title": "1-liners-other-than-the-boring-n-n-1-p",
                "content": "**C++**\\n\\nUsing how doubles represent numbers.\\n\\n    bool isPowerOfTwo(double n) {\\n        return n > 0 && !(*(long long*)&n << 12);\\n    }\\n\\n**Python Golf**\\n\\nUsing n&-n and chained comparisons.\\n\\n    def isPowerOfTwo(self, n):\\n        return-n&n==n>0\\n\\n**Python**\\n\\nAssigning a set's method.\\n\\n    class Solution:\\n        isPowerOfTwo = {1<<e for e in range(31)}.__contains__",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "class Solution:\\n        isPowerOfTwo = {1<<e for e in range(31)}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569274,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565371,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1567229,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1570435,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1570176,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565174,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565805,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1719202,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1576395,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1576106,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1569274,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565371,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1567229,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1570435,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1570176,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565174,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1565805,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1719202,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1576395,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1576106,
                "content": [
                    {
                        "username": "DontSuCharlie",
                        "content": "I wish the poster for the [n&(n-1) trick](https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick) gave a more intuitive reason for why it works. This is my reasoning:\\n\\nAt a power of 2, we only have one bit set to 1 at its respective decimal place (e.g. 1000).\\nAt the power of 2 minus 1, we have **all the bits before the current decimal place set to 1 (e.g. 0111)**, which means that `n & (n - 1) == 0` for powers of 2. \\nThe reason why this happens is because we\\'re in the binary number system and a power of 2 means we\\'re going to the next decimal place (i.e. 0111 + 1 = 1000).\\n\\nWhat about when n is not a power of 2? If you look at a list of binary numbers:\\n\\n0100\\n0101\\n0110\\n0111\\n1000\\n\\nRemember how the power of 2 is the special case where adding 1 results in us moving to the next decimal place (i.e. 0111 + 1 = 1000)? Since every other case doesn\\'t result in that, there is at least the current power of 2\\'s 1 bit overlapping with whatever the number is (i.e. we\\'re at 0100, 0101 will always share the 0100 bit. The only time the 0100 bit becomes 0 again is if we go to the next power of 2).\\n\\nI hope this made sense!\\n"
                    },
                    {
                        "username": "Neo-Prime",
                        "content": "Great idea for implementing the solution. I also discovered the fact that the \\'power of 2\\' always possesses the bit 1 at its respective decimal place. What I was lacking was to find a way to count \\'if there was a single 1\\' in the binary representation. \\n\\nBut, your way is actually better and smarter.......thanks a lot :)"
                    },
                    {
                        "username": "akabhishek680",
                        "content": "thanks for such beautiful explanation "
                    },
                    {
                        "username": "asen",
                        "content": "bool isPowerOfTwo(int n){return n>0&&!(n&(n-1));}"
                    },
                    {
                        "username": "samparly",
                        "content": "Note that 2^n = 00..100..0\\nand 2^n-1 = 00...011..1\\nso 2^n & 2^n-1 = 0\\n\\npublic class PowerofTwo {\\n\\n\\tpublic static boolean isPowerOfTwo(int n) {\\n\\t\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n\\t}\\n\\n}"
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "please don't add solution here \nhere we come to see discussion\n"
                    },
                    {
                        "username": "Soulreaper1OO",
                        "content": "the mask for this one was literally behind it all this time"
                    },
                    {
                        "username": "eyalz15",
                        "content": "return n>0 and (n & (n-1) == 0)\\n\\npower of two is in the form of 10....00\\nthe previous number is 01....1\\nSo They have nothing in common.\\nIt happens only to powers of 2.\\n\\nWatch out for negative numbers."
                    },
                    {
                        "username": "icenet90",
                        "content": "\\tpublic bool IsPowerOfTwo(int n)\\n\\t{\\n\\t\\treturn n > 0 && (n & (n - 1)) == 0;\\n\\t}"
                    },
                    {
                        "username": "rishabhcode_7_",
                        "content": "why here is not error while writing if statement and in that performing operation throws error"
                    },
                    {
                        "username": "nikcode",
                        "content": "Why people downvoting unnecessary"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for December, Day 21.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/power-of-two/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Bitwise Operators : Get the Rightmost 1-bit\n\n  \n**Approach 2:** Bitwise operators : Turn off the Rightmost 1-bit\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "GuruSajjan007",
                        "content": "If n is divisible by 2 the in Binary representation it should have only one once. \nreturn n > 0 and str(bin(n)).count('1') == 1\n\nIF you liked it please Upvote."
                    },
                    {
                        "username": "kushguptacse",
                        "content": "We need to find the number of digits in base 2 form. Since in java we dont have generic log method to calculate in base b. for that we can use log property logba = logca/logcb. now we have number digits-1.\\nif there is no decimals i.e. %1 will be zero in such case. return true\\n \\n just 1 line ->\\n return (Math.log10(n)/Math.log10(2))%1==0;\\n"
                    },
                    {
                        "username": "arpan_b8907",
                        "content": "There are various methods of solve this problem .\\n1. Method 1 (recursion) -> We will start from 2 power 0 , and start looping till we have 2 power i less than equal to n . if at any time we get 2 power i equal to n ..then we will return true .\\n\\nso T.complexity -> O(Logn) ....as we are increasin power \\n     S.complexity->O(1)\\n\\t \\nMethod 2(more optimised using bit-masking) -> We will using the xor property ...Xor of a same number gives 0, while different number gives nonzereo.\\n\\nfor any number which is a power of 2 , if we write binary representation we will get no of set bits is one ...![image](https://assets.leetcode.com/users/images/d40cd08b-346b-437f-b68a-bc709701306a_1640078926.0708427.png)\\n\\nSo, T.complexity of this solution is O(1) , and S.complexity->O(1)\\n"
                    },
                    {
                        "username": "19dce130",
                        "content": "Are these T.Complexity correct for both solutions?\\nI think both the solution have complexity of O(n)."
                    }
                ]
            },
            {
                "id": 1573727,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1922858,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1762347,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1697333,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1679887,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1575444,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1575158,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1574817,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1573902,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1572828,
                "content": [
                    {
                        "username": "poitevinpm",
                        "content": "https://medium.com/@poitevinpm/leetcode-231-powers-of-2-bad49e24b198"
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "I Just can\\'t believe my mind told me to use binary search and I solved this question with the help of binary search. It means a lot to me because I was struggling these days because Iam from non tech background."
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "Why -2^31 is not considered as power of two?"
                    },
                    {
                        "username": "alankar_asthana",
                        "content": "[@CT-7567](/CT-7567) Thank You"
                    },
                    {
                        "username": "CT-7567",
                        "content": "mathematically, all negative numbers should be false I guess. Imagine taking square root of -4, at the end you will have 2\\u221A-1 which is 2i."
                    },
                    {
                        "username": "sutirthverma",
                        "content": "Hey, I came up with this solution but while testing it for `n = 4` testcase it is giving wrong answer, so I tried running it on my local ide and the result shows correct answer.\\n\\nbool isPowerOfTwo(int n){\\n    static int x;\\n    if(pow(2,x) == n)\\n        return 1;\\n    \\n    if(n < pow(2,x))\\n        return 0;\\n    \\n    x++;\\n    return isPowerOfTwo(n);            \\n}"
                    },
                    {
                        "username": "SeaShanty",
                        "content": "why is my code not passing the last test case?\\n\\n\\nResult:\\n      n=536870912\\n      output: false\\n      expected: true\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n\\n        if(n==1)\\n        {\\n            return true;\\n        }\\n\\n        if( Math.round(log2(n)) == log2(n))\\n        {\\n            return true;\\n        }\\n\\n        return false;\\n        \\n    }\\n\\n    public double log2(double n)\\n    {\\n        return Math.log(n)/Math.log(2);\\n    }\\n}"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "brother you have to define if n = -v then what would return  true , or false \\n\\nand you should return false .  "
                    },
                    {
                        "username": "divyanshusingh290828",
                        "content": "int x=1;\\n          if(n==1 || n==2)\\n          {\\n            return true;\\n          }\\n          while(Math.pow(2,x)<n)\\n          {\\n             x=x+1;\\n             if(Math.pow(2,x)==n)\\n             {\\n                 return true;\\n             }\\n          }\\n          return false;\\n    }"
                    },
                    {
                        "username": "yozaam",
                        "content": "Power of two has only 1 set bit :)\\n\\n0000100000 this is a power of two\\n1110001100 this is not, since it is sum of many powers of 2\\n\\nSo, how to check one set bit?\\n\\n`return bin(n).count(\\'1\\') == 1`\\n\\nOr else we can look at the \\'erase LSB trick\\' since in binary of n-1, we just do a carry of all 0 before LSB becoming 1 and LSB becomes 0\\n\\n`return n!=0 and 0 == (n&(n-1))`"
                    },
                    {
                        "username": "uzdik",
                        "content": "Simple way to solve this problem by using this:\\n`return n!=0 and (n&-n)==n  `"
                    },
                    {
                        "username": "Livid_s",
                        "content": "return n > 0 and list((bin(n))).count(\\'1\\') == 1"
                    },
                    {
                        "username": "the_imperor",
                        "content": "if(n<=0||n&(n-1)) return false; return true;"
                    },
                    {
                        "username": "wwwzhangshenzecn",
                        "content": "Convert this number to hexadecimal, right truncated 0, only 1 is True, otherwise False\\n\\t\\t\\n\\t\\treturn True if bin(n)[2:].rstrip(\\'0\\')==\\'1\\'else False\\n"
                    }
                ]
            },
            {
                "id": 1571467,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571468,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1571466,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2064143,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2059422,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2037307,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2002478,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1998339,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1988413,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1987050,
                "content": [
                    {
                        "username": "duanmeng",
                        "content": "\\nreturn (n > 0) && (n & (n - 1)) == 0;"
                    },
                    {
                        "username": "mlmc03",
                        "content": "I've included 'from math import log' and am getting an error with 'math domain error' .. any suggestions?"
                    },
                    {
                        "username": "FredWe",
                        "content": "pow(2, 0) == 0, so 0 is also a power of 2\\nIsn't it ?"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Nah,brother 2^0=1"
                    },
                    {
                        "username": "vnhnhm",
                        "content": "[Here](https://leetcode.com/problems/power-of-two/solutions)'s the URL that you use for adding solutions/submissions. This place is the discussion section.\n\n"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "How do you optimize this Solution?\\n\\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;"
                    },
                    {
                        "username": "aastikmehta",
                        "content": "Very simple approach is that we have to check the number is matched with any power of 2 so return true else false  and check by using for loop by initializing variable with 0 and ending with 30 "
                    },
                    {
                        "username": "_-ProzpeKt-_",
                        "content": "why my this code, on input 3 gives true instead of false \\n\\n        if(n & (n-1) == 0){\\n            return \"True\";\\n        }else{\\n            return \"False\";\\n        }"
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Try this:\\n\\n    if(n<1)\\n    return false;\\n    return ((n & (n-1)) == 0);\\n    "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "Logically,it can\\'t be wrong,\\nI think its a compiler mistake.\\nI tried different methods,even printed the output of 2&3,it gives 1 for no reason."
                    },
                    {
                        "username": "sana479",
                        "content": "def poweroftwo(n):\\n    if n == 1:\\n        return True\\n    while n > 1:\\n       n %= 2\\n    if n == 0 :\\n        return True\\n    if n > 1  :\\n        return False \\nwhat is the problem of my code? "
                    },
                    {
                        "username": "Yagnik_Sharma",
                        "content": "try dividing check my you will understand the mistakes.\\n   \\ndouble m=n;\\n    if(n==0)\\n    return false;\\n    if(n==1)\\n    return true;\\n    \\n    while(m!=0.0)\\n    {\\n        m=m/2;\\n        if(m==1.0)\\n        return true;\\n\\n    }     \\n    \\n    return false;\\n    "
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n    if(n==0)\\n    return 0;\\n    if(n==1)\\n    return 1;\\n    if(n%2 == 1)//odd case like 3 it return false;\\n    return 0;\\n    int ans = (isPowerOfTwo(n/2));\\n    return ans;\\n    }\\n};\\n 100% solution\\n"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n       if(n<1) return false;\\n       if(n==1) return true;\\n       if(n%2 == 1)//odd case like 46/2--> 23 it return false;\\n       return false;\\n       //recursive relation\\n       return (isPowerOfTwo(n/2));\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1975873,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1969542,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1936398,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1936309,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1917041,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1894783,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1883906,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1876380,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1876201,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1862552,
                "content": [
                    {
                        "username": "AMRITPALOO7",
                        "content": "i write a code using if-else conditions ,but it is getting error for n=3;\\ncan someone explain:\\n class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        bool ispower;\\n        \\n        while(n!=0)\\n        {\\n            int bit = n&1;\\n            n = n>>1;\\n            if(bit==1)\\n            {\\n                if(n==0)\\n                {\\n                    ispower = true;\\n                }\\n                else{\\n                    ispower = false;\\n                }\\n            }\\n        }\\n        return ispower;\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "```\nimport math\nclass Solution(object):\n    def isPowerOfTwo(self, n):\n        x = math.log2(n)\n        return x % 1 == 0\n```\n\n\n`AttributeError: 'module' object has no attribute 'log2'` okay..."
                    },
                    {
                        "username": "Sahej5413",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n       long long power=1;\n       vector<long long>v(n,1);\n       if(n==1)return 1;\n       for(long long i=1;i<=n/2;i++){\n            power*=2;\n            v.push_back(power);\n       } \n       for(int i=1;i<=v.size()-1;i++)\n        {\n                if(v[i]==n)\n                    return 1;\n        }\n    return 0;\n    }\n};\n\nwhat the demerit of this code"
                    },
                    {
                        "username": "Akshat1978",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        for(int i=0;i<=30;i++)\n        {\n            int ans = pow(2,i);\n            if(ans==n)\n            {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n\nDo anyone have any idea to solving this problem with the different code?\nMay we do that with the help of function?"
                    },
                    {
                        "username": "code_meraki",
                        "content": "I\\'m unable to understand why this code is working for all testcases except 536870912 number.\\nCan someone please let me know where am i going wrong?\\n\\nclass Solution {\\npublic boolean isPowerOfTwo(int n) {\\nif(n<=0){\\n            return false;\\n        }\\n        double a=(double)n;\\n        return Math.ceil(Math.log(a)/Math.log(2))==Math.floor(Math.log(a)/Math.log(2));\\n    }\\n}"
                    },
                    {
                        "username": "Amitanandan",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int count=0;\\n        int m=n;\\n        \\n        while(m!=0){\\n            int bit=m&1;\\n             if(bit){\\n                count++;\\n             }\\n            m=m>>1;\\n        }\\n        if(count){\\n            return true;\\n        }else{\\n            return false;\\n        }\\n     \\n    }\\n};\\ncould someone tell me why it is showing i have exceeded time limit as of my knowledge the maximum 1 count could store is 30 or 31 (in the count and it is not a big number;)could someone clarify my doubt."
                    },
                    {
                        "username": "selindoga",
                        "content": "Is it bad if I used java\\'s own log function to solve this problem? Should not I solve it like that? I see that everyone solved this problem without using java.lang.Math ."
                    },
                    {
                        "username": "garyyaoresearch",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        b = \\'{:b}\\'.format(n)\\n        print(b, b.count(\\'1\\'))\\n        return(b.count(\\'1\\') == 1)\\n\\nhow come if n is -16, b is -\\'10000\\', b.count(\\'1\\') is 1, but b.count(\\'1\\') == 1 evaluates as false??"
                    },
                    {
                        "username": "Lainaaa",
                        "content": "Why recursions and loops are faster than AND operation? "
                    },
                    {
                        "username": "soumyajitsaha72",
                        "content": "Simple Logic...\\nIf we have to represent in powers of 2 then decimal should be;\\n0001 - 1\\n0010 - 2\\n0100 - 4\\n1000 - 8\\n\\nNote : - Every binary number is having only 1 - \\'1\\'bit, rest are 0 bits.\\nSo, if number of \\'1\\'bits is >= 2... it\\'s not divisible (false case ).\\nI hope... I have tried to simplify my logic."
                    }
                ]
            },
            {
                "id": 1857426,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1852631,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1837993,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1829023,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1827392,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1820668,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1812224,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1812067,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1802008,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1794915,
                "content": [
                    {
                        "username": "robinofautumn99",
                        "content": " `bool isPowerOfTwo(int n) \n    {\n        if (n==1) return true;\n        if(n>=2)\n        {\n            if(n%2==1) return false;\n            else\n            {\n                if ((log(n) / log(2)) == static_cast<int>(log(n) / log(2))) \n                    return true;\n            }\n        }\n        return false;\n    }`\n\nwhy is the above code failing for n = 536870912---> (2^29)\nthe above code returns false but should return true.\nplease someone explain"
                    },
                    {
                        "username": "omkar078655",
                        "content": "class Solution {\npublic:\n    bool isPowerOfTwo(int n) {\n        int m=n;\n        if(n==1)\n        return 1;\n        else if(n==0)\n        return 0;\n        while(m!=1){\n            m=m/2;\n            count++;    //here showing overloaded function\n        }\n        if(n==pow(2,count))\n        return 1;\n        else \n        return 0;\n    } \n};\n\nat count++ showing overloaded function how to resolve this"
                    },
                    {
                        "username": "vishal811",
                        "content": "why count++ gives us runtime error\\n"
                    },
                    {
                        "username": "prabin_gupta",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n == 1)\\n            return true;\\n        if(n % 2 == 0){\\n            return isPowerOfTwo(n/2);\\n        }else{\\n            return false;\\n        }\\n    }\\n}\\n\\nwhy is my code showing stack overflow"
                    },
                    {
                        "username": "Guddukumar7050",
                        "content": "why for -( 2^31 )the answer is false....."
                    },
                    {
                        "username": "satyamS_71",
                        "content": "I tried this ` return (Math.log(n) / Math.log(2)) % 1 == 0;` but this failed for the case n = 536870912. Can anybody tell why this is happening? "
                    },
                    {
                        "username": "alk68",
                        "content": "hah. this number 1073741824 not pass a test)))). Okay just divide by 4))"
                    },
                    {
                        "username": "alk68",
                        "content": "This is some kind of joke, but the division by 2 numbers that we check helped me. Maybe some kind of joke with bits."
                    },
                    {
                        "username": "himanshusingh2389",
                        "content": "simple java s0l.\nclass Solution {\n    public boolean isPowerOfFour(int n) {\n         \n         if(n<=0) return false;\n        while(n%4==0){\n            n/=4;\n        }\n        return n==1;\n    }\n}"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int c=0;\\n        if(n<0){\\n            return false;\\n        }\\n        while(n){\\n            if(n&1){\\n                c++;\\n            }\\n            n>>=1;\\n        }\\n        if(c==1){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "bharti820",
                        "content": "//base case\\nif(n==0)\\nreturn false\\nif(n==-2147483648)\\nreturn false\\nreturn !(n&(n-1))"
                    },
                    {
                        "username": "sourav03aeccse",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if(n<=0) return false;\\n        if(n==1) return 1;\\n        int n1=(int)(log(n)/log(2));\\n        return (int)pow(2,n1) == n;\\n    }\\n};"
                    },
                    {
                        "username": "varshini-S",
                        "content": "for(int i=0; i<n; i++){\\n        if(pow(2,i)==n){\\n            return true;\\n        }\\n    }\\n    return false;\\n\\nwhy can approach like this?? \\nsomeone help me!"
                    }
                ]
            },
            {
                "id": 1777421,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1774219,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1772820,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1772385,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1771151,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1760864,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1759628,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755999,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1755825,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749483,
                "content": [
                    {
                        "username": "helloadig",
                        "content": "Is anyone can refactor this code if possible?...\n```\nbool isPowerOfTwo(int n) {\n        for(int i = 0; i<=30; i++){\n            int ans = pow(2, i);\n            if(ans==n){\n                return true;\n            }\n        }\n        return false; \n}\n```"
                    },
                    {
                        "username": "Avadhesh-1636",
                        "content": "VERY EASY || JAVA || 0(N)  || USING DIVISION METHOD\\n\\nclass Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n==0){\\n            return false;\\n        }\\n        while(n!=1){\\n            if(n%2 != 0){\\n                return false;    \\n            }\\n            n = n/2;  \\n        }\\n         return true;\\n    }\\n}"
                    },
                    {
                        "username": "vinaygottipamula",
                        "content": "Who else missed the edge testcase=0 :-("
                    },
                    {
                        "username": "izzatullohboy007",
                        "content": "class Solution:\\n    def isPowerOfTwo(self, n: int) -> bool:\\n        while n > 0:\\n            if n == 1:\\n                return True\\n            if n % 2 ==1:\\n                return False\\n            n//=2\\n        return False\\n                      \\n"
                    },
                    {
                        "username": "omprakashpatel_mrop",
                        "content": "c++ Solution by #mrop\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        int ans = 1;\\n        \\n        for(int i = 0; i <= 30 ; i++){\\n\\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n            if(ans < INT_MAX/2)\\n              ans = ans * 2;\\n\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "mrdineshkumar",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        int ans=1;\\n        for(int i=0;i<=30;i++)\\n        {\\n            if(ans==n)\\n            return true;\\n            if(ans<INT_MAX/2)\\n            ans=ans*2;\\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "lone__wolf",
                        "content": "Why question tag is under \"recursion\" as well?"
                    },
                    {
                        "username": "dm2758",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n\\n        int ans = 1;\\n\\n        for(int i = 0; i <= 30; i++){\\n            \\n            \\n            if(ans == n)\\n            {\\n                return true;\\n            }\\n\\n            if(ans < INT_MIN/2)\\n            ans = ans * 2;\\n        }\\n        return false;\\n        \\n    }\\n};\\n\\nCan someone tell why this code is failing the middle test case.\\n"
                    },
                    {
                        "username": "codersams",
                        "content": "INT_MIN should be INT_MAX"
                    },
                    {
                        "username": "codersams",
                        "content": "It just came to my mind (only logic part): \n       double logOfN = Math.Log2(n);\n        if((logOfN * 10)%10 ==0)\n        {\n            return true;\n        } \n\nExplanation: log of n (base 2) will always be a whole number."
                    },
                    {
                        "username": "suryanshronak3",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<=30;i++){\\nint ans = pow(2,i);\\n\\nif(n==ans)\\nreturn ans;\\n\\n\\n        }\\n        return false;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1749183,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1741120,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1739578,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1731474,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1731028,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1724607,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1719343,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1714238,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1712162,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            },
            {
                "id": 1698212,
                "content": [
                    {
                        "username": "deependraparmar05",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        \\n        for(int i=0; i<=30; i++){\\n            int ans = pow(2,i);\\n\\n            if(ans == n){\\n                return true;\\n            }\\n        }\\n\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "RANJANSINGH9900",
                        "content": "class Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        for(int i=0;i<31;i++){\\n            if(pow(2,i)==n){\\n                return true;\\n            }\\n            \\n        }\\n        return false;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "code_souravit",
                        "content": "class Solution {\\n    public boolean isPowerOfTwo(int n) {\\n        if(n <= 0 ){\\n            return false;\\n        }\\n        long check = 1;\\n        while(check <= n){\\n            if(n%check != 0){\\n                return false;\\n            }check *= 2;\\n        }\\n        return true;\\n    }\\n}"
                    },
                    {
                        "username": "TBalaji",
                        "content": "n & n - 1 removes the last 1 in the binary form of n\\nif and only if n is a power of two, there is only one 1 in the binary form of n"
                    },
                    {
                        "username": "satyam_explor",
                        "content": "This problem can have many different approaches for solving. \\n\\n# METHOD 1    (Brute force) \\n\\n//  keep dividing and checking with all power of 2 until both numbers are the same\\n \\nclass Solution {\\npublic:                    \\n    bool isPowerOfTwo(int n) {\\n        int i=0;\\n        int store=0;                         \\n        if (n<=0){\\n            return false;\\n        }\\n\\n        while(store!=n){\\n            store= pow(2,i);                    \\n            if (n%store!=0){\\n                break;\\n            }\\n            else {\\n                if (store==n){\\n                    return true;\\n                }\\n                i++;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n\\n\\n# METHOD 2      ( Upgraded Brute Force   xD :)\\n\\n// count the number of set bits if (number of \\'1\\' in binary representation if >1 then false)\\n\\nclass Solution {\\npublic:\\n    bool isPowerOfTwo(int n) {\\n        if (n<=0){\\n            return false;\\n        }\\n        int count =0;\\n        while (n!=0){\\n            if(n&1){\\n                count++;\\n            }\\n            if (count>1){\\n                return false;\\n            }\\n            n=n>>1;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n# Method 3  ( BEST METHOD) \\n// The  \\'&\\'  operation of the number \\'n\\' , \\'n-1\\' is always = 0   for all powers of 2.   \\n\\npublic static boolean isPowerOfTwo(int n) {\\n\\treturn n < 1 ? false : (n & (n - 1)) == 0 ? true : false;\\n}\\n"
                    },
                    {
                        "username": "YogeshVats",
                        "content": "\\uD83D\\uDC31\\u200D\\uD83C\\uDFCDSOLUTION IN JAVA\\n\\n//will start from the index = 0 which will start checking the 2^(index) with the given value, n.\\nclass Solution {\\n    public boolean isPowerOfTwo(int n, int index){\\n        //BC\\n        if(Math.pow(2, index) > n) return false;\\n        //MC\\n        if(Math.pow(2, index) == n) return true;\\n        //RC\\n        return isPowerOfTwo(n, index+1);\\n    }\\n    public boolean isPowerOfTwo(int n) {\\n        return isPowerOfTwo(n, 0);\\n    }\\n}\\n"
                    },
                    {
                        "username": "Gautam8637",
                        "content": "if  any number power of 2 then it\\'s form is 00...100.. for example binary representation of 4 is 100 and 8 is 1000 and if we take \"and\" operation with it\\'s previous number like in case of 4 , 3 is previous number so binary of 3 is 011 and as we know binary of 4 is 100 so if we take \\'and\\' operation of  both then it will come to 0 in each case so if n is number which is power of 2 so n&(n-1)=0;"
                    },
                    {
                        "username": "pagarevijayy",
                        "content": "Interesting case:  when n = 16\\n\\nit works for `return n > 0 && !(n & (n - 1)) `\\nbut not for `return n > 0 && (n & (n - 1) == 0) `\\n\\nany reasons/explanations appreciated thanks."
                    },
                    {
                        "username": "pahwagautam786",
                        "content": "I have done it with recursion and beat 100% time"
                    },
                    {
                        "username": "adityakeshari",
                        "content": "Please tell me, why this code is not working?? getting this error \"signed integer overflow: 2147483647 + 1 cannot be represented in type \\'int\\' (solution.cpp)\"\\n\\nbool isPowerOfTwo(int n) {\\n        int temp;\\n        bool ispow=true;\\n        if( n==1 ){\\n            return true;\\n        }\\n        for(int i=0; pow==true && n!=1; i++){  \\n        if ( n&1==1 ){\\n            ispow=false;\\n            break;\\n        }\\n            else{\\n                n=n>>1;\\n            }\\n        }\\n        return pow;\\n    }"
                    }
                ]
            }
        ]
    },
    {
        "title": "Verify Preorder Serialization of a Binary Tree",
        "question_content": "<p>One way to serialize a binary tree is to use <strong>preorder traversal</strong>. When we encounter a non-null node, we record the node&#39;s value. If it is a null node, we record using a sentinel value such as <code>&#39;#&#39;</code>.</p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/03/12/pre-tree.jpg\" style=\"width: 362px; height: 293px;\" />\n<p>For example, the above binary tree can be serialized to the string <code>&quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</code>, where <code>&#39;#&#39;</code> represents a null node.</p>\n\n<p>Given a string of comma-separated values <code>preorder</code>, return <code>true</code> if it is a correct preorder traversal serialization of a binary tree.</p>\n\n<p>It is <strong>guaranteed</strong> that each comma-separated value in the string must be either an integer or a character <code>&#39;#&#39;</code> representing null pointer.</p>\n\n<p>You may assume that the input format is always valid.</p>\n\n<ul>\n\t<li>For example, it could never contain two consecutive commas, such as <code>&quot;1,,3&quot;</code>.</li>\n</ul>\n\n<p><strong>Note:&nbsp;</strong>You are not allowed to reconstruct the tree.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,3,4,#,#,1,#,#,2,#,6,#,#\"\n<strong>Output:</strong> true\n</pre><p><strong class=\"example\">Example 2:</strong></p>\n<pre><strong>Input:</strong> preorder = \"1,#\"\n<strong>Output:</strong> false\n</pre><p><strong class=\"example\">Example 3:</strong></p>\n<pre><strong>Input:</strong> preorder = \"9,#,#,1\"\n<strong>Output:</strong> false\n</pre>\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= preorder.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>preorder</code> consist of integers in the range <code>[0, 100]</code> and <code>&#39;#&#39;</code> separated by commas <code>&#39;,&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 78551,
                "title": "7-lines-easy-java-solution",
                "content": "Some used stack. Some used the depth of a stack. Here I use a different perspective. In a binary tree, if we consider null as leaves, then\\n\\n* all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root\\n* all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).\\n\\nSuppose we try to build this tree. During building, we record the difference between out degree and in degree `diff` = `outdegree - indegree`. When the next node comes, we then decrease `diff` by 1, because the node provides an in degree. If the node is not `null`, we increase diff by `2`, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished.\\n\\n\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int diff = 1;\\n        for (String node: nodes) {\\n            if (--diff < 0) return false;\\n            if (!node.equals(\"#\")) diff += 2;\\n        }\\n        return diff == 0;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Some used stack. Some used the depth of a stack. Here I use a different perspective. In a binary tree, if we consider null as leaves, then\\n\\n* all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root\\n* all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).\\n\\nSuppose we try to build this tree. During building, we record the difference between out degree and in degree `diff` = `outdegree - indegree`. When the next node comes, we then decrease `diff` by 1, because the node provides an in degree. If the node is not `null`, we increase diff by `2`, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished.\\n\\n\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int diff = 1;\\n        for (String node: nodes) {\\n            if (--diff < 0) return false;\\n            if (!node.equals(\"#\")) diff += 2;\\n        }\\n        return diff == 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78564,
                "title": "the-simplest-python-solution-with-explanation-no-stack-no-recursion",
                "content": "We just need to remember how many empty slots we have during the process. \\n\\nInitially we have one ( for the root ). \\n\\nfor each node we check if we still have empty slots to put it in. \\n\\n - a null node occupies one slot.\\n - a non-null node occupies one slot before he creates two more. the net gain is one. \\n\\n----------\\n    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            \"\"\"\\n            :type preorder: str\\n            :rtype: bool\\n            \"\"\"\\n            # remember how many empty slots we have\\n            # non-null nodes occupy one slot but create two new slots\\n            # null nodes occupy one slot\\n            \\n            p = preorder.split(',')\\n            \\n            #initially we have one empty slot to put the root in it\\n            slot = 1\\n            for node in p:\\n                \\n                # no empty slot to put the current node\\n                if slot == 0:\\n                    return False\\n                    \\n                # a null node?\\n                if node == '#':\\n                    # ocuppy slot\\n                    slot -= 1\\n                else:\\n                    # create new slot\\n                    slot += 1\\n            \\n            #we don't allow empty slots at the end\\n            return slot==0",
                "solutionTags": [
                    "Python"
                ],
                "code": "We just need to remember how many empty slots we have during the process. \\n\\nInitially we have one ( for the root ). \\n\\nfor each node we check if we still have empty slots to put it in. \\n\\n - a null node occupies one slot.\\n - a non-null node occupies one slot before he creates two more. the net gain is one. \\n\\n----------\\n    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            \"\"\"\\n            :type preorder: str\\n            :rtype: bool\\n            \"\"\"\\n            # remember how many empty slots we have\\n            # non-null nodes occupy one slot but create two new slots\\n            # null nodes occupy one slot\\n            \\n            p = preorder.split(',')\\n            \\n            #initially we have one empty slot to put the root in it\\n            slot = 1\\n            for node in p:\\n                \\n                # no empty slot to put the current node\\n                if slot == 0:\\n                    return False\\n                    \\n                # a null node?\\n                if node == '#':\\n                    # ocuppy slot\\n                    slot -= 1\\n                else:\\n                    # create new slot\\n                    slot += 1\\n            \\n            #we don't allow empty slots at the end\\n            return slot==0",
                "codeTag": "Java"
            },
            {
                "id": 78566,
                "title": "java-intuitive-22ms-solution-with-stack",
                "content": "See detailed comments below. Time complexity is O(n), space is also O(n) for the stack.\\n\\n    public class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            // using a stack, scan left to right\\n            // case 1: we see a number, just push it to the stack\\n            // case 2: we see #, check if the top of stack is also #\\n            // if so, pop #, pop the number in a while loop, until top of stack is not #\\n            // if not, push it to stack\\n            // in the end, check if stack size is 1, and stack top is #\\n            if (preorder == null) {\\n                return false;\\n            }\\n            Stack<String> st = new Stack<>();\\n            String[] strs = preorder.split(\",\");\\n            for (int pos = 0; pos < strs.length; pos++) {\\n                String curr = strs[pos];\\n                while (curr.equals(\"#\") && !st.isEmpty() && st.peek().equals(curr)) {\\n                    st.pop();\\n                    if (st.isEmpty()) {\\n                        return false;\\n                    }\\n                    st.pop();\\n                }\\n                st.push(curr);\\n            }\\n            return st.size() == 1 && st.peek().equals(\"#\");\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            // using a stack, scan left to right\\n            // case 1: we see a number, just push it to the stack\\n            // case 2: we see #, check if the top of stack is also #\\n            // if so, pop #, pop the number in a while loop, until top of stack is not #\\n            // if not, push it to stack\\n            // in the end, check if stack size is 1, and stack top is #\\n            if (preorder == null) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78554,
                "title": "c-4ms-solution-o-1-space-o-n-time",
                "content": "The capacity is the number of node that can be put in the tree. The initial value is 1, which means there can be a root.\\n\\nWhen adding a node, capacity--;\\n\\nWhen adding  a non-NULL node, it means we obtains two more leafs, then capacity +=2.\\n\\nThe final capacity should be equal to 0\\n\\n\\n    class Solution {\\n    public:\\n    bool isValidSerialization(string preorder) {\\n        if (preorder.empty()) return false;\\n        preorder+=',';\\n        int sz=preorder.size(),idx=0;\\n        int capacity=1;\\n        for (idx=0;idx<sz;idx++){\\n            if (preorder[idx]!=',') continue;\\n            capacity--;\\n            if (capacity<0) return false;\\n            if (preorder[idx-1]!='#') capacity+=2;\\n        }\\n        return capacity==0;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool isValidSerialization(string preorder) {\\n        if (preorder.empty()) return false;\\n        preorder+=',';\\n        int sz=preorder.size(),idx=0;\\n        int capacity=1;\\n        for (idx=0;idx<sz;idx++){\\n            if (preorder[idx]!=',') continue;\\n            capacity--;\\n            if (capacity<0) return false;\\n            if (preorder[idx-1]!='#') capacity+=2;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 78560,
                "title": "simple-python-solution-using-stack-with-explanation",
                "content": "This is very simple problem if you use stacks. The key here is, when you see two consecutive \"#\" characters on stack, pop both of them and replace the topmost element on the stack with \"#\". Think of this step as collapsing (or folding) leaves into their parent node. When you fold leaves into the parent node, parent node becomes the leaf node. If you keep doing this for a valid input you should be able to fold all nodes into the root node until there is just one leaf node left.\\n\\nHere is an example,\\n\\n```\\nPre-order traversal: [1,2,3,#,#,#,#]\\nTree looks like:\\n      1\\n\\t / \\\\\\n    2   #\\n   /  \\\\\\n  3    #\\n / \\\\\\n#   #\\n```\\n\\npreorder = 1,2,3,#,#,#,#\\n\\nPass 1:  stack = [1]\\n\\nPass 2: stack = [1,2]\\n\\nPass 3: stack = [1,2,3]\\n\\nPass 4: stack = [1,2,3,#]\\n\\nPass 5: stack = [1,2,3,#,#] -> two #s on top so pop them and replace top with #. -> stack = [1,2,#] i.e. we collapse 3\\'s leaves:\\n```\\n      1\\n\\t / \\\\\\n    2   #\\n   /  \\\\\\n  #    #\\n```\\n\\nPass 6: stack = [1,2,#,#] -> two #s on top so pop them and replace top with #. -> stack = [1,#] i.e. we collapse 2\\'s leaves:\\n```\\n      1\\n\\t / \\\\\\n    #   #\\n```\\n\\nPass 7: stack = [1,#,#] -> two #s on top so pop them and replace top with #. -> stack = [#] i.e. we collapse 1\\'s leaves:\\n```\\n      #\\n```\\n\\nIf there is only one # on stack at the end of the string then return True else return False.\\n\\nHere is the code for that,\\n\\n    class Solution(object):\\n    def isValidSerialization(self, preorder):\\n        \"\"\"\\n        :type preorder: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        top = -1\\n        preorder = preorder.split(\\',\\')\\n        for s in preorder:\\n            stack.append(s)\\n            top += 1\\n            while(self.endsWithTwoHashes(stack,top)):\\n                h = stack.pop()\\n                top -= 1\\n                h = stack.pop()\\n                top -= 1\\n                if top < 0:\\n                    return False\\n                h = stack.pop()\\n                stack.append(\\'#\\')\\n            #print stack\\n        if len(stack) == 1:\\n            if stack[0] == \\'#\\':\\n                return True\\n        return False\\n    \\n    def endsWithTwoHashes(self,stack,top):\\n        if top<1:\\n            return False\\n        if stack[top]==\\'#\\' and stack[top-1]==\\'#\\':\\n            return True\\n        return False",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nPre-order traversal: [1,2,3,#,#,#,#]\\nTree looks like:\\n      1\\n\\t / \\\\\\n    2   #\\n   /  \\\\\\n  3    #\\n / \\\\\\n#   #\\n```\n```\\n      1\\n\\t / \\\\\\n    2   #\\n   /  \\\\\\n  #    #\\n```\n```\\n      1\\n\\t / \\\\\\n    #   #\\n```\n```\\n      #\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427037,
                "title": "c-simple-and-short-solution-o-n-tc-o-1-sc-explained",
                "content": "**Idea:**\\nWe use stringstream to split the string by commas.\\nWe use `nodes` to count the nodes we are allowed to have next.\\nEvery time we get a new node we decrease `nodes`, if we got below zero it\\'s false.\\nIf we get a non-null node, we can have after it two more nodes.\\nAt the end, we are supposed to end up with `nodes == 0`, otherwise the tree is not good.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string curr;\\n        int nodes = 1;\\n        while (getline(ss, curr, \\',\\')) {\\n            nodes--;\\n            if (nodes < 0) return false;\\n            if (curr != \"#\") nodes += 2;\\n        }\\n        return nodes == 0;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string curr;\\n        int nodes = 1;\\n        while (getline(ss, curr, \\',\\')) {\\n            nodes--;\\n            if (nodes < 0) return false;\\n            if (curr != \"#\") nodes += 2;\\n        }\\n        return nodes == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78552,
                "title": "java-counting-indegree-and-outdegree-simple-clear",
                "content": "     public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        int degree = -1;         // root has no indegree, for compensate init with -1\\n        for (String str: strs) {\\n            degree++;             // all nodes have 1 indegree (root compensated)\\n            if (degree > 0) {     // total degree should never exceeds 0\\n                return false;\\n            }      \\n            if (!str.equals(\"#\")) {// only non-leaf node has 2 outdegree\\n                degree -= 2;\\n            }  \\n        }\\n        return degree == 0;\\n    }",
                "solutionTags": [],
                "code": "     public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        int degree = -1;         // root has no indegree, for compensate init with -1\\n        for (String str: strs) {\\n            degree++;             // all nodes have 1 indegree (root compensated)\\n            if (degree > 0) {     // total degree should never exceeds 0\\n                return false;\\n            }      \\n            if (!str.equals(\"#\")) {// only non-leaf node has 2 outdegree\\n                degree -= 2;\\n            }  \\n        }\\n        return degree == 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1427004,
                "title": "python-simple-stack-explained",
                "content": "Similar to Problem **297**: Serialize and Deserialize Binary Tree, but here we do not really need to reconstruct our tree, and using stack is enough. The trick is to add elements one by one and when we see `num, #, #`, we replace it with `#`. If we get just one `#` in the end, return `True`, else: `False`. Let us look at the example `9,3,4,#,#,1,#,#,2,#,6,#,#`. Let us go through steps:\\n\\n1. We add elements until we have `9, 3, 4, #, #`. It means now that `4` is leaf, so let us remove it: we have `9, 3, #`.\\n2. Add elements, so we have `9, 3, #, 1, #, #`. We have leaf `1`, remove it: `9, 3, #, #`. Now, we have `3` as leaf as well: remove it: `9, #`.\\n3. Add elements `9, #, 2, #, 6, #, #` -> `9, #, 2, #, # -> 9, #, # -> #`.\\n\\n#### Complexity\\nIt is `O(n)` for time and `O(h)` for space, where `h` is the height of our binary tree.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def isValidSerialization(self, preorder):\\n        stack = []\\n        for elem in preorder.split(\",\"):\\n            stack.append(elem)\\n            while len(stack) > 2 and stack[-2:] == [\"#\"]*2 and stack[-3] != \"#\":\\n                stack.pop(-3)\\n                stack.pop(-2)\\n            \\n        return stack == [\"#\"]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSerialization(self, preorder):\\n        stack = []\\n        for elem in preorder.split(\",\"):\\n            stack.append(elem)\\n            while len(stack) > 2 and stack[-2:] == [\"#\"]*2 and stack[-3] != \"#\":\\n                stack.pop(-3)\\n                stack.pop(-2)\\n            \\n        return stack == [\"#\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426956,
                "title": "python3-java-easy-solution-explained-in-detail-o-1-space",
                "content": "Whoever is downvoting, please comment and let me know how I can improve.\\n\\n***BASICS***\\n- **Preorder traversal** follows the following logic:\\n\\t- explore the current node\\n\\t- recurse left\\n\\t- recurse right\\n- In our case, we define a binary tree by saying two things:\\n\\t- Each **null node** has `0` children.\\n\\t- Each **non-null node** has `2` children - can be either null nodes or non-null nodes.\\n\\n![image](https://assets.leetcode.com/users/images/290876ad-ba4c-4cca-892f-4d4f6ef4ab7e_1629963000.540849.png)\\n\\n***LOGIC***\\nWe say that a tree is valid if it follows both of the above conditions. It basically looks like we need to **keep a track of the number of children**. Let\\'s call it `slots` as in the slots we can fill each child in.\\n\\nSo, a null node gives `0` children and consumes `1` space. Giving a total of `-1`.\\n\\nA non-null node consumes `1` space similarly, but produces space for `2` more. So,\\n\\n- `-1` for null node\\n- `+1` for valid node\\n\\nWe now only need to count the `slots`! `solts` themselves follow 2 more conditions:\\n- They are always `>0` during the program run\\n- They are `==0` at the end of the run.\\n\\nAnd that\\'s it!\\n\\n***CODE***\\nPython3\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        nodes = preorder.split(\\',\\')\\n        slots = 1\\n        for node in nodes:\\n            if slots <= 0: return False\\n            slots += -1 if node == \\'#\\' else 1\\n        return slots == 0\\n```\\n\\nJava\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int slots = 1;\\n        for(String node: nodes) {\\n            if (slots <= 0) return false;\\n            if (node.equals(\"#\")) slots--;\\n            else slots++;\\n        }\\n        return slots == 0;\\n    }\\n}\\n```\\n\\n***COMPLEXITY ANALYSIS***\\n- Time: `O(N)` where N is the total number of nodes.\\n- Space: `O(1)` since we only store 1 variable.\\n\\n**Upvote if this helps :D Feedback/Discussions are welcome!**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        nodes = preorder.split(\\',\\')\\n        slots = 1\\n        for node in nodes:\\n            if slots <= 0: return False\\n            slots += -1 if node == \\'#\\' else 1\\n        return slots == 0\\n```\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int slots = 1;\\n        for(String node: nodes) {\\n            if (slots <= 0) return false;\\n            if (node.equals(\"#\")) slots--;\\n            else slots++;\\n        }\\n        return slots == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426993,
                "title": "verify-preorder-serialization-of-a-binary-tree-how-many-slots-are-available",
                "content": "**Solution 1:**\\n```\\nExplanation:\\nLet us first try to understand the meaning of \"Slot\",\\nSlot is an empty place where we can put the TreeNode,\\n\\nNow why we are dealing with Slots??\\nAs we want to verify whether the preorder serialization is correct or not!,\\nso we want to confirm whether the number of TreeNodes(including nullable nodes \\'#\\') are equal to NumberOfSlotsAvailable in Tree,\\ni.e, Number Of TreeNodes == Number Of Slots Available (Valid Preorder Serialization)\\nelse Invalid Preorder Serialization.\\n\\nNow Let us see that how we can calculate the number of slots,\\n1) For a Leaf Node (0 Children) the slots will be 1 (Why because that slot is only for that leaf node).\\n2) For a Non Leaf Node the slots will be 3 ,\\nHOW??\\n1 slot for the non leaf node itself,\\n2 slots for its Left and Rigth Child,\\n\\n3) And for Nullable Node(\\'#\\') the slots will be 1,\\nwhy??\\nbecause if a node is NULL then its parent has to define a pointer (NULL) to mention that\\neither its left or right child is NULL.\\n\\nLets take One Example:\\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\\n\\nInitially The numberOfSlots = 1 (To accomodate root node only)\\n\\n1) when we encounter 9 ,\\nwe decrease the numberOfSlots by 1 (because the node 9 is now placed at that slot)\\nso numberOfSlots become 0\\nnow we will check whether this node is Non Leaf Node,(if it is != \\'#\\'),\\nso as 9 is non leaf node,\\nso we add 2 in the numberOfSlots(2 slots for its children)\\nnow numberOfSlots become 2\\n\\n2) Similarly for \"3\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n3) Similarly for \"4\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 4)\\n\\n4) For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 3)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n5) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n6) Similarly for \"1\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n7) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n8) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n9)Similarly for \"2\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n10) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n11) Similarly for \"6\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n12) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n13) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\nAnd finally compare whether numberOfSlots == 0 (If Yes) return true else return false;\\n\\n```\\n\\n***\\nC++:\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n        stringstream ss(preorder);\\n        string temp;\\n//      For Root Node\\n        int numberOfSlotsAvailable = 1;\\n        while(getline(ss,temp,\\',\\'))\\n        {\\n//          When we put one node into the empty slot\\n            numberOfSlotsAvailable--;\\n            if(numberOfSlotsAvailable<0)\\n                return false;\\n            if(temp!=\"#\")\\n            {\\n//                 It means we already put the Non Leaf Node and there are new 2 slots being created for left and right child.\\n                numberOfSlotsAvailable+=2;\\n            }\\n        }\\n        return numberOfSlotsAvailable==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExplanation:\\nLet us first try to understand the meaning of \"Slot\",\\nSlot is an empty place where we can put the TreeNode,\\n\\nNow why we are dealing with Slots??\\nAs we want to verify whether the preorder serialization is correct or not!,\\nso we want to confirm whether the number of TreeNodes(including nullable nodes \\'#\\') are equal to NumberOfSlotsAvailable in Tree,\\ni.e, Number Of TreeNodes == Number Of Slots Available (Valid Preorder Serialization)\\nelse Invalid Preorder Serialization.\\n\\nNow Let us see that how we can calculate the number of slots,\\n1) For a Leaf Node (0 Children) the slots will be 1 (Why because that slot is only for that leaf node).\\n2) For a Non Leaf Node the slots will be 3 ,\\nHOW??\\n1 slot for the non leaf node itself,\\n2 slots for its Left and Rigth Child,\\n\\n3) And for Nullable Node(\\'#\\') the slots will be 1,\\nwhy??\\nbecause if a node is NULL then its parent has to define a pointer (NULL) to mention that\\neither its left or right child is NULL.\\n\\nLets take One Example:\\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\\n\\nInitially The numberOfSlots = 1 (To accomodate root node only)\\n\\n1) when we encounter 9 ,\\nwe decrease the numberOfSlots by 1 (because the node 9 is now placed at that slot)\\nso numberOfSlots become 0\\nnow we will check whether this node is Non Leaf Node,(if it is != \\'#\\'),\\nso as 9 is non leaf node,\\nso we add 2 in the numberOfSlots(2 slots for its children)\\nnow numberOfSlots become 2\\n\\n2) Similarly for \"3\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n3) Similarly for \"4\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 4)\\n\\n4) For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 3)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n5) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n6) Similarly for \"1\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n7) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n8) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n9)Similarly for \"2\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n10) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n11) Similarly for \"6\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n12) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n13) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\nAnd finally compare whether numberOfSlots == 0 (If Yes) return true else return false;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n        stringstream ss(preorder);\\n        string temp;\\n//      For Root Node\\n        int numberOfSlotsAvailable = 1;\\n        while(getline(ss,temp,\\',\\'))\\n        {\\n//          When we put one node into the empty slot\\n            numberOfSlotsAvailable--;\\n            if(numberOfSlotsAvailable<0)\\n                return false;\\n            if(temp!=\"#\")\\n            {\\n//                 It means we already put the Non Leaf Node and there are new 2 slots being created for left and right child.\\n                numberOfSlotsAvailable+=2;\\n            }\\n        }\\n        return numberOfSlotsAvailable==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78722,
                "title": "straight-forward-c-solution-with-explanation",
                "content": "The idea is simple.\\n\\nDenote the number of null nodes as `nullCnt`, the number of actual nodes as `nodeCnt`.\\n\\nFor a binary tree, the number of null nodes is always the number of actual nodes plus 1. `nullCnt==nodeCnt+1`;\\n\\nSo,\\n\\n 1. if `nullCnt>nodeCnt+1`, the tree is invalid.\\n 2. if `nullCnt<nodeCnt+1`, the tree is incomplete.\\n 3. if `nullCnt==nodeCnt+1`, the tree is complete and can't be extended.\\n\\nWe just need to keep track of `nullCnt` and `nodeCnt` as we go through the sequence and check these conditions above.\\n\\nActually, recording `nullCnt-nodeCnt` is enough, so you can further improve the code.\\n\\n    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            int nodeCnt=0,nullCnt=0;\\n            vector<string> v=splitStr(preorder,',');\\n            for(int i = 0; i<v.size(); i++){\\n                if(v[i]==\"#\") ++nullCnt;\\n                else ++nodeCnt;\\n                if(nullCnt>=nodeCnt+1 && i!=v.size()-1) return false;\\n            }\\n            return nullCnt==nodeCnt+1;\\n        }\\n        \\n        vector<string> splitStr(string str, char delimiter){\\n        \\tvector<string> r;\\n        \\tstring tmpstr;\\n        \\twhile (!str.empty()){\\n        \\t\\tint ind = str.find_first_of(delimiter);\\n        \\t\\tif (ind == -1){\\n        \\t\\t\\tr.push_back(str);\\n        \\t\\t\\tstr.clear();\\n        \\t\\t}\\n        \\t\\telse{\\n        \\t\\t\\tr.push_back(str.substr(0, ind));\\n        \\t\\t\\tstr = str.substr(ind + 1, str.size() - ind - 1);\\n        \\t\\t}\\n        \\t}\\n        \\treturn r;\\n        }\\n    };\\n\\n\\n\\n**Edit:**\\nThe algorithm scans the string **one node at a time from the beginning**, once it finds `nullCnt>nodeCnt+1`, it stops and return false. \\n\\nIf it finds `nullCnt==nodeCnt+1`, that means by now, the tree is valid(otherwise the algorithm would return false before this) and complete, if there are more nodes to come, it returns false; if it's the last node, the algorithm returns true. \\n\\nIf it finds `nullCnt<nodeCnt+1`, that means the tree is incomplete but not invalid(or the algorithm would return false before this) by now, if this is the last node and no more nodes comes after it, the tree is invalid.\\n\\nExample:\\n\\n` \"#,1,#\"`\\t1st node is `#`, `nullCnt==1`, `nodeCnt==0`, `nullCnt==nodeCnt+1`, the tree is complete by now, but there are more nodes after it, so it's invalid.\\n\\n` \"1, #\"`\\t1st node is `1`, `nullCnt==0`, `nodeCnt==1`, `nullCnt<nodeCnt+1`, the tree is incomplete, but there are more nodes after it, so we proceed, 2nd node is `#`, `nullCnt==1`, `nodeCnt==1`, `nullCnt<nodeCnt+1`, the tree is incomplete and there are no more nodes left, so it's invalid.\\n\\n**Edit2:**\\n\\nWhy for a binary tree, `nullCnt==nodeCnt+1`?\\n\\nFor an empty binary tree, `nullCnt=1`, `nodeCnt=0`, `nullCnt==nodeCnt+1`.\\n\\nEach time we add an actual node, we take the place of one null node and create two null nodes, so the net gain of null node is one, which is also the net gain of actual node. Thus, the actual nodes and null nodes will increase by the same amount, which means `nullCnt==nodeCnt+1` will always hold.",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            int nodeCnt=0,nullCnt=0;\\n            vector<string> v=splitStr(preorder,',');\\n            for(int i = 0; i<v.size(); i++){\\n                if(v[i]==\"#\") ++nullCnt;\\n                else ++nodeCnt;\\n                if(nullCnt>=nodeCnt+1 && i!=v.size()-1) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78640,
                "title": "2-lines-java-using-regex",
                "content": "Regex idea from [andrei3's solution](https://leetcode.com/discuss/83896/8-line-regex-solution-without-building-the-tree).\\n\\n    public boolean isValidSerialization(String preorder) {\\n        String s = preorder.replaceAll(\"\\\\\\\\d+,#,#\", \"#\");\\n        return s.equals(\"#\") || !s.equals(preorder) && isValidSerialization(s);\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Regex idea from [andrei3's solution](https://leetcode.com/discuss/83896/8-line-regex-solution-without-building-the-tree).\\n\\n    public boolean isValidSerialization(String preorder) {\\n        String s = preorder.replaceAll(\"\\\\\\\\d+,#,#\", \"#\");\\n        return s.equals(\"#\") || !s.equals(preorder) && isValidSerialization(s);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78653,
                "title": "6-lines-python-7-lines-java",
                "content": "**Python**\\n\\n    def isValidSerialization(self, preorder):\\n        need = 1\\n        for val in preorder.split(','):\\n            if not need:\\n                return False\\n            need -= ' #'.find(val)\\n        return not need\\n\\n**Java**\\n\\n    public boolean isValidSerialization(String preorder) {\\n        int need = 1;\\n        for (String val : preorder.split(\",\")) {\\n            if (need == 0)\\n                return false;\\n            need -= \" #\".indexOf(val);\\n        }\\n        return need == 0;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "**Python**\\n\\n    def isValidSerialization(self, preorder):\\n        need = 1\\n        for val in preorder.split(','):\\n            if not need:\\n                return False\\n            need -= ' #'.find(val)\\n        return not need\\n\\n**Java**\\n\\n    public boolean isValidSerialization(String preorder) {\\n        int need = 1;\\n        for (String val : preorder.split(\",\")) {\\n            if (need == 0)\\n                return false;\\n            need -= \" #\".indexOf(val);\\n        }\\n        return need == 0;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 78692,
                "title": "simple-o-n-solution",
                "content": "Use iterative preorder traversal, actually no need to use stack, just a integer to track the depth of the stack.\\n\\n    public class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            if (preorder == null || preorder.length() == 0) return false;\\n            String[] strs = preorder.split(\",\");\\n            int depth = 0;\\n            int i = 0; \\n            while (i < strs.length - 1) {\\n                if (strs[i++].equals(\"#\")) {\\n                    if (depth == 0) return false;\\n                    else depth--;\\n                }\\n                else depth++;\\n            }\\n            if (depth != 0) return false;\\n            return strs[strs.length - 1].equals(\"#\");\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            if (preorder == null || preorder.length() == 0) return false;\\n            String[] strs = preorder.split(\",\");\\n            int depth = 0;\\n            int i = 0; \\n            while (i < strs.length - 1) {\\n                if (strs[i++].equals(\"#\")) {\\n                    if (depth == 0) return false;\\n                    else depth--;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78661,
                "title": "clear-c-solution",
                "content": "\\tbool isValidSerialization(string preorder) {\\n\\t\\tint degree = 1;\\n\\t\\tstring temp;\\n\\t\\tstringstream ss;\\n\\t\\tss << preorder;\\n\\t\\twhile (getline(ss, temp, ',')) {\\n\\t\\t\\tdegree--;\\n\\t\\t\\tif (degree < 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (temp[0] != '#')\\n\\t\\t\\t\\tdegree += 2;\\n\\t\\t}\\n\\t\\treturn degree == 0;\\n\\t}",
                "solutionTags": [],
                "code": "\\tbool isValidSerialization(string preorder) {\\n\\t\\tint degree = 1;\\n\\t\\tstring temp;\\n\\t\\tstringstream ss;\\n\\t\\tss << preorder;\\n\\t\\twhile (getline(ss, temp, ',')) {\\n\\t\\t\\tdegree--;\\n\\t\\t\\tif (degree < 0)\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\tif (temp[0] != '#')\\n\\t\\t\\t\\tdegree += 2;\\n\\t\\t}\\n\\t\\treturn degree == 0;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 78605,
                "title": "simple-c-solution-using-stack-without-extra-splitting-function",
                "content": " At first glance, a leaf node's pattern should look like `number,#,#`, start from the beginning of array, once you see this pattern, convert it to a single \"#\", meaning the node with value `number` has already been fully explored(left subtree, right subtree), so we replace it with a \"#\". While iterating the array, we just keep doing this kind of absorbing/merging backward until we reach the end of array. Then we check if the root has been fully explored, which should eventually be a single `#`. During absorbing, if this pattern appears `#,#,#`, return false. It's known that it's a pain in C++ that there is no split function as Java does, but it won't matter here since split string is not necessary, we just need to know before `,` it's a `number` or `#`.\\n\\n\"9,3,4,#,#,12,#,#,2,#,6,#,#\"\\n\\nstack status\\n\\n    char   stack\\n    '9':   '9'  \\n    '3':   '3','9'\\n    '4':   '4','3','9'\\n    '#':   '#','4','3','9'\\n    '#':   '#','3','9'\\n    '12':  'n', '#', '3','9'\\n    '#':   '#','1', '#', '3','9'\\n    '#':   '#','3','9' -> '#','9'\\n    '2':   '2', '#','9'\\n    '#':   '#', '2', '#','9'\\n    '6':   '6', '#', '2','#','9'\\n    '#':   '#', '6', '#', '2','#','9'\\n    '#':   '#', '2','#','9' -> '#','9' -> '#'\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            stack<char> stk;\\n            bool isNum = false;\\n            preorder.push_back(','); // dummy tail\\n            \\n            for(auto c: preorder){\\n                if(c == '#'){\\n                    // absorb: search for pattern `#, number` backward\\n                    while(!stk.empty() && stk.top() == '#'){ \\n                        stk.pop(); // pop `#`\\n                        if(stk.empty() || stk.top() == '#') return false; // pattern `#,#,#`\\n                        stk.pop(); // pop `number`\\n                    }\\n                    stk.push('#'); // replace `number` with `#` since it has been fully explored/validated\\n                }else if(c == ','){\\n                    if(isNum) stk.push('n'); // indicate this is a number instead of using the real number\\n                    isNum = false;\\n                }else{\\n                    isNum = true;\\n                }\\n            }\\n            \\n            return stk.size() == 1 && stk.top() == '#';\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            stack<char> stk;\\n            bool isNum = false;\\n            preorder.push_back(','); // dummy tail\\n            \\n            for(auto c: preorder){\\n                if(c == '#'){\\n                    // absorb: search for pattern `#, number` backward\\n                    while(!stk.empty() && stk.top() == '#'){ \\n                        stk.pop(); // pop `#`\\n                        if(stk.empty() || stk.top() == '#') return false; // pattern `#,#,#`\\n                        stk.pop(); // pop `number`\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 78683,
                "title": "8-line-python-non-recursive-solution-using-stack-replace-number-with-very-easy-to-understand",
                "content": "    def isValidSerialization(self, preorder):\\n        stack = []\\n        for value in preorder.split(','):\\n            if value == '#':\\n                while len(stack) >= 2 and stack[-1] == '#' and stack[-2] != '#':\\n                    stack.pop()\\n                    stack.pop()\\n            stack.append(value)\\n        return stack == ['#']",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "    def isValidSerialization(self, preorder):\\n        stack = []\\n        for value in preorder.split(','):\\n            if value == '#':\\n                while len(stack) >= 2 and stack[-1] == '#' and stack[-2] != '#':\\n                    stack.pop()\\n                    stack.pop()\\n            stack.append(value)\\n        return stack == ['#']",
                "codeTag": "Python3"
            },
            {
                "id": 78567,
                "title": "java-recursion-solution",
                "content": "Main idea is checking balance of nodes from bottom-up manner and bubble up failure condition.\\n\\n    public class Solution {\\n    \\tpublic boolean isValidSerialization(String preorder) {\\n    \\t\\tString[] tree = preorder.split(\",\");\\n    \\t\\treturn valid(tree, 0) == tree.length-1;\\n    \\t}\\n    \\n    \\tprivate int valid(String[] tree, int current) {\\n    \\t\\tif(current >= tree.length) return -1;\\n    \\t\\tif(\"#\".equals(tree[current])) return current;\\n    \\n    \\t\\t// left\\n    \\t\\tint next = valid(tree, current + 1);\\n    \\t\\tif(next == -1) return -1;\\n    \\n    \\t\\t// right\\n    \\t\\tnext = valid(tree, next + 1);\\n    \\t\\treturn next == -1 ? -1 : next;\\n    \\t}\\n    }",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\tpublic boolean isValidSerialization(String preorder) {\\n    \\t\\tString[] tree = preorder.split(\",\");\\n    \\t\\treturn valid(tree, 0) == tree.length-1;\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 1427083,
                "title": "c-clean-solution-using-vector",
                "content": "**Solution**\\n\\n**Approach**\\n1. \\',\\'(comma) divides the string into \\'#\\' and node values\\n2. Try to separate them and form a string with no \\',\\' and only \\'#\\' and integers(node values)\\n3. Now, the approach is to convert every triplet <integer, #, #> to #\\n4. The triplet mentioned above defines a leaf node and thus we can easily find the leaf nodes and replace them with a null(#) character.\\n5. Atlast, we should end with a null(#) character. This helps us to know that the preorder serialization was perfect and thus return true. Otherwise, return false.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        string ans = \"\";\\n        vector<string> v;\\n        for(int i = 0; i < preorder.size(); i++){\\n            if(preorder[i] == \\',\\'){\\n                v.push_back(ans);\\n                while(v.size() >= 3 and v[v.size() - 1] == \"#\" and v[v.size() - 2] == \"#\" and v[v.size() - 3] != \"#\"){\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.push_back(\"#\");\\n                }\\n                ans = \"\";\\n            }\\n            else\\n                ans += preorder[i];\\n        }\\n        if(!ans.empty()){\\n            v.push_back(ans);\\n            while(v.size() >= 3 and v[v.size() - 1] == \"#\" and v[v.size() - 2] == \"#\" and v[v.size() - 3] != \"#\"){\\n                v.erase(v.begin() + v.size() - 1);\\n                v.erase(v.begin() + v.size() - 1);\\n                v.erase(v.begin() + v.size() - 1);\\n                v.push_back(\"#\");\\n            }\\n            ans = \"\";\\n        }\\n        if(v.size() == 1 and v[0] == \"#\")\\n            return true;\\n        else return false;\\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        string ans = \"\";\\n        vector<string> v;\\n        for(int i = 0; i < preorder.size(); i++){\\n            if(preorder[i] == \\',\\'){\\n                v.push_back(ans);\\n                while(v.size() >= 3 and v[v.size() - 1] == \"#\" and v[v.size() - 2] == \"#\" and v[v.size() - 3] != \"#\"){\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.erase(v.begin() + v.size() - 1);\\n                    v.push_back(\"#\");\\n                }\\n                ans = \"\";\\n            }\\n            else\\n                ans += preorder[i];\\n        }\\n        if(!ans.empty()){\\n            v.push_back(ans);\\n            while(v.size() >= 3 and v[v.size() - 1] == \"#\" and v[v.size() - 2] == \"#\" and v[v.size() - 3] != \"#\"){\\n                v.erase(v.begin() + v.size() - 1);\\n                v.erase(v.begin() + v.size() - 1);\\n                v.erase(v.begin() + v.size() - 1);\\n                v.push_back(\"#\");\\n            }\\n            ans = \"\";\\n        }\\n        if(v.size() == 1 and v[0] == \"#\")\\n            return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78721,
                "title": "11-lines-concise-and-easy-understand-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            istringstream iss(preorder);\\n            int nullcnt = 0, nodecnt = 0;\\n            string tmp;\\n            vector<string> vec;\\n            while(getline(iss, tmp, ',')) vec.push_back(tmp);\\n            for(int i = 0; i < vec.size(); i++){\\n                if(vec[i] != \"#\") nodecnt++;\\n                else nullcnt++;\\n                if(nullcnt == nodecnt + 1 && i != vec.size() - 1) return false;\\n            }\\n            return nullcnt == nodecnt + 1;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            istringstream iss(preorder);\\n            int nullcnt = 0, nodecnt = 0;\\n            string tmp;\\n            vector<string> vec;\\n            while(getline(iss, tmp, ',')) vec.push_back(tmp);\\n            for(int i = 0; i < vec.size(); i++){\\n                if(vec[i] != \"#\") nodecnt++;\\n                else nullcnt++;\\n                if(nullcnt == nodecnt + 1 && i != vec.size() - 1) return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1427182,
                "title": "verify-preorder-serialization-of-a-binary-tree-how-many-slots-are-available",
                "content": "**Solution 1:**\\n```\\nExplanation:\\nLet us first try to understand the meaning of \"Slot\",\\nSlot is an empty place where we can put the TreeNode,\\n\\nNow why we are dealing with Slots??\\nAs we want to verify whether the preorder serialization is correct or not!,\\nso we want to confirm whether the number of TreeNodes(including nullable nodes \\'#\\') are equal to NumberOfSlotsAvailable in Tree,\\ni.e, Number Of TreeNodes == Number Of Slots Available (Valid Preorder Serialization)\\nelse Invalid Preorder Serialization.\\n\\nNow Let us see that how we can calculate the number of slots,\\n1) For a Leaf Node (0 Children) the slots will be 1 (Why because that slot is only for that leaf node).\\n2) For a Non Leaf Node the slots will be 3 ,\\nHOW??\\n1 slot for the non leaf node itself,\\n2 slots for its Left and Rigth Child,\\n\\n3) And for Nullable Node(\\'#\\') the slots will be 1,\\nwhy??\\nbecause if a node is NULL then its parent has to define a pointer (NULL) to mention that\\neither its left or right child is NULL.\\n\\nLets take One Example:\\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\\n\\nInitially The numberOfSlots = 1 (To accomodate root node only)\\n\\n1) when we encounter 9 ,\\nwe decrease the numberOfSlots by 1 (because the node 9 is now placed at that slot)\\nso numberOfSlots become 0\\nnow we will check whether this node is Non Leaf Node,(if it is != \\'#\\'),\\nso as 9 is non leaf node,\\nso we add 2 in the numberOfSlots(2 slots for its children)\\nnow numberOfSlots become 2\\n\\n2) Similarly for \"3\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n3) Similarly for \"4\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 4)\\n\\n4) For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 3)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n5) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n6) Similarly for \"1\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n7) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n8) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n9)Similarly for \"2\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n10) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n11) Similarly for \"6\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n12) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n13) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\nAnd finally compare whether numberOfSlots == 0 (If Yes) return true else return false;\\n\\n```\\n\\n***\\nC++:\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n        stringstream ss(preorder);\\n        string temp;\\n//      For Root Node\\n        int numberOfSlotsAvailable = 1;\\n        while(getline(ss,temp,\\',\\'))\\n        {\\n//          When we put one node into the empty slot\\n            numberOfSlotsAvailable--;\\n            if(numberOfSlotsAvailable<0)\\n                return false;\\n            if(temp!=\"#\")\\n            {\\n//                 It means we already put the Non Leaf Node and there are new 2 slots being created for left and right child.\\n                numberOfSlotsAvailable+=2;\\n            }\\n        }\\n        return numberOfSlotsAvailable==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nExplanation:\\nLet us first try to understand the meaning of \"Slot\",\\nSlot is an empty place where we can put the TreeNode,\\n\\nNow why we are dealing with Slots??\\nAs we want to verify whether the preorder serialization is correct or not!,\\nso we want to confirm whether the number of TreeNodes(including nullable nodes \\'#\\') are equal to NumberOfSlotsAvailable in Tree,\\ni.e, Number Of TreeNodes == Number Of Slots Available (Valid Preorder Serialization)\\nelse Invalid Preorder Serialization.\\n\\nNow Let us see that how we can calculate the number of slots,\\n1) For a Leaf Node (0 Children) the slots will be 1 (Why because that slot is only for that leaf node).\\n2) For a Non Leaf Node the slots will be 3 ,\\nHOW??\\n1 slot for the non leaf node itself,\\n2 slots for its Left and Rigth Child,\\n\\n3) And for Nullable Node(\\'#\\') the slots will be 1,\\nwhy??\\nbecause if a node is NULL then its parent has to define a pointer (NULL) to mention that\\neither its left or right child is NULL.\\n\\nLets take One Example:\\n\"9,3,4,#,#,1,#,#,2,#,6,#,#\"\\n\\nInitially The numberOfSlots = 1 (To accomodate root node only)\\n\\n1) when we encounter 9 ,\\nwe decrease the numberOfSlots by 1 (because the node 9 is now placed at that slot)\\nso numberOfSlots become 0\\nnow we will check whether this node is Non Leaf Node,(if it is != \\'#\\'),\\nso as 9 is non leaf node,\\nso we add 2 in the numberOfSlots(2 slots for its children)\\nnow numberOfSlots become 2\\n\\n2) Similarly for \"3\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n3) Similarly for \"4\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 4)\\n\\n4) For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 3)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n5) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n6) Similarly for \"1\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 3)\\n\\n7) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 2)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n8) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n9)Similarly for \"2\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n10) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n11) Similarly for \"6\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> Then increment numberOfSlots by 2 (numberOfSlots = 2)\\n\\n12) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 1)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\n13) again  For \"#\",\\n--> First we decrement numberOfSlots by 1. (numberOfSlots = 0)\\n--> As this is Nullable Node so we don\\'t increment the numberOfSlots\\n\\nAnd finally compare whether numberOfSlots == 0 (If Yes) return true else return false;\\n\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n        stringstream ss(preorder);\\n        string temp;\\n//      For Root Node\\n        int numberOfSlotsAvailable = 1;\\n        while(getline(ss,temp,\\',\\'))\\n        {\\n//          When we put one node into the empty slot\\n            numberOfSlotsAvailable--;\\n            if(numberOfSlotsAvailable<0)\\n                return false;\\n            if(temp!=\"#\")\\n            {\\n//                 It means we already put the Non Leaf Node and there are new 2 slots being created for left and right child.\\n                numberOfSlotsAvailable+=2;\\n            }\\n        }\\n        return numberOfSlotsAvailable==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427725,
                "title": "javascript-7-line-solution",
                "content": "The problem is pretty similar to this problem:\\n`Given a string of brackets which only consists of a single type of brackets, determine if it is balanced or not. A balanced string of brackets means the total number of open brackets is equal to the total number of close brackets, and while traversing the string from left to right, the number of open brackets is always greater than or equal to the number of close brackets.`\\nAt first, we have an empty slot, we can put a number or a `#` to it:\\n- Adding a number means removing an empty slot & creating 2 more empty slots, left & right child of the node we just added\\n- Adding a `#` just means removing an empty slot, because a NULL value prevents us from creating more nodes in a branch\\n\\nWhile traversing the tree, if there are no more empty slots at some point, the input is not a correct preorder traversal serialization of a binary tree.\\nAfter traversing the whole given input, the input is correct if there are no empty slots.\\n```\\n/**\\n * @param {string} preorder\\n * @return {boolean}\\n */\\nvar isValidSerialization = function(preorder) {\\n    let balance = 1\\n    for(const node of preorder.split(\\',\\'))\\n        if (balance > 0)\\n            if (node === \\'#\\') --balance\\n            else ++balance\\n        else return false\\n    return balance < 1\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\n/**\\n * @param {string} preorder\\n * @return {boolean}\\n */\\nvar isValidSerialization = function(preorder) {\\n    let balance = 1\\n    for(const node of preorder.split(\\',\\'))\\n        if (balance > 0)\\n            if (node === \\'#\\') --balance\\n            else ++balance\\n        else return false\\n    return balance < 1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 954428,
                "title": "c-easy-understanding-split",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> charary;\\n    bool isValidSerialization(string preorder) {\\n       split(preorder);\\n       int diff=1;\\n       for(string pre: charary){\\n           if(--diff<0) return false;\\n           if(pre!=\"#\") diff+=2;\\n       }\\n        return diff==0;\\n    }\\n    \\n    void split(string s) {\\n        stringstream ss(s);\\n        string tok;\\n        while (getline(ss, tok,\\',\\')) {\\n            charary.push_back(tok);\\n        }\\n    }\\n    \\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> charary;\\n    bool isValidSerialization(string preorder) {\\n       split(preorder);\\n       int diff=1;\\n       for(string pre: charary){\\n           if(--diff<0) return false;\\n           if(pre!=\"#\") diff+=2;\\n       }\\n        return diff==0;\\n    }\\n    \\n    void split(string s) {\\n        stringstream ss(s);\\n        string tok;\\n        while (getline(ss, tok,\\',\\')) {\\n            charary.push_back(tok);\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 276605,
                "title": "python-straightforward-stack",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        for c in preorder.split(\\',\\'):\\n            stack.append(c)\\n            while stack[-2:] == [\\'#\\', \\'#\\']:\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return False\\n                stack.pop()\\n                stack.append(\\'#\\')\\n        return stack == [\\'#\\']\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        for c in preorder.split(\\',\\'):\\n            stack.append(c)\\n            while stack[-2:] == [\\'#\\', \\'#\\']:\\n                stack.pop()\\n                stack.pop()\\n                if not stack: return False\\n                stack.pop()\\n                stack.append(\\'#\\')\\n        return stack == [\\'#\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78655,
                "title": "10-line-easy-c-solution",
                "content": "     bool isValidSerialization(string preorder) {\\n            if(preorder.empty())return false;\\n            int cnt=1,i=0;\\n            while(i<preorder.size()){\\n                if(preorder[i]=='#')cnt--;\\n                else cnt++;\\n                if(cnt==0)break;\\n                while(i<preorder.size()&&preorder[i++]!=',');\\n            }\\n            return cnt==0&&i==preorder.size()-1;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     bool isValidSerialization(string preorder) {\\n            if(preorder.empty())return false;\\n            int cnt=1,i=0;\\n            while(i<preorder.size()){\\n                if(preorder[i]=='#')cnt--;\\n                else cnt++;\\n                if(cnt==0)break;\\n                while(i<preorder.size()&&preorder[i++]!=',');\\n            }\\n            return cnt==0&&i==preorder.size()-1;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3476550,
                "title": "easy-intutive-o-n-solution-iterative-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string a) {\\n        int i,j,k,c=1,s=0;\\n        if(a.size()==0 )\\n        return 1;\\n\\n        if(a[0]==\\'#\\' and a.size()!=1)\\n        return 0;\\n\\n        for(i=0;i<a.size();i+=1){\\n            c-=1;\\n            if(c<0)\\n            return 0;\\n\\n            if(a[i]!=\\'#\\'){\\n                c+=2;\\n            }\\n            \\n            \\n            i++;\\n            while(i<a.size() and a[i]!=\\',\\'){\\n                i++;\\n            }\\n        }\\n        cout<<c;\\n\\n        if(c==0)return 1;\\n\\n        return 0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string a) {\\n        int i,j,k,c=1,s=0;\\n        if(a.size()==0 )\\n        return 1;\\n\\n        if(a[0]==\\'#\\' and a.size()!=1)\\n        return 0;\\n\\n        for(i=0;i<a.size();i+=1){\\n            c-=1;\\n            if(c<0)\\n            return 0;\\n\\n            if(a[i]!=\\'#\\'){\\n                c+=2;\\n            }\\n            \\n            \\n            i++;\\n            while(i<a.size() and a[i]!=\\',\\'){\\n                i++;\\n            }\\n        }\\n        cout<<c;\\n\\n        if(c==0)return 1;\\n\\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3244705,
                "title": "331-time-98-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nan explicit stack, and instead just uses a single variable degree to keep track of the outDegree (children) - inDegree (parent). It also removes the need for the stack and nodes lists used in the previous solution, which results in less memory usage and faster execution time.\\n\\nThe time complexity of this solution is O(n), where n is the number of nodes in the binary tree. The space complexity is O(1), as we are only using a single variable to keep track of the degree.\\n\\n# Complexity\\n- Time complexity:\\n98%\\n\\n- Space complexity:\\n75.32%\\n\\n# Code\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        # Initialize the outDegree (children) - inDegree (parent) to 1\\n        degree = 1\\n        \\n        # Iterate through the nodes in the preorder traversal\\n        for node in preorder.split(\\',\\'):\\n            degree -= 1 # Decrement the degree by 1 for each node\\n            \\n            if degree < 0: # If the degree is negative, return False\\n                return False\\n            \\n            if node != \\'#\\': # If the node is not a leaf node\\n                degree += 2 # Increment the degree by 2 for each non-leaf node\\n            \\n        # If the final degree is 0, the tree is valid, else invalid\\n        return degree == 0\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        # Initialize the outDegree (children) - inDegree (parent) to 1\\n        degree = 1\\n        \\n        # Iterate through the nodes in the preorder traversal\\n        for node in preorder.split(\\',\\'):\\n            degree -= 1 # Decrement the degree by 1 for each node\\n            \\n            if degree < 0: # If the degree is negative, return False\\n                return False\\n            \\n            if node != \\'#\\': # If the node is not a leaf node\\n                degree += 2 # Increment the degree by 2 for each non-leaf node\\n            \\n        # If the final degree is 0, the tree is valid, else invalid\\n        return degree == 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 864418,
                "title": "c-o-n-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Verify Preorder Serialization of a Binary Tree.\\nMemory Usage: 7 MB, less than 43.37% of C++ online submissions for Verify Preorder Serialization of a Binary Tree.\\n\\nhttps://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/473002/0-ms-C%2B%2B-simple-solution-with-counter\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        \\n        int count = 0;\\n        int n = preorder.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(preorder[i]==\\',\\')continue;\\n            \\n            // count<0 happens when node has no parent EX => [\"#,1,#\"]\\n            if(count<0) return false;\\n            \\n            // decrease count as we find NULL\\n            if(preorder[i]==\\'#\\')count--;\\n            else\\n            {\\n                while(i<n && preorder[i]!=\\',\\')i++;\\n                \\n                // increase count as there is a node\\n                count++;\\n            }            \\n        }\\n        \\n        // Valid preorder would have N node and N+1 NULL nodes and count would be -1\\n        return (count==-1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        \\n        int count = 0;\\n        int n = preorder.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(preorder[i]==\\',\\')continue;\\n            \\n            // count<0 happens when node has no parent EX => [\"#,1,#\"]\\n            if(count<0) return false;\\n            \\n            // decrease count as we find NULL\\n            if(preorder[i]==\\'#\\')count--;\\n            else\\n            {\\n                while(i<n && preorder[i]!=\\',\\')i++;\\n                \\n                // increase count as there is a node\\n                count++;\\n            }            \\n        }\\n        \\n        // Valid preorder would have N node and N+1 NULL nodes and count would be -1\\n        return (count==-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857654,
                "title": "c-full-explanation-beginner-friendly-vacancy-approach-with-pictorial-representation",
                "content": "[**@Iemprashant**](https://leetcode.com/iemprashant/) \\uD83D\\uDE80\\n[331. Verify Preorder Serialization of a Binary Tree](https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/)\\n```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\\n\\u26A1[ GithubRepo](https://github.com/iemprashant/LeetHub)\\n \\n**Observation** \\uD83D\\uDCCD\\n```\\nIdea-1=> As we start making a tree we have a single vacancy for node = root.\\nIdea-2=>For a node!=null-> creates 2 vacancy left and right.\\nIdea-3=>If node !=null and has left child ,so vacancy=> 1 from root that is right and 2 from root->left.\\n\\n```\\n![image](https://assets.leetcode.com/users/images/cf9ffe40-2364-458a-9618-cf22650fd100_1647513898.4065015.png)\\n\\n\\n**Approach** \\uD83D\\uDEA9 \\n1:=> Now, we will check the vacancy and traverse the string.\\n2:=>As string has \\',\\' Commas we need to split it, (we can\\'t use a single char of string as token as there are numbers like 92,934 are a valid token)\\n3=>We will split the token and put it into a vector.\\n4=>Now traversing the tokens of vector, for every char we will fill a vacancy so reduce it by 1;\\n5=>if we have vacancy less than 0, so no space left  return false,\\n6=>if we have char !=\\' #\\' i.e not null, so  it will create 2 vacancy => left , right;\\n7=>if we have char ==\\' #\\' null ,so no vacancy added.\\n\\n**CODE** \\uD83D\\uDCCB\\n```\\nclass Solution\\n{\\n    public:\\n        bool isValidSerialization(string p)\\n        {\\n            //creating Tokens\\n            vector<string> tokens;\\n            stringstream check(p);\\n            string temp;\\n            while (getline(check, temp, \\',\\'))\\n            {\\n                tokens.push_back(temp);\\n            }\\n            int v = 1;\\t//vacancy\\n            //checking for valid preorder\\n            for (auto s: tokens)\\n            {\\n                v--;\\n                if(v<0){\\n                    return false;\\n                }\\n                if (s != \"#\")\\n                {\\n                    v += 2;\\n                }\\n            }\\n            return v == 0;\\n        }\\n};\\n```\\n\\nPlease Upvote if it helps\\u2B06\\uFE0F",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n1. C++ Code. \\uD83C\\uDF93\\n2. Please Upvote if it helps\\u2B06\\uFE0F\\n3. Detailed Approach \\u2705\\n4. Github Repository for code:->\\n\\n```\n```\\nIdea-1=> As we start making a tree we have a single vacancy for node = root.\\nIdea-2=>For a node!=null-> creates 2 vacancy left and right.\\nIdea-3=>If node !=null and has left child ,so vacancy=> 1 from root that is right and 2 from root->left.\\n\\n```\n```\\nclass Solution\\n{\\n    public:\\n        bool isValidSerialization(string p)\\n        {\\n            //creating Tokens\\n            vector<string> tokens;\\n            stringstream check(p);\\n            string temp;\\n            while (getline(check, temp, \\',\\'))\\n            {\\n                tokens.push_back(temp);\\n            }\\n            int v = 1;\\t//vacancy\\n            //checking for valid preorder\\n            for (auto s: tokens)\\n            {\\n                v--;\\n                if(v<0){\\n                    return false;\\n                }\\n                if (s != \"#\")\\n                {\\n                    v += 2;\\n                }\\n            }\\n            return v == 0;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464500,
                "title": "c-clean-code-easy-solution-with-detailed-explanation",
                "content": "**Solution :**\\n\\nIn Preorder traversal we first record the current node value and then we traverse the left and right children of that node.\\n\\nAfter observing the preorder traversal of various binary trees we notice two things :\\n\\n1.  A leaf node will always be followed by two \\'#\\' ( which represent NULL values and also that we do not have to traverse this subtree).\\n2.  We can replace an entire subtree with a \\'#\\' after we have finished traversing that subtree. The \\'#\\' indicates that this subtree has already been traversed and we need to move on to the next child.\\n\\n**Refer the example below to understand the concept better.**\\n\\n![image](https://assets.leetcode.com/users/images/0ffb9e91-7dc9-4429-9683-c18c65279216_1661179462.6552796.png)\\n\\nA stack data structure will be of great help to track the nodes and remove them easily.\\n\\n**CODE : **\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream s(preorder);\\n        stack<string> st;\\n        string str;\\n        \\n        while(getline(s, str, \\',\\')){\\n            if(st.empty() || str != \"#\") st.push(str);\\n            else{\\n                while(!st.empty() && st.top() == \"#\"){\\n                    st.pop();\\n                    if(st.empty()) return false;\\n                    else st.pop();\\n                }\\n                \\n                st.push(str);\\n            }\\n        }\\n        \\n        return st.size() == 1 && st.top() == \"#\";\\n    } \\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream s(preorder);\\n        stack<string> st;\\n        string str;\\n        \\n        while(getline(s, str, \\',\\')){\\n            if(st.empty() || str != \"#\") st.push(str);\\n            else{\\n                while(!st.empty() && st.top() == \"#\"){\\n                    st.pop();\\n                    if(st.empty()) return false;\\n                    else st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1428642,
                "title": "java-simple-and-clean-with-easy-explanation",
                "content": "```\\n\\t  9\\n    /   \\\\\\n   3     2\\n  / \\\\   / \\\\\\n 4   1  #  6\\n/ \\\\ / \\\\   / \\\\\\n# # # #   # #\\n```\\n**Explanation**\\nIn a binary tree, if we consider null as leaves, then\\n1. all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root\\n2.   all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).\\n\\nSuppose we try to build this tree. During building, we record the difference between out degree and in degree diff = outdegree - indegree. When the next node comes, we then decrease diff by 1, because the node provides an in degree. If the node is not null, we increase diff by 2, because it provides two out degrees. If a serialization is correct, diff should never be negative and diff will be zero when finished.\\n```\\npublic boolean isValidSerialization(String preorder) {\\n    String[] nodes = preorder.split(\",\");\\n    int diff = 1;\\n    for (String node: nodes) {\\n        if (--diff < 0) return false;\\n        if (!node.equals(\"#\")) diff += 2;\\n    }\\n    return diff == 0;\\n}\\n```\\n\\nPlease Upvote so it remain at top",
                "solutionTags": [
                    "Java",
                    "String",
                    "Binary Tree"
                ],
                "code": "```\\n\\t  9\\n    /   \\\\\\n   3     2\\n  / \\\\   / \\\\\\n 4   1  #  6\\n/ \\\\ / \\\\   / \\\\\\n# # # #   # #\\n```\n```\\npublic boolean isValidSerialization(String preorder) {\\n    String[] nodes = preorder.split(\",\");\\n    int diff = 1;\\n    for (String node: nodes) {\\n        if (--diff < 0) return false;\\n        if (!node.equals(\"#\")) diff += 2;\\n    }\\n    return diff == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427175,
                "title": "c-o-1-space-clean-concise-with-explanation",
                "content": "### Solution Approach\\n\\n1. \\',\\'(comma) divides the string into \\'#\\' and node values.\\n2. Try to separate them and check for string with no \\',\\' and only \\'#\\' and integers(node values)\\n3. Now, the approach is to count number of leaf node this string has.\\n4. Atlast, we should end with total count == 0. This helps us to know that the preorder serialization was perfect and thus return true. Otherwise, return false.\\n\\n#### *Code*\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(const string& preorder) {  \\n        // Capacity is number of leaf node needed in valid tree.\\n        \\n        // Initialy tree can have 1 node (root) either null or value.\\n        int capacity = 1;\\n        stringstream ss(preorder); \\n        string node;\\n        while(getline(ss, node, \\',\\')) {\\n            // We enter in while loop means there is a value either node or leaf.\\n            // So we need 1 less leaf for above tree\\n            capacity--;\\n            \\n            // Number of leaf needed is negetive is not posible.\\n            if(capacity < 0)\\n                return false;\\n            \\n            // If we encounter another node than it has 2 more leafs so adding 2 in capacity.\\n            if(node != \"#\")\\n                capacity += 2;\\n        }\\n        \\n        // Final capacity should be zero for valid tree.\\n        return capacity == 0; \\n    }    \\n};\\n```\\n\\n**Time Complexity - O(N)**\\n**Space Complexity - O(N) -> For copy in stringstream**\\n*Note - You can iterate for input and find comma separator for O(1) space*\\nCode for O(1) space approach in the comments below.\\n\\n**Feel free to share your ideas or any improvements as well**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(const string& preorder) {  \\n        // Capacity is number of leaf node needed in valid tree.\\n        \\n        // Initialy tree can have 1 node (root) either null or value.\\n        int capacity = 1;\\n        stringstream ss(preorder); \\n        string node;\\n        while(getline(ss, node, \\',\\')) {\\n            // We enter in while loop means there is a value either node or leaf.\\n            // So we need 1 less leaf for above tree\\n            capacity--;\\n            \\n            // Number of leaf needed is negetive is not posible.\\n            if(capacity < 0)\\n                return false;\\n            \\n            // If we encounter another node than it has 2 more leafs so adding 2 in capacity.\\n            if(node != \"#\")\\n                capacity += 2;\\n        }\\n        \\n        // Final capacity should be zero for valid tree.\\n        return capacity == 0; \\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78569,
                "title": "traversal-solution-but-not-building-a-tree",
                "content": "```\\npublic class Solution {\\n    int idx;\\n    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        if (strs.length == 0) return true;\\n        if (strs.length == 1) {\\n            if (strs[0].equals(\"#\")) return true;\\n            else return false;\\n        }\\n        idx = 0;\\n        return preorder(strs) && (idx == strs.length);\\n    }\\n    boolean preorder(String[] strs) {\\n        if (idx == strs.length) return true;\\n        if (strs[idx].equals(\"#\")) {\\n            idx++;\\n            return true;\\n        }\\n        idx++;\\n        if (idx == strs.length) return false;\\n        boolean left = preorder(strs);\\n        if (idx == strs.length) return false;\\n        boolean right = preorder(strs);\\n        return left && right;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int idx;\\n    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        if (strs.length == 0) return true;\\n        if (strs.length == 1) {\\n            if (strs[0].equals(\"#\")) return true;\\n            else return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 78668,
                "title": "clean-sample-java-solution-with-explain",
                "content": "public boolean isValidSerialization(String preorder) {\\n        String[] chars = preorder.split(\",\");\\n        \\n        int sentinel = 0;\\n        int node = 0;\\n        for (int i = chars.length - 1; i >= 0; i--)\\n        {\\n            if (chars[i].equals(\"#\"))\\n            {\\n                sentinel++;\\n            }\\n            else\\n            {\\n                node++;\\n            }\\n            if (sentinel - node < 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return sentinel - node == 1;\\n    }\\n\\n1. Total quantity of sentinel is always nodes\\' quantity plus one.\\n2. Each time when adding a node to the tree, one more sentinel must be added some where after the node. (image a node replaced a sentinel, but it self has two sentinel)\\n3. Browse the string backward follow rule 1 and 2.",
                "solutionTags": [],
                "code": "public boolean isValidSerialization(String preorder) {\\n        String[] chars = preorder.split(\",\");\\n        \\n        int sentinel = 0;\\n        int node = 0;\\n        for (int i = chars.length - 1; i >= 0; i--)\\n        {\\n            if (chars[i].equals(\"#\"))\\n            {\\n                sentinel++;\\n            }\\n            else\\n            {\\n                node++;\\n            }\\n            if (sentinel - node < 1)\\n            {\\n                return false;\\n            }\\n        }\\n        return sentinel - node == 1;\\n    }\\n\\n1. Total quantity of sentinel is always nodes\\' quantity plus one.\\n2. Each time when adding a node to the tree, one more sentinel must be added some where after the node. (image a node replaced a sentinel, but it self has two sentinel)\\n3. Browse the string backward follow rule 1 and 2.",
                "codeTag": "Unknown"
            },
            {
                "id": 78654,
                "title": "fun-summary-of-3-different-c-solutions",
                "content": "**method 1** \\n\\nThe first solution is inspired from the idea that we can delete the leaf node level by level .....\\n\\nWe need first implement the split function for the latter calling ....\\n\\n             vector<string> split(string input, char delimiter){\\n                vector<string> result;\\n                string str=input;\\n                while(!str.empty()){\\n                    int ind=str.find_first_of(delimiter);\\n                    if(ind==-1){\\n                        result.push_back(str);\\n                        str.clear();\\n                    }\\n                    else{\\n                        result.push_back(str.substr(0, ind));\\n                        str=str.substr(ind+1);\\n                    }\\n                }\\n                return result;\\n            }\\n\\nBased the split function , we need first split the string to a string array .\\n\\nBy using a bool array to mimic the process of deleting the leaf node level by level .\\n\\n\\n\\n      class Solution {\\n        public:\\n            bool isValidSerialization(string preorder) {\\n                /*** for a binary tree : count_null=count_node+1 **/\\n                int count_null=0, count_node=0;\\n                vector<string> nodes=split(preorder, ',');\\n                vector<bool> stack(nodes.size(), false);\\n                int end = 0;\\n                for (auto node : nodes) {\\n                    if (end == 1 && !stack[end-1])  return false;\\n                    stack[end++] = !(node == \"#\");\\n                    while (end >= 3 && stack[end - 3] && !stack[end - 2] && !stack[end - 1]) {\\n                        stack[end - 3] = false;\\n                        end -= 2;\\n                    }\\n                }\\n                return end == 1 && !stack[0];\\n            }\\n        };\\n\\n**method 2**\\n\\nThis idea is based on the solution from @dietpepsi\\n\\nIn a binary tree, if we consider null as leaves, then\\n\\n      all non-null node provides 2 outdegree and 1 indegree (2 children and 1 parent), except root\\n      all null node provides 0 outdegree and 1 indegree (0 child and 1 parent).\\n\\nSuppose we try to build this tree. During building, we record the difference between out degree and in degree \\n\\n              diff = outdegree - indegree. \\n\\nWhen the next node comes, we then decrease diff by 1, because the node provides an in degree.\\n If the node is not null, we increase diff by2, because it provides two out degrees. \\n\\n         If a serialization is correct, diff should never be negative and diff will be zero when finished.\\n\\nHere is the AC implementation ...\\n\\n    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            /*** for a binary tree : count_null=count_node+1 **/\\n            int count_null=0, count_node=0;\\n            vector<string> nodes=split(preorder, ',');\\n            int diff = 1;\\n            for(auto node : nodes) {\\n                diff--;\\n                if(diff < 0)  return false;\\n                if(node != \"#\")  diff += 2;\\n            }\\n            return diff == 0;\\n        }\\n\\n\\n**Update**\\n\\nHere is a small changed version based on the method2 , I think this is more easy to understand ...\\n\\n    bool isValidSerialization(string preorder) {\\n        /*** for a binary tree : count_null=count_node+1 **/\\n        int count_null=0, count_node=0;\\n        vector<string> nodes=split(preorder, ',');\\n        int diff = 0;\\n        for (int i = 0; i < nodes.size(); i++) {\\n            if (i == 0) {\\n                if(nodes[i] != \"#\") {\\n                    diff += 2;\\n                }\\n                continue;\\n            }\\n            diff--;\\n            if(diff < 0)  return false;\\n            if(nodes[i] != \"#\")  diff += 2;\\n        }\\n        return diff == 0;\\n    }\\n\\n\\n**method 3**\\n\\n  The solution is based on the intuition that , \\n\\n        # of leaves = # of nonleaves + 1\\n\\nWe should satisfy the above equation in all the process of the pre-order-traverse of the tree ....\\n\\n**we just need to find the shortest prefix of the serialization sequence satisfying the property above. If such prefix does not exist, then the serialization is definitely invalid; otherwise, the serialization is valid if and only if the prefix is the entire sequence.**\\n\\n     bool isValidSerialization(string preorder) {\\n            /*** for a binary tree : count_null=count_node+1 **/\\n            int count_null=0, count_node=0;\\n            vector<string> nodes=split(preorder, ',');\\n            \\n            int i = 0;\\n            for (i = 0; i < nodes.size() && count_null != count_node + 1; i++) {\\n                if(nodes[i] == \"#\")  count_null++;\\n                else  count_node++;\\n            }\\n            return i == nodes.size() && (count_null == count_node + 1);\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n        public:\\n            bool isValidSerialization(string preorder) {\\n                /*** for a binary tree : count_null=count_node+1 **/\\n                int count_null=0, count_node=0;\\n                vector<string> nodes=split(preorder, ',');\\n                vector<bool> stack(nodes.size(), false);\\n                int end = 0;\\n                for (auto node : nodes) {\\n                    if (end == 1 && !stack[end-1])  return false;\\n                    stack[end++] = !(node == \"#\");\\n                    while (end >= 3 && stack[end - 3] && !stack[end - 2] && !stack[end - 1]) {\\n                        stack[end - 3] = false;\\n                        end -= 2;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3108396,
                "title": "c-well-commented",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int nodes=1;\\n        preorder+=\\',\\';\\n        for(int i=0;i<preorder.size();i++){\\n            if(preorder[i]!=\\',\\')continue;//comma seperated values of nodes\\n            nodes--; //after taking each node decrease value of left nodes\\n            if(nodes<0)return false;\\n            if(preorder[i-1]!=\\'#\\')nodes+=2;//if current node is not null means it will 2 childs si increase by 2;\\n        }\\n        return nodes==0;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int nodes=1;\\n        preorder+=\\',\\';\\n        for(int i=0;i<preorder.size();i++){\\n            if(preorder[i]!=\\',\\')continue;//comma seperated values of nodes\\n            nodes--; //after taking each node decrease value of left nodes\\n            if(nodes<0)return false;\\n            if(preorder[i-1]!=\\'#\\')nodes+=2;//if current node is not null means it will 2 childs si increase by 2;\\n        }\\n        return nodes==0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514908,
                "title": "c-easy-fully-commented",
                "content": "```\\n bool isValidSerialization(string pre) {\\n       //vacancy will be counted for every node .. vacancy means the number of more nodes that current node can generate i.e left and right child\\n        \\n        //initially root will occupy only 1 vacancy hence vacancy =1\\n        int vac=1;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            //if we encounter a , then do nothing\\n            if(pre[i]==\\',\\')\\n                continue;\\n            \\n            //reduce the vacancy as the current value eats up a vacancy by becoming the child of the previous parent node\\n            vac--;\\n            //increment the iterator till we encounter a nmbr because node value can be of more than one digit\\n            while(i<pre.size() && pre[i]>=\\'0\\'&&pre[i]<=\\'9\\'&&pre[i]!=\\',\\')i++;\\n            // if here we have an invalid vacancy then preorder is not correct i.e tree cannot be formed out of it\\n            if(vac<0)\\n                return false;\\n            //if the current value is not # then it will contribute 2 vacancy of left and right child hence increase vacancy\\n            if(pre[i]!=\\'#\\')\\n                vac+=2;\\n        }\\n        //if vacancy is still left but string is finished then we will return false\\n        if(vac)\\n            return false;\\n        return true;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n bool isValidSerialization(string pre) {\\n       //vacancy will be counted for every node .. vacancy means the number of more nodes that current node can generate i.e left and right child\\n        \\n        //initially root will occupy only 1 vacancy hence vacancy =1\\n        int vac=1;\\n        for(int i=0;i<pre.size();i++)\\n        {\\n            //if we encounter a , then do nothing\\n            if(pre[i]==\\',\\')\\n                continue;\\n            \\n            //reduce the vacancy as the current value eats up a vacancy by becoming the child of the previous parent node\\n            vac--;\\n            //increment the iterator till we encounter a nmbr because node value can be of more than one digit\\n            while(i<pre.size() && pre[i]>=\\'0\\'&&pre[i]<=\\'9\\'&&pre[i]!=\\',\\')i++;\\n            // if here we have an invalid vacancy then preorder is not correct i.e tree cannot be formed out of it\\n            if(vac<0)\\n                return false;\\n            //if the current value is not # then it will contribute 2 vacancy of left and right child hence increase vacancy\\n            if(pre[i]!=\\'#\\')\\n                vac+=2;\\n        }\\n        //if vacancy is still left but string is finished then we will return false\\n        if(vac)\\n            return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1653430,
                "title": "java-solution-with-stack",
                "content": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        Stack<String> stack = new Stack<>();\\n        String[] res = preorder.split(\",\");\\n        for(String r : res){\\n            while(\"#\".equals(r) && !stack.isEmpty() && \"#\".equals(stack.peek())){\\n                stack.pop();\\n                if(stack.isEmpty()) return false;\\n                stack.pop();\\n            }\\n            stack.push(r);\\n        }\\n        return stack.size()==1 && \"#\".equals(stack.peek());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        Stack<String> stack = new Stack<>();\\n        String[] res = preorder.split(\",\");\\n        for(String r : res){\\n            while(\"#\".equals(r) && !stack.isEmpty() && \"#\".equals(stack.peek())){\\n                stack.pop();\\n                if(stack.isEmpty()) return false;\\n                stack.pop();\\n            }\\n            stack.push(r);\\n        }\\n        return stack.size()==1 && \"#\".equals(stack.peek());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427141,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorder = preorder.split(\",\")\\n        n = len(preorder)\\n        if preorder[0] == \\'#\\':\\n            return n == 1\\n        stack = [preorder[0]]\\n        \\n        for idx in range(1, n):\\n            if preorder[idx] != \\'#\\':\\n                stack.append(preorder[idx])\\n            else:\\n                if not stack:\\n                    return idx == n - 1\\n                stack.pop()    \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorder = preorder.split(\",\")\\n        n = len(preorder)\\n        if preorder[0] == \\'#\\':\\n            return n == 1\\n        stack = [preorder[0]]\\n        \\n        for idx in range(1, n):\\n            if preorder[idx] != \\'#\\':\\n                stack.append(preorder[idx])\\n            else:\\n                if not stack:\\n                    return idx == n - 1\\n                stack.pop()    \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 293341,
                "title": "python3-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/jingdamai/image_1557994553.png)\\nWe can keep trimming the leaves until there is no one to remove. If a sequence is like \"9 # #\", change it to \"#\" and continue. \\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        tree = preorder.split(\\',\\')\\n        stack = []\\n        \\n        for node in tree:\\n            if not stack or node != \\'#\\':\\n                stack.append(node)\\n            else:\\n                while stack and stack[-1] == \\'#\\':\\n                    stack.pop()\\n                    if not stack:\\n                        return False\\n                    else:\\n                        stack.pop()\\n                stack.append(\\'#\\')\\n        \\n        return len(stack) == 1 and stack[-1] == \\'#\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        tree = preorder.split(\\',\\')\\n        stack = []\\n        \\n        for node in tree:\\n            if not stack or node != \\'#\\':\\n                stack.append(node)\\n            else:\\n                while stack and stack[-1] == \\'#\\':\\n                    stack.pop()\\n                    if not stack:\\n                        return False\\n                    else:\\n                        stack.pop()\\n                stack.append(\\'#\\')\\n        \\n        return len(stack) == 1 and stack[-1] == \\'#\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78656,
                "title": "3-lines-python-solution-by-re",
                "content": "    import re\\n    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            while re.search('[0-9]+,#,#', preorder):\\n                preorder = re.sub('[0-9]+,#,#', '#', preorder)\\n            return preorder == '#'",
                "solutionTags": [],
                "code": "    import re\\n    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            while re.search('[0-9]+,#,#', preorder):\\n                preorder = re.sub('[0-9]+,#,#', '#', preorder)\\n            return preorder == '#'",
                "codeTag": "Java"
            },
            {
                "id": 78732,
                "title": "simple-java-sol-without-tree-construction",
                "content": "The main thought is to keep track of 'opens' which is number of leaves that this tree can have. To have a valid tree, one have to satisfy the follow two constrains.\\nFirst constrain: during the process, opens must be positive.\\nSecond constrain: at the end, opens should be zero.\\n\\n    public class Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        int opens=1;\\n        int i;\\n        for(i = 0; i < strs.length && opens > 0; i++) {\\n            if(strs[i].compareTo(\"#\") == 0)\\n                opens--;\\n            else\\n                opens++;\\n        }\\n        return (opens == 0 && i == strs.length);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        int opens=1;\\n        int i;\\n        for(i = 0; i < strs.length && opens > 0; i++) {\\n            if(strs[i].compareTo(\"#\") == 0)\\n                opens--;\\n            else\\n                opens++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 78719,
                "title": "simple-python-solution",
                "content": "    def isValidSerialization(self, preorder):\\n        preorder = preorder.split(',')\\n        balance = 1\\n        for item in preorder:\\n            balance -= 1\\n            if balance < 0:\\n                return False\\n            if item != '#':\\n                balance += 2\\n        return balance == 0\\n##Every parent node will introduce 2 children. One child must have a parent. So if a node has 2 children, it should add 2, otherwise do not add. For every node introduced, it should -1 to balance parent number. Initial balance is 1 because root is special case.",
                "solutionTags": [],
                "code": "    def isValidSerialization(self, preorder):\\n        preorder = preorder.split(',')\\n        balance = 1\\n        for item in preorder:\\n            balance -= 1\\n            if balance < 0:\\n                return False\\n            if item != '#':\\n                balance += 2\\n        return balance == 0\\n##Every parent node will introduce 2 children. One child must have a parent. So if a node has 2 children, it should add 2, otherwise do not add. For every node introduced, it should -1 to balance parent number. Initial balance is 1 because root is special case.",
                "codeTag": "Python3"
            },
            {
                "id": 3305172,
                "title": "easiest-begginer-frinedly-o-1-space-c-solution",
                "content": "Here\\'s how the function works:\\n\\nInitialize a variable val to 1. This represents the number of nodes in the binary tree that have not yet been processed.\\n\\nIterate over the characters in the string nums. For each character:\\n\\na. If the character is a comma, skip it and continue to the next character.\\n\\nb. If the character is a \\'#\\' (representing a null node), decrement val by 1.\\n\\nc. If the character is not a \\'#\\' (representing a non-null node), decrement val by 1 and increment it by 2 (to account for the two child nodes that a non-null node has). Also, skip over the rest of the characters representing the current node\\'s value and its children (up to the next comma).\\n\\nd. If val becomes negative at any point, return false (because the tree is invalid).\\n\\nAfter processing all characters in the string, if val is equal to 0, return true (because the tree is valid). Otherwise, return false (because the tree is invalid\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string nums) {\\n        int val = 1;\\n        for (int i = 0; i < nums.length(); i++) {\\n            if (nums[i] == \\',\\') {\\n                continue;\\n            }\\n            val--;\\n            if (val < 0) {\\n                return false;\\n            }\\n            if (nums[i] != \\'#\\') {\\n                val += 2;\\n                while (i + 1 < nums.length() && nums[i+1] != \\',\\') {\\n                    i++;\\n                }\\n            }\\n        }\\n        return val == 0;\\n    }\\n};\\n```\\n\\n\\nSb answer pdh k chle jaate hai , koi upvote nhi krta",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string nums) {\\n        int val = 1;\\n        for (int i = 0; i < nums.length(); i++) {\\n            if (nums[i] == \\',\\') {\\n                continue;\\n            }\\n            val--;\\n            if (val < 0) {\\n                return false;\\n            }\\n            if (nums[i] != \\'#\\') {\\n                val += 2;\\n                while (i + 1 < nums.length() && nums[i+1] != \\',\\') {\\n                    i++;\\n                }\\n            }\\n        }\\n        return val == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1852001,
                "title": "7-lines-c-easy-peasy-0-ms",
                "content": "# Explaination in Comments\\uD83D\\uDE0E\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder){\\n\\t// declaring n means we are thinking of that atleast we have head in imginary BT/\\\\.\\n        int n=1,size=preorder.size(),i=0;\\n        preorder+=\\',\\';\\n\\t\\t// Doing this will help in traversing the string.\\n\\t\\t// i have also used the stringstream getline which takes 7ms but i have done this in 0ms according to leet code O(sizeofstring);\\n        while(i<size){\\n            string temp=\"\";\\n\\t\\t\\t// this while loop is get the node val between two\\',\\'node val \\',\\'\\n            while(preorder[i]!=\\',\\'){\\n                temp+=preorder[i];\\n                i++;\\n            }\\n            n--;\\n            if(n<0) return false;\\n\\t\\t\\t// As for any node there are two mode node left or right either they are null node or not\\n            if(temp!=\"#\") n+=2;\\n            i++;\\n        }\\n        return n==0;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValidSerialization(string preorder){\\n\\t// declaring n means we are thinking of that atleast we have head in imginary BT/\\\\.\\n        int n=1,size=preorder.size(),i=0;\\n        preorder+=\\',\\';\\n\\t\\t// Doing this will help in traversing the string.\\n\\t\\t// i have also used the stringstream getline which takes 7ms but i have done this in 0ms according to leet code O(sizeofstring);\\n        while(i<size){\\n            string temp=\"\";\\n\\t\\t\\t// this while loop is get the node val between two\\',\\'node val \\',\\'\\n            while(preorder[i]!=\\',\\'){\\n                temp+=preorder[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1459342,
                "title": "python3-o-n-time-and-o-n-space",
                "content": "The idea is to pop the element from the stack if you get the count of the element as 0.\\n\\nStack is storing the node and number of remaining branch that need to discover.\\nExample [2,2] will refer a node having value 2 and we did not traverse any of the branch (left or right) but at the moment we traverse the left branch that value will change to [2,1] and after traversing through right branch it will convert into [2,0].\\n\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        items = preorder.split(\",\")\\n        for i, val in enumerate(items):\\n            if i>0 and not stack:\\n                return False\\n            if stack:\\n                stack[-1][1] -= 1\\n                if stack[-1][1] == 0:\\n                    stack.pop()\\n            if val != \"#\":\\n                stack.append([val, 2])\\n        return not stack\\n ```\\n \\n If you find this good please upvote or like, and if you feel any trouble to understand then please comment here.\\n Thanks",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        items = preorder.split(\",\")\\n        for i, val in enumerate(items):\\n            if i>0 and not stack:\\n                return False\\n            if stack:\\n                stack[-1][1] -= 1\\n                if stack[-1][1] == 0:\\n                    stack.pop()\\n            if val != \"#\":\\n                stack.append([val, 2])\\n        return not stack\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1155735,
                "title": "2-solutions",
                "content": "**Idea explanation**\\n\\n![image](https://assets.leetcode.com/users/images/5cb45b50-f19f-43ee-b710-e82d389980b5_1618330517.505618.png)\\n<br>\\n\\nGrey nodes - internal nodes, pink (`#`) - external nodes. \\nNote that in any legit **binary tree** `number(internal)-number(external) == -1`.\\nHere\\'s how it\\'s stated and proven [in Sedgwick\\'s book](http://index-of.co.uk/Algorithms/Algorithms_in_C_-_Sedgewick.pdf)\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/5d3a521f-51bd-49d6-bebb-412f950944fc_1618329065.3934822.png)\\n\\n<br>\\n\\nMoreover if you have a list of internal and external nodes (in preorder) so that `number(internal)-number(external) == -1` you can cook up a binary tree using \"greedy\" approach (put current node in the next available slot according to the preorder).\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/4f985e0b-f6ea-4e37-ae42-12ed935ed436_1618337397.7040095.png)\\n\\n<br>\\n\\nIf you have intoduced some internal and external nodes `number(internal)-number(external)+1` counts the number of **vacant slots** (green rectangles) as every internal node(except for the root) introduces `2-1=1` extra slot while every external node deletes `1` slot (parent root introduces `2` slots). If `number(internal)-number(external) == -1` you have no more slots left.\\nBut if you still have nodes left in the list you can\\'t fit them into the constructed tree - you have no vacant slots left so you can\\'t construct the binary tree from such a list.\\n>  The algo is as follows: traverse the list keeping track of the difference between the number of internal nodes (not `#`) and external (`#`) ones.   When `number(internal)-number(external) == -1` check whether you have more nodes in the list. If yes, return `false`, if no - return `true`.\\nIf `number(internal)-number(external) == -1` is never fullfilled than return `false`.\\nIn other words the only time when `number(internal)-number(external) == -1` is at the end of the list !\\n\\n**Counter:** time `O(N)`, space `O(1)`\\n```\\nbool isValidSerialization(string p) \\n{\\n\\tint c{0};\\n\\tfor(stringstream ss{p}; getline(ss, p, \\',\\'); )\\n\\t\\tif(p[0]==\\'#\\' ? --c : ++c, c==-1)\\n\\t\\t\\treturn ss.eof();\\n\\treturn c==-1;\\n}\\n```\\n||\\n```\\nbool isValidSerialization(string p) \\n{\\n    stringstream ss{p};\\n\\tint c{0};\\n\\tfor( ; c!=-1 and !ss.eof(); getline(ss, p, \\',\\'), p[0]==\\'#\\' ? --c : ++c);\\n\\treturn c==-1 and ss.eof();\\n}\\n```\\n**Stack:** time `O(N)`, space `O(N)`\\n\\nYou can keep track current position in the tree with the help of the stack. In this way you can **simulate** insertions into binary tree.\\n\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/3803048b-09cd-4955-a909-bb43cf4269df_1618324945.9085522.png)\\n\\n<br>\\n\\n```\\nbool isValidSerialization(string p) \\n{\\n\\tstack<int> s;\\n\\tfor(stringstream ss{p}; getline(ss, p, \\',\\'); )\\n\\t\\tif(p[0]==\\'#\\')\\n\\t\\t{\\n\\t\\t\\tfor( ; !empty(s) and s.top(); s.pop());\\n\\t\\t\\tif(empty(s)) return ss.eof();\\n\\t\\t\\ts.top()=1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts.push(0);\\n\\treturn empty(s);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isValidSerialization(string p) \\n{\\n\\tint c{0};\\n\\tfor(stringstream ss{p}; getline(ss, p, \\',\\'); )\\n\\t\\tif(p[0]==\\'#\\' ? --c : ++c, c==-1)\\n\\t\\t\\treturn ss.eof();\\n\\treturn c==-1;\\n}\\n```\n```\\nbool isValidSerialization(string p) \\n{\\n    stringstream ss{p};\\n\\tint c{0};\\n\\tfor( ; c!=-1 and !ss.eof(); getline(ss, p, \\',\\'), p[0]==\\'#\\' ? --c : ++c);\\n\\treturn c==-1 and ss.eof();\\n}\\n```\n```\\nbool isValidSerialization(string p) \\n{\\n\\tstack<int> s;\\n\\tfor(stringstream ss{p}; getline(ss, p, \\',\\'); )\\n\\t\\tif(p[0]==\\'#\\')\\n\\t\\t{\\n\\t\\t\\tfor( ; !empty(s) and s.top(); s.pop());\\n\\t\\t\\tif(empty(s)) return ss.eof();\\n\\t\\t\\ts.top()=1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\ts.push(0);\\n\\treturn empty(s);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1003435,
                "title": "easy-to-understand-java-solution-3ms",
                "content": "we just keep the count of number of nodes we need. For the root node we need 2 child node and after that for every non-null node we add 2 child node in nodeCounter and decrese one node in NodeCounter. And for every null node we decreases nodeCounter. At last if nodeCounter is 0 than it is valid and at any time in the loop if nodecounter is become zero then we return false.\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String s) {\\n        int node=0;\\n        String[] ar = s.split(\",\");\\n        int n=ar.length;\\n        \\n        int i=0;\\n        if(n==0)\\n            return true;\\n        if(ar[0].charAt(0)!=\\'#\\')\\n            node=2;\\n        i=1;\\n        while(i<n){\\n            if(node==0)\\n                return false;\\n            \\n            if(ar[i].charAt(0)!=\\'#\\'){\\n                node++;\\n            }else{\\n                node--;\\n            }\\n            i++;\\n        }\\n        if(node==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String s) {\\n        int node=0;\\n        String[] ar = s.split(\",\");\\n        int n=ar.length;\\n        \\n        int i=0;\\n        if(n==0)\\n            return true;\\n        if(ar[0].charAt(0)!=\\'#\\')\\n            node=2;\\n        i=1;\\n        while(i<n){\\n            if(node==0)\\n                return false;\\n            \\n            if(ar[i].charAt(0)!=\\'#\\'){\\n                node++;\\n            }else{\\n                node--;\\n            }\\n            i++;\\n        }\\n        if(node==0)\\n            return true;\\n        else\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846494,
                "title": "clear-python-3-solution-faster-than-95-without-using-stack-comments-provided",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        nodes = deque(preorder.split(\\',\\'))\\n        count = 1    # number(s) of \\'null\\'/\\'None\\' to take care of at any point in time \\n        while nodes:\\n            node = nodes.popleft()\\n            if node != \\'#\\':\\n                count += 1 \\n            else:\\n                count -= 1    # one less \\'null\\'/\\'None\\' to take care of\\n            if not count and nodes:    # if there are still nodes left\\n                return False\\n        if count:    # if the number of \\'null\\'/\\'None\\' in the input string is less than what is needed \\n            return False\\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        nodes = deque(preorder.split(\\',\\'))\\n        count = 1    # number(s) of \\'null\\'/\\'None\\' to take care of at any point in time \\n        while nodes:\\n            node = nodes.popleft()\\n            if node != \\'#\\':\\n                count += 1 \\n            else:\\n                count -= 1    # one less \\'null\\'/\\'None\\' to take care of\\n            if not count and nodes:    # if there are still nodes left\\n                return False\\n        if count:    # if the number of \\'null\\'/\\'None\\' in the input string is less than what is needed \\n            return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 473002,
                "title": "0-ms-c-simple-solution-with-counter",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int count = 0;\\n        for(int i = 0 ; i < preorder.size() ; i++){\\n            if(preorder[i] == \\',\\') continue;\\n            \\n            if(count < 0) return false;\\n            \\n            if(preorder[i] == \\'#\\')\\n                count--;\\n            else{\\n                while(i < preorder.size() && preorder[i]!=\\',\\'  )\\n                    i++;\\n                count++;\\n            }\\n                \\n        }\\n        if(count == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int count = 0;\\n        for(int i = 0 ; i < preorder.size() ; i++){\\n            if(preorder[i] == \\',\\') continue;\\n            \\n            if(count < 0) return false;\\n            \\n            if(preorder[i] == \\'#\\')\\n                count--;\\n            else{\\n                while(i < preorder.size() && preorder[i]!=\\',\\'  )\\n                    i++;\\n                count++;\\n            }\\n                \\n        }\\n        if(count == -1) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362721,
                "title": "10-lines-concise-c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int idx = 0;\\n        return f(s, idx) && idx == s.size();\\n    }\\n    \\n    bool f(string &s, int &idx) {\\n        if(idx >= s.size()) return false;\\n        if(s[idx] == \\'#\\') {\\n            idx = min(idx+2, (int)s.size());\\n            return true;\\n        }\\n        while(idx < s.size() && s[idx++] != \\',\\');\\n        return f(s, idx) && f(s, idx);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int idx = 0;\\n        return f(s, idx) && idx == s.size();\\n    }\\n    \\n    bool f(string &s, int &idx) {\\n        if(idx >= s.size()) return false;\\n        if(s[idx] == \\'#\\') {\\n            idx = min(idx+2, (int)s.size());\\n            return true;\\n        }\\n        while(idx < s.size() && s[idx++] != \\',\\');\\n        return f(s, idx) && f(s, idx);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78622,
                "title": "c-2-lines-regex-solution-base-on-angrybirdrr-and-stefanpochmann-s-discussion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        string replaced = std::regex_replace(preorder, (regex)\"\\\\\\\\d+,#,#\", \"#\");\\n        return replaced == \"#\" || (replaced != preorder && isValidSerialization(replaced));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        string replaced = std::regex_replace(preorder, (regex)\"\\\\\\\\d+,#,#\", \"#\");\\n        return replaced == \"#\" || (replaced != preorder && isValidSerialization(replaced));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78625,
                "title": "3ms-c-with-o-1-space-and-o-n-time",
                "content": "The idea is simple: 1) Every node/null must have a parent except the root. 2) As a binary tree, the number of nulls must be one plus the number of nodes.\\nAs long as we meet a node/null we increment/decrement **cnt**. When we meet a new node/null we check if **cnt** already becomes zero (which means the tree has already been full before). When we are done with all nodes/nulls we also check if **cnt** has become zero which otherwise means the tree is not complete yet.\\n```\\nbool isValidSerialization(string preorder) {\\n    int cnt = 1;\\n    bool lastd = false;\\n    for (char c : preorder) {\\n        if (isdigit(c)) {\\n            if (lastd)\\n                continue;\\n            if (!cnt)\\n                return false;\\n            cnt++;\\n            lastd = true;\\n        }\\n        else {\\n            if (c == '#')\\n                cnt--;\\n            lastd = false;\\n        }\\n    }\\n    return cnt == 0;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool isValidSerialization(string preorder) {\\n    int cnt = 1;\\n    bool lastd = false;\\n    for (char c : preorder) {\\n        if (isdigit(c)) {\\n            if (lastd)\\n                continue;\\n            if (!cnt)\\n                return false;\\n            cnt++;\\n            lastd = true;\\n        }\\n        else {\\n            if (c == '#')\\n                cnt--;\\n            lastd = false;\\n        }\\n    }\\n    return cnt == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78660,
                "title": "4ms-c-solution-without-using-stack",
                "content": "    class Solution {\\n    public:\\n    bool isValidSerialization(string preorder) { \\n        int n=preorder.size();\\n        int num=0,ctr=0;\\n        for(int i=0;i<n;i++){\\n            if(preorder[i]=='#') ctr++;\\n            else if(preorder[i]!=','){\\n                num++;\\n                while(i+1<n&&preorder[i+1]>='0'&&preorder[i+1]<='9') i++;\\n            }\\n            if(ctr==num+1&&i<n-1) return false;\\n        }\\n        if(ctr==num+1) return true;\\n        else return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    bool isValidSerialization(string preorder) { \\n        int n=preorder.size();\\n        int num=0,ctr=0;\\n        for(int i=0;i<n;i++){\\n            if(preorder[i]=='#') ctr++;\\n            else if(preorder[i]!=','){\\n                num++;\\n                while(i+1<n&&preorder[i+1]>='0'&&preorder[i+1]<='9') i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 78698,
                "title": "my-solution-using-stack",
                "content": "Solution:\\nAt the first glance, I have no idea about the problem. So I decided to simulate some cases to find whether there are some regulations. After trying several cases I found that the value before two consecutive '#'s should be a leaf and there are two consecutive '#'s after a leaf. So I think out a solution using stack.\\n\\nHere is the steps of the algorithm: \\n\\n1)push a '*' when we encounter a number;\\n\\n2)push a '#' when we encounter a '#', \\n\\nthen judge whether the top two elements in the stack are '#',  -------------- question 1\\n\\nif yes for question 1, \\n\\njudge whether the third element is '*'  ---------------- question 2\\n\\nif yes for question 2, pop the top three element, then push a '#'.\\n\\nif no for question 2, then return false.\\n\\nif no for question 1, then continue.\\n\\nIn the end, if there is only one element in the stack and it is '#', then return true, else return false.\\n\\nThis algorithm runs in O(n) time complexity and O(n) space complexity.\\n\\nCode:\\n\\n\\n    class Solution {  \\n    public:  \\n        bool isValidSerialization(string preorder) {  \\n            stack<char>stk;  \\n            int i,len=preorder.length();  \\n            for(i=0;i<len;i++)  \\n            {  \\n                if(isdigit(preorder[i]))  \\n                {  \\n                    while(i<len&&isdigit(preorder[i]))  \\n                    {  \\n                        i++;  \\n                    }  \\n                    i--;  \\n                    stk.push('*');  \\n                }  \\n                else if(preorder[i]=='#')  \\n                {  \\n                    stk.push('#');  \\n                    while(stk.size()>=2&&stk.top()=='#')  \\n                    {  \\n                        stk.pop();  \\n                        if(stk.top()=='#')//get the last two '#', change '*' to '#'  \\n                        {  \\n                            stk.pop();  \\n                            if(stk.empty())return false;  \\n                            if(stk.top()=='#')return false;  \\n                            stk.pop();  \\n                            stk.push('#');  \\n                        }  \\n                        else  \\n                        {  \\n                            stk.push('#');  \\n                            break;  \\n                        }  \\n                    }  \\n                }  \\n            }  \\n              \\n            return stk.size()==1&&stk.top()=='#';  \\n        }  \\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {  \\n    public:  \\n        bool isValidSerialization(string preorder) {  \\n            stack<char>stk;  \\n            int i,len=preorder.length();  \\n            for(i=0;i<len;i++)  \\n            {  \\n                if(isdigit(preorder[i]))  \\n                {  \\n                    while(i<len&&isdigit(preorder[i]))  \\n                    {  \\n                        i++;  \\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 78718,
                "title": "you-only-need-to-count-open-leaf-positions-short-python-48ms-88-5",
                "content": "As the tree grows, the number of open leaves dynamically changes.  we just need to count these leaves.\\n\\nwhen a new node comes,  whether empty or not, it has to attach to some current leaf position, and as the preorder list gets exhausted, there must be no leave positions open (all sealed by '#', thus not open).\\n\\nwe start with 1 leaf position for the root to attach on, and then when there comes a non-empty node, the total open leave positions will increase by 1, and when there is a '#', it decreases the leaf position by 1 as it seals 1 position.  And at any moment, there should be at least 1 open leaf position for the new comer to attach to, until the end.\\n\\n    def isValidSerialization(self, preorder):\\n        preorder=preorder.split(',')\\n        leaves=1\\n        for node in preorder:\\n            if leaves==0:\\n                return False\\n            leaves-=(1 if node=='#' else -1)\\n        return leaves==0",
                "solutionTags": [],
                "code": "As the tree grows, the number of open leaves dynamically changes.  we just need to count these leaves.\\n\\nwhen a new node comes,  whether empty or not, it has to attach to some current leaf position, and as the preorder list gets exhausted, there must be no leave positions open (all sealed by '#', thus not open).\\n\\nwe start with 1 leaf position for the root to attach on, and then when there comes a non-empty node, the total open leave positions will increase by 1, and when there is a '#', it decreases the leaf position by 1 as it seals 1 position.  And at any moment, there should be at least 1 open leaf position for the new comer to attach to, until the end.\\n\\n    def isValidSerialization(self, preorder):\\n        preorder=preorder.split(',')\\n        leaves=1\\n        for node in preorder:\\n            if leaves==0:\\n                return False\\n            leaves-=(1 if node=='#' else -1)\\n        return leaves==0",
                "codeTag": "Python3"
            },
            {
                "id": 78735,
                "title": "simple-c-in-4ms-with-comments",
                "content": "    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            if (preorder.empty()) return true;\\n    \\n            int expected_chars = 1;  // root\\n            int next_expected_chars = 0;\\n    \\n            stringstream ss(preorder);\\n            string item;\\n            while (getline(ss, item, ',')) {\\n                if (expected_chars == 0) return false;  // we did not expect any more chars\\n                if (item != \"#\") next_expected_chars += 2;  // any non-null node will require 2 children in the next level\\n                if (--expected_chars == 0) {  // end of level\\n                    expected_chars = next_expected_chars;\\n                    next_expected_chars = 0;\\n                }\\n            }\\n    \\n            // Were we expecting any more chars?\\n            return expected_chars == 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            if (preorder.empty()) return true;\\n    \\n            int expected_chars = 1;  // root\\n            int next_expected_chars = 0;\\n    \\n            stringstream ss(preorder);\\n            string item;\\n            while (getline(ss, item, ',')) {\\n                if (expected_chars == 0) return false;  // we did not expect any more chars\\n                if (item != \"#\") next_expected_chars += 2;  // any non-null node will require 2 children in the next level\\n                if (--expected_chars == 0) {  // end of level\\n                    expected_chars = next_expected_chars;\\n                    next_expected_chars = 0;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78747,
                "title": "my-c-recursive-solution-non-recursive-soluton",
                "content": "Just do recursion. helper here is to check if we can use the characters of preorder starting from cur to build a valid tree (doesn't have to use all the characters). So, if\\n1) the current value is '#', then return true;\\n2) if the current value is not '#\", we have to check if we can use the rest characters to build two valid subtrees\\n\\nAt last, even we can build a valid tree with preorder, we have to check if we use all the characters, if not, still return false;\\n\\n    class Solution {\\n    private:\\n        bool helper(string &preorder, int &cur, int len)\\n        {\\n            if(cur>=len) return false; // if we reach the end of preorder while we need a new node, return false\\n            while(cur<len && preorder[cur]!=',') ++cur; // get the value of the current node, which ends at ','\\n            if(preorder[++cur-2]=='#') return true; // if the current node is null, then return true, and move cur forward to skip ','\\n            if(helper(preorder, cur, len) && helper(preorder, cur, len)) return true; // check if the left subtree and the right subree has valid serialization, if so, return true\\n            else return false;\\n        }\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            int len = preorder.size(), cur=0;\\n            if(len && helper(preorder, cur, len) && cur>len) return true; // we need to check cur>len to make sure all characters are used\\n            return false;\\n        }\\n    };\\n\\nFor non-recursive solution, use numTrees to track how many subtrees we need to construct. If the current node value is '#', then it is an empty tree, so reduce numTrees by 1, otherwise, it is a non-null node, increase numTrees by 1. Quit the outer while loop when either we reach the end of preorder or there is no subtrees to be constructed. Return true only when we use all the characters of preorder to build all the required subtrees.\\n\\n    class Solution {\\n    public:\\n        bool isValidSerialization(string preorder) {\\n            int numTrees  = 1, cur=0, len=preorder.size();\\n            while(cur<len && numTrees>0)\\n            {\\n                while(cur<len && preorder[cur]!=',') ++cur;\\n                if(preorder[++cur-2]=='#') --numTrees;\\n                else ++numTrees;\\n            }\\n            return cur>len && numTrees<=0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    private:\\n        bool helper(string &preorder, int &cur, int len)\\n        {\\n            if(cur>=len) return false; // if we reach the end of preorder while we need a new node, return false\\n            while(cur<len && preorder[cur]!=',') ++cur; // get the value of the current node, which ends at ','\\n            if(preorder[++cur-2]=='#') return true; // if the current node is null, then return true, and move cur forward to skip ','\\n            if(helper(preorder, cur, len) && helper(preorder, cur, len)) return true; // check if the left subtree and the right subree has valid serialization, if so, return true\\n            else return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 78752,
                "title": "8-line-regex-solution-without-building-the-tree",
                "content": "    using System.Text.RegularExpressions;\\n    \\n    public class Solution {\\n        public bool IsValidSerialization(string preorder) {\\n            var t = String.Empty;\\n            var r = new Regex(@\"[0-9]+,\\\\#,\\\\#\", RegexOptions.Compiled);\\n            while (preorder != t)\\n            {\\n                t = preorder;\\n                preorder = r.Replace(preorder, \"#\");\\n            }\\n            \\n            return preorder == \"#\";\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public bool IsValidSerialization(string preorder) {\\n            var t = String.Empty;\\n            var r = new Regex(@\"[0-9]+,\\\\#,\\\\#\", RegexOptions.Compiled);\\n            while (preorder != t)\\n            {\\n                t = preorder;\\n                preorder = r.Replace(preorder, \"#\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3607868,
                "title": "easy-c-soltuion-using-stack",
                "content": "\\n# Approach\\nthe first character of the preorder string is a comma, return false because a valid preorder serialization should not start with a comma.\\nIf the preorder string consists of a single character which is \\'#\\', return true because it represents a valid serialization of an empty tree.\\nInitialize a stack to simulate the construction of the binary tree nodes during the traversal.\\n\\nIterate over the characters in the preorder string:\\n\\nIf a comma is encountered, it indicates the end of a node\\'s value. Push the current temp string representing the node\\'s value onto the stack.\\nIf a character other than a comma is encountered, append it to the temp string.\\nAfter processing each node, check if there are more than two consecutive \\'#\\' symbols on the stack. If so, it means there are two leaf nodes without a parent, which is not a valid serialization. Return false in this case.\\n\\nIf there are three consecutive \\'#\\' symbols on the stack, replace them with a single \\'#\\' symbol to simulate collapsing them into a single leaf node.\\n\\nRepeat steps 4 and 5 until the stack has at most one element.\\n\\nFinally, check if there is exactly one element left on the stack, and if that element is \\'#\\'. If both conditions are true, return true; otherwise, return false.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool isValidSerialization(string preorder) {\\n        if(preorder[0]==\\',\\') return false;\\n        if(preorder[0]==\\'#\\') \\n        {\\n            if(preorder.length()==1)\\n            {\\n                return true;\\n            }    \\n            return false;\\n        }\\n        preorder.push_back(\\',\\');\\n        stack<string>st;\\n        string temp=\"\";\\n        for(int i = 0;i<preorder.length();i++)\\n        {\\n            if(preorder[i]==\\',\\'){\\n            st.push(temp);\\n            while(st.size()>2)\\n            {\\n                string s1=st.top();\\n                st.pop();\\n                string s2=st.top();\\n                st.pop();\\n                string s3=st.top();\\n                st.pop();\\n                if((s1==\"#\" && s2==\"#\" && s3==\"#\"))\\n                {\\n                    return false;\\n                }\\n                if((s1==\"#\" && s2==\"#\" && s3!=\"#\"))\\n                {\\n                    st.push(\"#\");\\n                }\\n                else\\n                {\\n                    st.push(s3);\\n                    st.push(s2);\\n                    st.push(s1);\\n                    break;\\n                }\\n            }\\n            temp.clear();\\n        }\\n        else\\n        {\\n            temp.push_back(preorder[i]);\\n        }\\n    }\\n    return st.size()==1 and st.top()==\"#\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool isValidSerialization(string preorder) {\\n        if(preorder[0]==\\',\\') return false;\\n        if(preorder[0]==\\'#\\') \\n        {\\n            if(preorder.length()==1)\\n            {\\n                return true;\\n            }    \\n            return false;\\n        }\\n        preorder.push_back(\\',\\');\\n        stack<string>st;\\n        string temp=\"\";\\n        for(int i = 0;i<preorder.length();i++)\\n        {\\n            if(preorder[i]==\\',\\'){\\n            st.push(temp);\\n            while(st.size()>2)\\n            {\\n                string s1=st.top();\\n                st.pop();\\n                string s2=st.top();\\n                st.pop();\\n                string s3=st.top();\\n                st.pop();\\n                if((s1==\"#\" && s2==\"#\" && s3==\"#\"))\\n                {\\n                    return false;\\n                }\\n                if((s1==\"#\" && s2==\"#\" && s3!=\"#\"))\\n                {\\n                    st.push(\"#\");\\n                }\\n                else\\n                {\\n                    st.push(s3);\\n                    st.push(s2);\\n                    st.push(s1);\\n                    break;\\n                }\\n            }\\n            temp.clear();\\n        }\\n        else\\n        {\\n            temp.push_back(preorder[i]);\\n        }\\n    }\\n    return st.size()==1 and st.top()==\"#\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2187963,
                "title": "c-solution-easy-to-understand-code-with-explanation-o-n-time-o-1-space",
                "content": "The idea here is to compute the required nodes for a given node.\\nFor 1 non-null node -> required node count = 2 (including null) .\\nFor 1 null node -> no more node is required as it is closing that branch.\\nOur aim to check if we have sufficient node count available at every node.\\n\\nWe start iterating, and ignore all the comma character.\\nWhenever we get a non- null node, we reduce reqirement by 1 and also add +2 because this node will further need 2 more nodes(null/not null) to close\\nIf we get a null node, we simply reduce requirement by one.\\nAlso check if requirement is always non- negative\\nand after complete check, requirements should be 0\\n\\n```\\nbool isValidSerialization(string preorder) {\\n        int n = preorder.size();\\n        int req =1;\\n        for(int i=0;i<n;i++){\\n            if(preorder[i]==\\',\\') continue;\\n            else if(preorder[i]==\\'#\\'){\\n                req--;\\n                if(req<0)  return 0;\\n            }\\n            else{\\n                while(i<n-1 && preorder[i+1]!=\\',\\')i++;\\n                req--;\\n                if(req<0) return 0;\\n                req+=2;\\n            }\\n        }\\n        return req==0 ;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "The idea here is to compute the required nodes for a given node.\\nFor 1 non-null node -> required node count = 2 (including null) .\\nFor 1 null node -> no more node is required as it is closing that branch.\\nOur aim to check if we have sufficient node count available at every node.\\n\\nWe start iterating, and ignore all the comma character.\\nWhenever we get a non- null node, we reduce reqirement by 1 and also add +2 because this node will further need 2 more nodes(null/not null) to close\\nIf we get a null node, we simply reduce requirement by one.\\nAlso check if requirement is always non- negative\\nand after complete check, requirements should be 0\\n\\n```\\nbool isValidSerialization(string preorder) {\\n        int n = preorder.size();\\n        int req =1;\\n        for(int i=0;i<n;i++){\\n            if(preorder[i]==\\',\\') continue;\\n            else if(preorder[i]==\\'#\\'){\\n                req--;\\n                if(req<0)  return 0;\\n            }\\n            else{\\n                while(i<n-1 && preorder[i+1]!=\\',\\')i++;\\n                req--;\\n                if(req<0) return 0;\\n                req+=2;\\n            }\\n        }\\n        return req==0 ;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1760322,
                "title": "c-3ms-solution-with-detailed-exlpanation",
                "content": "![image](https://assets.leetcode.com/users/images/920442e8-2a7c-4a7c-bfe7-00c9728f5748_1644486421.196695.png)\\n\\n```\\nstruct NODE{\\n    int val;\\n    int left = 0;\\n    int right = 0;\\n    NODE(int v){val = v;}\\n};\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder == \"#\") return true;\\n        if(preorder[0] == \\'#\\') return false;\\n        /* Construction of nums array to store node values*/\\n        vector<int> nums;\\n        string node;\\n        for(int i=0; i<preorder.size(); i++){\\n            //encounter a comma\\n            if(preorder[i] == \\',\\'){\\n                //compute the node\\n                if(node == \"#\") {nums.push_back(-1); node = \"\";}\\n                else{\\n                    int number=0;\\n                    for(char &x: node){\\n                        number*=10;\\n                        number+=(int)(x-\\'0\\');\\n                    }\\n                    nums.push_back(number);\\n                    node = \"\";\\n                }\\n                //end of this block\\n            }\\n            else node.push_back(preorder[i]);\\n        }\\n        //compute the last node because we ddn\\'t encounter comma at the end\\n        if(node == \"#\") nums.push_back(-1);\\n        else{\\n            int number=0;\\n            for(char &x: node){\\n                number*=10;\\n                number+=(x-\\'0\\');\\n            }\\n            nums.push_back(number);\\n        }\\n        //end of this block\\n        //for(int &x:nums) cout<<x<<\" \";\\n        /*nums array constructed*/\\n        stack<NODE*> tree; //created a stack to push and pop nodes\\n        NODE* root = new NODE(nums[0]);\\n        tree.push(root); \\n        //first pushed the root with left and right branches 0 indicating that left and right trees haven\\'t completed\\n        for(int i=1; i<nums.size(); i++){\\n            //if both branches become 1...then we have to pop that node from stack\\n            //because the subtree has completed\\n            NODE* top = tree.top();\\n            while(top->left and top->right) {\\n                tree.pop();\\n                if(tree.empty()) return false; //because the stack cannot become empty before we complete our traversal\\n                top = tree.top();\\n                if(!top->left) top->left = 1;\\n                else top->right = 1;\\n            }            \\n            //if we encounter -1\\n            //this means that the child branch has ended\\n            //so we make branch of the top of stack as 1 which was previously 0\\n            if(nums[i] == -1){\\n                if(!top->left) {top->left = 1; continue;}\\n                else {top->right = 1; continue;}\\n            }\\n            \\n            //if we encounter a normal value\\n            //we\\'ll push the node\\n            if(nums[i]>=0){\\n                NODE* newnode = new NODE(nums[i]);\\n                tree.push(newnode);\\n            }\\n        }\\n        NODE* top = tree.top();\\n        while(top->left and top->right) {\\n            tree.pop();\\n            if(tree.empty()) return true; //all the branches were traversed\\n            top = tree.top();\\n            if(!top->left) top->left = 1;\\n            else top->right = 1;\\n        }     \\n        return false; //we couldn\\'t fill up the tree\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstruct NODE{\\n    int val;\\n    int left = 0;\\n    int right = 0;\\n    NODE(int v){val = v;}\\n};\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder == \"#\") return true;\\n        if(preorder[0] == \\'#\\') return false;\\n        /* Construction of nums array to store node values*/\\n        vector<int> nums;\\n        string node;\\n        for(int i=0; i<preorder.size(); i++){\\n            //encounter a comma\\n            if(preorder[i] == \\',\\'){\\n                //compute the node\\n                if(node == \"#\") {nums.push_back(-1); node = \"\";}\\n                else{\\n                    int number=0;\\n                    for(char &x: node){\\n                        number*=10;\\n                        number+=(int)(x-\\'0\\');\\n                    }\\n                    nums.push_back(number);\\n                    node = \"\";\\n                }\\n                //end of this block\\n            }\\n            else node.push_back(preorder[i]);\\n        }\\n        //compute the last node because we ddn\\'t encounter comma at the end\\n        if(node == \"#\") nums.push_back(-1);\\n        else{\\n            int number=0;\\n            for(char &x: node){\\n                number*=10;\\n                number+=(x-\\'0\\');\\n            }\\n            nums.push_back(number);\\n        }\\n        //end of this block\\n        //for(int &x:nums) cout<<x<<\" \";\\n        /*nums array constructed*/\\n        stack<NODE*> tree; //created a stack to push and pop nodes\\n        NODE* root = new NODE(nums[0]);\\n        tree.push(root); \\n        //first pushed the root with left and right branches 0 indicating that left and right trees haven\\'t completed\\n        for(int i=1; i<nums.size(); i++){\\n            //if both branches become 1...then we have to pop that node from stack\\n            //because the subtree has completed\\n            NODE* top = tree.top();\\n            while(top->left and top->right) {\\n                tree.pop();\\n                if(tree.empty()) return false; //because the stack cannot become empty before we complete our traversal\\n                top = tree.top();\\n                if(!top->left) top->left = 1;\\n                else top->right = 1;\\n            }            \\n            //if we encounter -1\\n            //this means that the child branch has ended\\n            //so we make branch of the top of stack as 1 which was previously 0\\n            if(nums[i] == -1){\\n                if(!top->left) {top->left = 1; continue;}\\n                else {top->right = 1; continue;}\\n            }\\n            \\n            //if we encounter a normal value\\n            //we\\'ll push the node\\n            if(nums[i]>=0){\\n                NODE* newnode = new NODE(nums[i]);\\n                tree.push(newnode);\\n            }\\n        }\\n        NODE* top = tree.top();\\n        while(top->left and top->right) {\\n            tree.pop();\\n            if(tree.empty()) return true; //all the branches were traversed\\n            top = tree.top();\\n            if(!top->left) top->left = 1;\\n            else top->right = 1;\\n        }     \\n        return false; //we couldn\\'t fill up the tree\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1522402,
                "title": "java-stack",
                "content": "\\ngiven traversal is preorder means the order will be\\n* root\\n* preorder(left subtree)\\n* preorder(right subtree)\\n    \\nSimilarly we try to find the tree from given traversal by following above pattern.\\nTo do so we can use **stack** here\\n\\n----------------------------------------------------------------------------------------------\\nCreate a node with first value of traversal and add it to stack(here, as of now we haven\\'t filled left and right pointers of this node and we have to keep track of it).\\n\\nIterating through array of traversal \\nif :  value is not null\\nthen\\n* create a node and add it to stack.(here, as of now we haven\\'t filled left and right pointers of this node and we have to keep track of it)\\n* peek node from stack (it will be the root for the first time)\\n* if  : both left and right pointers are filled \\n         then \\n         ->we pop that node out and we keep doing this until we find a node which has been not filled with left or right pointer(while loop)\\n         ->doing so if stack becomes empty then the given traversal is not valid : return false\\n          ->As we are here then it means that there is a valid node that has not been filled with either of let or right pointer\\n          ->check if : left is not filled\\n                   then\\n                        -->create a new new_node\\n                        -->fill it to the node.left\\n                       -->mark that node\\'s left is filled\\n                        -->and push new_node to stack\\n                    else\\n                        -->create a new new_node\\n                        -->fill it to the node.right\\n                        -->mark that node\\'s right is filled\\n                        -->and push new_node to stack\\n                        \\nelse\\n*   the process will be same as above for finding a valid node from stack \\n    or \\n* stack becomes empty doing so then given traversal is invalid : return false\\n   after finding valid node\\n    check\\n        if its left is not filled\\n        then \\n            -->node.left=null\\n            -->mark that node\\'s left is filled\\n        else\\n            -->node.right=null\\n            -->mark that node\\'s right is filled\\n\\t\\t\\t\\n```\\nclass TreeNode{\\n    TreeNode left,right;\\n    String val;\\n    \\n    //to flag that left,right is added or not\\n    boolean l,r;\\n    TreeNode(String val){\\n        this.val=val;\\n        this.left=null;\\n        this.right=null;\\n        this.l=false;\\n        this.r=false;\\n    }\\n}\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        \\n        String arr[]=preorder.split(\",\");\\n        \\n        Stack<TreeNode> stk=new Stack<TreeNode>();\\n        \\n        //base cases\\n        if(arr[0].equals(\"#\")){\\n            if(arr.length==1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }else{\\n            TreeNode node=new TreeNode(arr[0]);\\n            stk.push(node);\\n        }\\n        \\n        for(int i=1;i<arr.length;i++){\\n            \\n            //not possible \\n            if(stk.isEmpty())\\n                return false;\\n            \\n            //considering values and null saperately\\n            //not null\\n            if(!arr[i].equals(\"#\")){\\n                //top of the stack\\n                TreeNode node=stk.peek();\\n                \\n                //if both left and right pointers are added\\n                //then looking for another node and remove this node\\n                while(node.l && node.r){\\n                    //finding other node if stack becomes empty that means \\n                    //given traversal is invalid\\n                    if(!stk.isEmpty()){\\n                        node=stk.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                //if left is pointer is already added then cosider right pointer\\n                if(node.l){\\n                    node.right=new TreeNode(arr[i]);\\n                    node.r=true;//flaggin right of node\\n                    stk.push(node.right);\\n                }else{\\n                    //if node is node added to node then we first add new node left side of current node\\n                    node.left=new TreeNode(arr[i]);\\n                    node.l=true;//flagging left\\n                    stk.push(node.left);\\n                }\\n            }else{\\n                //similar to above but if arr[i] is null then no need to add to stack\\n                TreeNode node=stk.peek();\\n                while(node.l && node.r){\\n                    if(!stk.isEmpty()){\\n                        node=stk.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(node.l){\\n                    node.right=null;\\n                    node.r=true;\\n                }else{\\n                    node.left=null;\\n                    node.l=true;\\n                }\\n            }\\n        }\\n        //lastly checking if all the nodes in stack has been added with left and right then its good otherwise given traversal is not valid.\\n        while(!stk.isEmpty()){\\n            TreeNode node=stk.pop();\\n            if(node.l && node.r)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass TreeNode{\\n    TreeNode left,right;\\n    String val;\\n    \\n    //to flag that left,right is added or not\\n    boolean l,r;\\n    TreeNode(String val){\\n        this.val=val;\\n        this.left=null;\\n        this.right=null;\\n        this.l=false;\\n        this.r=false;\\n    }\\n}\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        \\n        String arr[]=preorder.split(\",\");\\n        \\n        Stack<TreeNode> stk=new Stack<TreeNode>();\\n        \\n        //base cases\\n        if(arr[0].equals(\"#\")){\\n            if(arr.length==1){\\n                return true;\\n            }else{\\n                return false;\\n            }\\n        }else{\\n            TreeNode node=new TreeNode(arr[0]);\\n            stk.push(node);\\n        }\\n        \\n        for(int i=1;i<arr.length;i++){\\n            \\n            //not possible \\n            if(stk.isEmpty())\\n                return false;\\n            \\n            //considering values and null saperately\\n            //not null\\n            if(!arr[i].equals(\"#\")){\\n                //top of the stack\\n                TreeNode node=stk.peek();\\n                \\n                //if both left and right pointers are added\\n                //then looking for another node and remove this node\\n                while(node.l && node.r){\\n                    //finding other node if stack becomes empty that means \\n                    //given traversal is invalid\\n                    if(!stk.isEmpty()){\\n                        node=stk.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                //if left is pointer is already added then cosider right pointer\\n                if(node.l){\\n                    node.right=new TreeNode(arr[i]);\\n                    node.r=true;//flaggin right of node\\n                    stk.push(node.right);\\n                }else{\\n                    //if node is node added to node then we first add new node left side of current node\\n                    node.left=new TreeNode(arr[i]);\\n                    node.l=true;//flagging left\\n                    stk.push(node.left);\\n                }\\n            }else{\\n                //similar to above but if arr[i] is null then no need to add to stack\\n                TreeNode node=stk.peek();\\n                while(node.l && node.r){\\n                    if(!stk.isEmpty()){\\n                        node=stk.pop();\\n                    }else{\\n                        return false;\\n                    }\\n                }\\n                if(node.l){\\n                    node.right=null;\\n                    node.r=true;\\n                }else{\\n                    node.left=null;\\n                    node.l=true;\\n                }\\n            }\\n        }\\n        //lastly checking if all the nodes in stack has been added with left and right then its good otherwise given traversal is not valid.\\n        while(!stk.isEmpty()){\\n            TreeNode node=stk.pop();\\n            if(node.l && node.r)\\n                continue;\\n            else\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458745,
                "title": "using-the-property-of-full-binary-tree-noofleafnodes-no-of-internalnodes-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int internalNodes = 0,leafNodes = 0, n = preorder.length();\\n        for(int i=0;i<n;i++){\\n            if(leafNodes>internalNodes)\\n                return false;\\n            if(preorder[i]==\\'#\\')leafNodes++;\\n            else\\n                internalNodes++;\\n            while(i<n && preorder[i]!=\\',\\')\\n                i++;\\n        }\\n        return (leafNodes==internalNodes+1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int internalNodes = 0,leafNodes = 0, n = preorder.length();\\n        for(int i=0;i<n;i++){\\n            if(leafNodes>internalNodes)\\n                return false;\\n            if(preorder[i]==\\'#\\')leafNodes++;\\n            else\\n                internalNodes++;\\n            while(i<n && preorder[i]!=\\',\\')\\n                i++;\\n        }\\n        return (leafNodes==internalNodes+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428646,
                "title": "c-100-faster-o-n-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string arr) {\\n        int a=0,b=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(b>a)\\n                return false;\\n            if(arr[i]==\\'#\\')\\n                b++;\\n            else\\n                a++;\\n            while(i<arr.size()&&arr[i]!=\\',\\')\\n                i++;\\n        }\\n        return a==b-1;;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string arr) {\\n        int a=0,b=0;\\n        for(int i=0;i<arr.size();i++){\\n            if(b>a)\\n                return false;\\n            if(arr[i]==\\'#\\')\\n                b++;\\n            else\\n                a++;\\n            while(i<arr.size()&&arr[i]!=\\',\\')\\n                i++;\\n        }\\n        return a==b-1;;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427629,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        \\n        int vacancy = 1;\\n        \\n        for(String node : nodes){\\n            // visiting node\\n            vacancy--;\\n            \\n            // checking -ve case\\n            if(vacancy<0) return false;\\n            \\n            // for non null node there is always a chance of two child\\n            if(!node.equals(\"#\")){\\n                vacancy += 2;\\n            }\\n        }\\n        return vacancy == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        \\n        int vacancy = 1;\\n        \\n        for(String node : nodes){\\n            // visiting node\\n            vacancy--;\\n            \\n            // checking -ve case\\n            if(vacancy<0) return false;\\n            \\n            // for non null node there is always a chance of two child\\n            if(!node.equals(\"#\")){\\n                vacancy += 2;\\n            }\\n        }\\n        return vacancy == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427093,
                "title": "very-simple-c-count-of-null-not-null-nodes",
                "content": "**For a valid binary tree `null==notnull+1`\\nVerify using example**\\n\\n```\\nbool isValidSerialization(string pre) {\\n        if(pre[0]==\\'#\\'){  //if root node #\\n            if(pre.size()==1)return true;\\n            return false;\\n        }\\n        int null=0,notnull=0;  // counters for null and notnull nodes\\n        for(int i=0;i<pre.size();i++){\\n            if(pre[i]==\\',\\') continue;  // skip if \\',\\'\\n            else if(pre[i]==\\'#\\')null++;  //incriment null counter if \\'#\\' comes\\n            else{\\n                while(i<pre.size() && pre[i]!=\\',\\')i++;  // for values like \\'65\\' \\n                notnull++;\\n            }\\n            if(null>=notnull+1 && i!=pre.size()-1) return false;  // at every iteration check\\n        }\\n        return null==notnull+1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isValidSerialization(string pre) {\\n        if(pre[0]==\\'#\\'){  //if root node #\\n            if(pre.size()==1)return true;\\n            return false;\\n        }\\n        int null=0,notnull=0;  // counters for null and notnull nodes\\n        for(int i=0;i<pre.size();i++){\\n            if(pre[i]==\\',\\') continue;  // skip if \\',\\'\\n            else if(pre[i]==\\'#\\')null++;  //incriment null counter if \\'#\\' comes\\n            else{\\n                while(i<pre.size() && pre[i]!=\\',\\')i++;  // for values like \\'65\\' \\n                notnull++;\\n            }\\n            if(null>=notnull+1 && i!=pre.size()-1) return false;  // at every iteration check\\n        }\\n        return null==notnull+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1241485,
                "title": "c-simple-4-line-code-4ms",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool isValidSerialization(string p)\\n\\t\\t{\\n\\t\\t\\tint c = 1;\\n\\t\\t\\tfor(int i = 0; i < p.length(); ++i)\\n\\t\\t\\t{if(c <=0)return false; if(p[i] == \\'#\\') --c; else ++c; while(i < p.length() && p[i]!=\\',\\') ++i;}\\n\\t\\t\\treturn (c == 0) ? true : false;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool isValidSerialization(string p)\\n\\t\\t{\\n\\t\\t\\tint c = 1;\\n\\t\\t\\tfor(int i = 0; i < p.length(); ++i)\\n\\t\\t\\t{if(c <=0)return false; if(p[i] == \\'#\\') --c; else ++c; while(i < p.length() && p[i]!=\\',\\') ++i;}",
                "codeTag": "Java"
            },
            {
                "id": 1220277,
                "title": "using-the-fact-that-there-are-n-1-nodes-and-n-1-null-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int count = 0;\\n        int n = preorder.length();\\n        int i = 0;\\n        for (;i<n;i++)\\n        {\\n            if(preorder[i] == \\',\\')\\n                continue;\\n            if(count<0)\\n                return false;\\n            if(preorder[i] == \\'#\\')\\n                count--;\\n            else\\n            {\\n                while(i<preorder.length() && preorder[i] != \\',\\')\\n                {\\n                    i++;\\n                }\\n                    count++;\\n                \\n            }\\n        }\\n        if(count == -1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int count = 0;\\n        int n = preorder.length();\\n        int i = 0;\\n        for (;i<n;i++)\\n        {\\n            if(preorder[i] == \\',\\')\\n                continue;\\n            if(count<0)\\n                return false;\\n            if(preorder[i] == \\'#\\')\\n                count--;\\n            else\\n            {\\n                while(i<preorder.length() && preorder[i] != \\',\\')\\n                {\\n                    i++;\\n                }\\n                    count++;\\n                \\n            }\\n        }\\n        if(count == -1)\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 790197,
                "title": "python3-image-water-flowing-through-the-tree",
                "content": "Approach 1 - outlet \\nThink of the tree as water pipeline. Initially, there is one inlet toward the root. By adding an inner node, an extra outlet is introduced in a binary tree (+1). By adding a leaf node, a possible outlet is blocked (-1). \\n\\nSo the problem becomes to check if inlet and outlet are balancing. Given there was an initialy inlet (which requires 1 outlet) and each inner node introduces an extra outlet, `1 + inner` leaf nodes are required for the balance. Of course, end result alone is not enough. One also need to check the intermediate state. Namely, at any state before the end, one would require positive number of outlets. \\n\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        outlet = 1\\n        for x in preorder.split(\",\"): \\n            if outlet == 0: return False #intermediate \\n            outlet += 1 if x != \"#\" else -1\\n        return outlet == 0  #end result \\n```\\n\\nApproach 2 - reconstruction \\nAlternatively, one could somewhat reconstruct the tree via a stack. \\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        for n in preorder.split(\",\"):\\n            stack.append(n)\\n            while stack[-2:] == [\"#\", \"#\"]: \\n                stack.pop()\\n                stack.pop()\\n                if not stack: return False \\n                stack[-1] = \"#\"\\n        return stack == [\"#\"]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        outlet = 1\\n        for x in preorder.split(\",\"): \\n            if outlet == 0: return False #intermediate \\n            outlet += 1 if x != \"#\" else -1\\n        return outlet == 0  #end result \\n```\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        stack = []\\n        for n in preorder.split(\",\"):\\n            stack.append(n)\\n            while stack[-2:] == [\"#\", \"#\"]: \\n                stack.pop()\\n                stack.pop()\\n                if not stack: return False \\n                stack[-1] = \"#\"\\n        return stack == [\"#\"]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 775591,
                "title": "javascript-clean-dfs-solution",
                "content": "```javascript\\nvar isValidSerialization = function(preorder) {\\n    const arr = preorder.split(\\',\\');\\n    let i = 0;\\n    \\n    function callDFS() {\\n        if(i >= arr.length) return false;        \\n        if(arr[i++] === \\'#\\') return true;\\n        return callDFS() && callDFS();\\n    }\\n    return callDFS() && i == arr.length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```javascript\\nvar isValidSerialization = function(preorder) {\\n    const arr = preorder.split(\\',\\');\\n    let i = 0;\\n    \\n    function callDFS() {\\n        if(i >= arr.length) return false;        \\n        if(arr[i++] === \\'#\\') return true;\\n        return callDFS() && callDFS();\\n    }\\n    return callDFS() && i == arr.length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 699135,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        ## RC ##\\n\\t\\t## APPROACH : GREEDY ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. we start with root node, so slots = 1\\n\\t\\t#\\t2. Each node consumes 1 slot and adds 2 slots so. -1 + 2\\n\\t\\t#\\t3. Null node consumes 1 slot\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        nodes = 1\\n        for node in preorder.split(\\',\\'):\\n            nodes -= 1\\n            if nodes < 0:\\n                return False\\n            if node != \\'#\\':\\n                nodes += 2\\n        return nodes == 0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        ## RC ##\\n\\t\\t## APPROACH : GREEDY ##\\n\\t\\t## LOGIC ##\\n\\t\\t#\\t1. we start with root node, so slots = 1\\n\\t\\t#\\t2. Each node consumes 1 slot and adds 2 slots so. -1 + 2\\n\\t\\t#\\t3. Null node consumes 1 slot\\n\\t\\t## TIME COMPLEXICITY : O(N) ##\\n\\t\\t## SPACE COMPLEXICITY : O(1) ##\\n        \\n        nodes = 1\\n        for node in preorder.split(\\',\\'):\\n            nodes -= 1\\n            if nodes < 0:\\n                return False\\n            if node != \\'#\\':\\n                nodes += 2\\n        return nodes == 0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 151069,
                "title": "java-stack-implementation-check-preorder-traversal-check-bst-validation",
                "content": "* the preorder sequence is the dfs sequence. \\n* In dfs, each non-null node, visited exactly 3 times (null node just 1 time). 1 from inserting into stack, the other 2 from backtracking from two children. \\n* Thus, if we can keep tracking the visiting count for each node, we will have:\\n\\t* if count[index] == 1 // just visit this node and insert into stack\\n\\t* if count[index] == 2 // backtracking from left child (we can also **check left < root for BST validation**)\\n\\t* if count[index] == 3 // backtracking from right child (we can also **check right > root for BST validation**)\\n\\n```\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int n = nodes.length;\\n        int[] count = new int[n]; // record visited times\\n        Stack<Integer> stack = new Stack<Integer>(); // keep curt dfs visiting nodes\\' index\\n        \\n        int i = 0;\\n        if(!nodes[i].equals(\"#\")) stack.push(i); // check if the tree is only \"#\"\\n        count[i]++;\\n        \\n        while(!stack.isEmpty() && i != n - 1 && count[stack.peek()] < 3) {\\n            i++;\\n            stack.push(i);\\n            count[i]++;\\n            while(!stack.isEmpty() && (nodes[stack.peek()].equals(\"#\") || count[stack.peek()] == 3)) { \\n                int childIndex = stack.pop();\\n                if(!stack.isEmpty()) {\\n                \\tcount[stack.peek()]++; // backtracking to parent, count +1\\n                \\tif(count[stack.peek()] == 2 && !nodes[childIndex].equals(\"#\")) {\\n                \\t\\tif(Integer.parseInt(nodes[childIndex]) > Integer.parseInt(nodes[stack.peek()])) {\\n                \\t\\t\\treturn false;\\n                \\t\\t}\\n                \\t}\\n                \\tif(count[stack.peek()] == 3 && !nodes[childIndex].equals(\"#\")) {\\n                \\t\\tif(Integer.parseInt(nodes[childIndex]) < Integer.parseInt(nodes[stack.peek()])) {\\n                \\t\\t\\treturn false;\\n                \\t\\t}\\n                \\t}\\n                }\\n            }\\n        }\\n        \\n        if(i == n - 1 && stack.isEmpty()) return true;\\n        else return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        int n = nodes.length;\\n        int[] count = new int[n]; // record visited times\\n        Stack<Integer> stack = new Stack<Integer>(); // keep curt dfs visiting nodes\\' index\\n        \\n        int i = 0;\\n        if(!nodes[i].equals(\"#\")) stack.push(i); // check if the tree is only \"#\"\\n        count[i]++;\\n        \\n        while(!stack.isEmpty() && i != n - 1 && count[stack.peek()] < 3) {\\n            i++;\\n            stack.push(i);\\n            count[i]++;\\n            while(!stack.isEmpty() && (nodes[stack.peek()].equals(\"#\") || count[stack.peek()] == 3)) { \\n                int childIndex = stack.pop();\\n                if(!stack.isEmpty()) {\\n                \\tcount[stack.peek()]++; // backtracking to parent, count +1\\n                \\tif(count[stack.peek()] == 2 && !nodes[childIndex].equals(\"#\")) {\\n                \\t\\tif(Integer.parseInt(nodes[childIndex]) > Integer.parseInt(nodes[stack.peek()])) {\\n                \\t\\t\\treturn false;\\n                \\t\\t}\\n                \\t}\\n                \\tif(count[stack.peek()] == 3 && !nodes[childIndex].equals(\"#\")) {\\n                \\t\\tif(Integer.parseInt(nodes[childIndex]) < Integer.parseInt(nodes[stack.peek()])) {\\n                \\t\\t\\treturn false;\\n                \\t\\t}\\n                \\t}\\n                }\\n            }\\n        }\\n        \\n        if(i == n - 1 && stack.isEmpty()) return true;\\n        else return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78553,
                "title": "c-3ms-o-1-space-o-n-time-with-stringstream",
                "content": "A tree with one value has 1 non null node and 2 null nodes. Whenever you add a node, you replace a null node with a non null node, then you add two null nodes to your new node, for a net difference between non null and null nodes per node insertion is 0. \\n\\nThe tree with one value had 1 more null than non null, so any valid tree must also have 1 more null than non null. Additionally, the final node of the pre order must be null no matter what. If it isn't then that means there are more nodes, which means its not the final node. This means that before reaching the final node, there must always be equal amounts of non nulls and nulls. \\n\\nIf we consider adding a non null node to be +1 and adding a non null to be -1, the final tree must have a balance of -1. Because non null nodes are added before the null nodes are, the balance of the tree should never go negative until the final node is reached. \\n\\nThis code uses stringstream to iterate through the values and continuously adds to the balance of the tree. If the balance goes negative, it breaks and returns true only if the end of the serialization was reached. It also returns false if the balance is not -1 even if the end of the serialization was reached. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int bal = 0;\\n        stringstream ss(preorder);\\n        string val;\\n        while(getline(ss,val,',')){\\n            bal += val == \"#\" ? -1 : 1;\\n            if (bal < 0) break;\\n        }\\n        string check;\\n        return bal == -1 && !(bool)getline(ss,check,',');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int bal = 0;\\n        stringstream ss(preorder);\\n        string val;\\n        while(getline(ss,val,',')){\\n            bal += val == \"#\" ? -1 : 1;\\n            if (bal < 0) break;\\n        }\\n        string check;\\n        return bal == -1 && !(bool)getline(ss,check,',');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78557,
                "title": "6ms-c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder == \"#\") return true;\\n        stringstream ss(preorder);\\n        stack<int>stk;\\n        string s = \"\";\\n        while(getline(ss, s, ',')){\\n            if(s == \"#\" && stk.empty()) return false;\\n            if(!stk.empty()) stk.top()++;\\n            if(!stk.empty() && stk.top() == 2) stk.pop();\\n            if(s != \"#\") stk.push(0);\\n            if(stk.empty() && !ss.eof()) return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder == \"#\") return true;\\n        stringstream ss(preorder);\\n        stack<int>stk;\\n        string s = \"\";\\n        while(getline(ss, s, ',')){\\n            if(s == \"#\" && stk.empty()) return false;\\n            if(!stk.empty()) stk.top()++;\\n            if(!stk.empty() && stk.top() == 2) stk.pop();\\n            if(s != \"#\") stk.push(0);\\n            if(stk.empty() && !ss.eof()) return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78614,
                "title": "c-recursive-check-every-node-has-a-left-and-right",
                "content": "    public bool IsValidSerialization(string preorder) \\n    {\\n        string[] nodes = preorder.Split(new char[] { ',' });\\n        int index = 0;\\n        return HasLeftAndRight(nodes, ref index) && index == nodes.Length - 1;\\n    }\\n    \\n    public bool HasLeftAndRight(string[] nodes, ref int index)\\n    {\\n        if (index >= nodes.Length) return false;\\n        if (nodes[index] == \"#\") return true;\\n        index += 1;\\n        bool hasLeft = HasLeftAndRight(nodes, ref index);\\n        index += 1;\\n        bool hasRight = HasLeftAndRight(nodes, ref index);\\n        return hasLeft && hasRight;\\n    }",
                "solutionTags": [],
                "code": "    public bool IsValidSerialization(string preorder) \\n    {\\n        string[] nodes = preorder.Split(new char[] { ',' });\\n        int index = 0;\\n        return HasLeftAndRight(nodes, ref index) && index == nodes.Length - 1;\\n    }\\n    \\n    public bool HasLeftAndRight(string[] nodes, ref int index)\\n    {\\n        if (index >= nodes.Length) return false;\\n        if (nodes[index] == \"#\") return true;\\n        index += 1;\\n        bool hasLeft = HasLeftAndRight(nodes, ref index);\\n        index += 1;\\n        bool hasRight = HasLeftAndRight(nodes, ref index);\\n        return hasLeft && hasRight;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78658,
                "title": "just-string-problem-8-lines-and-4-ms-this-c-code-is-very-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n    \\tbool isValidSerialization(string preorder) {\\n    \\t\\tint i, nul = 0, node = 1;\\n    \\t\\tfor (i = 0; i < preorder.length(); ++i){\\n    \\t\\t\\tif (preorder[i] == ',')node++;\\n    \\t\\t\\tif (preorder[i] == '#')nul++;\\n    \\t\\t\\tif (2 * nul == node + 1 && i != preorder.length() - 1)return false;\\n    \\t\\t}\\n    \\t\\treturn 2 * nul == node + 1;\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tbool isValidSerialization(string preorder) {\\n    \\t\\tint i, nul = 0, node = 1;\\n    \\t\\tfor (i = 0; i < preorder.length(); ++i){\\n    \\t\\t\\tif (preorder[i] == ',')node++;\\n    \\t\\t\\tif (preorder[i] == '#')nul++;\\n    \\t\\t\\tif (2 * nul == node + 1 && i != preorder.length() - 1)return false;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 78671,
                "title": "very-intuitive-java-solution",
                "content": "    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < strs.length; i++) {\\n            stack.push(strs[i]);\\n            if (stack.size() >= 3) {\\n                if(!helper(stack)) return false;\\n            }\\n        }\\n        return stack.size() == 1 && stack.peek().equals(\"#\");\\n    }\\n    \\n    private boolean helper(Stack<String> stack) {\\n        String top = stack.pop();\\n        String second = stack.peek();\\n        stack.push(top);\\n        while (!stack.isEmpty() && stack.peek().equals(\"#\") && second.equals(\"#\")) {\\n            stack.pop(); // first #\\n            stack.pop(); // second #\\n            if(stack.peek().equals(\"#\")) {\\n                return false; // \"#, #, #\"\\n            } else {\\n                stack.pop(); // pop a number\\n                if(stack.size() >= 2) {\\n                    second = stack.peek();\\n                    stack.push(\"#\");\\n                } else {\\n                    stack.push(\"#\");\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "    public boolean isValidSerialization(String preorder) {\\n        String[] strs = preorder.split(\",\");\\n        Stack<String> stack = new Stack<>();\\n        for(int i = 0; i < strs.length; i++) {\\n            stack.push(strs[i]);\\n            if (stack.size() >= 3) {\\n                if(!helper(stack)) return false;\\n            }\\n        }\\n        return stack.size() == 1 && stack.peek().equals(\"#\");\\n    }\\n    \\n    private boolean helper(Stack<String> stack) {\\n        String top = stack.pop();\\n        String second = stack.peek();\\n        stack.push(top);\\n        while (!stack.isEmpty() && stack.peek().equals(\"#\") && second.equals(\"#\")) {\\n            stack.pop(); // first #\\n            stack.pop(); // second #\\n            if(stack.peek().equals(\"#\")) {\\n                return false; // \"#, #, #\"\\n            } else {\\n                stack.pop(); // pop a number\\n                if(stack.size() >= 2) {\\n                    second = stack.peek();\\n                    stack.push(\"#\");\\n                } else {\\n                    stack.push(\"#\");\\n                    break;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78697,
                "title": "easy-java-recursive-solution-just-follow-what-preorder-does",
                "content": "Version 2: without global variable:\\n\\n    public class Solution {\\n    \\tpublic boolean isValidSerialization(String preorder) {\\n    \\t\\tint[] pos = new int[]{-1};\\n    \\t\\tString[] s = preorder.split(\",\");\\n    \\t\\treturn isValid(s, pos) && pos[0] == s.length - 1;\\n        }\\n    \\tprivate boolean isValid(String[] s, int[] pos){\\n            if (++pos[0]>= s.length) return false;\\n            if (s[pos[0]].equals(\"#\")) return true;        \\t\\n    \\t\\t//verify left and right node\\n            return isValid(s, pos) && isValid(s, pos);\\n    \\t}\\n    }\\n\\n\\nOriginal version below:\\n\\nThe idea is to verify the root, the left and right. I am still learning java, let me know if this can be improved.\\n\\n    public class Solution {\\n    \\tint pos = -1;\\n    \\tpublic boolean isValidSerialization(String preorder) {\\n    \\t\\tString[] s = preorder.split(\",\");\\n    \\t\\treturn isValid(s) && pos == s.length - 1;\\n        }\\n    \\tprivate boolean isValid(String[] s){\\n            if (++pos >= s.length) return false;\\n            if (s[pos].equals(\"#\")) return true;\\n\\t\\t\\t//verify left and right node\\n            return isValid(s) && isValid(s);\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    \\tpublic boolean isValidSerialization(String preorder) {\\n    \\t\\tint[] pos = new int[]{-1}",
                "codeTag": "Java"
            },
            {
                "id": 78750,
                "title": "simple-11-lines-python-solution",
                "content": "    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            def isValid(it):\\n                value = next(it, None)\\n                if value == None: return False\\n                if value != \"#\":\\n                    return isValid(it) and isValid(it) \\n                return True\\n                \\n            it = iter(preorder.split(\",\"))\\n            return isValid(it) and next(it, None) == None\\nA valid preorder traversal of a unique structured tree should have exact amount of nodes (including null pointers) to reconstruct the tree.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def isValidSerialization(self, preorder):\\n            def isValid(it):\\n                value = next(it, None)\\n                if value == None: return False\\n                if value != \"#\":\\n                    return isValid(it) and isValid(it) \\n                return True\\n                \\n            it = iter(preorder.split(\",\"))\\n            return isValid(it) and next(it, None) == None\\nA valid preorder traversal of a unique structured tree should have exact amount of nodes (including null pointers) to reconstruct the tree.",
                "codeTag": "Java"
            },
            {
                "id": 78756,
                "title": "simple-recursive-solution-easy-to-understand",
                "content": "Basically we simulate the preorder traversal in the recursive way while moving along on the string tokens. After the traversal is done, if we also exhaust the tokens, no more no less, then it is a valid serialization.\\n\\n    public class Solution {\\n        int reach(String[] tokens, int start) {\\n            if (start >= tokens.length) return -1;\\n            if (tokens[start].equals(\"#\")) return start+1;\\n            int rl = reach(tokens, start+1);\\n            if (rl < 0) return -1;\\n            return reach(tokens, rl);\\n        }\\n        public boolean isValidSerialization(String preorder) {\\n            String[] tokens = preorder.split(\",\");\\n            return reach(tokens, 0) == tokens.length;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        int reach(String[] tokens, int start) {\\n            if (start >= tokens.length) return -1;\\n            if (tokens[start].equals(\"#\")) return start+1;\\n            int rl = reach(tokens, start+1);\\n            if (rl < 0) return -1;\\n            return reach(tokens, rl);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 78763,
                "title": "share-my-10-line-java-solution-with-explanation",
                "content": "If we think about the iterative approach of pre-order traversing a binary tree, whose halting condition is \"stack.isEmpty() && currentNode==null\", which means \"you have done everything && now you have nothing to do\" -- a valid pre-order sequence should comply with this.\\n\\n1. If we meet \"#\", which means current root (the element at stack top)'s left subtree is done, we should pop this root (--stackSize) and go on traversing its right subtree. If no such root (stackSize == 0), we should stop and check whether we have traversed the entire tree (p == seq.length-1), or we are given an invalid sequence (there are still nodes we have not visited, that is p < seq.length-1).\\n\\n2. If we meet \"some integer\", it means we are visiting current root and should push it into our stack (++stackSize) and move on to its left subtree. \\n\\n\\n----------\\n\\n\\n    public class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            String[] seq = preorder.split(\",\");\\n            int stackSize = 0, p = 0;\\n            for (; p<seq.length; ++p) {\\n                if (seq[p].equals(\"#\")) { \\n                    if (stackSize == 0) { break; } \\n                    --stackSize;\\n                }\\n                else { ++stackSize; }\\n            }\\n            return stackSize==0 && p==seq.length-1;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean isValidSerialization(String preorder) {\\n            String[] seq = preorder.split(\",\");\\n            int stackSize = 0, p = 0;\\n            for (; p<seq.length; ++p) {\\n                if (seq[p].equals(\"#\")) { \\n                    if (stackSize == 0) { break; }",
                "codeTag": "Java"
            },
            {
                "id": 3598349,
                "title": "c-short-concise",
                "content": "```c++\\nbool isValidSerialization(string preorder) {\\n    int degree = 1;\\n    stringstream ss(preorder);\\n    for (string temp; getline(ss, temp, \\',\\');) {\\n        degree--;\\n        if (degree < 0) return false;\\n        if (temp.back() != \\'#\\') degree += 2;\\n    }\\n    return !degree;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nbool isValidSerialization(string preorder) {\\n    int degree = 1;\\n    stringstream ss(preorder);\\n    for (string temp; getline(ss, temp, \\',\\');) {\\n        degree--;\\n        if (degree < 0) return false;\\n        if (temp.back() != \\'#\\') degree += 2;\\n    }\\n    return !degree;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343335,
                "title": "easy-understanding-java-solution-tree-only-traverse",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[]nodes = preorder.split(\",\");\\n\\n        int dif=1;\\n        for(String node:nodes){\\n         if(--dif<0) return false;\\n         if(!node.equals(\"#\")) dif+=2;\\n        }\\n        return dif==0;\\n    }\\n}\\n``` \" UPVOTE IF YOU LIKE THIS SOLUTION!!!\"",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[]nodes = preorder.split(\",\");\\n\\n        int dif=1;\\n        for(String node:nodes){\\n         if(--dif<0) return false;\\n         if(!node.equals(\"#\")) dif+=2;\\n        }\\n        return dif==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3262292,
                "title": "intutive-beginner-friendly-solution-without-stringstream-and-getline-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n     preorder+=\",\";\\n     vector<string> arr;\\n     int n=preorder.size();\\n     \\n    int i=0;\\n    while(i<n)\\n    {\\n        string p=\"\";\\n        while(preorder[i]!=\\',\\')\\n        {\\n            p+=preorder[i];\\n            i++;\\n        }\\n        arr.push_back(p);\\n        i++;\\n    }\\n\\n\\n\\n     for(auto i:arr) cout<<i<<\" \";\\n     stack<string> st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string p=arr[i];\\n            \\n            if(st.empty() || p!=\"#\") st.push(p);\\n            else\\n            {\\n                while(!st.empty() && st.top()==\"#\")\\n                {\\n                    st.pop();\\n                    if(st.empty()) return false;\\n                     else\\n                      st.pop();\\n                }\\n                st.push(p);\\n            }\\n        }\\n        return st.size() == 1 && st.top() == \"#\";\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n     preorder+=\",\";\\n     vector<string> arr;\\n     int n=preorder.size();\\n     \\n    int i=0;\\n    while(i<n)\\n    {\\n        string p=\"\";\\n        while(preorder[i]!=\\',\\')\\n        {\\n            p+=preorder[i];\\n            i++;\\n        }\\n        arr.push_back(p);\\n        i++;\\n    }\\n\\n\\n\\n     for(auto i:arr) cout<<i<<\" \";\\n     stack<string> st;\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            string p=arr[i];\\n            \\n            if(st.empty() || p!=\"#\") st.push(p);\\n            else\\n            {\\n                while(!st.empty() && st.top()==\"#\")\\n                {\\n                    st.pop();\\n                    if(st.empty()) return false;\\n                     else\\n                      st.pop();\\n                }\\n                st.push(p);\\n            }\\n        }\\n        return st.size() == 1 && st.top() == \"#\";\\n    }\\n        \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3256601,
                "title": "easy-java-solution-using-stack",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        return preorder(preorder, 0);\\n    }\\n\\n    public boolean preorder(String s, int index){\\n        String[] str= s.split(\",\");\\n        Stack<String> s1= new Stack<>();\\n\\n        for(int i=0; i<str.length; i++){\\n            if(str[i].equals(\"#\") == false){\\n                s1.push(str[i]);\\n            }\\n            else{\\n                if(s1.size() > 0 && s1.peek() == \"#\"){\\n                    s1.pop();   //  \"#\" removed\\n                    if(s1.size() > 0){\\n                        s1.pop();   //  number removed\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                    i--;\\n                }\\n                else{\\n                    s1.push(\"#\");\\n                }\\n            }\\n        }\\n\\n        if(s1.size() == 1 && s1.peek() == \"#\"){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```\\n![please-upvote.jpg](https://assets.leetcode.com/users/images/678e9287-6deb-49aa-92a1-9b2e48837806_1677948214.6646483.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        return preorder(preorder, 0);\\n    }\\n\\n    public boolean preorder(String s, int index){\\n        String[] str= s.split(\",\");\\n        Stack<String> s1= new Stack<>();\\n\\n        for(int i=0; i<str.length; i++){\\n            if(str[i].equals(\"#\") == false){\\n                s1.push(str[i]);\\n            }\\n            else{\\n                if(s1.size() > 0 && s1.peek() == \"#\"){\\n                    s1.pop();   //  \"#\" removed\\n                    if(s1.size() > 0){\\n                        s1.pop();   //  number removed\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                    i--;\\n                }\\n                else{\\n                    s1.push(\"#\");\\n                }\\n            }\\n        }\\n\\n        if(s1.size() == 1 && s1.peek() == \"#\"){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507869,
                "title": "smallest-solution-o-1-memory-iterative-appraoch",
                "content": "Every parent node will create 2 spaces for its child node & consume 1 space for itself.\\nEvery leaf node \\'#\\' will create 0 spaces but consume 1 space for itself.\\n\\nConclusion : Every non leaf node increases the length of the total space by 1 where as leaf node reduces the total space by 1.\\nSo in the end we should left with 0 spaces, whereas at the time of traversal we should atleast have one space to bring other nodes into consideration.\\n\\nImplementation : \\n\\n```\\npublic class Solution {\\n    public bool IsValidSerialization(string preorder) {\\n        var nodeArray = preorder.Split(\\',\\');\\n        int nodeSpace = 1;\\n        for(int i = 0; i<nodeArray.Length; i++){\\n            if(nodeSpace == 0)\\n                return false;\\n            \\n            nodeSpace += nodeArray[i] == \"#\" ? -1 : 1;\\n        }\\n        return nodeSpace == 0;\\n    }  \\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsValidSerialization(string preorder) {\\n        var nodeArray = preorder.Split(\\',\\');\\n        int nodeSpace = 1;\\n        for(int i = 0; i<nodeArray.Length; i++){\\n            if(nodeSpace == 0)\\n                return false;\\n            \\n            nodeSpace += nodeArray[i] == \"#\" ? -1 : 1;\\n        }\\n        return nodeSpace == 0;\\n    }  \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496149,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        a=preorder.split(\\',\\')\\n        c=1\\n        for i in range(len(a)):\\n             if not c:\\n                return False\\n             c-=\\' #\\'.find(a[i])  \\n        return not c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        a=preorder.split(\\',\\')\\n        c=1\\n        for i in range(len(a)):\\n             if not c:\\n                return False\\n             c-=\\' #\\'.find(a[i])  \\n        return not c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414273,
                "title": "c-one-pass-beat-100",
                "content": "At first there is one empty position. If we add one \\'#\\' null node we have one less empty position, if we add one number we have one more empty position (1 empty position changed to two so there is one more empty position). \\n\\nThe string is valid if we always have empty position before the end of string, AND there is no empty position at the end.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int empty = 1, t = 0, n = s.size();\\n        while (t < n) {\\n            if (s[t] == \\',\\') t++;\\n            empty += (s[t] == \\'#\\') ? -1 : 1;\\n            while (t < n && s[t] != \\',\\') t++;  \\n            if (empty == 0 && t < n) return false;\\n        }\\n        return empty==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int empty = 1, t = 0, n = s.size();\\n        while (t < n) {\\n            if (s[t] == \\',\\') t++;\\n            empty += (s[t] == \\'#\\') ? -1 : 1;\\n            while (t < n && s[t] != \\',\\') t++;  \\n            if (empty == 0 && t < n) return false;\\n        }\\n        return empty==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2395817,
                "title": "easy-recursive-0ms-solution-100-faster",
                "content": "Serialization can be checked by following simple recursive approach:\\n1. We maintain a global index (idx) of the array.\\n2. We check for that index, if it is a number\\n    (we have to take the complete number at a time \"100\" goes in three indexes, check code for clarification)\\n3. if Number , increment idx accordingly and go check for its left and right, if \\'#\\' we increment idx to next position BUT return true!!\\n4. we are only going left and right, if there is a number!!, so if at any point we go out of index we return FALSE, because we were sent by some root , so it is either root\\'s left or root\\'s right child ; which should either be a number or \"#\".\\n```\\nclass Solution {\\npublic:\\n    bool rec(string &preorder, int &idx){\\n        if(idx>=preorder.size()) return false;\\n        else if(preorder[idx]==\\'#\\'){\\n            idx+=2;\\n            return true;\\n        }\\n        else{\\n            if(idx+1<preorder.size() && preorder[idx+1]!=\\'#\\' && preorder[idx+1]!=\\',\\') idx+=1;\\n            if(idx+1<preorder.size() && preorder[idx+1]!=\\'#\\' && preorder[idx+1]!=\\',\\') idx+=1;\\n            idx+=2;\\n            if(rec(preorder,idx)==false) return false;\\n            if(rec(preorder,idx)==false) return false;\\n            return true;\\n        }\\n    }\\n    bool isValidSerialization(string preorder) {\\n        int idx=0;\\n        bool ans= rec(preorder,idx)&&(idx>=preorder.size());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool rec(string &preorder, int &idx){\\n        if(idx>=preorder.size()) return false;\\n        else if(preorder[idx]==\\'#\\'){\\n            idx+=2;\\n            return true;\\n        }\\n        else{\\n            if(idx+1<preorder.size() && preorder[idx+1]!=\\'#\\' && preorder[idx+1]!=\\',\\') idx+=1;\\n            if(idx+1<preorder.size() && preorder[idx+1]!=\\'#\\' && preorder[idx+1]!=\\',\\') idx+=1;\\n            idx+=2;\\n            if(rec(preorder,idx)==false) return false;\\n            if(rec(preorder,idx)==false) return false;\\n            return true;\\n        }\\n    }\\n    bool isValidSerialization(string preorder) {\\n        int idx=0;\\n        bool ans= rec(preorder,idx)&&(idx>=preorder.size());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364811,
                "title": "c-using-stringstream",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream s(preorder);\\n        string str;\\n        int slots=1;\\n        while(getline(s, str, \\',\\')) {\\n            if(slots==0) return 0;\\n            if(str==\"#\") slots--;\\n            else slots++;\\n        }\\n        return slots==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream s(preorder);\\n        string str;\\n        int slots=1;\\n        while(getline(s, str, \\',\\')) {\\n            if(slots==0) return 0;\\n            if(str==\"#\") slots--;\\n            else slots++;\\n        }\\n        return slots==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364283,
                "title": "c-two-approaches-detailed-explanation",
                "content": "**Approach 1:** \\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string item;\\n\\t\\t\\n        // slots store no.of free slots available to add nodes into the tree\\n        // Initially we can allow root to add into the tree\\n        int slots = 1;\\n\\t\\t\\n        while(getline(ss, item, \\',\\')){\\n            // No free slots to add the current node into tree\\n            if(slots == 0){\\n                return false;\\n            }\\n            // Decrease the no.of free slots available as we add current node  \\n            slots--;\\n            // If node is not NULL then we can allow 2 more slots for its children\\n            if(item != \"#\"){\\n                slots += 2;\\n            } \\n        }\\n\\t\\t// If slots > 0, that means there are nodes with no children assinged to them. Hence, return false\\n        return slots == 0;\\n    }  \\n};\\n```\\n**Approach 2:**\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string item;\\n\\t\\t// Store all the nodes in the queue\\n        queue<string> q;\\n        while(getline(ss, item, \\',\\')){\\n            q.push(item);\\n        }\\n        string root = q.front(); q.pop();\\n\\t\\t\\n\\t\\t// Root is NULL but there are children which is not possible\\n        if(root == \"#\") return q.size()==0;\\n\\t\\t\\n\\t\\t// Processed all children but the queue is not empty\\n\\t\\t// Ex: [9,#,#,1] -> After processing queue will still contain 1\\n        return helper(root, q) && q.size()==0;\\n    }\\n    \\n    bool helper(string root, queue<string> &q){\\n\\t\\t// Root is not NULL but has less than two children\\n        if(root != \"#\" && q.size() < 2){\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t// Storing two children in left and right\\n        string left = q.front(); q.pop();\\n        string right = q.front(); q.pop();\\n        bool flag = true;\\n\\t\\t\\n\\t\\t// If not NULL, process children nodes\\n        if(left != \"#\") flag = flag && helper(left, q);\\n        if(right != \"#\") flag = flag && helper(right, q);\\n        \\n        return flag;\\n    }\\n};\\n```\\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string item;\\n\\t\\t\\n        // slots store no.of free slots available to add nodes into the tree\\n        // Initially we can allow root to add into the tree\\n        int slots = 1;\\n\\t\\t\\n        while(getline(ss, item, \\',\\')){\\n            // No free slots to add the current node into tree\\n            if(slots == 0){\\n                return false;\\n            }\\n            // Decrease the no.of free slots available as we add current node  \\n            slots--;\\n            // If node is not NULL then we can allow 2 more slots for its children\\n            if(item != \"#\"){\\n                slots += 2;\\n            } \\n        }\\n\\t\\t// If slots > 0, that means there are nodes with no children assinged to them. Hence, return false\\n        return slots == 0;\\n    }  \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string item;\\n\\t\\t// Store all the nodes in the queue\\n        queue<string> q;\\n        while(getline(ss, item, \\',\\')){\\n            q.push(item);\\n        }\\n        string root = q.front(); q.pop();\\n\\t\\t\\n\\t\\t// Root is NULL but there are children which is not possible\\n        if(root == \"#\") return q.size()==0;\\n\\t\\t\\n\\t\\t// Processed all children but the queue is not empty\\n\\t\\t// Ex: [9,#,#,1] -> After processing queue will still contain 1\\n        return helper(root, q) && q.size()==0;\\n    }\\n    \\n    bool helper(string root, queue<string> &q){\\n\\t\\t// Root is not NULL but has less than two children\\n        if(root != \"#\" && q.size() < 2){\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t// Storing two children in left and right\\n        string left = q.front(); q.pop();\\n        string right = q.front(); q.pop();\\n        bool flag = true;\\n\\t\\t\\n\\t\\t// If not NULL, process children nodes\\n        if(left != \"#\") flag = flag && helper(left, q);\\n        if(right != \"#\") flag = flag && helper(right, q);\\n        \\n        return flag;\\n    }\\n};\\n```\n```\\ncout << \"Upvote the solution if you like it !!\" << endl;\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2269617,
                "title": "c-time-o-n-space-o-1-preorder-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    bool isValidSerialization(string s) {\\n        if(ind>=s.length())\\n            return 0;\\n        \\n        int f=ind;\\n        string t=\"\";\\n        while(ind<s.length() && s[ind]!=\\',\\')\\n            t+=s[ind++];\\n        ind++;\\n        if(t==\"#\") // null node ( can\\'t have child )\\n        {\\n            if(f==0 && ind!=s.length()+1) // if root is NULL but has child\\n                return 0;\\n            return 1;\\n        }\\n        int p=isValidSerialization(s); // left child\\n        p=isValidSerialization(s); // right child\\n        \\n        if(p==0)// index out of bound ( not enough tree )\\n            return 0;\\n        if(f==0 && ind!=s.length()+1)// ( total tree is not covered yet)\\n            return 0;\\n        \\n        return 1;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ind=0;\\n    bool isValidSerialization(string s) {\\n        if(ind>=s.length())\\n            return 0;\\n        \\n        int f=ind;\\n        string t=\"\";\\n        while(ind<s.length() && s[ind]!=\\',\\')\\n            t+=s[ind++];\\n        ind++;\\n        if(t==\"#\") // null node ( can\\'t have child )\\n        {\\n            if(f==0 && ind!=s.length()+1) // if root is NULL but has child\\n                return 0;\\n            return 1;\\n        }\\n        int p=isValidSerialization(s); // left child\\n        p=isValidSerialization(s); // right child\\n        \\n        if(p==0)// index out of bound ( not enough tree )\\n            return 0;\\n        if(f==0 && ind!=s.length()+1)// ( total tree is not covered yet)\\n            return 0;\\n        \\n        return 1;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102566,
                "title": "python-simple-stack-solution",
                "content": "\\n    def isValidSerialization(self, preorder):\\n        ans, stack = preorder.split(\",\"), []\\n        \\n        if ans.pop() != \"#\":\\n            return False\\n        \\n        for i in ans:\\n            if i != \"#\":\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    return False\\n                else:\\n                    stack.pop()\\n\\n        return len(stack) == 0",
                "solutionTags": [],
                "code": "\\n    def isValidSerialization(self, preorder):\\n        ans, stack = preorder.split(\",\"), []\\n        \\n        if ans.pop() != \"#\":\\n            return False\\n        \\n        for i in ans:\\n            if i != \"#\":\\n                stack.append(i)\\n            else:\\n                if not stack:\\n                    return False\\n                else:\\n                    stack.pop()\\n\\n        return len(stack) == 0",
                "codeTag": "Python3"
            },
            {
                "id": 1951353,
                "title": "javascript-recursive-o-n-time-o-n-space-98-time-88-space",
                "content": "```\\n// DFS\\nvar isValidSerialization = function(preorder) {\\n    let arr = preorder.split(\\',\\');\\n    var idx = 0;\\n    \\n    function verify() {\\n        if (idx >= arr.length) return false;\\n        if (arr[idx] === \\'#\\') {\\n            idx++;\\n            return true;\\n        }\\n        idx++;\\n        let left, right;\\n        left = verify();\\n        right = verify();\\n        return left && right;\\n    }\\n    \\n    let result = verify();\\n    if (idx <= arr.length - 1) return false;\\n    else return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// DFS\\nvar isValidSerialization = function(preorder) {\\n    let arr = preorder.split(\\',\\');\\n    var idx = 0;\\n    \\n    function verify() {\\n        if (idx >= arr.length) return false;\\n        if (arr[idx] === \\'#\\') {\\n            idx++;\\n            return true;\\n        }\\n        idx++;\\n        let left, right;\\n        left = verify();\\n        right = verify();\\n        return left && right;\\n    }\\n    \\n    let result = verify();\\n    if (idx <= arr.length - 1) return false;\\n    else return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1724935,
                "title": "c-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n      \\n      std::vector<int> tree = { 0 }; // counts how many child is completed\\n      \\n      preorder+=\\',\\'; // final comma to handle last element\\n      char prev = 0; // prev character to deduce if it is null or not\\n      for(char c: preorder)\\n      {\\n        if(c!=\\',\\')\\n        {\\n          prev = c;\\n          continue;\\n        }\\n          \\n        if(tree.empty())\\n          return false;\\n\\n        if(prev==\\'#\\') // nullptr\\n          tree.back()++;\\n        else // number\\n          tree.push_back(0);\\n\\n        // normalize\\n        while(!tree.empty() && tree.back()==2)\\n        {\\n          tree.pop_back();\\n          if(!tree.empty())\\n            tree.back()++;\\n        }\\n      }\\n      \\n      return tree.size()==1 && tree.back()==1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n      \\n      std::vector<int> tree = { 0 }; // counts how many child is completed\\n      \\n      preorder+=\\',\\'; // final comma to handle last element\\n      char prev = 0; // prev character to deduce if it is null or not\\n      for(char c: preorder)\\n      {\\n        if(c!=\\',\\')\\n        {\\n          prev = c;\\n          continue;\\n        }\\n          \\n        if(tree.empty())\\n          return false;\\n\\n        if(prev==\\'#\\') // nullptr\\n          tree.back()++;\\n        else // number\\n          tree.push_back(0);\\n\\n        // normalize\\n        while(!tree.empty() && tree.back()==2)\\n        {\\n          tree.pop_back();\\n          if(!tree.empty())\\n            tree.back()++;\\n        }\\n      }\\n      \\n      return tree.size()==1 && tree.back()==1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1698777,
                "title": "c-easy-to-understand-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder.size() == 0) return false;\\n        \\n        stringstream s(preorder);\\n        string str;\\n        \\n        int cap = 1, n = preorder.size();\\n        \\n        \\n        \\n        /*\\n            Initially the capacity is 1 which means there can be a root node\\n            when adding a node the capacity will be decreased but if the node is Not NUll cap will increase by 2 as two more nodes can \\n             be added \\n         */\\n        while(getline(s, str, \\',\\')){\\n           \\n            cap--;\\n            \\n            if(cap < 0) return false;\\n            \\n            if(str != \"#\") cap += 2;\\n        }\\n        \\n        return cap == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder.size() == 0) return false;\\n        \\n        stringstream s(preorder);\\n        string str;\\n        \\n        int cap = 1, n = preorder.size();\\n        \\n        \\n        \\n        /*\\n            Initially the capacity is 1 which means there can be a root node\\n            when adding a node the capacity will be decreased but if the node is Not NUll cap will increase by 2 as two more nodes can \\n             be added \\n         */\\n        while(getline(s, str, \\',\\')){\\n           \\n            cap--;\\n            \\n            if(cap < 0) return false;\\n            \\n            if(str != \"#\") cap += 2;\\n        }\\n        \\n        return cap == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1689568,
                "title": "simple-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    //Main solution is to verify the string to be the correct representation\\n    // of the preorder BST\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        \\n        //split the string by the delimnator \",\"\\n        String[] nodes= preorder.split(\",\");\\n        //keeping the initial differnce in the elements as 1\\n        int diff=1;\\n        //iterate every element of the array\\n        for(String node: nodes)\\n        {\\n            \\n            if(--diff <0) return false;\\n            if(!(\"#\".equals(node)))\\n            {\\n                diff +=2;\\n                \\n            }\\n            \\n        }\\n        \\n        return diff==0;\\n        \\n        \\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    //Main solution is to verify the string to be the correct representation\\n    // of the preorder BST\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        \\n        //split the string by the delimnator \",\"\\n        String[] nodes= preorder.split(\",\");\\n        //keeping the initial differnce in the elements as 1\\n        int diff=1;\\n        //iterate every element of the array\\n        for(String node: nodes)\\n        {\\n            \\n            if(--diff <0) return false;\\n            if(!(\"#\".equals(node)))\\n            {\\n                diff +=2;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1659132,
                "title": "java-simple-100-solution",
                "content": "```java\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        \\n        for(int i = 0; i < preorder.length(); ++i) {\\n            while(i < preorder.length() && preorder.charAt(i) != \\',\\')\\n                sb.append(preorder.charAt(i++));\\n            \\n            count--;\\n            \\n            if(count < 0)\\n                return false;\\n            \\n            if(sb.charAt(0) != \\'#\\')\\n                count += 2;\\n            \\n            sb.setLength(0);\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        StringBuilder sb = new StringBuilder();\\n        int count = 1;\\n        \\n        for(int i = 0; i < preorder.length(); ++i) {\\n            while(i < preorder.length() && preorder.charAt(i) != \\',\\')\\n                sb.append(preorder.charAt(i++));\\n            \\n            count--;\\n            \\n            if(count < 0)\\n                return false;\\n            \\n            if(sb.charAt(0) != \\'#\\')\\n                count += 2;\\n            \\n            sb.setLength(0);\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1627459,
                "title": "python-easiest-stack-soln-o-n",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, pre: str) -> bool:\\n        pre = pre.split(\\',\\')\\n        stack = []\\n        \\n        for i in pre:\\n            while stack and stack[-1] == \\'#\\' and i == \\'#\\':\\n                stack.pop()\\n                if stack and stack[-1].isdigit():\\n                    stack.pop()\\n                else:\\n                    return False\\n                \\n            stack.append(i)\\n        \\n        return stack == [\\'#\\']\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, pre: str) -> bool:\\n        pre = pre.split(\\',\\')\\n        stack = []\\n        \\n        for i in pre:\\n            while stack and stack[-1] == \\'#\\' and i == \\'#\\':\\n                stack.pop()\\n                if stack and stack[-1].isdigit():\\n                    stack.pop()\\n                else:\\n                    return False\\n                \\n            stack.append(i)\\n        \\n        return stack == [\\'#\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596236,
                "title": "easy-to-understand-java-solution",
                "content": "class Solution {\\n    public boolean isValidSerialization(String s) {\\n        \\n        String[] arr = s.split(\",\");    \\n        Stack<String> st = new Stack<>();\\n\\n        for(int i = 0;i<arr.length-1;i++)\\n        {\\n             \\n            if( arr[i].equals(\"#\"))\\n            {\\n                if(st.isEmpty())\\n                {\\n                    return false;\\n                }\\n                String ch = st.pop();\\n                \\n            }\\n            else{\\n                \\n                st.push(arr[i]);\\n            }           \\n        }\\n        // check if the last string is # and the stack is empty\\n        return st.isEmpty() && arr[arr.length-1].equals(\"#\");\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValidSerialization(String s) {\\n        \\n        String[] arr = s.split(\",\");    \\n        Stack<String> st = new Stack<>();\\n\\n        for(int i = 0;i<arr.length-1;i++)\\n        {\\n             \\n            if( arr[i].equals(\"#\"))\\n            {\\n                if(st.isEmpty())\\n                {\\n                    return false;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1584131,
                "title": "pyhton3-recursive-faster-than-99-07",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        if len(preorder) == 0:\\n            return True\\n        \\n        preorder = preorder.split(\",\")\\n        \\n        def isValid(preorder):\\n            if len(preorder) == 0:\\n                return False\\n            \\n            node = preorder.pop(0)\\n            \\n            if node == \\'#\\':\\n                return True\\n            \\n            left = isValid(preorder)\\n            right = isValid(preorder)\\n            \\n            return left and right\\n        \\n        result = isValid(preorder)\\n        \\n        return len(preorder) == 0 and result\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/29090a3b-6022-474e-852b-c89028d22050_1637215692.3666236.png)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        if len(preorder) == 0:\\n            return True\\n        \\n        preorder = preorder.split(\",\")\\n        \\n        def isValid(preorder):\\n            if len(preorder) == 0:\\n                return False\\n            \\n            node = preorder.pop(0)\\n            \\n            if node == \\'#\\':\\n                return True\\n            \\n            left = isValid(preorder)\\n            right = isValid(preorder)\\n            \\n            return left and right\\n        \\n        result = isValid(preorder)\\n        \\n        return len(preorder) == 0 and result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569807,
                "title": "c-o-n-t-c-o-1-s-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int v=1;\\n        for(int i=0; i<preorder.size(); i++){\\n          if(preorder[i]==\\',\\') continue;\\n            v--;\\n            if(v<0) return false;\\n             if(preorder[i]!=\\'#\\') {\\n                \\n                 while(i<preorder.size() && preorder[i]!=\\',\\') i++;\\n                 v+=2;\\n                              \\n             }\\n        }\\n          return v==0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int v=1;\\n        for(int i=0; i<preorder.size(); i++){\\n          if(preorder[i]==\\',\\') continue;\\n            v--;\\n            if(v<0) return false;\\n             if(preorder[i]!=\\'#\\') {\\n                \\n                 while(i<preorder.size() && preorder[i]!=\\',\\') i++;\\n                 v+=2;\\n                              \\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1556742,
                "title": "java-easy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        if (preorder.equals(\"#\")) {\\n            return true;\\n        }\\n        \\n        if (preorder.charAt(preorder.length() - 1) != \\'#\\') {\\n            return false;\\n        }\\n        \\n        int flag = 0;\\n        for (String s : preorder.substring(0, preorder.length() - 1).split(\",\")) {\\n            if (s.equals(\"#\")) {\\n                flag--;\\n                if (flag < 0) return false;\\n            } else {\\n                flag++;\\n            }\\n        }\\n        return flag == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        if (preorder.equals(\"#\")) {\\n            return true;\\n        }\\n        \\n        if (preorder.charAt(preorder.length() - 1) != \\'#\\') {\\n            return false;\\n        }\\n        \\n        int flag = 0;\\n        for (String s : preorder.substring(0, preorder.length() - 1).split(\",\")) {\\n            if (s.equals(\"#\")) {\\n                flag--;\\n                if (flag < 0) return false;\\n            } else {\\n                flag++;\\n            }\\n        }\\n        return flag == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1533536,
                "title": "c-o-n-time-o-1-space-iterative-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n    bool isValidSerialization(string preorder)\\n    {\\n        int stack=0;\\n        int i=0;\\n        while(i<preorder.size())\\n        {\\n            if(preorder[i]==\\',\\')//ignore commas\\n            {\\n                i++;\\n                continue;\\n            }\\n            else if(preorder[i]!=\\'#\\')//number\\n            {\\n                while(i<preorder.size() && preorder[i]!=\\',\\')//scan whole number\\n                    i++;\\n                stack++;\\n                continue;\\n            }\\n            if(stack==0)\\n                break;\\n            i++;\\n            stack--;\\n        }\\n        return stack==0 && i==preorder.size()-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n    bool isValidSerialization(string preorder)\\n    {\\n        int stack=0;\\n        int i=0;\\n        while(i<preorder.size())\\n        {\\n            if(preorder[i]==\\',\\')//ignore commas\\n            {\\n                i++;\\n                continue;\\n            }\\n            else if(preorder[i]!=\\'#\\')//number\\n            {\\n                while(i<preorder.size() && preorder[i]!=\\',\\')//scan whole number\\n                    i++;\\n                stack++;\\n                continue;\\n            }\\n            if(stack==0)\\n                break;\\n            i++;\\n            stack--;\\n        }\\n        return stack==0 && i==preorder.size()-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1527586,
                "title": "approach-3-not-optimal-40-91-right-to-left-python",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        if preorder == \\'#\\':\\n            return True\\n        preoderList = preorder.split(\\',\\')\\n        nnew = 1\\n        n = len(preoderList)\\n        while nnew != n:\\n            #print(n)\\n            n = len(preoderList)\\n            i = n - 1\\n            while i >= 0 :\\n                if preoderList[i-1:i+1] == [\\'#\\',\\'#\\']and preoderList[i-2] != \\'#\\':\\n                    preoderList.pop(i)\\n                    preoderList.pop(i-1)\\n                    preoderList[i-2] = \\'#\\'\\n                    i -= 2\\n                else:\\n                    i -= 1\\n            if len(preoderList) == 1:\\n                return True\\n            nnew = len(preoderList)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        if preorder == \\'#\\':\\n            return True\\n        preoderList = preorder.split(\\',\\')\\n        nnew = 1\\n        n = len(preoderList)\\n        while nnew != n:\\n            #print(n)\\n            n = len(preoderList)\\n            i = n - 1\\n            while i >= 0 :\\n                if preoderList[i-1:i+1] == [\\'#\\',\\'#\\']and preoderList[i-2] != \\'#\\':\\n                    preoderList.pop(i)\\n                    preoderList.pop(i-1)\\n                    preoderList[i-2] = \\'#\\'\\n                    i -= 2\\n                else:\\n                    i -= 1\\n            if len(preoderList) == 1:\\n                return True\\n            nnew = len(preoderList)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486652,
                "title": "clean-python-solution-self-explained-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(N) for creating the list preorder.split(\\',\\')\\n\"\"\"\\nclass Solution(object):\\n    def isValidSerialization(self, preorder):\\n        slot = 1\\n        \\n        for c in preorder.split(\\',\\'):\\n            slot -= 1 #each elemet consumes a slot\\n            if slot<0: return False\\n            if c!=\\'#\\': slot += 2 #each non-null node also create 2 slot\\n            \\n        return slot==0 #all slots should be fill\\n\\t\\t\\n\"\"\"\\nRelated Problems:\\nInvert Binary Tree\\nKth Smallest Element in a BST\\nBinary Tree Longest Consecutive Sequence\\nValidate Binary Search Tree\\nFlatten Binary Tree to Linked List\\nPath Sum (DFS or BFS)\\nPath Sum II (DFS)\\nConstruct Binary Tree from Inorder and Postorder Traversal\\nConstruct Binary Tree from Preorder and Inorder Traversal\\nConvert Sorted Array to Binary Search Tree\\nConvert Sorted List to Binary Search Tree\\nMinimum Depth of Binary Tree\\nBinary Tree Maximum Path Sum *\\nBalanced Binary Tree\\nSymmetric Tree\\nBinary Search Tree Iterator\\nBinary Tree Right Side View\\nLowest Common Ancestor of a Binary Search Tree\\nLowest Common Ancestor of a Binary Tree\\nMost Frequent Subtree Sum\\nVerify Preorder Serialization of a Binary Tree\\nPopulating Next Right Pointers in Each Node\\nPopulating Next Right Pointers in Each Node II\\nUnique Binary Search Trees (DP)\\nUnique Binary Search Trees II (DFS)\\nSum Root to Leaf Numbers (DFS)\\nCount Complete Tree Nodes\\nClosest Binary Search Tree Value\\nBinary Tree Paths\\nMaximum Depth of Binary Tree\\nRecover Binary Search Tree\\nSame Tree\\nSerialize and Deserialize Binary Tree\\nInorder Successor in BST, Inorder Successor in BST II\\nFind Leaves of Binary Tree\\nLargest BST Subtree\\nConvert BST to Sorted Doubly Linked List\\n\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(N) for creating the list preorder.split(\\',\\')\\n\"\"\"\\nclass Solution(object):\\n    def isValidSerialization(self, preorder):\\n        slot = 1\\n        \\n        for c in preorder.split(\\',\\'):\\n            slot -= 1 #each elemet consumes a slot\\n            if slot<0: return False\\n            if c!=\\'#\\': slot += 2 #each non-null node also create 2 slot\\n            \\n        return slot==0 #all slots should be fill\\n\\t\\t\\n\"\"\"\\nRelated Problems:\\nInvert Binary Tree\\nKth Smallest Element in a BST\\nBinary Tree Longest Consecutive Sequence\\nValidate Binary Search Tree\\nFlatten Binary Tree to Linked List\\nPath Sum (DFS or BFS)\\nPath Sum II (DFS)\\nConstruct Binary Tree from Inorder and Postorder Traversal\\nConstruct Binary Tree from Preorder and Inorder Traversal\\nConvert Sorted Array to Binary Search Tree\\nConvert Sorted List to Binary Search Tree\\nMinimum Depth of Binary Tree\\nBinary Tree Maximum Path Sum *\\nBalanced Binary Tree\\nSymmetric Tree\\nBinary Search Tree Iterator\\nBinary Tree Right Side View\\nLowest Common Ancestor of a Binary Search Tree\\nLowest Common Ancestor of a Binary Tree\\nMost Frequent Subtree Sum\\nVerify Preorder Serialization of a Binary Tree\\nPopulating Next Right Pointers in Each Node\\nPopulating Next Right Pointers in Each Node II\\nUnique Binary Search Trees (DP)\\nUnique Binary Search Trees II (DFS)\\nSum Root to Leaf Numbers (DFS)\\nCount Complete Tree Nodes\\nClosest Binary Search Tree Value\\nBinary Tree Paths\\nMaximum Depth of Binary Tree\\nRecover Binary Search Tree\\nSame Tree\\nSerialize and Deserialize Binary Tree\\nInorder Successor in BST, Inorder Successor in BST II\\nFind Leaves of Binary Tree\\nLargest BST Subtree\\nConvert BST to Sorted Doubly Linked List\\n\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428828,
                "title": "python3-clear-and-easy-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        slots = 1\\n        for node in preorder.split(\\',\\'):\\n            if slots<1: return False\\n            slots += -1 if node == \\'#\\' else 1\\n        \\n        return slots == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        slots = 1\\n        for node in preorder.split(\\',\\'):\\n            if slots<1: return False\\n            slots += -1 if node == \\'#\\' else 1\\n        \\n        return slots == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428668,
                "title": "c-solution",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    bool next(string &s, int &i)\\n    {\\n        bool flag = true;\\n        if(s[i] == \\'#\\') flag = false;\\n        while(i != s.size()) \\n            if( s[i++] == \\',\\') break;\\n        return flag;\\n    }\\n    bool isValidSerialization(string preorder) \\n    {\\n        int stack = 0, lim_id = preorder.size(), i = 0;\\n        while(i != lim_id)\\n            if(next(preorder, i)) stack++;\\n        else if(stack) stack--;\\n        else return i == lim_id;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    bool next(string &s, int &i)\\n    {\\n        bool flag = true;\\n        if(s[i] == \\'#\\') flag = false;\\n        while(i != s.size()) \\n            if( s[i++] == \\',\\') break;\\n        return flag;\\n    }\\n    bool isValidSerialization(string preorder) \\n    {\\n        int stack = 0, lim_id = preorder.size(), i = 0;\\n        while(i != lim_id)\\n            if(next(preorder, i)) stack++;\\n        else if(stack) stack--;\\n        else return i == lim_id;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428402,
                "title": "python-stack-solution-with-explanation-complexity-analysis",
                "content": "#### Intuition\\nTo validate a tree, we need to make sure each node has left and right child. Looking at the preorder we have, we need to validate bottom up from the leaves.\\n\\nSince we are checking backwards, stack is the best data structure here. A leaf will has 2 \\'#\\' after it, So thats what we are checking.\\n\\nTo make life easier, we marked checked nodes as \\'#\\' to reuse the same logic.\\n\\n#### Algorithm\\n\\n\\n1. Loop through preorder\\n2. Mark and reduce stack if we are able to\\n3. Check the stack in the end\\n\\n  \\n\\n#### Code\\n```python\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorderList = preorder.split(\\',\\')\\n        if len(preorderList)%2 != 1:\\n            return False\\n        stack = []\\n        for node in preorderList:\\n            stack.append(node)\\n            while len(stack) >= 3 and stack[-2] == stack[-1] == \\'#\\' and stack[-3] != \\'#\\':\\n                for i in range(3):\\n                    stack.pop()\\n                stack.append(\\'#\\')\\n        return len(stack) == 1 and stack[0] == \\'#\\'\\n```\\n\\n#### Complexity Analysis\\n\\n  \\n\\n-  **Time Complexity:**  `O(n)`, one pass\\n\\n-  **Space Complexity:**  `O(n)`, our stack",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorderList = preorder.split(\\',\\')\\n        if len(preorderList)%2 != 1:\\n            return False\\n        stack = []\\n        for node in preorderList:\\n            stack.append(node)\\n            while len(stack) >= 3 and stack[-2] == stack[-1] == \\'#\\' and stack[-3] != \\'#\\':\\n                for i in range(3):\\n                    stack.pop()\\n                stack.append(\\'#\\')\\n        return len(stack) == 1 and stack[0] == \\'#\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428112,
                "title": "c-linear-solution-explained-100-time-95-space",
                "content": "Sweet problem that forces you to think a bit deeper about representing data. And also a step up the classic [valid parentheses](https://leetcode.com/problems/valid-parentheses/) problem, [solved here](https://leetcode.com/problems/valid-parentheses/discuss/1025908/)).\\n\\nMy intuition here was initially to use a stack, then I found it unnecessary and opted for a counter for each direction, but before I even began coding it, it dawned to me how to proceed: all that we need is to keep track of how many `nodes` we encounter and know that each one of them has to terminate with either another node or `\\'#\\'`.\\n\\nBut since, recursively, each new node would still need the same condition, we will figure out that from that that the number of nodes in a valid tree is equal to the amount of `\\'#\\'` plus `1`.\\n\\nFurthermore, we can never encounter more `\\'#\\'` than nodes we have seen so far, so we need to check for that.\\n\\nTo solve this problem, we will handle first the edge case of an input starting with `\\'#\\'` itself: this tree will be valid only if it is the only character in `s`.\\n\\nWith that checked, we can now be sure that the first node is a non-null one and since we just explained that we want the amount of nulls to be always `1` more than the the actual nodes met, we can initialise the variable `nodes` with the value of `2` (`1` from the root node, plus another `1` to make it \"even\" with the expected nulls in a valid tree).\\n\\nWe will then loop through `s` with the pointer `i` initially set to `1` up to `lmt` (the size of our initial input) and every time we spot a `\\',\\'` we will:*\\n* check if the next character is a null (`\\'#\\'`) in which case we will decrease `nodes` by `1` and:\\n\\t* check if `nodes == 0`, in which case we will `return` `true` only if it was the last node (ie: `i + 2 == lmt`), `false` otherwise;\\n* otherwise, increase `nodes` by `1`;\\n* increase `i` (we want to move at least 2 steps after a comma).\\n\\nOnce done, we will `return` `true` only if `nodes == 0` (ie: we found a balanced tree), `false` otherwise.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        // edge case off\\n        if (s[0] == \\'#\\') return s.size()  == 1;\\n        // support variables\\n        int nodes = 2;\\n        // parsing s\\n        for (int i = 1, lmt = s.size(); i < lmt; i++) {\\n            // detecting a new node\\n            if (s[i] == \\',\\') {\\n                // finding a null\\n                if (s[i + 1] == \\'#\\') {\\n                    nodes--;\\n                    if (!nodes) return i + 2 == lmt;\\n                }\\n                // finding a node\\n                else nodes++;\\n                i++;\\n            }\\n        }\\n        return !nodes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        // edge case off\\n        if (s[0] == \\'#\\') return s.size()  == 1;\\n        // support variables\\n        int nodes = 2;\\n        // parsing s\\n        for (int i = 1, lmt = s.size(); i < lmt; i++) {\\n            // detecting a new node\\n            if (s[i] == \\',\\') {\\n                // finding a null\\n                if (s[i + 1] == \\'#\\') {\\n                    nodes--;\\n                    if (!nodes) return i + 2 == lmt;\\n                }\\n                // finding a node\\n                else nodes++;\\n                i++;\\n            }\\n        }\\n        return !nodes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427717,
                "title": "verify-preorder-serialization-of-a-binary-tree-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder)\\n    {\\n        istringstream iss(preorder);\\n        \\n        int sent = 1;\\n        for(string s; getline( iss, s, \\',\\');) {\\n            if(sent == 0)\\n                return false;\\n            if(s == \"#\")\\n                --sent;\\n            else\\n                ++sent;\\n        }\\n        return sent == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder)\\n    {\\n        istringstream iss(preorder);\\n        \\n        int sent = 1;\\n        for(string s; getline( iss, s, \\',\\');) {\\n            if(sent == 0)\\n                return false;\\n            if(s == \"#\")\\n                --sent;\\n            else\\n                ++sent;\\n        }\\n        return sent == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427641,
                "title": "easy-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string pre) {\\n        \\n        \\n        int vac=1;\\n        pre+=\\',\\';\\n        for(int i=0;i<pre.length();i++){\\n            \\n             if(pre[i]==\\',\\'){\\n                 continue;\\n             } \\n           \\n            \\n             vac--;\\n            \\n             if(vac<0){\\n                return false;\\n            }\\n            \\n           \\n          \\n            if(pre[i]!=\\'#\\'){\\n                \\n               vac+=2;\\n                \\n                while(pre[i]!=\\',\\'){   // This loop handle the case when digit >=10\\n                 \\n                     i++;\\n                    \\n                }\\n                \\n            }\\n        \\n        }\\n    \\n        return vac==0;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string pre) {\\n        \\n        \\n        int vac=1;\\n        pre+=\\',\\';\\n        for(int i=0;i<pre.length();i++){\\n            \\n             if(pre[i]==\\',\\'){\\n                 continue;\\n             } \\n           \\n            \\n             vac--;\\n            \\n             if(vac<0){\\n                return false;\\n            }\\n            \\n           \\n          \\n            if(pre[i]!=\\'#\\'){\\n                \\n               vac+=2;\\n                \\n                while(pre[i]!=\\',\\'){   // This loop handle the case when digit >=10\\n                 \\n                     i++;\\n                    \\n                }\\n                \\n            }\\n        \\n        }\\n    \\n        return vac==0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427637,
                "title": "python-a-simple-recusive-solution",
                "content": "The preorder string of a binary tree can be considered as `node, [left subtree], [right subtree]`. Therefore,to check if the traversal is valid, we just need to go through the preorder string in this way and check if the length of it matches or expectation.\\n\\n`preorder_traveral` is a function that returns the expected end index of a given subtree. We just need to check if the length of preorder string matches the expectation.\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorder = preorder.split(\",\")\\n        def preorder_traveral(beg):\\n            if beg >= len(preorder) or preorder[beg] == \\'#\\': return beg\\n            lend = preorder_traveral(beg + 1)\\n            return preorder_traveral(lend + 1)\\n        return preorder_traveral(0) == len(preorder) - 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        preorder = preorder.split(\",\")\\n        def preorder_traveral(beg):\\n            if beg >= len(preorder) or preorder[beg] == \\'#\\': return beg\\n            lend = preorder_traveral(beg + 1)\\n            return preorder_traveral(lend + 1)\\n        return preorder_traveral(0) == len(preorder) - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427620,
                "title": "intuitive-iterate-from-end-stack-no-stack",
                "content": "```\\n// itertaing from end.. with stack\\n    public boolean isValidSerialization(String preorder) {\\n        Stack<String> stack = new Stack<>();\\n        String[] parts = preorder.split(\",\");\\n        for(int i=parts.length-1;i>=0;--i){\\n            if(!parts[i].equals(\"#\")){\\n                if(stack.size()<2) return false;\\n                stack.pop();\\n                stack.pop();\\n            } \\n            stack.push(parts[i]);\\n        }\\n        return stack.size()==1;\\n    }\\n\\t\\n\\t\\n    // converting from stack DS to int.. as stack is used only to check size\\n    public boolean isValidSerialization(String preorder) {\\n        int stack=0;\\n        String[] parts = preorder.split(\",\");\\n        for(int i=parts.length-1;i>=0;--i){\\n            if(!parts[i].equals(\"#\")){\\n                if(stack<2) return false;\\n                stack-=2;\\n            } \\n            stack++;\\n        }\\n        return stack==1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// itertaing from end.. with stack\\n    public boolean isValidSerialization(String preorder) {\\n        Stack<String> stack = new Stack<>();\\n        String[] parts = preorder.split(\",\");\\n        for(int i=parts.length-1;i>=0;--i){\\n            if(!parts[i].equals(\"#\")){\\n                if(stack.size()<2) return false;\\n                stack.pop();\\n                stack.pop();\\n            } \\n            stack.push(parts[i]);\\n        }\\n        return stack.size()==1;\\n    }\\n\\t\\n\\t\\n    // converting from stack DS to int.. as stack is used only to check size\\n    public boolean isValidSerialization(String preorder) {\\n        int stack=0;\\n        String[] parts = preorder.split(\",\");\\n        for(int i=parts.length-1;i>=0;--i){\\n            if(!parts[i].equals(\"#\")){\\n                if(stack<2) return false;\\n                stack-=2;\\n            } \\n            stack++;\\n        }\\n        return stack==1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427610,
                "title": "python3-solution-easy-clean",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, p: str) -> bool:\\n        i=0\\n        st=1\\n        lst=p.split(\",\")\\n        while(i<len(lst)):\\n            st-=1\\n            if st<0:\\n                return False\\n            if lst[i]!=\"#\": \\n                st+=2\\n            i=i+1\\n        \\n        if st==0:\\n            return True\\n        else:\\n            return False\\n```\\nnot really fast but it is 85% space efficient.if you have any doubts regarding the logic do lemme know !",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, p: str) -> bool:\\n        i=0\\n        st=1\\n        lst=p.split(\",\")\\n        while(i<len(lst)):\\n            st-=1\\n            if st<0:\\n                return False\\n            if lst[i]!=\"#\": \\n                st+=2\\n            i=i+1\\n        \\n        if st==0:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427546,
                "title": "rust-recursive-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_valid_serialization(preorder: String) -> bool {\\n        let mut iter = preorder.split(\\',\\').map(|s| s != \"#\");\\n        Self::dfs(&mut iter) && iter.next().is_none()\\n    }\\n    fn dfs(iter: &mut impl std::iter::Iterator<Item = bool>) -> bool {\\n        if let Some(b) = iter.next() {\\n            if b {\\n                if !Self::dfs(iter) {\\n                    return false;\\n                }\\n                if !Self::dfs(iter) {\\n                    return false;\\n                }\\n            }\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Recursion"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_valid_serialization(preorder: String) -> bool {\\n        let mut iter = preorder.split(\\',\\').map(|s| s != \"#\");\\n        Self::dfs(&mut iter) && iter.next().is_none()\\n    }\\n    fn dfs(iter: &mut impl std::iter::Iterator<Item = bool>) -> bool {\\n        if let Some(b) = iter.next() {\\n            if b {\\n                if !Self::dfs(iter) {\\n                    return false;\\n                }\\n                if !Self::dfs(iter) {\\n                    return false;\\n                }\\n            }\\n            true\\n        } else {\\n            false\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1427463,
                "title": "python-3-an-recursive-solution",
                "content": "This is quite straightforward.\\n\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        arr = preorder.split(\",\")\\n        index = 0\\n        N = len(arr)\\n        \\n        def dfs():\\n            nonlocal index\\n            if index == N:\\n                return False\\n            if arr[index] == \"#\":\\n                return True\\n            \\n            index += 1\\n            left = dfs()\\n            if not left:\\n                return False\\n            \\n            index += 1\\n            right = dfs()\\n            if not right:\\n                return False\\n            \\n            return True\\n        \\n        if not dfs():\\n            return False\\n        \\n        return index == N-1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        arr = preorder.split(\",\")\\n        index = 0\\n        N = len(arr)\\n        \\n        def dfs():\\n            nonlocal index\\n            if index == N:\\n                return False\\n            if arr[index] == \"#\":\\n                return True\\n            \\n            index += 1\\n            left = dfs()\\n            if not left:\\n                return False\\n            \\n            index += 1\\n            right = dfs()\\n            if not right:\\n                return False\\n            \\n            return True\\n        \\n        if not dfs():\\n            return False\\n        \\n        return index == N-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427347,
                "title": "c-easy-clean-solution-fastest-with-comments-recursion-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    // convert space seperated string to tokens\\n    vector<string> tokenizeString(string &s) {\\n        vector<string> res;\\n        stringstream ss(s);\\n        string word;\\n        while (ss >> word)\\n            res.push_back(word);\\n        return res;\\n    }\\n    // validate the preoder encoding\\n    bool isValidPreorder(vector<string> &pre, int &n) {\\n        // base cases\\n        if (n >= pre.size()) return false;\\n        if (pre[n] == \"#\") return true;\\n        // below reflect Preorder (DFS) technique\\n        bool left = isValidPreorder(pre, ++n);\\n        bool right = isValidPreorder(pre, ++n);\\n        // root is valid only if left and right are valid\\n        return left and right;\\n    }\\n    // main\\n    bool isValidSerialization(string preorder) {\\n        // replace \\',\\' by \\' \\' in preoder string\\n        replace_if(preorder.begin(), preorder.end(), [] (char &c) {return c == \\',\\';}, \\' \\');\\n        // tokenize preoder into pre vector\\n        vector<string> pre = tokenizeString(preorder);\\n        // check if preOrder is valid or not\\n        int n = 0;\\n        // n == pre.size() - 1 is checked to make sure the whole string was processed,\\n        // if not => given encoding is invalid prorder\\n        return isValidPreorder(pre, n) and n == pre.size() - 1;\\n    }\\n};\\n```\\n\\n**NOTE:**\\n*If you find this post helpful then please **upvote**. It keeps me **motivated** to post such helpful solutions. Thanks!*\\n\\n**PS:**\\nI have also written a post on all C++ (15+) sorting algorithms in a cleaner way [here](https://leetcode.com/problems/sort-an-array/discuss/1401412/C%2B%2B-Clean-Code-Solution-or-Fastest-or-All-(15%2B)-Sorting-Methods-or-Detailed) on leetcode.\\n*Do check it out/ bookmark (and upvote :)) to revise those concepts for the interview. Thanks!*",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // convert space seperated string to tokens\\n    vector<string> tokenizeString(string &s) {\\n        vector<string> res;\\n        stringstream ss(s);\\n        string word;\\n        while (ss >> word)\\n            res.push_back(word);\\n        return res;\\n    }\\n    // validate the preoder encoding\\n    bool isValidPreorder(vector<string> &pre, int &n) {\\n        // base cases\\n        if (n >= pre.size()) return false;\\n        if (pre[n] == \"#\") return true;\\n        // below reflect Preorder (DFS) technique\\n        bool left = isValidPreorder(pre, ++n);\\n        bool right = isValidPreorder(pre, ++n);\\n        // root is valid only if left and right are valid\\n        return left and right;\\n    }\\n    // main\\n    bool isValidSerialization(string preorder) {\\n        // replace \\',\\' by \\' \\' in preoder string\\n        replace_if(preorder.begin(), preorder.end(), [] (char &c) {return c == \\',\\';}, \\' \\');\\n        // tokenize preoder into pre vector\\n        vector<string> pre = tokenizeString(preorder);\\n        // check if preOrder is valid or not\\n        int n = 0;\\n        // n == pre.size() - 1 is checked to make sure the whole string was processed,\\n        // if not => given encoding is invalid prorder\\n        return isValidPreorder(pre, n) and n == pre.size() - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427269,
                "title": "python-intuitive-regex-no-need-to-think-about-the-trees-change-all-digit-to",
                "content": "\\nThe idea is to replace every integer with #,# into #. Basicaly we find leaf nodes and prune them untill we reach out the root.\\n\\nHere is how it would look like for the valid tree test example:\\n\\n`9,3,4,#,#,1,#,#,2,#,6,#,#`\\n`9,3,#,#,2,#,#`\\n`9,#,#`\\n`#`\\n\\n\\n\\n```python\\nimport re\\nclass Solution:\\n    def isValidSerialization(self, S: str) -> bool:\\n        while S:\\n            s2 = re.sub(\"([0-9]+),#,#\",\"#\", S) # replace node.val,#,# -> #\\n            \\n            # if it\\'s # means we reached the final node and it\\'s good\\n            if s2 == \"#\": return True         \\n            \\n            # if the lenght didn\\'t change means the format is messed up\\n            if len(s2) == len(S): return False\\n            S = s2\\n```\\n\\nTime complexity `O(N^2)`\\nSpace `O(N)`\\n\\n",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```python\\nimport re\\nclass Solution:\\n    def isValidSerialization(self, S: str) -> bool:\\n        while S:\\n            s2 = re.sub(\"([0-9]+),#,#\",\"#\", S) # replace node.val,#,# -> #\\n            \\n            # if it\\'s # means we reached the final node and it\\'s good\\n            if s2 == \"#\": return True         \\n            \\n            # if the lenght didn\\'t change means the format is messed up\\n            if len(s2) == len(S): return False\\n            S = s2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427229,
                "title": "c-24-line-o-n-time-o-1-space-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int len = preorder.length();\\n\\t\\t//difference = sentinel_count - number_count\\n        int difference = 0;\\n        for(int i = len - 1; i >= 0; i-=2){\\n            if(preorder[i] == \\'#\\'){\\n                difference++;\\n            }\\n            else{\\n\\t\\t\\t    //it\\'s a number, skip all digits\\n\\t\\t\\t    while(i >= 1 && preorder[i - 1] != \\',\\'){\\n                    i--;\\n                }\\n                difference--;\\n            }\\n            if(difference < 1){\\n                return false;\\n            }\\n        }\\n        return difference == 1;\\n    }\\n};\\n/* \\nThe idea is based on leaf-vertices deletions (by replacing substr \"num,#,#\" by \"#\")\\nuntill the string will become serialization of null root (\"#\").\\nIf there is no leafs and the string is not equal to \"#\" the answer is false.\\nNote that correct serialization always ends with several sentinels.\\nLet assume it ends with n sentinels (we don\\'t take into account commas) \\nand there is m consecutive numbers just before this sentinels. \\nLet\\'s start deleting leafs from the end of the string:\\nwe take the last number in the string and two following \\'#\\' and replace it by \\'#\\'.\\nBoth m and n decremented after this operation. Let\\'s continue.\\nNote that if m >= n after (n - 1) operations we will get one \\'#\\'\\nin the end of string and at least 1 number just before it.\\nCurrent last number can never be deleted if continue deleting leafs\\nso the answer is false, m should be <= n - 1 if the answer is true.\\n\\nLet\\'s do this transformtions (consequtive leaf deletion from the end of string) on example:\\n\"9,3,4,#,#,1,#,#,2,#,(6,#,#)\" -> \"9,3,4,#,#,1,#,#,(2,#,#)\" ->\\n\"9,3,4,#,#,(1,#,#),#\" -> \"9,3,(4,#,#),#,#\" -> \"9,(3,#,#),#\" ->\\n\"(9,#,#)\" -> \"#\" - so the answer is true\\n\\nAs I mentioned before the string is a serialization of tree if at each step the number of \\'#\\' \\nin the end (n) is at least equals to m + 1 (n >= m + 1), where m is the number\\nof consequctive numbers just before the sentinels in the end of the string.\\n\\nSo I found out that I can check string without actually deleting the leafs,\\nI can simply check if difference = sentinel_count - number_count >= 1 all the time\\nwhen I scan string from the end. And also I need to check if finally difference = 1.\\n\\nThe difference should be equal 1 after string scanning because during one leaf deletion I \\ndecrement both numbers_count and sentinel_count. And in the end I should get \"#\"\\nif the answer is true.\\n*/\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int len = preorder.length();\\n\\t\\t//difference = sentinel_count - number_count\\n        int difference = 0;\\n        for(int i = len - 1; i >= 0; i-=2){\\n            if(preorder[i] == \\'#\\'){\\n                difference++;\\n            }\\n            else{\\n\\t\\t\\t    //it\\'s a number, skip all digits\\n\\t\\t\\t    while(i >= 1 && preorder[i - 1] != \\',\\'){\\n                    i--;\\n                }\\n                difference--;\\n            }\\n            if(difference < 1){\\n                return false;\\n            }\\n        }\\n        return difference == 1;\\n    }\\n};\\n/* \\nThe idea is based on leaf-vertices deletions (by replacing substr \"num,#,#\" by \"#\")\\nuntill the string will become serialization of null root (\"#\").\\nIf there is no leafs and the string is not equal to \"#\" the answer is false.\\nNote that correct serialization always ends with several sentinels.\\nLet assume it ends with n sentinels (we don\\'t take into account commas) \\nand there is m consecutive numbers just before this sentinels. \\nLet\\'s start deleting leafs from the end of the string:\\nwe take the last number in the string and two following \\'#\\' and replace it by \\'#\\'.\\nBoth m and n decremented after this operation. Let\\'s continue.\\nNote that if m >= n after (n - 1) operations we will get one \\'#\\'\\nin the end of string and at least 1 number just before it.\\nCurrent last number can never be deleted if continue deleting leafs\\nso the answer is false, m should be <= n - 1 if the answer is true.\\n\\nLet\\'s do this transformtions (consequtive leaf deletion from the end of string) on example:\\n\"9,3,4,#,#,1,#,#,2,#,(6,#,#)\" -> \"9,3,4,#,#,1,#,#,(2,#,#)\" ->\\n\"9,3,4,#,#,(1,#,#),#\" -> \"9,3,(4,#,#),#,#\" -> \"9,(3,#,#),#\" ->\\n\"(9,#,#)\" -> \"#\" - so the answer is true\\n\\nAs I mentioned before the string is a serialization of tree if at each step the number of \\'#\\' \\nin the end (n) is at least equals to m + 1 (n >= m + 1), where m is the number\\nof consequctive numbers just before the sentinels in the end of the string.\\n\\nSo I found out that I can check string without actually deleting the leafs,\\nI can simply check if difference = sentinel_count - number_count >= 1 all the time\\nwhen I scan string from the end. And also I need to check if finally difference = 1.\\n\\nThe difference should be equal 1 after string scanning because during one leaf deletion I \\ndecrement both numbers_count and sentinel_count. And in the end I should get \"#\"\\nif the answer is true.\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427107,
                "title": "c-simple-solution-100-faster",
                "content": "class Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        \\n        string str=\"\";\\n        stringstream ss(preorder);\\n        int value = 1;\\n        while(getline(ss,str,\\',\\'))\\n        {\\n            value--;\\n            if(value<0)\\n                return false;\\n            \\n            if(str!=\"#\")\\n            {\\n                value = value+2;\\n            }\\n        }\\n        return value==0;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        \\n        string str=\"\";\\n        stringstream ss(preorder);\\n        int value = 1;\\n        while(getline(ss,str,\\',\\'))\\n        {\\n            value--;\\n            if(value<0)\\n                return false;\\n            \\n            if(str!=\"#\")\\n            {\\n                value = value+2;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1427099,
                "title": "java-stack-based",
                "content": "**Idea:**\\n1. Here, every node has 2 children, even leaves has 2 null childs\\n2. So, we check, can we assign 2 children to all nodes or not?\\n3. If yes, then serialization is valid. Else invalid.\\n\\n**Steps:**\\n1. Create a Stack `st`\\n2. for each values of comma-splitted input:\\n\\t1. if it is a `#`:\\n\\t\\t1. if `st` is empty, then it means this null can\\'t be value of any node; so given serialization is invalid.\\n\\t\\t2. else, \\n\\t\\t\\t1. assign it to stack top (pop and increment)\\n\\t\\t\\t2. if child count is 2, it means current node has all childs assigned, don\\'t push it back to st\\n\\t\\t\\t3. else, push it back to `st`\\n\\t2. else\\n\\t\\t1. if `st` is empty, goto 3\\n\\t\\t2. else, \\n\\t\\t\\t1. assign it to stack top (pop and increment)\\n\\t\\t\\t2. if child count is 2, it means current node has all childs assigned, don\\'t push it \\n\\t\\t3. push `0` it to stack\\n3. In the end, `st` should be empty, bcoz all nodes have 2 children assigned\\n\\nCode:\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {   \\n        if(preorder.length()==1) return preorder.charAt(0) == \\'#\\';\\n        String[] parts = preorder.split(\",\");\\n        if(parts.length % 2 == 0) return false; // total entries will always be odd if it is valid\\n        \\n        Deque<Integer> st = new LinkedList<>();\\n        for(String str: parts) {\\n            if(str.equals(\"#\")) {\\n                if(st.isEmpty()) \\n                    return false;\\n                int curr = st.pop();\\n                curr++;\\n                if(curr < 2)\\n                    st.push(curr);\\n            } else {\\n                if(st.isEmpty()) {\\n                    st.push(0);\\n                } else {\\n                    int curr = st.pop();\\n                    curr++;\\n                    if(curr < 2) {\\n                        st.push(curr);\\n                    }\\n                    st.push(0);\\n                }\\n            }\\n        }\\n        \\n        return st.isEmpty();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {   \\n        if(preorder.length()==1) return preorder.charAt(0) == \\'#\\';\\n        String[] parts = preorder.split(\",\");\\n        if(parts.length % 2 == 0) return false; // total entries will always be odd if it is valid\\n        \\n        Deque<Integer> st = new LinkedList<>();\\n        for(String str: parts) {\\n            if(str.equals(\"#\")) {\\n                if(st.isEmpty()) \\n                    return false;\\n                int curr = st.pop();\\n                curr++;\\n                if(curr < 2)\\n                    st.push(curr);\\n            } else {\\n                if(st.isEmpty()) {\\n                    st.push(0);\\n                } else {\\n                    int curr = st.pop();\\n                    curr++;\\n                    if(curr < 2) {\\n                        st.push(curr);\\n                    }\\n                    st.push(0);\\n                }\\n            }\\n        }\\n        \\n        return st.isEmpty();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427079,
                "title": "c-simple-o-n-time-o-1-space-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n       int count=0,count1=0;\\n       bool finished=false; \\n       for(char ch:preorder)\\n       {\\n           if(finished)\\n               return false;\\n           if(ch==\\',\\')\\n               count++;\\n           if(ch==\\'#\\')\\n               count1++;\\n           if(count+2==2*count1)\\n               finished=true;\\n       }\\n        return finished;    \\n    }\\n};\\n```\\n***Explanation:The no of #s will always be 1 greater than no of integers in valid string\\ni.e: ((count+1)-count1)+1=count1\\ni.e: count+2=2count1***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) \\n    {\\n       int count=0,count1=0;\\n       bool finished=false; \\n       for(char ch:preorder)\\n       {\\n           if(finished)\\n               return false;\\n           if(ch==\\',\\')\\n               count++;\\n           if(ch==\\'#\\')\\n               count1++;\\n           if(count+2==2*count1)\\n               finished=true;\\n       }\\n        return finished;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427073,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        vector<string> vec;\\n        stringstream check(preorder);\\n        string str;\\n        while(getline(check,str,\\',\\')){\\n            vec.push_back(str);\\n        }\\n        \\n        int i=0,n=vec.size(),slot=1;\\n\\n        while(i<n){\\n            if(slot==0) return false;\\n            if(vec[i]==\"#\"){\\n                slot--;\\n            }else{\\n                slot++;\\n            }\\n            ++i;\\n        }\\n        return slot==0 ? true : false; \\n    }\\n};\\n```\\nPlease **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        vector<string> vec;\\n        stringstream check(preorder);\\n        string str;\\n        while(getline(check,str,\\',\\')){\\n            vec.push_back(str);\\n        }\\n        \\n        int i=0,n=vec.size(),slot=1;\\n\\n        while(i<n){\\n            if(slot==0) return false;\\n            if(vec[i]==\"#\"){\\n                slot--;\\n            }else{\\n                slot++;\\n            }\\n            ++i;\\n        }\\n        return slot==0 ? true : false; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426977,
                "title": "c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int nodes = 1 , n =preorder.length(); \\n        for(int i=0;i<n;i++){\\n            if(preorder[i]==\\',\\')\\n                continue; \\n            --nodes;\\n            if(nodes<0)\\n                return 0;            \\n            if(preorder[i]!=\\'#\\'){  //each non null node can have a left and right child \\n                while(i<n && isdigit(preorder[i]))     // Value of node is from 0 to 100  \"9,#,92,#,#\" \\n                    i++;\\n                i--;\\n                nodes += 2;       \\n            }      \\n        }        \\n        return nodes == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        int nodes = 1 , n =preorder.length(); \\n        for(int i=0;i<n;i++){\\n            if(preorder[i]==\\',\\')\\n                continue; \\n            --nodes;\\n            if(nodes<0)\\n                return 0;            \\n            if(preorder[i]!=\\'#\\'){  //each non null node can have a left and right child \\n                while(i<n && isdigit(preorder[i]))     // Value of node is from 0 to 100  \"9,#,92,#,#\" \\n                    i++;\\n                i--;\\n                nodes += 2;       \\n            }      \\n        }        \\n        return nodes == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426929,
                "title": "java-recursive-solution-single-pass",
                "content": "```java\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    boolean validate(String[] arr) {\\n        if (pos == arr.length)\\n            return false;\\n        \\n        //If null node\\n        if (arr[pos].equals(\"#\")) {\\n            ++pos;\\n            return true;\\n        }\\n        else {\\n            ++pos;\\n            //The nodes immediately following current node must be its left and right children.\\n            boolean isLeftChildValid = validate(arr), isRightChildValid = validate(arr);\\n            return isLeftChildValid && isRightChildValid;\\n        }\\n    }\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        String[] input = preorder.split(\",\");\\n        //Even if the function returned true, the input is invalid if any part of it is unused.\\n        return validate(input) && pos == input.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    int pos = 0;\\n    \\n    boolean validate(String[] arr) {\\n        if (pos == arr.length)\\n            return false;\\n        \\n        //If null node\\n        if (arr[pos].equals(\"#\")) {\\n            ++pos;\\n            return true;\\n        }\\n        else {\\n            ++pos;\\n            //The nodes immediately following current node must be its left and right children.\\n            boolean isLeftChildValid = validate(arr), isRightChildValid = validate(arr);\\n            return isLeftChildValid && isRightChildValid;\\n        }\\n    }\\n    \\n    public boolean isValidSerialization(String preorder) {\\n        String[] input = preorder.split(\",\");\\n        //Even if the function returned true, the input is invalid if any part of it is unused.\\n        return validate(input) && pos == input.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410309,
                "title": "python-simple-6-lines",
                "content": "```python\\ndef isValidSerialization(self, preorder: str) -> bool:\\n        res = 1\\n        for c in preorder.split(\\',\\'):\\n            if not res:\\n                return False\\n            res += 1 if c != \\'#\\' else -1\\n        return not res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef isValidSerialization(self, preorder: str) -> bool:\\n        res = 1\\n        for c in preorder.split(\\',\\'):\\n            if not res:\\n                return False\\n            res += 1 if c != \\'#\\' else -1\\n        return not res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1374469,
                "title": "2-c-solutions-using-stack-o-n-space-and-only-1-variable-with-explanation",
                "content": "1. Solution 1, using stack\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder==\"\")\\n            return false;\\n        preorder+=\\',\\';\\n        vector<string>result;\\n        string temp;\\n        for(char c:preorder){\\n            if(c==\\',\\'){\\n                result.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            temp+=c;\\n        }\\n        \\n        //result just has # and int values now\\n        stack<string>st;\\n        for(int i=0;i<result.size();i++){\\n            string curr = result[i];\\n            while(curr==\"#\" && !st.empty() && st.top()==curr){\\n                st.pop();   //pop out one \\n                if (st.empty()) {   //if stack becomes empty before string ends - root is processed\\n                    return false;\\n                }\\n                st.pop();   //done processing this child\\n            }\\n            st.push(curr);   //push the curr char\\n        }\\n        return st.size() == 1 && st.top()==\"#\";\\n    }\\n};\\n```\\n2. Solution 2, using a single variable\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if (preorder.empty()) return false;\\n        preorder+=\\',\\';\\n        \\n        int sizeOfTree = 1;\\n        \\n        for(int i=0;i<preorder.size();i++){\\n            if(preorder[i]!=\\',\\')continue;   //process only at commas(ending of node val)\\n            \\n            sizeOfTree--;                   //used one available capacity\\n            if (sizeOfTree<0) return false; //cant accomodate more nodes\\n            \\n            if(preorder[i-1]!=\\'#\\')  //if prev node was non-null - we can add 2 more nodes - right and left\\n                sizeOfTree+=2;\\n        }\\n        return sizeOfTree==0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if(preorder==\"\")\\n            return false;\\n        preorder+=\\',\\';\\n        vector<string>result;\\n        string temp;\\n        for(char c:preorder){\\n            if(c==\\',\\'){\\n                result.push_back(temp);\\n                temp=\"\";\\n                continue;\\n            }\\n            temp+=c;\\n        }\\n        \\n        //result just has # and int values now\\n        stack<string>st;\\n        for(int i=0;i<result.size();i++){\\n            string curr = result[i];\\n            while(curr==\"#\" && !st.empty() && st.top()==curr){\\n                st.pop();   //pop out one \\n                if (st.empty()) {   //if stack becomes empty before string ends - root is processed\\n                    return false;\\n                }\\n                st.pop();   //done processing this child\\n            }\\n            st.push(curr);   //push the curr char\\n        }\\n        return st.size() == 1 && st.top()==\"#\";\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        if (preorder.empty()) return false;\\n        preorder+=\\',\\';\\n        \\n        int sizeOfTree = 1;\\n        \\n        for(int i=0;i<preorder.size();i++){\\n            if(preorder[i]!=\\',\\')continue;   //process only at commas(ending of node val)\\n            \\n            sizeOfTree--;                   //used one available capacity\\n            if (sizeOfTree<0) return false; //cant accomodate more nodes\\n            \\n            if(preorder[i-1]!=\\'#\\')  //if prev node was non-null - we can add 2 more nodes - right and left\\n                sizeOfTree+=2;\\n        }\\n        return sizeOfTree==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1372467,
                "title": "javascript-recursion-95",
                "content": "\\n\\n```\\n/**\\n * @param {string} preorder\\n * @return {boolean}\\n */\\nvar isValidSerialization = function(preorder) {\\n  if (!preorder) return false;\\n  \\n  const arr = preorder.split(\\',\\');\\n  let idx = 0;\\n  \\n  const traverse = () => {\\n    const val = arr[idx++];\\n    \\n    if (!val) return false;\\n    if (val === \\'#\\') return true;\\n    \\n    let left = traverse();\\n    let right = traverse();\\n    \\n    return left && right;\\n  };\\n\\n  return traverse() && !arr[idx];\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} preorder\\n * @return {boolean}\\n */\\nvar isValidSerialization = function(preorder) {\\n  if (!preorder) return false;\\n  \\n  const arr = preorder.split(\\',\\');\\n  let idx = 0;\\n  \\n  const traverse = () => {\\n    const val = arr[idx++];\\n    \\n    if (!val) return false;\\n    if (val === \\'#\\') return true;\\n    \\n    let left = traverse();\\n    let right = traverse();\\n    \\n    return left && right;\\n  };\\n\\n  return traverse() && !arr[idx];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369910,
                "title": "easy-c-0-ms-100-fast-o-n-solution",
                "content": "```\\nbool isValidSerialization(string s) {\\n        int n=1,i=0;\\n        while(i<s.length()){\\n            if(s[i]==\\',\\'){\\n                i++;\\n                continue;\\n            }\\n            n--;\\n            if(n<0)\\n                return false;\\n            if(s[i]==\\'#\\')\\n                i++;\\n            else{\\n                while(s[i]>=\\'0\\'&&s[i]<=\\'9\\')\\n                    i++;\\n                n+=2;\\n            }\\n        }\\n        return n==0;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nbool isValidSerialization(string s) {\\n        int n=1,i=0;\\n        while(i<s.length()){\\n            if(s[i]==\\',\\'){\\n                i++;\\n                continue;\\n            }\\n            n--;\\n            if(n<0)\\n                return false;\\n            if(s[i]==\\'#\\')\\n                i++;\\n            else{\\n                while(s[i]>=\\'0\\'&&s[i]<=\\'9\\')\\n                    i++;\\n                n+=2;\\n            }\\n        }\\n        return n==0;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1310950,
                "title": "c-binary-tree",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preOrder) {\\n        if(preOrder.size() > 1 and preOrder[0] == \\'#\\')\\n            return false;\\n        if(preOrder.size() == 1 and preOrder[0] == \\'#\\')\\n            return true;\\n        int count = 1;\\n        stringstream ss(preOrder);\\n        string tok;\\n        bool flag = false;\\n        while (getline(ss, tok,\\',\\')) {\\n            if(flag || count < 0)\\n                return false;\\n            if(tok != \"#\")\\n                count++;\\n            else\\n                count--;\\n            if(count == 0)\\n                flag = true;\\n        }\\n        return count == 0 ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preOrder) {\\n        if(preOrder.size() > 1 and preOrder[0] == \\'#\\')\\n            return false;\\n        if(preOrder.size() == 1 and preOrder[0] == \\'#\\')\\n            return true;\\n        int count = 1;\\n        stringstream ss(preOrder);\\n        string tok;\\n        bool flag = false;\\n        while (getline(ss, tok,\\',\\')) {\\n            if(flag || count < 0)\\n                return false;\\n            if(tok != \"#\")\\n                count++;\\n            else\\n                count--;\\n            if(count == 0)\\n                flag = true;\\n        }\\n        return count == 0 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1252806,
                "title": "simple-and-easy-python-solution",
                "content": "Ideahere is  when you see two consecutive \"#\" characters on stack, pop both of them and replace the topmost element on the stack with \"#\".\\nIf there is only one # on stack at the end of the string then return True else return False.\\npreorder = 1,2,3,#,#,#,#\\n```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        \\n        preorder=preorder.split(\",\")\\n        stack=[]\\n        \\n        for node in preorder:\\n            stack.append(node)\\n            \\n            while len(stack)>2 and stack[-1]==\"#\" and stack[-2]==\"#\":\\n                if stack[-3]==\\'#\\':\\n                    return False\\n                stack=stack[:-3]\\n                stack.append(node)\\n        \\n        if len(stack)==1:\\n            if stack[-1]==\"#\":\\n                return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        \\n        preorder=preorder.split(\",\")\\n        stack=[]\\n        \\n        for node in preorder:\\n            stack.append(node)\\n            \\n            while len(stack)>2 and stack[-1]==\"#\" and stack[-2]==\"#\":\\n                if stack[-3]==\\'#\\':\\n                    return False\\n                stack=stack[:-3]\\n                stack.append(node)\\n        \\n        if len(stack)==1:\\n            if stack[-1]==\"#\":\\n                return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239966,
                "title": "single-pass-constant-space-solution",
                "content": "**Approach :**\\n\\nWe just need to remember how many empty slots we have during the process.\\n\\nInitially we have one ( for the root ).\\n\\nfor each node we check if we still have empty slots to put it in.\\n\\na null node occupies one slot.\\na non-null node occupies one slot before he creates two more. the net gain is one.\\n\\n**Complexity :**\\n\\nTime : O(n)\\nSpace O(1) \\n\\n**Implementation** :\\n\\n```\\nclass Solution {\\npublic:\\n    Solution() { ios_base::sync_with_stdio(0); cin.tie(NULL); }\\n    bool isValidSerialization(string preorder) {\\n        int ct = 1,f=0;\\n        for(auto &x:preorder)\\n        {   \\n            if(x>=\\'0\\' && x<=\\'9\\') { f=1; }\\n            else if(ct==0) return false;\\n            else if(x == \\'#\\') { ct--; f=0; }\\n            else if( x==\\',\\' && f==1 ) ct++;\\n        }\\n        return ct==0 ? true : false;\\n    }\\n};\\n```\\n**Upvote if this solution is helpful for you**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    Solution() { ios_base::sync_with_stdio(0); cin.tie(NULL); }\\n    bool isValidSerialization(string preorder) {\\n        int ct = 1,f=0;\\n        for(auto &x:preorder)\\n        {   \\n            if(x>=\\'0\\' && x<=\\'9\\') { f=1; }\\n            else if(ct==0) return false;\\n            else if(x == \\'#\\') { ct--; f=0; }\\n            else if( x==\\',\\' && f==1 ) ct++;\\n        }\\n        return ct==0 ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232655,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<int> s;\\n        for(int i=0; i<preorder.length(); i++){\\n            if(preorder[i]>=\\'0\\' && preorder[i]<=\\'9\\'){\\n               if(i==0)\\n                   s.push(preorder[i]-\\'0\\');\\n               else{\\n                   if(preorder[i-1]==\\',\\')\\n                       s.push(preorder[i]-\\'0\\');\\n                   else{\\n                       s.top() = s.top()*10 + (preorder[i]-\\'0\\');\\n                   }\\n               }\\n            }\\n            else if(preorder[i]==\\'#\\'){\\n                    while(!s.empty() && s.top()==-1){\\n                        s.pop();\\n                        if(!s.empty())\\n                            s.pop();\\n                        else\\n                            return false;\\n                    }\\n                s.push(-1);\\n            }\\n        }\\n        if(s.size()==1){\\n            if(s.top()==-1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<int> s;\\n        for(int i=0; i<preorder.length(); i++){\\n            if(preorder[i]>=\\'0\\' && preorder[i]<=\\'9\\'){\\n               if(i==0)\\n                   s.push(preorder[i]-\\'0\\');\\n               else{\\n                   if(preorder[i-1]==\\',\\')\\n                       s.push(preorder[i]-\\'0\\');\\n                   else{\\n                       s.top() = s.top()*10 + (preorder[i]-\\'0\\');\\n                   }\\n               }\\n            }\\n            else if(preorder[i]==\\'#\\'){\\n                    while(!s.empty() && s.top()==-1){\\n                        s.pop();\\n                        if(!s.empty())\\n                            s.pop();\\n                        else\\n                            return false;\\n                    }\\n                s.push(-1);\\n            }\\n        }\\n        if(s.size()==1){\\n            if(s.top()==-1)\\n                return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1183960,
                "title": "0ms-o-n-time-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<char> s;\\n        int i = preorder.size() - 1;\\n        for (; i >= 0; i --) {\\n            if (preorder[i] == \\',\\') continue;\\n            if (preorder[i] == \\'#\\') s.push(preorder[i]);\\n            else {\\n                if (s.size() < 2) {\\n                    s.push(\\'a\\'); s.push(\\'a\\');\\n                    break;\\n                }\\n                s.pop(); s.pop(); s.push(preorder[i]);\\n                while(i >= 0 && preorder[i] != \\',\\') -- i;\\n            }\\n        }\\n        //cout << s.size() << \"\\\\n\";\\n        return s.size() == 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<char> s;\\n        int i = preorder.size() - 1;\\n        for (; i >= 0; i --) {\\n            if (preorder[i] == \\',\\') continue;\\n            if (preorder[i] == \\'#\\') s.push(preorder[i]);\\n            else {\\n                if (s.size() < 2) {\\n                    s.push(\\'a\\'); s.push(\\'a\\');\\n                    break;\\n                }\\n                s.pop(); s.pop(); s.push(preorder[i]);\\n                while(i >= 0 && preorder[i] != \\',\\') -- i;\\n            }\\n        }\\n        //cout << s.size() << \"\\\\n\";\\n        return s.size() == 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1012687,
                "title": "java-very-concise-recursive-solution-3ms-beats-93",
                "content": "\\n```\\nclass Solution {\\n    private int root = 0;\\n    public boolean isValidSerialization(String preorder) {\\n        String[] arr = preorder.split(\",\");\\n        return isPre(arr) && root == arr.length;\\n    }\\n    \\n    private boolean isPre(String[] arr) {\\n        if (root >= arr.length) return false;\\n        if (arr[root++].equals(\"#\")) return true;\\n        return isPre(arr) && isPre(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int root = 0;\\n    public boolean isValidSerialization(String preorder) {\\n        String[] arr = preorder.split(\",\");\\n        return isPre(arr) && root == arr.length;\\n    }\\n    \\n    private boolean isPre(String[] arr) {\\n        if (root >= arr.length) return false;\\n        if (arr[root++].equals(\"#\")) return true;\\n        return isPre(arr) && isPre(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895556,
                "title": "c-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int j=0,n=s.length();\\n        if(s.length()==0 || (s.length()==1 && s[0]==\\'#\\')) return true;\\n        if(s[0]==\\'#\\') return false;\\n        queue<int> q;\\n        q.push(1);\\n        while(j<n && s[j]!=\\',\\') j++;\\n        while(!q.empty()){\\n            j++;\\n            if(j>=s.length()) return false;\\n            q.pop();\\n            if(s[j]==\\'#\\') j++;\\n            else{\\n                q.push(1);\\n                while(j<n && s[j]!=\\',\\') j++;\\n            }\\n            j++;\\n            if(j>=s.length()) return false;\\n            if(s[j]==\\'#\\') j++;\\n            else{\\n                q.push(1);\\n                while(j<n && s[j]!=\\',\\') j++;\\n            }\\n        }\\n        if(j<s.length()-1) return false;\\n        return true;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValidSerialization(string s) {\\n        int j=0,n=s.length();\\n        if(s.length()==0 || (s.length()==1 && s[0]==\\'#\\')) return true;\\n        if(s[0]==\\'#\\') return false;\\n        queue<int> q;\\n        q.push(1);\\n        while(j<n && s[j]!=\\',\\') j++;\\n        while(!q.empty()){\\n            j++;\\n            if(j>=s.length()) return false;\\n            q.pop();\\n            if(s[j]==\\'#\\') j++;\\n            else{\\n                q.push(1);\\n                while(j<n && s[j]!=\\',\\') j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 872194,
                "title": "0ms-better-than-100-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string&s) {\\n        int cnt=1,i=0,sz=s.size();\\nwhile(i<sz){\\n  if(s[i]!=\\',\\'){\\n  if(!cnt)\\n    return false;\\n  if(s[i]==\\'#\\')\\n    --cnt;\\n  else{\\n    while(i<sz and s[i]!=\\',\\')\\n      ++i;\\n     ++cnt;\\n  }\\n}\\n++i;\\n}\\nreturn !cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string&s) {\\n        int cnt=1,i=0,sz=s.size();\\nwhile(i<sz){\\n  if(s[i]!=\\',\\'){\\n  if(!cnt)\\n    return false;\\n  if(s[i]==\\'#\\')\\n    --cnt;\\n  else{\\n    while(i<sz and s[i]!=\\',\\')\\n      ++i;\\n     ++cnt;\\n  }\\n}\\n++i;\\n}\\nreturn !cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846064,
                "title": "simple-python-solution",
                "content": "```\\ndef isValidSerialization(self, preorder):\\n        \"\"\"\\n        :type preorder: str\\n        :rtype: bool\\n        \"\"\"\\n    \\n        n = len(preorder)\\n        spots = 1\\n        num = 0\\n        i = 0\\n        while i < n:\\n            if spots <= 0:    \\n                return False\\n            if preorder[i] == \",\":\\n                i+=1\\n                continue\\n\\n            if preorder[i].isdigit():\\n                while i!=n-1 and preorder[i+1].isdigit():\\n                    i+=1\\n                spots+=2\\n                                    \\n            spots-=1\\n            i+=1\\n    \\n        return spots == 0\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\ndef isValidSerialization(self, preorder):\\n        \"\"\"\\n        :type preorder: str\\n        :rtype: bool\\n        \"\"\"\\n    \\n        n = len(preorder)\\n        spots = 1\\n        num = 0\\n        i = 0\\n        while i < n:\\n            if spots <= 0:    \\n                return False\\n            if preorder[i] == \",\":\\n                i+=1\\n                continue\\n\\n            if preorder[i].isdigit():\\n                while i!=n-1 and preorder[i+1].isdigit():\\n                    i+=1\\n                spots+=2\\n                                    \\n            spots-=1\\n            i+=1\\n    \\n        return spots == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 780538,
                "title": "c-very-intuitive-recursive-solution",
                "content": "```\\nclass Solution {\\n    int index;\\n    \\n    void helper(int& index, vector<string>& nodes) {\\n        if (index >= nodes.size())\\n            return;\\n        \\n        if (nodes[index] == \"#\") // null node\\n            return;\\n        \\n        helper(++index, nodes); // left subtree\\n        helper(++index, nodes); // right subtree\\n    }\\n    \\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stringstream ss(preorder);\\n        string ch;\\n        vector<string> nodes;\\n        \\n        while(getline(ss, ch, \\',\\'))\\n            nodes.push_back(ch);\\n        \\n        index = 0;\\n        \\n        helper(index, nodes);\\n        \\n        return index == nodes.size() - 1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    int index;\\n    \\n    void helper(int& index, vector<string>& nodes) {\\n        if (index >= nodes.size())\\n            return;\\n        \\n        if (nodes[index] == \"#\") // null node\\n            return;\\n        \\n        helper(++index, nodes); // left subtree\\n        helper(++index, nodes); // right subtree\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 723961,
                "title": "reducing-the-string-like-a-parser-would-parse-a-grammar-not-the-fastest-way-c",
                "content": "This solution is NOT the most efficient, but it emulates a parser parsing a grammar and reducing a parse tree. If its not able to reduce, then the tree is not valid. It uses a stack.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<string> st;\\n        \\n        stringstream ss(preorder);\\n        string curr;\\n        \\n        \\n        while(getline(ss, curr, \\',\\'))\\n        {\\n            st.push(curr);\\n            while(st.size() >= 3)\\n            {\\n                string one,two,three;\\n                one = st.top();\\n                st.pop();\\n                \\n                two = st.top();\\n                st.pop();\\n                \\n                three = st.top();\\n                st.pop();\\n                \\n                // cout<<three<<\":\"<<two<<\":\"<<one<<endl;\\n                \\n                if(one == two && two==\"#\" && three != \"#\")\\n                {\\n                    st.push(\"#\");\\n                    continue;\\n                }\\n                    \\n                \\n                st.push(three);\\n                st.push(two);\\n                st.push(one);\\n                break;\\n            }\\n        }\\n        if(st.size()==1 && st.top()==\"#\")\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        stack<string> st;\\n        \\n        stringstream ss(preorder);\\n        string curr;\\n        \\n        \\n        while(getline(ss, curr, \\',\\'))\\n        {\\n            st.push(curr);\\n            while(st.size() >= 3)\\n            {\\n                string one,two,three;\\n                one = st.top();\\n                st.pop();\\n                \\n                two = st.top();\\n                st.pop();\\n                \\n                three = st.top();\\n                st.pop();\\n                \\n                // cout<<three<<\":\"<<two<<\":\"<<one<<endl;\\n                \\n                if(one == two && two==\"#\" && three != \"#\")\\n                {\\n                    st.push(\"#\");\\n                    continue;\\n                }\\n                    \\n                \\n                st.push(three);\\n                st.push(two);\\n                st.push(one);\\n                break;\\n            }\\n        }\\n        if(st.size()==1 && st.top()==\"#\")\\n            return true;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 645656,
                "title": "c-easy-solution-only-with-single-count-100-time-and-100-space",
                "content": "```\\n bool isValidSerialization(string pre) {\\n        if(pre.size() == 0 || (pre[0]==\\'#\\' && pre.size()>1))\\n            return false;\\n        if(pre[0]==\\'#\\')\\n            return true;\\n        int i=0 ,j,count=2;\\n        while(i<pre.size() && pre[i] != \\',\\')\\n                i++;\\n        \\n        for(;i<pre.size();i++){\\n\\n            while(i<pre.size()-1 && pre[i+1] !=\\',\\')\\n                i++;\\n        \\n            if(pre[i]!=\\'#\\' && count==0)\\n                return false;\\n            else if(pre[i]!=\\'#\\')\\n                count++;\\n            else\\n                count--;\\n        }\\n        if(count!=0)\\n            return false;\\n        return true; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n bool isValidSerialization(string pre) {\\n        if(pre.size() == 0 || (pre[0]==\\'#\\' && pre.size()>1))\\n            return false;\\n        if(pre[0]==\\'#\\')\\n            return true;\\n        int i=0 ,j,count=2;\\n        while(i<pre.size() && pre[i] != \\',\\')\\n                i++;\\n        \\n        for(;i<pre.size();i++){\\n\\n            while(i<pre.size()-1 && pre[i+1] !=\\',\\')\\n                i++;\\n        \\n            if(pre[i]!=\\'#\\' && count==0)\\n                return false;\\n            else if(pre[i]!=\\'#\\')\\n                count++;\\n            else\\n                count--;\\n        }\\n        if(count!=0)\\n            return false;\\n        return true; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 573905,
                "title": "c-without-using-stack",
                "content": "The basic idea is a stack would be empty and only a single # will remain at the end so, we know that it is valid preorder. Instead of stack as we are not using those value we can simply use cnt for that purpose.\\n```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        vector <string> v;\\n        string tmp=\"\";\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]==\\',\\')\\n            {\\n                v.push_back(tmp);\\n                tmp = \"\";\\n            }\\n            else\\n                tmp += preorder[i];\\n        }\\n        v.push_back(tmp);\\n        int i=0,cnt=0;\\n        for(i=0;i<v.size();i++)\\n        {\\n            if(v[i]==\"#\")\\n            {\\n                if(cnt<=0)\\n                    break;\\n                cnt--;\\n            }\\n            else\\n                cnt++;\\n        }\\n        if(i==v.size()-1 && cnt==0)\\n            return 1;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValidSerialization(string preorder) {\\n        vector <string> v;\\n        string tmp=\"\";\\n        for(int i=0;i<preorder.size();i++)\\n        {\\n            if(preorder[i]==\\',\\')\\n            {\\n                v.push_back(tmp);\\n                tmp = \"\";\\n            }\\n            else\\n                tmp += preorder[i];\\n        }\\n        v.push_back(tmp);\\n        int i=0,cnt=0;\\n        for(i=0;i<v.size();i++)\\n        {\\n            if(v[i]==\"#\")\\n            {\\n                if(cnt<=0)\\n                    break;\\n                cnt--;\\n            }\\n            else\\n                cnt++;\\n        }\\n        if(i==v.size()-1 && cnt==0)\\n            return 1;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 511084,
                "title": "python3-two-simple-solutions",
                "content": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        \"\"\"\\n        O(n) time, O(1) space\\n        \"\"\"\\n        valid=1\\n        for char in preorder:\\n            if char==\",\":\\n                valid-=1\\n                if valid<0: return False\\n                if prev!=\"#\": valid+=2\\n            prev=char\\n        if char!=\"#\": valid+=1\\n        else: valid-=1\\n        return True if valid==0 else False\\n    \\n    def isValidSerialization1(self, preorder: str) -> bool:\\n        \"\"\"\\n        O(n) time, O(n) space\\n        \"\"\"\\n        valid=1\\n        for node in preorder.split(\",\"):\\n            valid-=1\\n            if valid<0: return False\\n            if node!=\"#\": valid+=2\\n        return True if valid==0 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        \"\"\"\\n        O(n) time, O(1) space\\n        \"\"\"\\n        valid=1\\n        for char in preorder:\\n            if char==\",\":\\n                valid-=1\\n                if valid<0: return False\\n                if prev!=\"#\": valid+=2\\n            prev=char\\n        if char!=\"#\": valid+=1\\n        else: valid-=1\\n        return True if valid==0 else False\\n    \\n    def isValidSerialization1(self, preorder: str) -> bool:\\n        \"\"\"\\n        O(n) time, O(n) space\\n        \"\"\"\\n        valid=1\\n        for node in preorder.split(\",\"):\\n            valid-=1\\n            if valid<0: return False\\n            if node!=\"#\": valid+=2\\n        return True if valid==0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445670,
                "title": "java-easy-iterative-solution",
                "content": "If you are here, try implementing an iterative solution without converting into char array. It improves memory utilization from linear to constant.\\n```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        final String _hash = \"#\";\\n   \\n        int count = 1;\\n        for(String n : nodes) {\\n            count--;\\n            if(count < 0)\\n                return false;\\n            if(!n.equals(_hash))\\n                count += 2;\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValidSerialization(String preorder) {\\n        String[] nodes = preorder.split(\",\");\\n        final String _hash = \"#\";\\n   \\n        int count = 1;\\n        for(String n : nodes) {\\n            count--;\\n            if(count < 0)\\n                return false;\\n            if(!n.equals(_hash))\\n                count += 2;\\n        }\\n        \\n        return count == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 417915,
                "title": "python-super-simple-o-n-time-o-1-memory",
                "content": "```\\ndef isValidSerialization(self, preorder: str) -> bool:\\n\\tnodes = preorder.split(\",\")\\n\\tnul_nodes = 1\\n\\tfor node in nodes:\\n\\t\\tif node == \"#\":\\n\\t\\t\\tnul_nodes -=1\\n\\t\\telse:\\n\\t\\t\\tnul_nodes += 1\\n\\t\\t\\tif nul_nodes == 1:\\n\\t\\t\\t\\treturn False\\n\\treturn nul_nodes == 0\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef isValidSerialization(self, preorder: str) -> bool:\\n\\tnodes = preorder.split(\",\")\\n\\tnul_nodes = 1\\n\\tfor node in nodes:\\n\\t\\tif node == \"#\":\\n\\t\\t\\tnul_nodes -=1\\n\\t\\telse:\\n\\t\\t\\tnul_nodes += 1\\n\\t\\t\\tif nul_nodes == 1:\\n\\t\\t\\t\\treturn False\\n\\treturn nul_nodes == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 329756,
                "title": "java-preorder-traversal-faster-than-97-6",
                "content": "Deserialize tree using global index variable. \\nThe index should be equal to the length of the array got from splitting the initial string. If its not, then you either have too few array elements, or possibly a \"#\" non-leaf node\\n```\\nclass Solution {\\n    \\n    int index = 0;\\n    public boolean isValidSerialization(String preorder) {\\n        String[]sarr = preorder.split(\",\");\\n        preorder(sarr);\\n        if (index != sarr.length - 1) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    private String preorder(String[]sarr) {\\n        if (index >= sarr.length || sarr[index].equals(\"#\")) {\\n            return null;\\n        }\\n        \\n        String node = sarr[index];\\n        \\n        index++;\\n        preorder(sarr);\\n        \\n        index++;\\n        preorder(sarr);\\n        \\n        return node;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int index = 0;\\n    public boolean isValidSerialization(String preorder) {\\n        String[]sarr = preorder.split(\",\");\\n        preorder(sarr);\\n        if (index != sarr.length - 1) {\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 326713,
                "title": "python-just-traverse-beats-97-93",
                "content": "```python\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        def verify():\\n            if next(g) != \\'#\\':\\n                verify()\\n                verify()\\n            \\n        g = iter(preorder.split(\\',\\'))\\n        \\n        try:\\n            verify()\\n        except StopIteration:\\n            return False\\n        \\n        try:\\n            next(g)\\n            return False\\n        except StopIteration:\\n            return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValidSerialization(self, preorder: str) -> bool:\\n        def verify():\\n            if next(g) != \\'#\\':\\n                verify()\\n                verify()\\n            \\n        g = iter(preorder.split(\\',\\'))\\n        \\n        try:\\n            verify()\\n        except StopIteration:\\n            return False\\n        \\n        try:\\n            next(g)\\n            return False\\n        except StopIteration:\\n            return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323998,
                "title": "very-simple-dfs-java-solution",
                "content": "I used to do this using a stack, but then I realized I could simply do a \"DFS walk\" over the array which produces a simpler solution, which beats 97%.\\n\\n```\\npublic boolean isValidSerialization(String preorder) {\\n\\tint[] idx = new int[1];\\n\\tString[] tokens = preorder.split(\",\");\\n\\treturn dfs(tokens, idx) && idx[0] == tokens.length;\\n}\\n\\nboolean dfs(String[] preorder, int[] idx){\\n\\tint i = idx[0];\\n\\tif (i == preorder.length) return false;\\n\\tString cur = preorder[i];\\n\\tidx[0]++;\\n\\tif (\"#\".equals(cur)) return true;\\n\\treturn dfs(preorder, idx) && dfs(preorder, idx);\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\npublic boolean isValidSerialization(String preorder) {\\n\\tint[] idx = new int[1];\\n\\tString[] tokens = preorder.split(\",\");\\n\\treturn dfs(tokens, idx) && idx[0] == tokens.length;\\n}\\n\\nboolean dfs(String[] preorder, int[] idx){\\n\\tint i = idx[0];\\n\\tif (i == preorder.length) return false;\\n\\tString cur = preorder[i];\\n\\tidx[0]++;\\n\\tif (\"#\".equals(cur)) return true;\\n\\treturn dfs(preorder, idx) && dfs(preorder, idx);\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1571591,
                "content": [
                    {
                        "username": "bottomc0der",
                        "content": "I submitted my solution yesterday. It was accepted, appearing on my submissions list. Today I am encountering some resistance: My solution is missing from my submissions list, even after I relog and refresh the page.\\n\\nI resubmitted, again getting an accept. However, clicking on \"More Details\" leads to \"The requested URL /submissions/detail/89452380/ was not found on this server.\" This continues to happen each time I resubmit -- i.e., I get acceptance, but the problem does not appear on my submissions list.\\n\\nIs the gremlin on my end or on the site? Thanks for any suggestions."
                    },
                    {
                        "username": "JaninBV",
                        "content": "Under the Constraints, it says \"preoder\" instead \"Preorder\""
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: how can we decide whether a number or a '# ' is the left node or the right node? For a valid tree, the number of left and right nodes should be the same, and left nodes always come first. "
                    }
                ]
            },
            {
                "id": 1570570,
                "content": [
                    {
                        "username": "bottomc0der",
                        "content": "I submitted my solution yesterday. It was accepted, appearing on my submissions list. Today I am encountering some resistance: My solution is missing from my submissions list, even after I relog and refresh the page.\\n\\nI resubmitted, again getting an accept. However, clicking on \"More Details\" leads to \"The requested URL /submissions/detail/89452380/ was not found on this server.\" This continues to happen each time I resubmit -- i.e., I get acceptance, but the problem does not appear on my submissions list.\\n\\nIs the gremlin on my end or on the site? Thanks for any suggestions."
                    },
                    {
                        "username": "JaninBV",
                        "content": "Under the Constraints, it says \"preoder\" instead \"Preorder\""
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: how can we decide whether a number or a '# ' is the left node or the right node? For a valid tree, the number of left and right nodes should be the same, and left nodes always come first. "
                    }
                ]
            },
            {
                "id": 1852464,
                "content": [
                    {
                        "username": "bottomc0der",
                        "content": "I submitted my solution yesterday. It was accepted, appearing on my submissions list. Today I am encountering some resistance: My solution is missing from my submissions list, even after I relog and refresh the page.\\n\\nI resubmitted, again getting an accept. However, clicking on \"More Details\" leads to \"The requested URL /submissions/detail/89452380/ was not found on this server.\" This continues to happen each time I resubmit -- i.e., I get acceptance, but the problem does not appear on my submissions list.\\n\\nIs the gremlin on my end or on the site? Thanks for any suggestions."
                    },
                    {
                        "username": "JaninBV",
                        "content": "Under the Constraints, it says \"preoder\" instead \"Preorder\""
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: how can we decide whether a number or a '# ' is the left node or the right node? For a valid tree, the number of left and right nodes should be the same, and left nodes always come first. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Encode N-ary Tree to Binary Tree",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1569314,
                "content": [
                    {
                        "username": "wayettt",
                        "content": "The solutions all look pretty cool, and I am sure there are more than one solution to solve this, as long as you could encode and decode and get the same N-ary tree.\\nBut I am wondering what the practical usage of this question. \\nThanks! "
                    },
                    {
                        "username": "SACD",
                        "content": "Is this example meaningful?"
                    }
                ]
            },
            {
                "id": 2069501,
                "content": [
                    {
                        "username": "wayettt",
                        "content": "The solutions all look pretty cool, and I am sure there are more than one solution to solve this, as long as you could encode and decode and get the same N-ary tree.\\nBut I am wondering what the practical usage of this question. \\nThanks! "
                    },
                    {
                        "username": "SACD",
                        "content": "Is this example meaningful?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Lonely Pixel I",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1566091,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "Am just curious, as there is a somewhat similar problem (set matrix zeros) that can be done in O(1) space. Did anyone get this problem in an interview, and if so, were you asked to do it in O(1) space?"
                    },
                    {
                        "username": "desio",
                        "content": "Yes, but O(1) *extra* space. You can use the first row and first col of the input, and then an extra variable for the overlapping top-left cell."
                    },
                    {
                        "username": "karkisa",
                        "content": "Its a simple question. \\nNo need for graph, dfs, bfs. nothing.\\nnested for loops are encouraged. "
                    }
                ]
            },
            {
                "id": 1956752,
                "content": [
                    {
                        "username": "IWantToPass",
                        "content": "Am just curious, as there is a somewhat similar problem (set matrix zeros) that can be done in O(1) space. Did anyone get this problem in an interview, and if so, were you asked to do it in O(1) space?"
                    },
                    {
                        "username": "desio",
                        "content": "Yes, but O(1) *extra* space. You can use the first row and first col of the input, and then an extra variable for the overlapping top-left cell."
                    },
                    {
                        "username": "karkisa",
                        "content": "Its a simple question. \\nNo need for graph, dfs, bfs. nothing.\\nnested for loops are encouraged. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Smallest Range Covering Elements from K Lists",
        "question_content": "<p>You have <code>k</code> lists of sorted integers in <strong>non-decreasing&nbsp;order</strong>. Find the <b>smallest</b> range that includes at least one number from each of the <code>k</code> lists.</p>\n\n<p>We define the range <code>[a, b]</code> is smaller than range <code>[c, d]</code> if <code>b - a &lt; d - c</code> <strong>or</strong> <code>a &lt; c</code> if <code>b - a == d - c</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\n<strong>Output:</strong> [20,24]\n<strong>Explanation: </strong>\nList 1: [4, 10, 15, 24,26], 24 is in range [20,24].\nList 2: [0, 9, 12, 20], 20 is in range [20,24].\nList 3: [5, 18, 22, 30], 22 is in range [20,24].\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1,2,3],[1,2,3],[1,2,3]]\n<strong>Output:</strong> [1,1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>nums.length == k</code></li>\n\t<li><code>1 &lt;= k &lt;= 3500</code></li>\n\t<li><code>1 &lt;= nums[i].length &lt;= 50</code></li>\n\t<li><code>-10<sup>5</sup> &lt;= nums[i][j] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>nums[i]</code>&nbsp;is sorted in <strong>non-decreasing</strong> order.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 104904,
                "title": "python-heap-based-solution",
                "content": "```\\ndef smallestRange(self, A):\\n    pq = [(row[0], i, 0) for i, row in enumerate(A)]\\n    heapq.heapify(pq)\\n    \\n    ans = -1e9, 1e9\\n    right = max(row[0] for row in A)\\n    while pq:\\n        left, i, j = heapq.heappop(pq)\\n        if right - left < ans[1] - ans[0]:\\n            ans = left, right\\n        if j + 1 == len(A[i]):\\n            return ans\\n        v = A[i][j+1]\\n        right = max(right, v)\\n        heapq.heappush(pq, (v, i, j+1))\\n```\\n\\nKeep a heap of the smallest elements.  As we pop element A[i][j], we'll replace it with A[i][j+1].  For each such element ```left```, we want ```right```, the maximum of the closest value in each row of the array that is ```>= left```, which is also equal to the current maximum of our heap.  We'll keep track of ```right``` as we proceed.\\n\\n*Edited with thanks to @StefanPochmann*",
                "solutionTags": [],
                "code": "```\\ndef smallestRange(self, A):\\n    pq = [(row[0], i, 0) for i, row in enumerate(A)]\\n    heapq.heapify(pq)\\n    \\n    ans = -1e9, 1e9\\n    right = max(row[0] for row in A)\\n    while pq:\\n        left, i, j = heapq.heappop(pq)\\n        if right - left < ans[1] - ans[0]:\\n            ans = left, right\\n        if j + 1 == len(A[i]):\\n            return ans\\n        v = A[i][j+1]\\n        right = max(right, v)\\n        heapq.heappush(pq, (v, i, j+1))\\n```\n```left```\n```right```\n```>= left```\n```right```",
                "codeTag": "Python3"
            },
            {
                "id": 104893,
                "title": "java-code-using-priorityqueue-similar-to-merge-k-array",
                "content": "Image you are merging k sorted array using a heap. Then everytime you pop the smallest element out and add the next element of that array to the heap. By keep doing this, you will have the smallest range. \\n\\n```\\npublic int[] smallestRange(int[][] nums) {\\n\\t\\tPriorityQueue<Element> pq = new PriorityQueue<Element>(new Comparator<Element>() {\\n\\t\\t\\tpublic int compare(Element a, Element b) {\\n\\t\\t\\t\\treturn a.val - b.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tElement e = new Element(i, 0, nums[i][0]);\\n\\t\\t\\tpq.offer(e);\\n\\t\\t\\tmax = Math.max(max, nums[i][0]);\\n\\t\\t}\\n\\t\\tint range = Integer.MAX_VALUE;\\n\\t\\tint start = -1, end = -1;\\n\\t\\twhile (pq.size() == nums.length) {\\n\\n\\t\\t\\tElement curr = pq.poll();\\n\\t\\t\\tif (max - curr.val < range) {\\n\\t\\t\\t\\trange = max - curr.val;\\n\\t\\t\\t\\tstart = curr.val;\\n\\t\\t\\t\\tend = max;\\n\\t\\t\\t}\\n\\t\\t\\tif (curr.idx + 1 < nums[curr.row].length) {\\n\\t\\t\\t\\tcurr.idx = curr.idx + 1;\\n\\t\\t\\t\\tcurr.val = nums[curr.row][curr.idx];\\n\\t\\t\\t\\tpq.offer(curr);\\n\\t\\t\\t\\tif (curr.val > max) {\\n\\t\\t\\t\\t\\tmax = curr.val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[] { start, end };\\n\\t}\\n\\n\\tclass Element {\\n\\t\\tint val;\\n\\t\\tint idx;\\n\\t\\tint row;\\n\\n\\t\\tpublic Element(int r, int i, int v) {\\n\\t\\t\\tval = v;\\n\\t\\t\\tidx = i;\\n\\t\\t\\trow = r;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallestRange(int[][] nums) {\\n\\t\\tPriorityQueue<Element> pq = new PriorityQueue<Element>(new Comparator<Element>() {\\n\\t\\t\\tpublic int compare(Element a, Element b) {\\n\\t\\t\\t\\treturn a.val - b.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tElement e = new Element(i, 0, nums[i][0]);\\n\\t\\t\\tpq.offer(e);\\n\\t\\t\\tmax = Math.max(max, nums[i][0]);\\n\\t\\t}\\n\\t\\tint range = Integer.MAX_VALUE;\\n\\t\\tint start = -1, end = -1;\\n\\t\\twhile (pq.size() == nums.length) {\\n\\n\\t\\t\\tElement curr = pq.poll();\\n\\t\\t\\tif (max - curr.val < range) {\\n\\t\\t\\t\\trange = max - curr.val;\\n\\t\\t\\t\\tstart = curr.val;\\n\\t\\t\\t\\tend = max;\\n\\t\\t\\t}\\n\\t\\t\\tif (curr.idx + 1 < nums[curr.row].length) {\\n\\t\\t\\t\\tcurr.idx = curr.idx + 1;\\n\\t\\t\\t\\tcurr.val = nums[curr.row][curr.idx];\\n\\t\\t\\t\\tpq.offer(curr);\\n\\t\\t\\t\\tif (curr.val > max) {\\n\\t\\t\\t\\t\\tmax = curr.val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn new int[] { start, end };\\n\\t}\\n\\n\\tclass Element {\\n\\t\\tint val;\\n\\t\\tint idx;\\n\\t\\tint row;\\n\\n\\t\\tpublic Element(int r, int i, int v) {\\n\\t\\t\\tval = v;\\n\\t\\t\\tidx = i;\\n\\t\\t\\trow = r;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624185,
                "title": "c-sliding-window-easy-solution",
                "content": "Firstly we merge k groups to one group, each number recoard it\\'s group, eg:\\n\\n[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\\n\\nafter merged we got\\uFF1A\\n[(0, 1), (4, 0), (5, 2), (9, 1), (10, 0), (12, 1), (15, 0), (18, 2), (20, 1), (22, 2), (24, 0), (26, 0), (30, 2)]\\n\\nand see only group, it\\'s\\n[1, 0, 2, 1, 0, 1, 0, 2, 1, 2, 0, 0, 2]\\n\\nwe can slide window by group when current groups satifies condition and recoard min range.\\n```\\n[1 0 2] 2 1 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 [0 2 1] 1 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0] 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0 1] 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0 1 0] 0 2 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 [1 0 2] 2 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 [0 2 1] 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 [0 2 1 2] 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 0 2 [1 2 0] 0 0 2    [20, 24]\\n1 0 2 1 0 1 0 2 [1 2 0 0] 0 2    [20, 24]\\n1 0 2 1 0 1 0 2 [1 2 0 0 2] 2    [20, 24]\\n```\\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> ordered; // (number, group)\\n        for (size_t k = 0; k < nums.size(); ++k)\\n            for (auto n: nums[k]) ordered.push_back({n, k});\\n        sort(ordered.begin(), ordered.end());\\n\\n        int i = 0, k = 0;\\n        vector<int> ans;\\n        unordered_map<int, int> count;\\n        for (size_t j = 0; j < ordered.size(); ++j) {\\n            if (! count[ordered[j].second]++) ++k;\\n            if (k == nums.size()) { \\n                while (count[ordered[i].second] > 1) --count[ordered[i++].second]; // minialize range\\n                if (ans.empty() || ans[1] - ans[0] > ordered[j].first - ordered[i].first) {\\n                    ans = vector<int>{ordered[i].first, ordered[j].first};\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n[1 0 2] 2 1 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 [0 2 1] 1 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0] 0 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0 1] 1 0 2 1 2 0 0 2    [0, 5]\\n1 0 [2 1 0 1 0] 0 2 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 [1 0 2] 2 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 [0 2 1] 1 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 [0 2 1 2] 2 0 0 2    [0, 5]\\n1 0 2 1 0 1 0 2 [1 2 0] 0 0 2    [20, 24]\\n1 0 2 1 0 1 0 2 [1 2 0 0] 0 2    [20, 24]\\n1 0 2 1 0 1 0 2 [1 2 0 0 2] 2    [20, 24]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> ordered; // (number, group)\\n        for (size_t k = 0; k < nums.size(); ++k)\\n            for (auto n: nums[k]) ordered.push_back({n, k});\\n        sort(ordered.begin(), ordered.end());\\n\\n        int i = 0, k = 0;\\n        vector<int> ans;\\n        unordered_map<int, int> count;\\n        for (size_t j = 0; j < ordered.size(); ++j) {\\n            if (! count[ordered[j].second]++) ++k;\\n            if (k == nums.size()) { \\n                while (count[ordered[i].second] > 1) --count[ordered[i++].second]; // minialize range\\n                if (ans.empty() || ans[1] - ans[0] > ordered[j].first - ordered[i].first) {\\n                    ans = vector<int>{ordered[i].first, ordered[j].first};\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104886,
                "title": "clean-c-priority-queue-solution-using-iterators",
                "content": "Yes. The idea is just similar to Merge K Sorted List. Keep a priority queue of iterators/pointers which points to the current head of a row.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        typedef vector<int>::iterator vi;\\n        \\n        struct comp {\\n            bool operator()(pair<vi, vi> p1, pair<vi, vi> p2) {\\n                return *p1.first > *p2.first;\\n            }\\n        };\\n        \\n        int lo = INT_MAX, hi = INT_MIN;\\n        priority_queue<pair<vi, vi>, vector<pair<vi, vi>>, comp> pq;\\n        for (auto &row : nums) {\\n            lo = min(lo, row[0]);\\n            hi = max(hi, row[0]);\\n            pq.push({row.begin(), row.end()});\\n        }\\n        \\n        vector<int> ans = {lo, hi};\\n        while (true) {\\n            auto p = pq.top();\\n            pq.pop();\\n            ++p.first;\\n            if (p.first == p.second)\\n                break;\\n            pq.push(p);\\n            \\n            lo = *pq.top().first;\\n            hi = max(hi, *p.first);\\n            if (hi - lo < ans[1] - ans[0])\\n                ans = {lo, hi};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        typedef vector<int>::iterator vi;\\n        \\n        struct comp {\\n            bool operator()(pair<vi, vi> p1, pair<vi, vi> p2) {\\n                return *p1.first > *p2.first;\\n            }\\n        };\\n        \\n        int lo = INT_MAX, hi = INT_MIN;\\n        priority_queue<pair<vi, vi>, vector<pair<vi, vi>>, comp> pq;\\n        for (auto &row : nums) {\\n            lo = min(lo, row[0]);\\n            hi = max(hi, row[0]);\\n            pq.push({row.begin(), row.end()});\\n        }\\n        \\n        vector<int> ans = {lo, hi};\\n        while (true) {\\n            auto p = pq.top();\\n            pq.pop();\\n            ++p.first;\\n            if (p.first == p.second)\\n                break;\\n            pq.push(p);\\n            \\n            lo = *pq.top().first;\\n            hi = max(hi, *p.first);\\n            if (hi - lo < ans[1] - ans[0])\\n                ans = {lo, hi};\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258013,
                "title": "python-sliding-window-easy-to-understand",
                "content": "First we concentrate all the lists in nums together. When doing that, we bind the list-id with each number. For example, if the nums is [[3,5], [6,7], [9]], the concentrated list is [[3,0], [5,0], [6,1], [7,1], [9,2]]. Now the original problem becomes a sliding window problem. Our task is find the shortest subarray (the start point and end point) which contains exactly K=len(nums) kinds of elements. \\n\\nWe keep tow pointer left and right. We update left pointer by left++ only when the current window contains K kinds of list-id (In this case we need to make the window shorter since it already contains K kinds of list-id). And let right pointer be the current number index we are visiting. \\n```\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        d = []\\n        K = len(nums)\\n        count = collections.defaultdict(int)\\n        for i, num in enumerate(nums):\\n            for n in num:\\n                d.append([n, i])\\n        d.sort(key=lambda x: x[0])\\n        #print d\\n        res = []\\n        left = 0\\n        for right, n in enumerate(d):\\n            count[n[1]] += 1\\n            while len(count)==K:\\n                if not res or d[right][0]-d[left][0]<res[1]-res[0]:\\n                    res = [d[left][0], d[right][0]]\\n                count[d[left][1]] -= 1\\n                if count[d[left][1]]==0:\\n                    count.pop(d[left][1])\\n                left += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        d = []\\n        K = len(nums)\\n        count = collections.defaultdict(int)\\n        for i, num in enumerate(nums):\\n            for n in num:\\n                d.append([n, i])\\n        d.sort(key=lambda x: x[0])\\n        #print d\\n        res = []\\n        left = 0\\n        for right, n in enumerate(d):\\n            count[n[1]] += 1\\n            while len(count)==K:\\n                if not res or d[right][0]-d[left][0]<res[1]-res[0]:\\n                    res = [d[left][0], d[right][0]]\\n                count[d[left][1]] -= 1\\n                if count[d[left][1]]==0:\\n                    count.pop(d[left][1])\\n                left += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180839,
                "title": "c-99-priority-queue-easy-to-explain-and-impl-in-10mins-cheers",
                "content": "```\\n#include <vector>\\n#include <queue>\\n#include <limits>\\n\\nusing namespace std;\\n\\nstruct Item {\\n    int val;\\n    int r;\\n    int c;\\n    \\n    Item(int val, int r, int c): val(val), r(r), c(c) {\\n    }\\n};\\n\\nstruct Comp {\\n    bool operator() (const Item& it1, const Item& it2) {\\n        return it2.val < it1.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<Item, vector<Item>, Comp> pq;\\n        \\n        int high = numeric_limits<int>::min();\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            pq.push(Item(nums[i][0], i, 0));\\n            high = max(high , nums[i][0]);\\n        }\\n        int low = pq.top().val;\\n        \\n        vector<int> res{low, high};\\n        \\n        while (pq.size() == (size_t)n) {\\n            auto it = pq.top();\\n            pq.pop();\\n            \\n            if ((size_t)it.c + 1 < nums[it.r].size()) {\\n                pq.push(Item(nums[it.r][it.c + 1], it.r, it.c + 1));\\n                high = max(high, nums[it.r][it.c + 1]);\\n                low = pq.top().val;\\n                if (high - low < res[1] - res[0]) {\\n                    res[0] = low;\\n                    res[1] = high;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <vector>\\n#include <queue>\\n#include <limits>\\n\\nusing namespace std;\\n\\nstruct Item {\\n    int val;\\n    int r;\\n    int c;\\n    \\n    Item(int val, int r, int c): val(val), r(r), c(c) {\\n    }\\n};\\n\\nstruct Comp {\\n    bool operator() (const Item& it1, const Item& it2) {\\n        return it2.val < it1.val;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<Item, vector<Item>, Comp> pq;\\n        \\n        int high = numeric_limits<int>::min();\\n        int n = nums.size();\\n        for (int i = 0; i < n; ++i) {\\n            pq.push(Item(nums[i][0], i, 0));\\n            high = max(high , nums[i][0]);\\n        }\\n        int low = pq.top().val;\\n        \\n        vector<int> res{low, high};\\n        \\n        while (pq.size() == (size_t)n) {\\n            auto it = pq.top();\\n            pq.pop();\\n            \\n            if ((size_t)it.c + 1 < nums[it.r].size()) {\\n                pq.push(Item(nums[it.r][it.c + 1], it.r, it.c + 1));\\n                high = max(high, nums[it.r][it.c + 1]);\\n                low = pq.top().val;\\n                if (high - low < res[1] - res[0]) {\\n                    res[0] = low;\\n                    res[1] = high;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 869071,
                "title": "c-priority-queue-simple-solution",
                "content": "```\\ntypedef pair<int, pair<int, int>> pi;\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        int mn = INT_MAX, mx = INT_MIN, range = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            pq.push({nums[i][0], {i, 0}});\\n            mn = min(mn, nums[i][0]);\\n            mx = max(mx, nums[i][0]);\\n        }\\n        int a = mn, b = mx;\\n        while (!pq.empty()) {\\n            pi curr = pq.top();\\n            pq.pop();\\n            //cout<<curr.first<<\" \"<<curr.second.first<<\" \"<<curr.second.second<<endl;\\n            if (curr.second.second + 1 < nums[curr.second.first].size()) {\\n                int r = curr.second.first, c = curr.second.second + 1;\\n                pq.push({nums[r][c], {r, c}});\\n                mn = pq.top().first;\\n                mx = max(mx, nums[r][c]);\\n                if (b-a > mx-mn) {\\n                    a = mn;\\n                    b = mx;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int, pair<int, int>> pi;\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int n = nums.size();\\n        priority_queue<pi, vector<pi>, greater<pi>> pq;\\n        int mn = INT_MAX, mx = INT_MIN, range = INT_MAX;\\n        for (int i=0; i<n; i++) {\\n            pq.push({nums[i][0], {i, 0}});\\n            mn = min(mn, nums[i][0]);\\n            mx = max(mx, nums[i][0]);\\n        }\\n        int a = mn, b = mx;\\n        while (!pq.empty()) {\\n            pi curr = pq.top();\\n            pq.pop();\\n            //cout<<curr.first<<\" \"<<curr.second.first<<\" \"<<curr.second.second<<endl;\\n            if (curr.second.second + 1 < nums[curr.second.first].size()) {\\n                int r = curr.second.first, c = curr.second.second + 1;\\n                pq.push({nums[r][c], {r, c}});\\n                mn = pq.top().first;\\n                mx = max(mx, nums[r][c]);\\n                if (b-a > mx-mn) {\\n                    a = mn;\\n                    b = mx;\\n                }\\n            } else {\\n                break;\\n            }\\n        }\\n        return {a, b};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 334343,
                "title": "java-sliding-window-solution",
                "content": "1. Sort the input lists to one sorted array.\\n2. Use two pointers to find the range which contains at least one element from each input list.\\n3. Find the shortest range from every candidate.\\n\\nExample:\\n```\\nInput:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\\n\\nsorted array = [0, 4, 5, 9, 10, 12, 15, 18, 20, 22, 24, 26, 30]\\n\\nl = 0, r = 0 =>   [0]              // Not match\\nl = 0, r = 1 =>   [0,4]            // Not match\\nl = 0, r = 2 =>   [0,4,5]          // Match, ans = [0,5]\\nl = 1, r = 3 =>   [4,5,9]          // Match, compare [4,9] with [0,5], ans = [0,5]\\nl = 2, r = 4 =>   [5,9,10]         // Match, compare [5,10] with [0,5], ans = [0,5]\\nl = 3, r = 7 =>   [9,10,12,15,18]  // Match, compare [9,18] with [0,5], ans = [0,5]\\nl = 4, r = 7 =>   [10,12,15,18]    // Match, compare [10,18] with [0,5], ans = [0,5]\\nl = 5, r = 7 =>   [12,15,18]       // Match, compare [12,18] with [0,5], ans = [0,5]\\nl = 6, r = 8 =>   [15,18, 20]      // Match, compare [15,20] with [0,5], ans = [0,5]\\nl = 7, r = 10 =>  [18,20,22,24]    // Match, compare [18,24] with [0,5], ans = [0,5]\\nl = 8, r = 10 =>  [20,22,24]       // Match, compare [20,24] with [0,5], ans = [20,24]\\nl = 9, r = 12 =>  [22,24,26,30]    // Not match\\nl = 10, r = 12 => [24,26,30]       // Not match\\nl = 11, r = 12 => [26,30]          // Not match\\nl = 12, r = 12 => [30]             // Not match\\n```\\n\\nJava:\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        // Keep index of every element\\n        TreeMap<Integer, List<Integer>> map = new TreeMap();\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int n : nums.get(i)) {\\n                if(!map.containsKey(n)) map.put(n, new ArrayList<>());\\n                map.get(n).add(i);\\n            }\\n        }\\n        \\n        // Create a sorted array\\n        List<Integer> list = new ArrayList(map.keySet());\\n\\t\\t\\n        // Sliding window\\n        int l = 0, r = 0;\\n        int[] ans = new int[]{ list.get(0), list.get(list.size()-1) };\\n        int[] cnt = new int[nums.size()];\\n        while(l < list.size()) {\\n            // Move right pointer\\n            while(r < list.size() && !allIn(cnt)) {\\n                for(int m : map.get(list.get(r))) cnt[m]++;\\n                r++;\\n            }\\n            // Condition match\\n            if(allIn(cnt) && (list.get(r-1) - list.get(l)) < (ans[1] - ans[0])) {\\n                ans = new int[]{ list.get(l), list.get(r-1) };\\n            }\\n            // Move left pointer\\n            for(int m : map.get(list.get(l))) cnt[m]--;\\n            l++;\\n        }\\n        return ans;\\n    }\\n    private boolean allIn(int[] cnt) {\\n        for(int c : cnt) {\\n            if(c == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```\\nTime complexity: O(nlogn)\\nSpace: O(n)",
                "solutionTags": [],
                "code": "```\\nInput:[[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\\n\\nsorted array = [0, 4, 5, 9, 10, 12, 15, 18, 20, 22, 24, 26, 30]\\n\\nl = 0, r = 0 =>   [0]              // Not match\\nl = 0, r = 1 =>   [0,4]            // Not match\\nl = 0, r = 2 =>   [0,4,5]          // Match, ans = [0,5]\\nl = 1, r = 3 =>   [4,5,9]          // Match, compare [4,9] with [0,5], ans = [0,5]\\nl = 2, r = 4 =>   [5,9,10]         // Match, compare [5,10] with [0,5], ans = [0,5]\\nl = 3, r = 7 =>   [9,10,12,15,18]  // Match, compare [9,18] with [0,5], ans = [0,5]\\nl = 4, r = 7 =>   [10,12,15,18]    // Match, compare [10,18] with [0,5], ans = [0,5]\\nl = 5, r = 7 =>   [12,15,18]       // Match, compare [12,18] with [0,5], ans = [0,5]\\nl = 6, r = 8 =>   [15,18, 20]      // Match, compare [15,20] with [0,5], ans = [0,5]\\nl = 7, r = 10 =>  [18,20,22,24]    // Match, compare [18,24] with [0,5], ans = [0,5]\\nl = 8, r = 10 =>  [20,22,24]       // Match, compare [20,24] with [0,5], ans = [20,24]\\nl = 9, r = 12 =>  [22,24,26,30]    // Not match\\nl = 10, r = 12 => [24,26,30]       // Not match\\nl = 11, r = 12 => [26,30]          // Not match\\nl = 12, r = 12 => [30]             // Not match\\n```\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        // Keep index of every element\\n        TreeMap<Integer, List<Integer>> map = new TreeMap();\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(int n : nums.get(i)) {\\n                if(!map.containsKey(n)) map.put(n, new ArrayList<>());\\n                map.get(n).add(i);\\n            }\\n        }\\n        \\n        // Create a sorted array\\n        List<Integer> list = new ArrayList(map.keySet());\\n\\t\\t\\n        // Sliding window\\n        int l = 0, r = 0;\\n        int[] ans = new int[]{ list.get(0), list.get(list.size()-1) };\\n        int[] cnt = new int[nums.size()];\\n        while(l < list.size()) {\\n            // Move right pointer\\n            while(r < list.size() && !allIn(cnt)) {\\n                for(int m : map.get(list.get(r))) cnt[m]++;\\n                r++;\\n            }\\n            // Condition match\\n            if(allIn(cnt) && (list.get(r-1) - list.get(l)) < (ans[1] - ans[0])) {\\n                ans = new int[]{ list.get(l), list.get(r-1) };\\n            }\\n            // Move left pointer\\n            for(int m : map.get(list.get(l))) cnt[m]--;\\n            l++;\\n        }\\n        return ans;\\n    }\\n    private boolean allIn(int[] cnt) {\\n        for(int c : cnt) {\\n            if(c == 0) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157760,
                "title": "python-solution-using-pq",
                "content": "```\\nimport heapq\\n\\nclass Solution:\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\" \\n        heap = [(List[0], index, 0) for index, List in enumerate(nums)]  # First element of each list with list number and index of the element in each list\\n        heapq.heapify(heap)                                              # to get the min value from all the elements of each list\\n        \\n        max_val = max([List[0] for List in nums])                        # To get the max value for the range\\n        smallest_range = -1e9, 1e9                                       # max and min for the range\\n        \\n        while heap:\\n            min_val, list_index, num_index = heapq.heappop(heap)         # get the min value, the list its from and the index it is at in the particular list\\n            \\n            if max_val - min_val < smallest_range[1] - smallest_range[0]:  # To find the smallest difference which will be the range\\n                smallest_range = min_val, max_val\\n                \\n            if num_index + 1 == len(nums[list_index]):                   # once any one of the list is exhausted, return the range\\n                return smallest_range\\n            \\n            next_num = nums[list_index][num_index+1]                     # To get the next element from the list that has the min value\\n            \\n            max_val = max(max_val, next_num)\\n            heapq.heappush(heap, (next_num, list_index, num_index+1))\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\nclass Solution:\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\" \\n        heap = [(List[0], index, 0) for index, List in enumerate(nums)]  # First element of each list with list number and index of the element in each list\\n        heapq.heapify(heap)                                              # to get the min value from all the elements of each list\\n        \\n        max_val = max([List[0] for List in nums])                        # To get the max value for the range\\n        smallest_range = -1e9, 1e9                                       # max and min for the range\\n        \\n        while heap:\\n            min_val, list_index, num_index = heapq.heappop(heap)         # get the min value, the list its from and the index it is at in the particular list\\n            \\n            if max_val - min_val < smallest_range[1] - smallest_range[0]:  # To find the smallest difference which will be the range\\n                smallest_range = min_val, max_val\\n                \\n            if num_index + 1 == len(nums[list_index]):                   # once any one of the list is exhausted, return the range\\n                return smallest_range\\n            \\n            next_num = nums[list_index][num_index+1]                     # To get the next element from the list that has the min value\\n            \\n            max_val = max(max_val, next_num)\\n            heapq.heappush(heap, (next_num, list_index, num_index+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104920,
                "title": "java-8-sliding-window",
                "content": "The idea is to sort all the elements in the k lists and run a sliding window over the sorted list, to find the minimum window that satisfies the criteria of having atleast one element from each list.\\n```\\npublic static int[] smallestRange(List<List<Integer>> nums) {\\n        List<int[]> list = IntStream.range(0, nums.size())\\n                .mapToObj( i -> nums.get(i).stream().map(x -> new int[]{x, i}))\\n                .flatMap(y -> y)\\n                .sorted(Comparator.comparingInt(p -> p[0])).collect(toList());\\n        int[] counts = new int[nums.size()];\\n        BitSet set = new BitSet(nums.size());\\n        int start = -1;\\n        int[] res = new int[2];\\n        for(int i = 0; i < list.size(); i++) {\\n            int[] p = list.get(i);\\n            set.set(p[1]);\\n            counts[p[1]] += 1;\\n            if(start == -1) { start = 0; }\\n            while(start < i && counts[list.get(start)[1]] > 1) {\\n                counts[list.get(start)[1]]--;\\n                start++;\\n            }\\n            if(set.cardinality() == nums.size()) {\\n                if( (res[0] == 0 && res[1] == 0) || (list.get(i)[0] - list.get(start)[0]) < res[1] - res[0]) {\\n                    res[0] = list.get(start)[0];\\n                    res[1] = list.get(i)[0];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int[] smallestRange(List<List<Integer>> nums) {\\n        List<int[]> list = IntStream.range(0, nums.size())\\n                .mapToObj( i -> nums.get(i).stream().map(x -> new int[]{x, i}))\\n                .flatMap(y -> y)\\n                .sorted(Comparator.comparingInt(p -> p[0])).collect(toList());\\n        int[] counts = new int[nums.size()];\\n        BitSet set = new BitSet(nums.size());\\n        int start = -1;\\n        int[] res = new int[2];\\n        for(int i = 0; i < list.size(); i++) {\\n            int[] p = list.get(i);\\n            set.set(p[1]);\\n            counts[p[1]] += 1;\\n            if(start == -1) { start = 0; }\\n            while(start < i && counts[list.get(start)[1]] > 1) {\\n                counts[list.get(start)[1]]--;\\n                start++;\\n            }\\n            if(set.cardinality() == nums.size()) {\\n                if( (res[0] == 0 && res[1] == 0) || (list.get(i)[0] - list.get(start)[0]) < res[1] - res[0]) {\\n                    res[0] = list.get(start)[0];\\n                    res[1] = list.get(i)[0];\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305385,
                "title": "python-using-heap",
                "content": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        n = len(nums)\\n        \\n        pq = []\\n        ma = 0\\n        \\n        for i in range(n):\\n            \\n            heappush(pq, (nums[i][0] , i, 0))\\n            ma = max(ma , nums[i][0])\\n        \\n        ans = [pq[0][0] , ma]\\n        while True:\\n            \\n            _,i,j = heappop(pq)\\n            \\n            \\n            if j == len(nums[i])-1:\\n                break\\n                \\n            next_num = nums[i][j+1]\\n            \\n            ma = max( ma , next_num)\\n            \\n            heappush(pq,(next_num, i , j+1))\\n            \\n            if ma-pq[0][0] < ans[1] - ans[0]:\\n                ans= [pq[0][0], ma]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        n = len(nums)\\n        \\n        pq = []\\n        ma = 0\\n        \\n        for i in range(n):\\n            \\n            heappush(pq, (nums[i][0] , i, 0))\\n            ma = max(ma , nums[i][0])\\n        \\n        ans = [pq[0][0] , ma]\\n        while True:\\n            \\n            _,i,j = heappop(pq)\\n            \\n            \\n            if j == len(nums[i])-1:\\n                break\\n                \\n            next_num = nums[i][j+1]\\n            \\n            ma = max( ma , next_num)\\n            \\n            heappush(pq,(next_num, i , j+1))\\n            \\n            if ma-pq[0][0] < ans[1] - ans[0]:\\n                ans= [pq[0][0], ma]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104905,
                "title": "python-straightforward-with-explanation",
                "content": "```\\ndef smallestRange(self, A):\\n    A = [row[::-1] for row in A]\\n    \\n    ans = -1e9, 1e9\\n    for left in sorted(reduce(set.union, map(set, A))):\\n        right = -1e9\\n        for B in A:\\n            while B and B[-1] < left:\\n                B.pop()\\n            if not B:\\n                return ans\\n            right = max(right, B[-1])\\n        if right - left < ans[1] - ans[0]:\\n            ans = left, right\\n    return ans\\n```\\n\\nClearly, each left and right bound must be a value in some array.\\n\\nFor each candidate left bound equal to some value in some array, let's determine the next-rightmost value of each array.  If it doesn't exist, then our left is already too large for any subsequent candidates to have a solution.  Otherwise, we can choose the maximum of these to be the corresponding right bound for our candidate left bound.  We take the maximum of all such candidates.",
                "solutionTags": [],
                "code": "```\\ndef smallestRange(self, A):\\n    A = [row[::-1] for row in A]\\n    \\n    ans = -1e9, 1e9\\n    for left in sorted(reduce(set.union, map(set, A))):\\n        right = -1e9\\n        for B in A:\\n            while B and B[-1] < left:\\n                B.pop()\\n            if not B:\\n                return ans\\n            right = max(right, B[-1])\\n        if right - left < ans[1] - ans[0]:\\n            ans = left, right\\n    return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101213,
                "title": "complete-handwritten-approach-dry-run",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n![Screenshot_20230126_152505.png](https://assets.leetcode.com/users/images/0368b095-c4fb-4189-bb54-a43700e7128e_1674727039.6645882.png)\\n![Screenshot_20230126_165557.png](https://assets.leetcode.com/users/images/735a1647-09a9-49a1-817e-8ac7544c76a8_1674732465.112298.png)\\n![Screenshot_20230126_165617.png](https://assets.leetcode.com/users/images/7be1b729-99e6-4425-bce9-7c03dee7a504_1674732488.7670653.png)\\n![Screenshot_20230126_152548.png](https://assets.leetcode.com/users/images/6e440ec1-0917-470d-83ea-f96278e4eafa_1674727069.7845447.png)\\n![Screenshot_20230126_152556.png](https://assets.leetcode.com/users/images/a8daba65-a2d1-44f9-b8dd-05ae078997d6_1674727085.0894868.png)\\n![Screenshot_20230126_152608.png](https://assets.leetcode.com/users/images/a8059e19-1e7f-4615-b913-cf928dcab314_1674727099.1595638.png)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n        struct Data {\\n        int value;\\n        int arr_No;\\n        int ind_No;\\n        Data(int v1, int v2, int v3) : value(v1), arr_No(v2), ind_No(v3) {}\\n    };\\n\\n    struct Compare {\\n        bool operator()(Data lhs, Data rhs) {\\n            return lhs.value > rhs.value;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>&arr) \\n    {\\n        int rows=arr.size();\\n        int cols=arr[0].size();\\n        priority_queue<Data, vector<Data>, Compare> pq;\\n        //store the first k elements in the pq ie the id 0 if each array\\n        int max_ele=INT_MIN;\\n        int min_ele=INT_MAX;\\n        for(int i=0;i<rows;i++)\\n        {\\n            Data d1(arr[i][0],i,0);\\n            pq.push(d1);\\n            max_ele=max(max_ele,arr[i][0]);\\n            min_ele=min(min_ele,arr[i][0]);\\n        }\\n        int range_start=min_ele;\\n        int range_end=max_ele;\\n        int min_range=max_ele-min_ele;//initial range\\n        while(true)\\n        {\\n            int arr_ind=pq.top().arr_No;\\n            int next_ind=pq.top().ind_No+1;\\n            pq.pop();\\n            if(next_ind==arr[arr_ind].size())//max_size reached\\n                break;\\n            int next_val=arr[arr_ind][next_ind];//next element in the array\\n            max_ele=max(max_ele,next_val);//update max\\n            Data d(next_val,arr_ind,next_ind);//push the data in the queue\\n            pq.push(d);\\n            int new_min_ele=pq.top().value;//new min value\\n            int range=max_ele-new_min_ele;\\n            if(range<min_range)//update the range start and range end\\n            {\\n                range_start=new_min_ele;\\n                range_end=max_ele;\\n                min_range=range;\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(range_start);\\n        ans.push_back(range_end);\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        struct Data {\\n        int value;\\n        int arr_No;\\n        int ind_No;\\n        Data(int v1, int v2, int v3) : value(v1), arr_No(v2), ind_No(v3) {}\\n    };\\n\\n    struct Compare {\\n        bool operator()(Data lhs, Data rhs) {\\n            return lhs.value > rhs.value;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>&arr) \\n    {\\n        int rows=arr.size();\\n        int cols=arr[0].size();\\n        priority_queue<Data, vector<Data>, Compare> pq;\\n        //store the first k elements in the pq ie the id 0 if each array\\n        int max_ele=INT_MIN;\\n        int min_ele=INT_MAX;\\n        for(int i=0;i<rows;i++)\\n        {\\n            Data d1(arr[i][0],i,0);\\n            pq.push(d1);\\n            max_ele=max(max_ele,arr[i][0]);\\n            min_ele=min(min_ele,arr[i][0]);\\n        }\\n        int range_start=min_ele;\\n        int range_end=max_ele;\\n        int min_range=max_ele-min_ele;//initial range\\n        while(true)\\n        {\\n            int arr_ind=pq.top().arr_No;\\n            int next_ind=pq.top().ind_No+1;\\n            pq.pop();\\n            if(next_ind==arr[arr_ind].size())//max_size reached\\n                break;\\n            int next_val=arr[arr_ind][next_ind];//next element in the array\\n            max_ele=max(max_ele,next_val);//update max\\n            Data d(next_val,arr_ind,next_ind);//push the data in the queue\\n            pq.push(d);\\n            int new_min_ele=pq.top().value;//new min value\\n            int range=max_ele-new_min_ele;\\n            if(range<min_range)//update the range start and range end\\n            {\\n                range_start=new_min_ele;\\n                range_end=max_ele;\\n                min_range=range;\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(range_start);\\n        ans.push_back(range_end);\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 591029,
                "title": "java-priorityqueue-easy-solution-with-simple-explanation",
                "content": "Here idea is to follow below steps::::\\n1. Create an Min heap to store k elements, one from each array and a variable minrange initilized to a maximum value and also keep a variable max to store the maximum integer.\\n2. Initially put the first element of each element from each list and store the maximum value in max.\\n3. Repeat the following steps until atleast one list exhausts :\\n\\t* To find the minimum value or min, use the top or root of the Min heap which is the minimum element.\\n\\t* Now update the minrange if current (max-min) is less than minrange.\\n\\t* remove the top or root element from priority queue and insert the next element from the list which contains the min element and upadate the max with the new element inserted.\\n\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = new int[2];\\n        int minx=Integer.MAX_VALUE;\\n        int maxy=Integer.MIN_VALUE;\\n        int minRange=Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((i,j) -> \\n        i[0] - j[0]                                 \\n        );\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //get the maximun value from first element of every list \\n            if(nums.get(i).get(0)>maxy)\\n                maxy=nums.get(i).get(0);\\n            //dumping the value in min heap based on the values\\n            pq.offer(new int[] {nums.get(i).get(0),i,0});\\n        }\\n        \\n        while(!pq.isEmpty())\\n        {\\n            //get the min-value from the heap\\n            int[] min=pq.poll();\\n            int i=min[1];\\n            int j=min[2];\\n            //compare the value of min value with max value and updayte the minrange which would be storing the answer\\n            if(maxy-min[0] < minRange)\\n            {\\n                minRange=maxy-min[0];\\n                res[0]=min[0];\\n                res[1]=maxy;\\n            }\\n            //get the next value from the list in which the minimum is found and update the value of min-heap and maxy accordingly. \\n            if(i<nums.size() && j+1<nums.get(i).size())\\n            {\\n                pq.offer(new int[] {nums.get(i).get(j+1),i,j+1});\\n                if(nums.get(i).get(j+1)>maxy)\\n                    maxy=nums.get(i).get(j+1);\\n            }\\n            //If any of the list is traversed, break out of the loop\\n            else\\n                break;\\n        }\\n        //return the result.\\n        return res;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = new int[2];\\n        int minx=Integer.MAX_VALUE;\\n        int maxy=Integer.MIN_VALUE;\\n        int minRange=Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq=new PriorityQueue<>((i,j) -> \\n        i[0] - j[0]                                 \\n        );\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            //get the maximun value from first element of every list \\n            if(nums.get(i).get(0)>maxy)\\n                maxy=nums.get(i).get(0);\\n            //dumping the value in min heap based on the values\\n            pq.offer(new int[] {nums.get(i).get(0),i,0});\\n        }\\n        \\n        while(!pq.isEmpty())\\n        {\\n            //get the min-value from the heap\\n            int[] min=pq.poll();\\n            int i=min[1];\\n            int j=min[2];\\n            //compare the value of min value with max value and updayte the minrange which would be storing the answer\\n            if(maxy-min[0] < minRange)\\n            {\\n                minRange=maxy-min[0];\\n                res[0]=min[0];\\n                res[1]=maxy;\\n            }\\n            //get the next value from the list in which the minimum is found and update the value of min-heap and maxy accordingly. \\n            if(i<nums.size() && j+1<nums.get(i).size())\\n            {\\n                pq.offer(new int[] {nums.get(i).get(j+1),i,j+1});\\n                if(nums.get(i).get(j+1)>maxy)\\n                    maxy=nums.get(i).get(j+1);\\n            }\\n            //If any of the list is traversed, break out of the loop\\n            else\\n                break;\\n        }\\n        //return the result.\\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2142779,
                "title": "c-easy-to-understand-priority-queue-based-approach-comment-rich",
                "content": "We take the 1st element from each of the k lists and insert it inside the min heap. We use a min heap to track the min element from each of the k list (`currMin`), and `currMax` to track the max element whilst keeping the range as minimum as possible (`currRange`). We track the `start` and `end` as the min and max of the smallest range.\\n```\\nclass Solution {\\npublic:\\n    struct node {\\n        int data, row, column;\\n        node(int value, int i, int j) : data(value), row(i), column(j) {}\\n    };\\n    struct comparator {\\n        bool operator() (node a, node b) {\\n            return a.data > b.data;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        // this approach will use a min heap of size k\\n        priority_queue<node, vector<node>, comparator> minHeap;\\n        int currMin = INT_MAX, currMax = INT_MIN, currRange = INT_MAX;\\n        // run a loop for k times and build the min heap\\n        for(int i = 0; i < k; ++i) {\\n            currMax = max(currMax, nums[i][0]);\\n            node temp(nums[i][0], i, 0);\\n            minHeap.push(temp);\\n        }\\n        // the start and end range of our answer\\n        int start = currMin, end = currMax;\\n        while(true) {\\n            node min = minHeap.top();\\n            minHeap.pop();\\n            currMin = min.data;\\n            // if we got a smaller range\\n            if(currMax - currMin < currRange) {\\n                start = currMin;\\n                end = currMax;\\n                currRange = currMax - currMin;\\n            }\\n            // if we don\\'t have anymore elements in the row of min element, we\\'re done\\n            if(min.column + 1 == nums[min.row].size())\\n                break;\\n            // if we still have atleast one element push it inside the min heap\\n            node next(nums[min.row][min.column + 1], min.row, min.column + 1);\\n            minHeap.push(next);\\n            // update the currMax if the next element is bigger than this\\n            if(next.data > currMax)\\n                currMax = next.data;\\n        }\\n        return {start, end};\\n    }\\n};\\n```\\n\\nTime-complexity: O(nk * logk)\\nSpace-complexity: O(k)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int data, row, column;\\n        node(int value, int i, int j) : data(value), row(i), column(j) {}\\n    };\\n    struct comparator {\\n        bool operator() (node a, node b) {\\n            return a.data > b.data;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        // this approach will use a min heap of size k\\n        priority_queue<node, vector<node>, comparator> minHeap;\\n        int currMin = INT_MAX, currMax = INT_MIN, currRange = INT_MAX;\\n        // run a loop for k times and build the min heap\\n        for(int i = 0; i < k; ++i) {\\n            currMax = max(currMax, nums[i][0]);\\n            node temp(nums[i][0], i, 0);\\n            minHeap.push(temp);\\n        }\\n        // the start and end range of our answer\\n        int start = currMin, end = currMax;\\n        while(true) {\\n            node min = minHeap.top();\\n            minHeap.pop();\\n            currMin = min.data;\\n            // if we got a smaller range\\n            if(currMax - currMin < currRange) {\\n                start = currMin;\\n                end = currMax;\\n                currRange = currMax - currMin;\\n            }\\n            // if we don\\'t have anymore elements in the row of min element, we\\'re done\\n            if(min.column + 1 == nums[min.row].size())\\n                break;\\n            // if we still have atleast one element push it inside the min heap\\n            node next(nums[min.row][min.column + 1], min.row, min.column + 1);\\n            minHeap.push(next);\\n            // update the currMax if the next element is bigger than this\\n            if(next.data > currMax)\\n                currMax = next.data;\\n        }\\n        return {start, end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1917281,
                "title": "c-sliding-window-2-pointers-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<pair<int,int>>ve;\\n        int n=nums.size();\\n        int i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(auto j:nums[i])\\n            {\\n                ve.push_back({j,i});\\n            }\\n        }\\n        sort(ve.begin(),ve.end());  \\n        vector<int>ans;\\n        map<int,int>seen;\\n        int total=0;\\n        int req=n;\\n         i=0,j=0;\\n        int sz=ve.size();\\n        int mini=1e9;\\n        while(i<sz)\\n        {\\n            seen[ve[i].second]++;\\n            if(seen[ve[i].second]==1)\\n            {\\n                total++;\\n            }\\n            if(total==req)\\n            {\\n                while(seen[ve[j].second]>1)\\n                {\\n                    seen[ve[j++].second]--;\\n                }\\n                if(ve[i].first-ve[j].first<mini)\\n                {\\n                    mini=ve[i].first-ve[j].first;\\n                    ans=vector<int>{ve[i].first,ve[j].first};\\n                }\\n            }\\n            i++;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the solution if you found helpful, it means a lot.\\nAlso comment down your doubts.\\nHappy Coding : )**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<pair<int,int>>ve;\\n        int n=nums.size();\\n        int i,j;\\n        for(i=0;i<n;i++)\\n        {\\n            for(auto j:nums[i])\\n            {\\n                ve.push_back({j,i});\\n            }\\n        }\\n        sort(ve.begin(),ve.end());  \\n        vector<int>ans;\\n        map<int,int>seen;\\n        int total=0;\\n        int req=n;\\n         i=0,j=0;\\n        int sz=ve.size();\\n        int mini=1e9;\\n        while(i<sz)\\n        {\\n            seen[ve[i].second]++;\\n            if(seen[ve[i].second]==1)\\n            {\\n                total++;\\n            }\\n            if(total==req)\\n            {\\n                while(seen[ve[j].second]>1)\\n                {\\n                    seen[ve[j++].second]--;\\n                }\\n                if(ve[i].first-ve[j].first<mini)\\n                {\\n                    mini=ve[i].first-ve[j].first;\\n                    ans=vector<int>{ve[i].first,ve[j].first};\\n                }\\n            }\\n            i++;\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104918,
                "title": "java-solution-with-maxheap-minheap",
                "content": "```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n          PriorityQueue<int[]> min=new PriorityQueue<>(1,new Comparator<int[]>(){\\n              public int compare(int[] n1,int[] n2){\\n                  return nums.get(n1[0]).get(n1[1])-nums.get(n2[0]).get(n2[1]);\\n              }              \\n          });\\n          \\n          PriorityQueue<int[]> max=new PriorityQueue<>(1,new Comparator<int[]>(){\\n              public int compare(int[] n1,int[] n2){\\n                  return nums.get(n2[0]).get(n2[1])-nums.get(n1[0]).get(n1[1]);\\n              }\\n          });\\n          \\n          for(int i=0;i<nums.size();i++){\\n                int[] tmp=new int[]{i,0};\\n                min.offer(tmp);\\n                max.offer(tmp);\\n          }\\n          int[] res=new int[]{Integer.MIN_VALUE,Integer.MAX_VALUE};\\n          \\n          while(min.size()==nums.size()){\\n              int[] m1=max.peek();\\n              int[] m2=min.poll();\\n              if((long)nums.get(m1[0]).get(m1[1])-(long)nums.get(m2[0]).get(m2[1])<(long)res[1]-(long)res[0]){\\n                  res[0]=nums.get(m2[0]).get(m2[1]);\\n                  res[1]=nums.get(m1[0]).get(m1[1]);\\n              }\\n              \\n              if(m2[1]+1<nums.get(m2[0]).size()){\\n                  int[] m3=new int[]{m2[0],m2[1]+1};\\n                  min.offer(m3);\\n                  max.offer(m3);\\n                  max.remove(m2);\\n              }\\n          }\\n          \\n          return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n          PriorityQueue<int[]> min=new PriorityQueue<>(1,new Comparator<int[]>(){\\n              public int compare(int[] n1,int[] n2){\\n                  return nums.get(n1[0]).get(n1[1])-nums.get(n2[0]).get(n2[1]);\\n              }              \\n          });\\n          \\n          PriorityQueue<int[]> max=new PriorityQueue<>(1,new Comparator<int[]>(){\\n              public int compare(int[] n1,int[] n2){\\n                  return nums.get(n2[0]).get(n2[1])-nums.get(n1[0]).get(n1[1]);\\n              }\\n          });\\n          \\n          for(int i=0;i<nums.size();i++){\\n                int[] tmp=new int[]{i,0};\\n                min.offer(tmp);\\n                max.offer(tmp);\\n          }\\n          int[] res=new int[]{Integer.MIN_VALUE,Integer.MAX_VALUE};\\n          \\n          while(min.size()==nums.size()){\\n              int[] m1=max.peek();\\n              int[] m2=min.poll();\\n              if((long)nums.get(m1[0]).get(m1[1])-(long)nums.get(m2[0]).get(m2[1])<(long)res[1]-(long)res[0]){\\n                  res[0]=nums.get(m2[0]).get(m2[1]);\\n                  res[1]=nums.get(m1[0]).get(m1[1]);\\n              }\\n              \\n              if(m2[1]+1<nums.get(m2[0]).size()){\\n                  int[] m3=new int[]{m2[0],m2[1]+1};\\n                  min.offer(m3);\\n                  max.offer(m3);\\n                  max.remove(m2);\\n              }\\n          }\\n          \\n          return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 133085,
                "title": "c-38ms-o-n-log-k-solution-using-std-map-beats-99-7",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        map<int, vector<int>> m;\\n        vector<int> pos(k, 0);\\n        for (int i = 0; i < k; i++) {\\n            int n = nums[i][pos[i]];\\n            m[n].push_back(i);\\n        }\\n        \\n        int minr = INT_MAX;\\n        vector<int> result(2);\\n        while (true) {\\n            auto it1 = m.begin();\\n            auto it2 = prev(m.end());\\n            int st = (*it1).first;\\n            int ed = (*it2).first;\\n            if (ed - st < minr) {\\n                minr = ed - st;\\n                result[0] = st;\\n                result[1] = ed;\\n            }\\n            vector<int> v = (*it1).second;\\n            m.erase(it1);\\n            for (int i : v) {\\n                pos[i]++;\\n                if (pos[i] >= nums[i].size()) return result;\\n                int num = nums[i][pos[i]];\\n                m[num].push_back(i);\\n            }\\n        }        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        map<int, vector<int>> m;\\n        vector<int> pos(k, 0);\\n        for (int i = 0; i < k; i++) {\\n            int n = nums[i][pos[i]];\\n            m[n].push_back(i);\\n        }\\n        \\n        int minr = INT_MAX;\\n        vector<int> result(2);\\n        while (true) {\\n            auto it1 = m.begin();\\n            auto it2 = prev(m.end());\\n            int st = (*it1).first;\\n            int ed = (*it2).first;\\n            if (ed - st < minr) {\\n                minr = ed - st;\\n                result[0] = st;\\n                result[1] = ed;\\n            }\\n            vector<int> v = (*it1).second;\\n            m.erase(it1);\\n            for (int i : v) {\\n                pos[i]++;\\n                if (pos[i] >= nums[i].size()) return result;\\n                int num = nums[i][pos[i]];\\n                m[num].push_back(i);\\n            }\\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474163,
                "title": "o-nlogk-javascript-approach-explained-with-comments",
                "content": "```\\nvar smallestRange = function(nums) {\\n  // Priority queue structure: // list_index(out of k lists), current pointer in list, value\\n  // sort by just value\\n    const minPQ = new MinPriorityQueue({\\n        priority: a => a[2] \\n    });\\n    \\n    let minRange = Number.MAX_VALUE;\\n\\n    // Put first values in priority queue from all k lists\\n    for (let i=0;i<nums.length;i++) {\\n        minPQ.enqueue([i, 0, nums[i][0]]);\\n    }\\n\\t\\n    let ans = [];\\n\\n    while (!minPQ.isEmpty()) {\\n\\t  // get minimum and maximum value from priority queue, else maintain max_value in variable\\n        const range =  minPQ.back().element[2] - minPQ.front().element[2];\\n        if (minRange > range) {\\n            minRange = range;\\n            ans = [minPQ.front().element[2], minPQ.back().element[2]];\\n        }\\n        \\n        const [listIndex, listIterator, currentValue] = minPQ.front().element;\\n\\n        if (listIterator + 1 < nums[listIndex].length) {\\n\\t\\t   // Move the pointer for smallest value to check\\n\\t\\t   // if we can increase the closeness between values in priority queue\\n            minPQ.dequeue();\\n            minPQ.enqueue([listIndex,listIterator + 1, nums[listIndex][listIterator + 1]]);\\n        } else {\\n            // If one of the list is exhausted, then break out from the loop\\n\\t\\t\\t// because if we need values from all the k lists or size of the priority\\n\\t\\t\\t// queue should be atleast k\\n            break;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nvar smallestRange = function(nums) {\\n  // Priority queue structure: // list_index(out of k lists), current pointer in list, value\\n  // sort by just value\\n    const minPQ = new MinPriorityQueue({\\n        priority: a => a[2] \\n    });\\n    \\n    let minRange = Number.MAX_VALUE;\\n\\n    // Put first values in priority queue from all k lists\\n    for (let i=0;i<nums.length;i++) {\\n        minPQ.enqueue([i, 0, nums[i][0]]);\\n    }\\n\\t\\n    let ans = [];\\n\\n    while (!minPQ.isEmpty()) {\\n\\t  // get minimum and maximum value from priority queue, else maintain max_value in variable\\n        const range =  minPQ.back().element[2] - minPQ.front().element[2];\\n        if (minRange > range) {\\n            minRange = range;\\n            ans = [minPQ.front().element[2], minPQ.back().element[2]];\\n        }\\n        \\n        const [listIndex, listIterator, currentValue] = minPQ.front().element;\\n\\n        if (listIterator + 1 < nums[listIndex].length) {\\n\\t\\t   // Move the pointer for smallest value to check\\n\\t\\t   // if we can increase the closeness between values in priority queue\\n            minPQ.dequeue();\\n            minPQ.enqueue([listIndex,listIterator + 1, nums[listIndex][listIterator + 1]]);\\n        } else {\\n            // If one of the list is exhausted, then break out from the loop\\n\\t\\t\\t// because if we need values from all the k lists or size of the priority\\n\\t\\t\\t// queue should be atleast k\\n            break;\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3515964,
                "title": "awesome-logic-with-heap-concept",
                "content": "# Using Heap Concept:\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        heap=[]\\n        maxvalue=0\\n        for i in range(len(nums)):\\n            heapq.heappush(heap,[nums[i][0],i,0])\\n            maxvalue=max(maxvalue,nums[i][0])\\n        answer=[heap[0][0],maxvalue]\\n        while True:\\n            _,row,col=heapq.heappop(heap)\\n            if col==len(nums[row])-1:\\n                break\\n            next_num=nums[row][col+1]\\n            heapq.heappush(heap,[next_num,row,col+1])\\n            maxvalue=max(maxvalue,next_num)\\n            if maxvalue-heap[0][0]<answer[1]-answer[0]:\\n                answer=[heap[0][0],maxvalue]\\n        return answer\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        heap=[]\\n        maxvalue=0\\n        for i in range(len(nums)):\\n            heapq.heappush(heap,[nums[i][0],i,0])\\n            maxvalue=max(maxvalue,nums[i][0])\\n        answer=[heap[0][0],maxvalue]\\n        while True:\\n            _,row,col=heapq.heappop(heap)\\n            if col==len(nums[row])-1:\\n                break\\n            next_num=nums[row][col+1]\\n            heapq.heappush(heap,[next_num,row,col+1])\\n            maxvalue=max(maxvalue,next_num)\\n            if maxvalue-heap[0][0]<answer[1]-answer[0]:\\n                answer=[heap[0][0],maxvalue]\\n        return answer\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1481931,
                "title": "python-using-heapq-time-o-nlogk-space-o-k",
                "content": "```\\nimport heapq\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        result = []\\n        hq = []\\n        high = -sys.maxsize\\n        for i in range(len(nums)):\\n            heapq.heappush(hq, (nums[i][0], i, 0))\\n            high = max(high, nums[i][0])\\n        result = [hq[0][0], high]\\n        while True:\\n            num , listIndex, numIndex = heapq.heappop(hq)\\n            if numIndex == len(nums[listIndex]) - 1:\\n                break;\\n            nextNum = nums[listIndex][numIndex + 1]\\n            heapq.heappush(hq, (nextNum, listIndex, numIndex + 1))\\n            high = max(high, nextNum)\\n            if high - hq[0][0] < result[1] - result[0]:\\n                result = [hq[0][0], high]\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        result = []\\n        hq = []\\n        high = -sys.maxsize\\n        for i in range(len(nums)):\\n            heapq.heappush(hq, (nums[i][0], i, 0))\\n            high = max(high, nums[i][0])\\n        result = [hq[0][0], high]\\n        while True:\\n            num , listIndex, numIndex = heapq.heappop(hq)\\n            if numIndex == len(nums[listIndex]) - 1:\\n                break;\\n            nextNum = nums[listIndex][numIndex + 1]\\n            heapq.heappush(hq, (nextNum, listIndex, numIndex + 1))\\n            high = max(high, nextNum)\\n            if high - hq[0][0] < result[1] - result[0]:\\n                result = [hq[0][0], high]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1123394,
                "title": "java-min-heap-similar-question",
                "content": "**Similar Question:**[Merge k sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n\\n**Code:**\\n```\\n public int[] smallestRange(List<List<Integer>> nums) {\\n     \\n        if(nums.size()==0) return new int[2];\\n        \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n           int left=Integer.MAX_VALUE;\\n           int right=Integer.MIN_VALUE;\\n        \\n        //1.Add 1st value from every List\\n        for(int i=0;i<nums.size();i++){\\n            Pair np=new Pair(i,0,nums.get(i).get(0)); //np: new Pair\\n            \\n            right=Math.max(right,nums.get(i).get(0));\\n            left=Math.min(right,nums.get(i).get(0));\\n            pq.add(np);\\n        }\\n        \\n        int length=Integer.MAX_VALUE;\\n         int fl=left;  //fl: finalLeft\\n         int fr=right;//fr : finalRight\\n        \\n          //pq have 1 value from all 3 lists and we have to compare this values;\\n        while(pq.size()==nums.size()){\\n            \\n            Pair top=pq.remove();\\n            left=top.val;  \\n            \\n            if(Math.abs(right-left)<length){\\n                fr=right;\\n                fl=left;\\n                length=Math.abs(right-left);\\n            }\\n            if(top.vi>=nums.get(top.li).size()-1){\\n                break;\\n            }\\n            \\n            Pair np=new Pair(top.li,top.vi+1,nums.get(top.li).get(top.vi+1));\\n            right=Math.max(right,nums.get(top.li).get(top.vi+1));\\n            pq.add(np);\\n            \\n        }\\n        \\n        int[] arr=new int[2];\\n        arr[0]=fl;\\n        arr[1]=fr;\\n        return arr;\\n        \\n    }\\n    \\n    class Pair implements Comparable<Pair>{\\n        int li;  //list idx\\n        int vi;  //value idx\\n        int val; //value\\n        \\n        Pair(int li,int vi,int val){\\n            this.li=li;\\n            this.vi=vi;\\n            this.val=val;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return this.val - other.val;\\n        }\\n    }\\n```\\t\\n\\n**Complexity Analysis**:\\n`Time:O(nlogk) and Space: O(k)`\\n\\nPlease **UPVOTE** if found it helpful :)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n public int[] smallestRange(List<List<Integer>> nums) {\\n     \\n        if(nums.size()==0) return new int[2];\\n        \\n        PriorityQueue<Pair> pq=new PriorityQueue<>();\\n           int left=Integer.MAX_VALUE;\\n           int right=Integer.MIN_VALUE;\\n        \\n        //1.Add 1st value from every List\\n        for(int i=0;i<nums.size();i++){\\n            Pair np=new Pair(i,0,nums.get(i).get(0)); //np: new Pair\\n            \\n            right=Math.max(right,nums.get(i).get(0));\\n            left=Math.min(right,nums.get(i).get(0));\\n            pq.add(np);\\n        }\\n        \\n        int length=Integer.MAX_VALUE;\\n         int fl=left;  //fl: finalLeft\\n         int fr=right;//fr : finalRight\\n        \\n          //pq have 1 value from all 3 lists and we have to compare this values;\\n        while(pq.size()==nums.size()){\\n            \\n            Pair top=pq.remove();\\n            left=top.val;  \\n            \\n            if(Math.abs(right-left)<length){\\n                fr=right;\\n                fl=left;\\n                length=Math.abs(right-left);\\n            }\\n            if(top.vi>=nums.get(top.li).size()-1){\\n                break;\\n            }\\n            \\n            Pair np=new Pair(top.li,top.vi+1,nums.get(top.li).get(top.vi+1));\\n            right=Math.max(right,nums.get(top.li).get(top.vi+1));\\n            pq.add(np);\\n            \\n        }\\n        \\n        int[] arr=new int[2];\\n        arr[0]=fl;\\n        arr[1]=fr;\\n        return arr;\\n        \\n    }\\n    \\n    class Pair implements Comparable<Pair>{\\n        int li;  //list idx\\n        int vi;  //value idx\\n        int val; //value\\n        \\n        Pair(int li,int vi,int val){\\n            this.li=li;\\n            this.vi=vi;\\n            this.val=val;\\n        }\\n        \\n        @Override\\n        public int compareTo(Pair other){\\n            return this.val - other.val;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836390,
                "title": "c-solution-smallest-range-covering-elements-from-k-lists",
                "content": "```\\nclass node{\\n    public:\\n    int data;\\n    int row;\\n    int col;\\n    \\n    node(int d , int r , int c){\\n        data = d;\\n        row = r;\\n        col = c;\\n    }\\n};\\n\\nclass compare{\\n    public:\\n    bool operator()(node *a , node *b)    {\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n    int mini = INT_MAX;\\n    int maxi = INT_MIN;\\n    int k = nums.size();\\n    // int n = nums[0].size();\\n    \\n    priority_queue<node*,vector<node*>,compare> pq;\\n    \\n    //step 1 : insert the first element of each list into min heap and update mini/maxi\\n    for(int i = 0 ; i < k ; i++) {\\n        int element = nums[i][0];\\n        mini = min(mini , element);\\n        maxi = max(maxi , element);\\n        node *temp = new node(element , i , 0);\\n        pq.push(temp);\\n    }\\n    \\n    int start = mini;\\n    int end = maxi;\\n    \\n    while(pq.size() > 0){\\n        node *temp = pq.top();\\n        pq.pop();\\n        \\n        mini = temp->data;\\n        \\n        if(maxi-mini < end-start){\\n            start = mini;\\n            end = maxi;\\n        }\\n        \\n        if(temp->col + 1 < nums[temp->row].size()){\\n            maxi = max(maxi , nums[temp->row][temp->col+1]);\\n            pq.push(new node(nums[temp->row][temp->col+1] , temp->row , temp->col + 1));\\n        }\\n        \\n        else{\\n            break;\\n        }\\n    }\\n    \\n        return {start,end};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass node{\\n    public:\\n    int data;\\n    int row;\\n    int col;\\n    \\n    node(int d , int r , int c){\\n        data = d;\\n        row = r;\\n        col = c;\\n    }\\n};\\n\\nclass compare{\\n    public:\\n    bool operator()(node *a , node *b)    {\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n    int mini = INT_MAX;\\n    int maxi = INT_MIN;\\n    int k = nums.size();\\n    // int n = nums[0].size();\\n    \\n    priority_queue<node*,vector<node*>,compare> pq;\\n    \\n    //step 1 : insert the first element of each list into min heap and update mini/maxi\\n    for(int i = 0 ; i < k ; i++) {\\n        int element = nums[i][0];\\n        mini = min(mini , element);\\n        maxi = max(maxi , element);\\n        node *temp = new node(element , i , 0);\\n        pq.push(temp);\\n    }\\n    \\n    int start = mini;\\n    int end = maxi;\\n    \\n    while(pq.size() > 0){\\n        node *temp = pq.top();\\n        pq.pop();\\n        \\n        mini = temp->data;\\n        \\n        if(maxi-mini < end-start){\\n            start = mini;\\n            end = maxi;\\n        }\\n        \\n        if(temp->col + 1 < nums[temp->row].size()){\\n            maxi = max(maxi , nums[temp->row][temp->col+1]);\\n            pq.push(new node(nums[temp->row][temp->col+1] , temp->row , temp->col + 1));\\n        }\\n        \\n        else{\\n            break;\\n        }\\n    }\\n    \\n        return {start,end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2434928,
                "title": "c-minheap-simulating-merging-of-arrays",
                "content": "* We simulate merging of k sorted arrays. \\n\\n* For merging we put all the first entries of all k arrays in a minHeap, so that the element which is the minimum at the current point in time, can be removed and its index can be moved forward to process more elements.\\n\\n* At any point in time , we also track the maximum out of all entries present currently in pq.\\n\\n* All the elements in the pq at that time are bound to lie between `maximum and minimum`. So we update the answer if we can.\\n\\n```\\nclass Solution {\\npublic:\\n    using arr = array<int,3> ;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<arr,vector<arr>,greater<arr>> pq ;\\n        int lo = -1e5 , hi = 1e5 , maxi = INT_MIN ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ) maxi = max(maxi,nums[i][0]) , pq.push({nums[i][0],0,i}) ;\\n        \\n        while(pq.size() == nums.size()){\\n            auto [mini,i,j] = pq.top() ; pq.pop() ;\\n            if(hi - lo > maxi - mini) lo = mini , hi = maxi ;\\n            else if(hi - lo == maxi - mini and mini < lo) lo = mini , hi = maxi ;\\n            \\n            if(i + 1 < nums[j].size()) maxi = max(maxi,nums[j][i + 1]) , pq.push({nums[j][i + 1],i + 1,j}) ;\\n        }\\n        \\n        return {lo,hi} ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    using arr = array<int,3> ;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<arr,vector<arr>,greater<arr>> pq ;\\n        int lo = -1e5 , hi = 1e5 , maxi = INT_MIN ;\\n        \\n        for(int i = 0 ; i < nums.size() ; ++i ) maxi = max(maxi,nums[i][0]) , pq.push({nums[i][0],0,i}) ;\\n        \\n        while(pq.size() == nums.size()){\\n            auto [mini,i,j] = pq.top() ; pq.pop() ;\\n            if(hi - lo > maxi - mini) lo = mini , hi = maxi ;\\n            else if(hi - lo == maxi - mini and mini < lo) lo = mini , hi = maxi ;\\n            \\n            if(i + 1 < nums[j].size()) maxi = max(maxi,nums[j][i + 1]) , pq.push({nums[j][i + 1],i + 1,j}) ;\\n        }\\n        \\n        return {lo,hi} ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497998,
                "title": "priorityqueue-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> v={-100000,100000};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        int mx=INT_MIN,n=nums.size(),d=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i][0]>mx)mx=nums[i][0];\\n            pq.push({nums[i][0],i,0});\\n        }        \\n        while(!pq.empty()){\\n            vector<int>mn=pq.top();\\n            pq.pop();\\n            int td=mx-mn[0];\\n            if(td<d){\\n                d=td;\\n                v={mn[0],mx};\\n            }\\n            if(mn[2]+1<nums[mn[1]].size()){\\n                if(nums[mn[1]][mn[2]+1]>mx)mx=nums[mn[1]][mn[2]+1];\\n                pq.push({nums[mn[1]][mn[2]+1],mn[1],mn[2]+1});\\n            }\\n            else break;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> v={-100000,100000};\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        int mx=INT_MIN,n=nums.size(),d=INT_MAX;\\n        for(int i=0;i<n;i++){\\n            if(nums[i][0]>mx)mx=nums[i][0];\\n            pq.push({nums[i][0],i,0});\\n        }        \\n        while(!pq.empty()){\\n            vector<int>mn=pq.top();\\n            pq.pop();\\n            int td=mx-mn[0];\\n            if(td<d){\\n                d=td;\\n                v={mn[0],mx};\\n            }\\n            if(mn[2]+1<nums[mn[1]].size()){\\n                if(nums[mn[1]][mn[2]+1]>mx)mx=nums[mn[1]][mn[2]+1];\\n                pq.push({nums[mn[1]][mn[2]+1],mn[1],mn[2]+1});\\n            }\\n            else break;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1474027,
                "title": "java-solution-using-priority-queue",
                "content": "\\tclass Solution {\\n\\t\\t/**\\n\\t\\t* Find and keep track of the smallest and biggest elements in the provided\\n\\t\\t* lists\\n\\t\\t* start: <Smallest Element in all the lists>\\n\\t\\t* end:   <Largest element in all the ists>\\n\\t\\t* we need to minimize the difference between (end-start)\\n\\t\\t*/\\n\\t\\tprivate class Pair {\\n\\t\\t\\tint listIdx;\\n\\t\\t\\tint valIdx;\\n\\t\\t\\tint val;\\n\\t\\t\\tPair(int listIdx, int valIdx, int val) {\\n\\t\\t\\t\\tthis.listIdx = listIdx;\\n\\t\\t\\t\\tthis.valIdx = valIdx;\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tpublic int[] smallestRange(List<List<Integer>> nums) {\\n\\t\\t/*\\n\\t\\t* PriorityQueue is needed to keep the track of the smallest value among all the lists,\\n\\t\\t* since we do not know the number of lists that will be provided in the input,\\n\\t\\t* otherwise we could have used a variable for each value or a fixed size array to keep\\n\\t\\t* track of the smallest value in the lists\\n\\t\\t*/\\n\\t\\t\\tPriorityQueue<Pair> pq = new PriorityQueue<>((pair1, pair2) -> pair1.val - pair2.val); \\n\\n\\t\\t\\tint start = (int)1e9;\\n\\t\\t\\tint end = (int)-1e9;\\n\\n\\t\\t\\t// Initialize by inserting the 0th idx values of all the lists in the PriorityQueue\\n\\t\\t\\tfor(int i = 0; i < nums.size(); i++) {\\n\\t\\t\\t\\tint val = nums.get(i).get(0);\\n\\n\\t\\t\\t\\tstart = Math.min(start, val);\\n\\t\\t\\t\\tend = Math.max(end, val);\\n\\n\\t\\t\\t\\tpq.add(new Pair(i, 0, val));   \\n\\t\\t\\t}\\n\\n\\t\\t\\tint[] ans = new int[2];\\n\\t\\t\\tans[0] = start;\\n\\t\\t\\tans[1] = end;\\n\\n\\t\\t\\tint rangeLength = end - start;\\n\\n\\t\\t\\twhile(pq.size() > 0) {\\n\\t\\t\\t// in order to minimize the range, we always move the pointer of the smallest value in all the lists\\n\\t\\t\\t\\tPair smallestPair = pq.remove(); \\n\\n\\t\\t\\t\\tint newValIdx = smallestPair.valIdx + 1;\\n\\t\\t\\t\\tint listIdx = smallestPair.listIdx;\\n\\n\\t\\t\\t\\tif(newValIdx >= nums.get(listIdx).size()) break;\\n\\n\\t\\t\\t\\tint newVal = nums.get(listIdx).get(newValIdx);\\n\\n\\t\\t\\t\\tpq.add(new Pair(listIdx, newValIdx, newVal));\\n\\n\\t\\t\\t\\tstart = pq.peek().val;\\n\\t\\t\\t\\tend = Math.max(end, newVal);\\n\\n\\t\\t\\t\\t// update start and end values only if rangeLength becomes smaller than previous value of rangeLength\\n\\t\\t\\t\\tif(end - start < rangeLength) {\\n\\t\\t\\t\\t\\tans[0] = start;\\n\\t\\t\\t\\t\\tans[1] = end;\\n\\t\\t\\t\\t\\trangeLength = end - start;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\t/**\\n\\t\\t* Find and keep track of the smallest and biggest elements in the provided\\n\\t\\t* lists\\n\\t\\t* start: <Smallest Element in all the lists>\\n\\t\\t* end:   <Largest element in all the ists>\\n\\t\\t* we need to minimize the difference between (end-start)\\n\\t\\t*/\\n\\t\\tprivate class Pair {\\n\\t\\t\\tint listIdx;\\n\\t\\t\\tint valIdx;\\n\\t\\t\\tint val;\\n\\t\\t\\tPair(int listIdx, int valIdx, int val) {\\n\\t\\t\\t\\tthis.listIdx = listIdx;\\n\\t\\t\\t\\tthis.valIdx = valIdx;\\n\\t\\t\\t\\tthis.val = val;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 740910,
                "title": "python-heap",
                "content": "\\tclass Solution(object):\\n\\t\\tdef smallestRange(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[List[int]]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\th = []\\n\\t\\t\\tstart, end = float(\\'inf\\'), float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\theapq.heappush(h, [nums[i][0], i, 0])\\n\\t\\t\\t\\tstart = min(start, nums[i][0])\\n\\t\\t\\t\\tend = max(nums[i][0], end)   \\n\\n\\t\\t\\tres = [start, end]\\n\\t\\t\\tmax_end = end\\n\\t\\t\\twhile h:\\n\\t\\t\\t\\tval, list_index, index = heapq.heappop(h)\\n\\t\\t\\t\\tif index + 1 >= len(nums[list_index]):\\n\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\tindex = index + 1\\n\\t\\t\\t\\theapq.heappush(h, [nums[list_index][index], list_index, index])\\n\\t\\t\\t\\tnew_start = h[0][0]\\n\\t\\t\\t\\tmax_end = max(max_end, nums[list_index][index])\\n\\t\\t\\t\\tif max_end - new_start < res[1] - res[0]:\\n\\t\\t\\t\\t\\tres = [new_start, max_end]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution(object):\\n\\t\\tdef smallestRange(self, nums):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\t:type nums: List[List[int]]\\n\\t\\t\\t:rtype: List[int]\\n\\t\\t\\t\"\"\"\\n\\t\\t\\th = []\\n\\t\\t\\tstart, end = float(\\'inf\\'), float(\\'-inf\\')\\n\\t\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t\\theapq.heappush(h, [nums[i][0], i, 0])\\n\\t\\t\\t\\tstart = min(start, nums[i][0])\\n\\t\\t\\t\\tend = max(nums[i][0], end)   \\n\\n\\t\\t\\tres = [start, end]\\n\\t\\t\\tmax_end = end\\n\\t\\t\\twhile h:\\n\\t\\t\\t\\tval, list_index, index = heapq.heappop(h)\\n\\t\\t\\t\\tif index + 1 >= len(nums[list_index]):\\n\\t\\t\\t\\t\\treturn res\\n\\t\\t\\t\\tindex = index + 1\\n\\t\\t\\t\\theapq.heappush(h, [nums[list_index][index], list_index, index])\\n\\t\\t\\t\\tnew_start = h[0][0]\\n\\t\\t\\t\\tmax_end = max(max_end, nums[list_index][index])\\n\\t\\t\\t\\tif max_end - new_start < res[1] - res[0]:\\n\\t\\t\\t\\t\\tres = [new_start, max_end]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 208236,
                "title": "python-min-heap-solution",
                "content": "\\n```\\nimport heapq\\n\\n# given m lists and and about k elements in each list\\n# Time: O(m*k * log(m))\\n# Space: O(m)\\n\\nclass Solution:\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int] \\n        \"\"\"\\n        \\n        # Let\\'s call each array in nums a bucket\\n        # Use an indices array to trace the bucket indices\\n        # [bucket 0\\'s index, bucket 1\\'s index, ...]\\n        indices = [0 for _ in range(len(nums))]\\n        \\n        # min heap storing: (value in each bucket, bucket id)\\n        min_heap = [(num[0], bid) for (bid, num) in enumerate(nums)]\\n        heapq.heapify(min_heap)\\n        \\n        # global upper/ lower bound to be returned\\n        upper = max([num[0] for num in nums])\\n        lower = min_heap[0][0]\\n        \\n        # trace the max value\\n        high = upper\\n        \\n        while True:\\n            \\n            # move the index of smallest value\\'s bucket forward\\n            min_val, bid = heapq.heappop(min_heap)\\n            indices[bid] += 1\\n            ind = indices[bid] \\n            \\n            # cannot move the smallest value\\'s bucket index forward anymore\\n            # exit the loop\\n            # Note: increase the index for other buckets cannot make the range\\n            # smaller anymore because the lower bound won\\'t change and the\\n            # upper bound only increases\\n            if ind == len(nums[bid]):\\n                break\\n            \\n            # add the new element to the min heap\\n            heapq.heappush(min_heap, (nums[bid][ind], bid))\\n            \\n            # trace the maximum\\n            high = max(high, nums[bid][ind])\\n            \\n            # get the current group minimum from heap\\n            low = min_heap[0][0]\\n            \\n            # update bound if the group range is smaller\\n            if high - low < upper - lower:\\n                lower, upper = low, high\\n        \\n        return [lower, upper]\\n        \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\n\\n# given m lists and and about k elements in each list\\n# Time: O(m*k * log(m))\\n# Space: O(m)\\n\\nclass Solution:\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int] \\n        \"\"\"\\n        \\n        # Let\\'s call each array in nums a bucket\\n        # Use an indices array to trace the bucket indices\\n        # [bucket 0\\'s index, bucket 1\\'s index, ...]\\n        indices = [0 for _ in range(len(nums))]\\n        \\n        # min heap storing: (value in each bucket, bucket id)\\n        min_heap = [(num[0], bid) for (bid, num) in enumerate(nums)]\\n        heapq.heapify(min_heap)\\n        \\n        # global upper/ lower bound to be returned\\n        upper = max([num[0] for num in nums])\\n        lower = min_heap[0][0]\\n        \\n        # trace the max value\\n        high = upper\\n        \\n        while True:\\n            \\n            # move the index of smallest value\\'s bucket forward\\n            min_val, bid = heapq.heappop(min_heap)\\n            indices[bid] += 1\\n            ind = indices[bid] \\n            \\n            # cannot move the smallest value\\'s bucket index forward anymore\\n            # exit the loop\\n            # Note: increase the index for other buckets cannot make the range\\n            # smaller anymore because the lower bound won\\'t change and the\\n            # upper bound only increases\\n            if ind == len(nums[bid]):\\n                break\\n            \\n            # add the new element to the min heap\\n            heapq.heappush(min_heap, (nums[bid][ind], bid))\\n            \\n            # trace the maximum\\n            high = max(high, nums[bid][ind])\\n            \\n            # get the current group minimum from heap\\n            low = min_heap[0][0]\\n            \\n            # update bound if the group range is smaller\\n            if high - low < upper - lower:\\n                lower, upper = low, high\\n        \\n        return [lower, upper]\\n        \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 104924,
                "title": "like-merge-k-sorted-array-using-minheap",
                "content": "This problem is very similar to merge K sorted array. We maintain a minHeap with K elements inside. \\n```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] result = new int[2];\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<Pair>(new Comparator<Pair>(){\\n            @Override\\n            public int compare(Pair p1, Pair p2) {\\n                return p1.val - p2.val;\\n            }\\n            \\n        });\\n        int endVal = Integer.MIN_VALUE;\\n        int k = nums.size();\\n        for (int i = 0; i < k; i++) {\\n            endVal = Math.max(endVal, nums.get(i).get(0));\\n            minHeap.offer(new Pair(i, 0, nums.get(i).get(0)));\\n        }\\n        int startVal = minHeap.peek().val;\\n        result[0] = startVal;\\n        result[1] = endVal;\\n        while (!minHeap.isEmpty()) {\\n            Pair curr = minHeap.poll();\\n            int row = curr.row;\\n            int col = curr.col + 1;\\n            if (col < nums.get(row).size()) {\\n                minHeap.offer(new Pair(row, col, nums.get(row).get(col)));\\n                endVal = Math.max(endVal, nums.get(row).get(col));\\n            }\\n            else {\\n                break;\\n            }\\n            startVal = minHeap.peek().val;\\n            if (smallerRange(startVal, endVal, result)) {\\n                result[0] = startVal;\\n                result[1] = endVal;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    private boolean smallerRange(int startVal, int endVal, int[] result) {\\n        if (endVal - startVal < result[1] - result[0]) {\\n            return true;\\n        }\\n        else if (endVal - startVal == result[1] - result[0]) {\\n            return startVal < result[0];\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Pair {\\n    int row, col, val;\\n    public Pair(int row, int col, int val) {\\n        this.row = row;\\n        this.col = col;\\n        this.val = val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] result = new int[2];\\n        PriorityQueue<Pair> minHeap = new PriorityQueue<Pair>(new Comparator<Pair>(){\\n            @Override\\n            public int compare(Pair p1, Pair p2) {\\n                return p1.val - p2.val;\\n            }\\n            \\n        });\\n        int endVal = Integer.MIN_VALUE;\\n        int k = nums.size();\\n        for (int i = 0; i < k; i++) {\\n            endVal = Math.max(endVal, nums.get(i).get(0));\\n            minHeap.offer(new Pair(i, 0, nums.get(i).get(0)));\\n        }\\n        int startVal = minHeap.peek().val;\\n        result[0] = startVal;\\n        result[1] = endVal;\\n        while (!minHeap.isEmpty()) {\\n            Pair curr = minHeap.poll();\\n            int row = curr.row;\\n            int col = curr.col + 1;\\n            if (col < nums.get(row).size()) {\\n                minHeap.offer(new Pair(row, col, nums.get(row).get(col)));\\n                endVal = Math.max(endVal, nums.get(row).get(col));\\n            }\\n            else {\\n                break;\\n            }\\n            startVal = minHeap.peek().val;\\n            if (smallerRange(startVal, endVal, result)) {\\n                result[0] = startVal;\\n                result[1] = endVal;\\n            }\\n        }\\n        return result;\\n        \\n    }\\n    private boolean smallerRange(int startVal, int endVal, int[] result) {\\n        if (endVal - startVal < result[1] - result[0]) {\\n            return true;\\n        }\\n        else if (endVal - startVal == result[1] - result[0]) {\\n            return startVal < result[0];\\n        }\\n        else {\\n            return false;\\n        }\\n    }\\n}\\n\\nclass Pair {\\n    int row, col, val;\\n    public Pair(int row, int col, int val) {\\n        this.row = row;\\n        this.col = col;\\n        this.val = val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2599428,
                "title": "min-heap-python-3-o-n-log-k",
                "content": "I\\'m posting my solution to benefit the community.\\n\\n```python\\ndef smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        # TC: O(n*log(k)), SC: O(k), n = max(len(array in nums)), k = len(nums)\\n        # (value, array index, num index)\\n        min_heap = [(nums[i][0], i, 0) for i in range(len(nums))]\\n        heapq.heapify(min_heap)\\n        curr_max = max(min_heap)[0]\\n        min_range = [min_heap[0][0], curr_max]\\n\\n        while min_heap[0][2] < len(nums[min_heap[0][1]]) - 1:\\n            _, i, j = heapq.heappop(min_heap)\\n            next_num = nums[i][j + 1]\\n            curr_max = max(curr_max, next_num)\\n            heapq.heappush(min_heap, (next_num, i, j + 1))\\n            if curr_max - min_heap[0][0] < min_range[1] - min_range[0]:\\n                min_range = [min_heap[0][0], curr_max]\\n        \\n        return min_range\\n  ```\\n  \\n  The looping condition `min_heap[0][2] < len(nums[min_heap[0][1]]) - 1` is `True` when the minimum value does **NOT** come from the last element of an array in the input `nums`.\\n  \\n  > When the minimum value **is** coming from the last element of an array in `nums`, there is no need to advance any pointers further, because that will only increase the range.\\n \\n **General Algorithm Intuition**\\n \\n 1. Say that we have `k` arrays in the input `nums`. We have **one** pointer for each array in `nums`, and we keep track of the value that the pointer is pointing to. The pointers start at index 0 for each array.\\n 2. Find the minimum value pointed to from the `k` pointers. Increment the minimum pointer by 1. Keep doing this until the pointer pointing to the minimum value reaches the end of its array.\\n\\nPlease **upvote** if you find this post helpful. Thank you!",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```python\\ndef smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        # TC: O(n*log(k)), SC: O(k), n = max(len(array in nums)), k = len(nums)\\n        # (value, array index, num index)\\n        min_heap = [(nums[i][0], i, 0) for i in range(len(nums))]\\n        heapq.heapify(min_heap)\\n        curr_max = max(min_heap)[0]\\n        min_range = [min_heap[0][0], curr_max]\\n\\n        while min_heap[0][2] < len(nums[min_heap[0][1]]) - 1:\\n            _, i, j = heapq.heappop(min_heap)\\n            next_num = nums[i][j + 1]\\n            curr_max = max(curr_max, next_num)\\n            heapq.heappush(min_heap, (next_num, i, j + 1))\\n            if curr_max - min_heap[0][0] < min_range[1] - min_range[0]:\\n                min_range = [min_heap[0][0], curr_max]\\n        \\n        return min_range\\n  ```",
                "codeTag": "Python3"
            },
            {
                "id": 2436272,
                "title": "c-priority-queue-beginner-friendly-comments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> ans(2, 0);\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        \\n        // Min Priority Queue to store num, pos(x, y)\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq; \\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            pq.push({nums[i][0], {i, 0}});\\n            // Updating the curr high and lows\\n            high = max(high, nums[i][0]);\\n            low = min(low, nums[i][0]);\\n            \\n        }\\n        \\n        \\n        // Updating the answer\\n        ans[0] = low;\\n        ans[1] = high;\\n        \\n        while(true){\\n            \\n            // Removing the lowest element\\n            pair<int, pair<int, int>> curr = pq.top();\\n            pq.pop();\\n            \\n            // Updating Low\\n            low = pq.top().first;\\n\\n            \\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            \\n            // If any arr ends then we have to stop iterating\\n            if(nums[x].size() == y + 1)\\n                break;\\n            \\n            y = y+1;\\n            // Updating high and low checking the new number\\n            high = max(high, nums[x][y]);\\n            low = min(low, nums[x][y]);\\n            pq.push({nums[x][y], {x, y}});\\n            \\n            // Updating answer if better result is found\\n            if(high - low < ans[1] - ans[0]){\\n                ans[0] = low;\\n                ans[1] = high;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> ans(2, 0);\\n        int low = INT_MAX;\\n        int high = INT_MIN;\\n        \\n        // Min Priority Queue to store num, pos(x, y)\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq; \\n        \\n        for(int i=0;i<nums.size();i++){\\n            \\n            pq.push({nums[i][0], {i, 0}});\\n            // Updating the curr high and lows\\n            high = max(high, nums[i][0]);\\n            low = min(low, nums[i][0]);\\n            \\n        }\\n        \\n        \\n        // Updating the answer\\n        ans[0] = low;\\n        ans[1] = high;\\n        \\n        while(true){\\n            \\n            // Removing the lowest element\\n            pair<int, pair<int, int>> curr = pq.top();\\n            pq.pop();\\n            \\n            // Updating Low\\n            low = pq.top().first;\\n\\n            \\n            int x = curr.second.first;\\n            int y = curr.second.second;\\n            \\n            // If any arr ends then we have to stop iterating\\n            if(nums[x].size() == y + 1)\\n                break;\\n            \\n            y = y+1;\\n            // Updating high and low checking the new number\\n            high = max(high, nums[x][y]);\\n            low = min(low, nums[x][y]);\\n            pq.push({nums[x][y], {x, y}});\\n            \\n            // Updating answer if better result is found\\n            if(high - low < ans[1] - ans[0]){\\n                ans[0] = low;\\n                ans[1] = high;\\n            }\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219050,
                "title": "c-straightforward-code-with-visualization-multimap-vector",
                "content": "Initially we set the selected number to the first element in each list.\\n\\n```cpp\\n             [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nselectedNum:   ^              (^)          ^            ----- [0,4,5]\\nindex:         0               0           0\\n                              (min)\\n```\\n\\nWhat if we move the index of the largest number `5` to `18`? We will only get larger range. What if we move the index of neither the smallest nor largest number? The length of the new range would not change. So we should move the index of the smallest number `0` in the second list to find smaller ranges.\\n\\nThe rest of the operations are as follows.\\n\\n```cpp\\n             [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nselectedNum:   ^              (^)          ^            ----- [0,4,5]\\nindex:         0               0           0\\nselectedNum:  (^)                ^         ^            ----- [4,5,9]\\nindex:         0                 1         0\\nselectedNum:      ^              ^        (^)           ----- [5,9,10]\\nindex:            1              1         0\\nselectedNum:      ^             (^)           ^         ----- [9,10,18]\\nindex:            1              1            1\\nselectedNum:     (^)                ^         ^         ----- [10,12,18]\\nindex:            1                 2         1\\nselectedNum:         ^             (^)        ^         ----- [12,15,18]\\nindex:               2              2         1\\nselectedNum:        (^)                 ^     ^         ----- [15,18,20]\\nindex:               2                  3     1\\nselectedNum:             ^              ^    (^)        ----- [18,20,24]\\nindex:                   3              3     1\\nselectedNum:             ^             (^)        ^     ----- [20,22,24] (answer)\\nindex:                   3              3         2\\n```\\n\\nHow should we implement? Moving indexes is very simple we can just use a vector to track them. The performance critical part is how do we remove the smallest number and insert a new number while keeping order in a list. The first data structure that came to my mind is `multiset`, but I also want to know the list in which the smallest number is so I use `multimap` here.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& numList) {\\n        const int listSize = numList.size();\\n        \\n        multimap<int, int> selectedNumToIndex;\\n        for (int i = 0; i < listSize; i++) {\\n            selectedNumToIndex.insert({numList[i].front(), i});\\n        }\\n        \\n        vector<int> selectedNumIndexes(listSize, 0);\\n        vector<int> result = {-100000, 100000};\\n        while (true) {\\n            const auto minIt = selectedNumToIndex.begin();\\n            const auto maxIt = selectedNumToIndex.rbegin();\\n            const int minVal = minIt->first;\\n            const int maxVal = maxIt->first;\\n            const int minListIndex = minIt->second;\\n            if (maxVal - minVal < result[1] - result[0]) {\\n                result[0] = minVal;\\n                result[1] = maxVal;\\n            }\\n            \\n            selectedNumToIndex.erase(minIt);\\n            \\n            const int newIndex = selectedNumIndexes[minListIndex]++;\\n            const auto &nums = numList[minListIndex];\\n            if (newIndex >= nums.size()) break;\\n            \\n            selectedNumToIndex.insert({nums[newIndex], minListIndex});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\nI also simplified the code a bit by removing the check of whether a range is smaller of the second case (`a < c` if `b - a == d - c`). We don\\'t need to check because the smallest number `a` will only get larger as we move forward.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n             [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nselectedNum:   ^              (^)          ^            ----- [0,4,5]\\nindex:         0               0           0\\n                              (min)\\n```\n```cpp\\n             [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nselectedNum:   ^              (^)          ^            ----- [0,4,5]\\nindex:         0               0           0\\nselectedNum:  (^)                ^         ^            ----- [4,5,9]\\nindex:         0                 1         0\\nselectedNum:      ^              ^        (^)           ----- [5,9,10]\\nindex:            1              1         0\\nselectedNum:      ^             (^)           ^         ----- [9,10,18]\\nindex:            1              1            1\\nselectedNum:     (^)                ^         ^         ----- [10,12,18]\\nindex:            1                 2         1\\nselectedNum:         ^             (^)        ^         ----- [12,15,18]\\nindex:               2              2         1\\nselectedNum:        (^)                 ^     ^         ----- [15,18,20]\\nindex:               2                  3     1\\nselectedNum:             ^              ^    (^)        ----- [18,20,24]\\nindex:                   3              3     1\\nselectedNum:             ^             (^)        ^     ----- [20,22,24] (answer)\\nindex:                   3              3         2\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& numList) {\\n        const int listSize = numList.size();\\n        \\n        multimap<int, int> selectedNumToIndex;\\n        for (int i = 0; i < listSize; i++) {\\n            selectedNumToIndex.insert({numList[i].front(), i});\\n        }\\n        \\n        vector<int> selectedNumIndexes(listSize, 0);\\n        vector<int> result = {-100000, 100000};\\n        while (true) {\\n            const auto minIt = selectedNumToIndex.begin();\\n            const auto maxIt = selectedNumToIndex.rbegin();\\n            const int minVal = minIt->first;\\n            const int maxVal = maxIt->first;\\n            const int minListIndex = minIt->second;\\n            if (maxVal - minVal < result[1] - result[0]) {\\n                result[0] = minVal;\\n                result[1] = maxVal;\\n            }\\n            \\n            selectedNumToIndex.erase(minIt);\\n            \\n            const int newIndex = selectedNumIndexes[minListIndex]++;\\n            const auto &nums = numList[minListIndex];\\n            if (newIndex >= nums.size()) break;\\n            \\n            selectedNumToIndex.insert({nums[newIndex], minListIndex});\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706944,
                "title": "javascript-heap-o-nlogk-runtime",
                "content": "Here is a O(Nlogk) solution using a min heap written in JS. N is the total number of elements and k is the total number of groups of numbers.\\n\\n```\\nclass MinHeap {\\n    constructor() {\\n        this.list = []; // a list of [num, groupID]\\n        this.size = 0;\\n    }\\n    \\n    push(item) {\\n        const list = this.list;\\n        const size = ++this.size;\\n        \\n        list[size - 1] = item;\\n        this.bubbleUp(size - 1);\\n    }\\n    \\n    pop() {\\n        if (this.size === 0) return;\\n        \\n        const list = this.list;\\n        const size = this.size;\\n        const item = list[0];\\n        \\n        [list[0], list[size - 1]] = [list[size - 1], list[0]];\\n        this.size--;\\n        this.bubbleDown(0);\\n        return item;\\n    }\\n    \\n    bubbleUp(index) {\\n        const list = this.list;\\n        const size = this.size;\\n        const parent = Math.floor((index - 1) / 2);\\n        \\n        if (parent < 0 || parent >= size) return;\\n        if (index < 0 || index >= size) return;\\n        \\n        if (list[index][0] < list[parent][0]) {\\n            [list[index], list[parent]] = [list[parent], list[index]];\\n            this.bubbleUp(parent);\\n        }\\n    }\\n    \\n    bubbleDown(index) {\\n        if (index < 0 || index >= this.size) return;\\n        \\n        const list = this.list;\\n        const size = this.size;\\n        const left = index * 2 + 1;\\n        const right = index * 2 + 2;\\n        let minVal = list[index][0];\\n        let minIndex = index;\\n        \\n        if (left >= 0 && left < size) {\\n            if (list[left][0] < minVal) {\\n                minVal = list[left][0];\\n                minIndex = left;\\n            }\\n        }\\n        if (right >= 0 && right < size) {\\n            if (list[right][0] < minVal) {\\n                minVal = list[right][0];\\n                minIndex = right;\\n            }\\n        }\\n        if (minIndex !== index) {\\n            [list[index], list[minIndex]] = [list[minIndex], list[index]];\\n            this.bubbleDown(minIndex);\\n        }\\n    }\\n}\\n\\nconst smallestRange = (nums) => {\\n    const pointers = new Array(nums.length).fill(0);\\n    const minHeap = new MinHeap();\\n    const answer = [-Infinity, Infinity];\\n    let max = -Infinity;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        minHeap.push([nums[i][0], i]);\\n        max = Math.max(max, nums[i][0]);\\n    }\\n        \\n\\t// iterate through at most N elements\\n    while (true) {\\n        const [min, group] = minHeap.pop(); // this takes O(logk)\\n        \\n        if (max - min < answer[1] - answer[0]) {\\n            answer[0] = min;\\n            answer[1] = max;\\n        }\\n        pointers[group]++;\\n        if (pointers[group] >= nums[group].length) break;\\n        minHeap.push([nums[group][pointers[group]], group]); // this takes O(logk)\\n        max = Math.max(max, nums[group][pointers[group]]);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass MinHeap {\\n    constructor() {\\n        this.list = []; // a list of [num, groupID]\\n        this.size = 0;\\n    }\\n    \\n    push(item) {\\n        const list = this.list;\\n        const size = ++this.size;\\n        \\n        list[size - 1] = item;\\n        this.bubbleUp(size - 1);\\n    }\\n    \\n    pop() {\\n        if (this.size === 0) return;\\n        \\n        const list = this.list;\\n        const size = this.size;\\n        const item = list[0];\\n        \\n        [list[0], list[size - 1]] = [list[size - 1], list[0]];\\n        this.size--;\\n        this.bubbleDown(0);\\n        return item;\\n    }\\n    \\n    bubbleUp(index) {\\n        const list = this.list;\\n        const size = this.size;\\n        const parent = Math.floor((index - 1) / 2);\\n        \\n        if (parent < 0 || parent >= size) return;\\n        if (index < 0 || index >= size) return;\\n        \\n        if (list[index][0] < list[parent][0]) {\\n            [list[index], list[parent]] = [list[parent], list[index]];\\n            this.bubbleUp(parent);\\n        }\\n    }\\n    \\n    bubbleDown(index) {\\n        if (index < 0 || index >= this.size) return;\\n        \\n        const list = this.list;\\n        const size = this.size;\\n        const left = index * 2 + 1;\\n        const right = index * 2 + 2;\\n        let minVal = list[index][0];\\n        let minIndex = index;\\n        \\n        if (left >= 0 && left < size) {\\n            if (list[left][0] < minVal) {\\n                minVal = list[left][0];\\n                minIndex = left;\\n            }\\n        }\\n        if (right >= 0 && right < size) {\\n            if (list[right][0] < minVal) {\\n                minVal = list[right][0];\\n                minIndex = right;\\n            }\\n        }\\n        if (minIndex !== index) {\\n            [list[index], list[minIndex]] = [list[minIndex], list[index]];\\n            this.bubbleDown(minIndex);\\n        }\\n    }\\n}\\n\\nconst smallestRange = (nums) => {\\n    const pointers = new Array(nums.length).fill(0);\\n    const minHeap = new MinHeap();\\n    const answer = [-Infinity, Infinity];\\n    let max = -Infinity;\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        minHeap.push([nums[i][0], i]);\\n        max = Math.max(max, nums[i][0]);\\n    }\\n        \\n\\t// iterate through at most N elements\\n    while (true) {\\n        const [min, group] = minHeap.pop(); // this takes O(logk)\\n        \\n        if (max - min < answer[1] - answer[0]) {\\n            answer[0] = min;\\n            answer[1] = max;\\n        }\\n        pointers[group]++;\\n        if (pointers[group] >= nums[group].length) break;\\n        minHeap.push([nums[group][pointers[group]], group]); // this takes O(logk)\\n        max = Math.max(max, nums[group][pointers[group]]);\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1637999,
                "title": "c-stright-forward-sliding-window-min-heap-well-commented",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<int> range = {0,INT_MAX} ;\\n        // pointers on lists \\n        vector<int> ptrs(nums.size(),0) ;\\n        // min heap\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minHeap;\\n        // vector of pairs <number,which list>\\n        vector<pair<int,int>> sorted; \\n        \\n        // push first k elements in heap\\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            // if pointer in range \\n            if(ptrs[i] < nums[i].size() ){\\n                minHeap.push({nums[i][ptrs[i]],i});\\n            }\\n        }\\n        \\n        // sort array of pairs with heap\\n        while(minHeap.size()){\\n            pair<int,int> min  = minHeap.top();   \\n            minHeap.pop();\\n            sorted.push_back(min);\\n            ptrs[min.second] ++ ;\\n            if( ptrs[min.second] < nums[min.second].size() ) minHeap.push({nums[min.second][ptrs[min.second]],min.second});\\n        }     \\n        // slide window to get smalles subarray with k keys \\n        int windowStart = 0;\\n        // number of indecies inside window \\n        unordered_map<int,int> indecies ; // <index of list, number of elements from that list >\\n        for(int windowEnd = 0 ; windowEnd < sorted.size() ; windowEnd ++ ) {\\n            pair<int,int> rightMost = sorted[windowEnd];\\n            indecies[rightMost.second] ++ ;\\n            // shrink \\n            while(indecies.size() == nums.size()) {\\n                // update answer \\n                if(isSmaller({sorted[windowStart].first,sorted[windowEnd].first},range ) ){\\n                    range = {sorted[windowStart].first,sorted[windowEnd].first} ;\\n                }\\n                pair<int,int> leftMost = sorted[windowStart] ;\\n                indecies[leftMost.second] --;\\n                if(!indecies[leftMost.second]) indecies.erase(leftMost.second);\\n                windowStart ++ ;\\n            }\\n        }\\n        return range;\\n    }\\n    \\n    bool isSmaller(vector<int> a, vector<int> b ){\\n        if(a[1] - a[0] != b[1]-b[0]) return a[1] - a[0] < b[1]-b[0] ;\\n        return a[0] < b[0] ;   \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<int> range = {0,INT_MAX} ;\\n        // pointers on lists \\n        vector<int> ptrs(nums.size(),0) ;\\n        // min heap\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minHeap;\\n        // vector of pairs <number,which list>\\n        vector<pair<int,int>> sorted; \\n        \\n        // push first k elements in heap\\n        for(int i = 0 ; i < nums.size() ; i++) {\\n            // if pointer in range \\n            if(ptrs[i] < nums[i].size() ){\\n                minHeap.push({nums[i][ptrs[i]],i});\\n            }\\n        }\\n        \\n        // sort array of pairs with heap\\n        while(minHeap.size()){\\n            pair<int,int> min  = minHeap.top();   \\n            minHeap.pop();\\n            sorted.push_back(min);\\n            ptrs[min.second] ++ ;\\n            if( ptrs[min.second] < nums[min.second].size() ) minHeap.push({nums[min.second][ptrs[min.second]],min.second});\\n        }     \\n        // slide window to get smalles subarray with k keys \\n        int windowStart = 0;\\n        // number of indecies inside window \\n        unordered_map<int,int> indecies ; // <index of list, number of elements from that list >\\n        for(int windowEnd = 0 ; windowEnd < sorted.size() ; windowEnd ++ ) {\\n            pair<int,int> rightMost = sorted[windowEnd];\\n            indecies[rightMost.second] ++ ;\\n            // shrink \\n            while(indecies.size() == nums.size()) {\\n                // update answer \\n                if(isSmaller({sorted[windowStart].first,sorted[windowEnd].first},range ) ){\\n                    range = {sorted[windowStart].first,sorted[windowEnd].first} ;\\n                }\\n                pair<int,int> leftMost = sorted[windowStart] ;\\n                indecies[leftMost.second] --;\\n                if(!indecies[leftMost.second]) indecies.erase(leftMost.second);\\n                windowStart ++ ;\\n            }\\n        }\\n        return range;\\n    }\\n    \\n    bool isSmaller(vector<int> a, vector<int> b ){\\n        if(a[1] - a[0] != b[1]-b[0]) return a[1] - a[0] < b[1]-b[0] ;\\n        return a[0] < b[0] ;   \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540558,
                "title": "java-solution-using-priority-queue-readable-code-with-explanation",
                "content": "**Approach Similiar to Merge k list**\\n\\nWhat we need is smallest range. So what we somehow keep track of min and max of every k size window, which will consists one element of each list at a time. \\nSo, what we are going to do is manage the min by a priority queue (min heap) and max by a variable, we can do vice-versa also.\\nSo first we need to add first element of each list, but how will we access it\\'s next elements, like if we remove a number from pq how will we come to know that the number is of which list, so we will create a pair class which will have row and col along with the value.\\nSo whenever we remove a pair from pq, it\\'s value will me min of current k elements we are comparing, whereas our max will hold the max of current k elements. So we can find our range accordingly. If our curr range is smaller then the previous one we will update our answer.\\nWhenever we reach at the end of any list from k given list, we will break as we are out of choices for a particular list, and we have already calculated the range of the list we have just exahusted.\\n\\nCode:\\n```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        Integer val;\\n        \\n        Pair(int row, int col , Integer val){\\n            this.row = row;\\n            this.col = col;\\n            this.val = val;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n\\t\\t//min pq\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\t\\t//max of each k element\\n        int max = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            max = Math.max(max, nums.get(i).get(0));\\n            pq.add(new Pair(i, 0, nums.get(i).get(0)));\\n        }\\n        int[] ans = new int[2];\\n        //range\\n        int range = Integer.MAX_VALUE;\\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            \\n\\t\\t\\t//updating range if smaller\\n            if(max - p.val < range){\\n                ans[0] = p.val;\\n                ans[1] = max;\\n                range = max - p.val;\\n            }\\n            \\n\\t\\t\\t//checking the validity \\n            if(p.col + 1 < nums.get(p.row).size()){\\n                max = Math.max(nums.get(p.row).get(p.col + 1), max);\\n                pq.add(new Pair(p.row, p.col + 1, nums.get(p.row).get(p.col + 1)));\\n            }else break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nSpace -: O(k) -> at most k elements in pq \\nTime -> O(n log(k)) \\n\\nPlease Up vote if found helpful. :-)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    class Pair{\\n        int row;\\n        int col;\\n        Integer val;\\n        \\n        Pair(int row, int col , Integer val){\\n            this.row = row;\\n            this.col = col;\\n            this.val = val;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n\\t\\t//min pq\\n        PriorityQueue<Pair> pq = new PriorityQueue<>((a, b) -> a.val - b.val);\\n\\t\\t//max of each k element\\n        int max = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            max = Math.max(max, nums.get(i).get(0));\\n            pq.add(new Pair(i, 0, nums.get(i).get(0)));\\n        }\\n        int[] ans = new int[2];\\n        //range\\n        int range = Integer.MAX_VALUE;\\n        while(pq.size() > 0){\\n            Pair p = pq.remove();\\n            \\n\\t\\t\\t//updating range if smaller\\n            if(max - p.val < range){\\n                ans[0] = p.val;\\n                ans[1] = max;\\n                range = max - p.val;\\n            }\\n            \\n\\t\\t\\t//checking the validity \\n            if(p.col + 1 < nums.get(p.row).size()){\\n                max = Math.max(nums.get(p.row).get(p.col + 1), max);\\n                pq.add(new Pair(p.row, p.col + 1, nums.get(p.row).get(p.col + 1)));\\n            }else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1469893,
                "title": "c-sliding-window",
                "content": "1. Reconstruct a vector by populating it with pair : <num, groupNo>.\\n2. Sort the vector\\n3. Using sliding window to find the interval [i, j] which satisfies the amounts of groups in this interval is k(nums.size()). \\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> vec;\\n        vector<int> res;\\n        for(int i = 0;i<nums.size();i++)\\n            for(int j = 0;j<nums[i].size();j++)\\n                vec.push_back({nums[i][j], i});\\n        \\n        sort(vec.begin(), vec.end());\\n        int i = 0, j = 0, groups = 0, n = vec.size(), k = nums.size();\\n        // key: group number, value: \\n        unordered_map<int, int> maps;\\n        while(j<n){\\n            if(maps[vec[j].second]++ == 0) groups++;\\n            while(groups == k)\\n            {\\n                if(res.empty() || vec[j].first - vec[i].first < res[1] - res[0])\\n                    res = {vec[i].first, vec[j].first};\\n                if(maps[vec[i].second]-- == 1) groups--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> vec;\\n        vector<int> res;\\n        for(int i = 0;i<nums.size();i++)\\n            for(int j = 0;j<nums[i].size();j++)\\n                vec.push_back({nums[i][j], i});\\n        \\n        sort(vec.begin(), vec.end());\\n        int i = 0, j = 0, groups = 0, n = vec.size(), k = nums.size();\\n        // key: group number, value: \\n        unordered_map<int, int> maps;\\n        while(j<n){\\n            if(maps[vec[j].second]++ == 0) groups++;\\n            while(groups == k)\\n            {\\n                if(res.empty() || vec[j].first - vec[i].first < res[1] - res[0])\\n                    res = {vec[i].first, vec[j].first};\\n                if(maps[vec[i].second]-- == 1) groups--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1215831,
                "title": "c-easy-faster-than-93-23-two-pointer-with-comments",
                "content": "First merge all the lists into a single list and sort them . Find the smallest sub element which contains elements from each list . Along with their values we need to store the list number from which it came , so that we can identify later. \\n```\\n vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int> > a;  //The big list\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j: nums[i])\\n            {\\n                a.push_back({j,i}); //merging  // (value,list number)\\n            }\\n        }\\n        sort(a.begin(),a.end());\\n        int j=0;  //the left pointer\\n        int total=0; //the elements between the two pointers are from how many lists\\n        int diff=nums.size(); // total number of lists\\n        int mp[diff]; // map to store how many elements from each lists we have seen till now\\n        memset(mp,0,sizeof(mp)); //initially all  of them should be zero\\n        vector<int> ans; //vector containing the range\\n        int mini=INT_MAX;  // initially the range should be a big number\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n           mp[a[i].second]++;  //increase the current element list number \\n           if(mp[a[i].second]==1) //if the value is 1 , then it denots elements from that list has occured first time\\n           {\\n               total++;  //so we can increase total \\n           }\\n            if(total==diff) //when elements from all the lists has been seen\\n            {\\n                if(a[i].first-a[j].first+1<mini) //checking that the current range is smaller or not\\n                {\\n\\t\\t\\t\\t//if smaller then update\\n                    mini=a[i].first-a[j].first+1;\\n                    ans={a[i].first,a[j].first};\\n                }\\n            }\\n            if(total==diff) \\n            {\\n                while(total==diff) //now time to move the first pointer right . If there are more than one element from a list , then we can shift the left pointer\\n                {\\n                    if(mp[a[j].second]>1) mp[a[j].second]--,j++;\\n                    else break;\\n                }\\n                if(a[i].first-a[j].first+1<mini) //after shifting the left pointer , again check if the range becomes smaller or not\\n                {\\n                    mini=a[i].first-a[j].first+1;\\n                    ans={a[i].first,a[j].first};\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```\\nIf you liked the code , give it a **Thumbs Up** !!!",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int> > a;  //The big list\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j: nums[i])\\n            {\\n                a.push_back({j,i}); //merging  // (value,list number)\\n            }\\n        }\\n        sort(a.begin(),a.end());\\n        int j=0;  //the left pointer\\n        int total=0; //the elements between the two pointers are from how many lists\\n        int diff=nums.size(); // total number of lists\\n        int mp[diff]; // map to store how many elements from each lists we have seen till now\\n        memset(mp,0,sizeof(mp)); //initially all  of them should be zero\\n        vector<int> ans; //vector containing the range\\n        int mini=INT_MAX;  // initially the range should be a big number\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n           mp[a[i].second]++;  //increase the current element list number \\n           if(mp[a[i].second]==1) //if the value is 1 , then it denots elements from that list has occured first time\\n           {\\n               total++;  //so we can increase total \\n           }\\n            if(total==diff) //when elements from all the lists has been seen\\n            {\\n                if(a[i].first-a[j].first+1<mini) //checking that the current range is smaller or not\\n                {\\n\\t\\t\\t\\t//if smaller then update\\n                    mini=a[i].first-a[j].first+1;\\n                    ans={a[i].first,a[j].first};\\n                }\\n            }\\n            if(total==diff) \\n            {\\n                while(total==diff) //now time to move the first pointer right . If there are more than one element from a list , then we can shift the left pointer\\n                {\\n                    if(mp[a[j].second]>1) mp[a[j].second]--,j++;\\n                    else break;\\n                }\\n                if(a[i].first-a[j].first+1<mini) //after shifting the left pointer , again check if the range becomes smaller or not\\n                {\\n                    mini=a[i].first-a[j].first+1;\\n                    ans={a[i].first,a[j].first};\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 643888,
                "title": "python-two-pointers-hash-table-solutions-with-explanations",
                "content": "Extremely similar to [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/), just change str to list of number.\\n\\n**Explanations**: The essence of this problem is to find the smallest range that intersect with all groups. `counts` maps group ID to the number that group shows up. `groups` is the number of current groups in  range `res`. \\nThen, it is the same algorithm as https://leetcode.com/problems/minimum-window-substring/discuss/571711/Python-Two-pointers-with-Explanations \\n\\n**Complexity**: O(N + NlogN), N is the total number of elements in `nums`. O( NlogN) is for sorting `v`. O(N) is the two pointers part. Space O(N).\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        v, seen, k = [], set(), len(nums)\\n        for i in range(k):\\n            for n in nums[i]:\\n                if (n, i) not in seen:\\n                    v.append((n, i))\\n                    seen.add((n, i))\\n        v.sort()\\n        slow, groups, counts = 0, 0, collections.Counter()\\n        res, minR = [0, 0], float(\\'inf\\')\\n        for fast in range(len(v)):\\n            if counts[v[fast][1]] == 0:\\n                groups += 1\\n            counts[v[fast][1]] += 1\\n            while slow <= fast and groups == k:\\n                diff = v[fast][0] - v[slow][0]\\n                if diff < minR or (diff == minR and v[slow][0] < res[0]):\\n                    minR, res = v[fast][0] - v[slow][0], [v[slow][0], v[fast][0]]\\n                counts[v[slow][1]] -= 1\\n                if counts[v[slow][1]] == 0:\\n                    groups -= 1\\n                slow += 1\\n        return res\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        v, seen, k = [], set(), len(nums)\\n        for i in range(k):\\n            for n in nums[i]:\\n                if (n, i) not in seen:\\n                    v.append((n, i))\\n                    seen.add((n, i))\\n        v.sort()\\n        slow, groups, counts = 0, 0, collections.Counter()\\n        res, minR = [0, 0], float(\\'inf\\')\\n        for fast in range(len(v)):\\n            if counts[v[fast][1]] == 0:\\n                groups += 1\\n            counts[v[fast][1]] += 1\\n            while slow <= fast and groups == k:\\n                diff = v[fast][0] - v[slow][0]\\n                if diff < minR or (diff == minR and v[slow][0] < res[0]):\\n                    minR, res = v[fast][0] - v[slow][0], [v[slow][0], v[fast][0]]\\n                counts[v[slow][1]] -= 1\\n                if counts[v[slow][1]] == 0:\\n                    groups -= 1\\n                slow += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231024,
                "title": "java-easy-to-understand-nlog-k-beets-97",
                "content": "Idea is to create a new object that has the (cur, ListIterator). This goes into the min-heap priority queue.\\nSo we know what is the minimum from PQ. However to find the range we need min and max value. For maxValue we capture the max in the begining while PQ is being initiallized and later on for maxValue we need to compare with the next being added to the minHeap if it is greate that the current max then we update maxValue with this value. just need to update the maxValue with the newly added value to PQ. \\n\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums == null || nums.isEmpty()) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<IntItr> minpq = new PriorityQueue<>(new Comparator<IntItr>(){\\n            public int compare (IntItr a, IntItr b) {\\n                return a.cur - b.cur;\\n            }\\n        });\\n        \\n        int maxValue = Integer.MIN_VALUE;\\n        for (List<Integer> list : nums) {\\n            IntItr intitr = new IntItr(list.listIterator());\\n            minpq.add(intitr);\\n            maxValue = Math.max(maxValue, intitr.getCur());\\n        }\\n        \\n        int range = Integer.MAX_VALUE;\\n        int[] result = new int[2];\\n        \\n        \\n        while(minpq.size() == nums.size()) {\\n            if (maxValue - minpq.peek().cur < range) {\\n                range = maxValue - minpq.peek().cur;\\n                result[0] = minpq.peek().cur;\\n                result[1] = maxValue;\\n            }\\n            IntItr min = minpq.poll();\\n            if(min.hasNext()) {\\n                min.next();\\n                minpq.add(min);\\n                maxValue = Math.max(maxValue, min.getCur());\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class IntItr{\\n        int cur;\\n        Iterator itr;\\n        public IntItr(ListIterator<Integer> iterator) {\\n            itr = iterator;\\n            cur = (Integer)itr.next();\\n        }\\n        \\n        public int getCur() {\\n            return cur;\\n        }\\n        \\n        public void next() {\\n            cur = (Integer)itr.next();\\n        }\\n        \\n        public boolean hasNext() {\\n            return itr.hasNext();\\n        }\\n    }\\n    \\n    \\n}```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums == null || nums.isEmpty()) {\\n            return null;\\n        }\\n        \\n        PriorityQueue<IntItr> minpq = new PriorityQueue<>(new Comparator<IntItr>(){\\n            public int compare (IntItr a, IntItr b) {\\n                return a.cur - b.cur;\\n            }\\n        });\\n        \\n        int maxValue = Integer.MIN_VALUE;\\n        for (List<Integer> list : nums) {\\n            IntItr intitr = new IntItr(list.listIterator());\\n            minpq.add(intitr);\\n            maxValue = Math.max(maxValue, intitr.getCur());\\n        }\\n        \\n        int range = Integer.MAX_VALUE;\\n        int[] result = new int[2];\\n        \\n        \\n        while(minpq.size() == nums.size()) {\\n            if (maxValue - minpq.peek().cur < range) {\\n                range = maxValue - minpq.peek().cur;\\n                result[0] = minpq.peek().cur;\\n                result[1] = maxValue;\\n            }\\n            IntItr min = minpq.poll();\\n            if(min.hasNext()) {\\n                min.next();\\n                minpq.add(min);\\n                maxValue = Math.max(maxValue, min.getCur());\\n            }\\n            \\n        }\\n        \\n        return result;\\n    }\\n    \\n    public class IntItr{\\n        int cur;\\n        Iterator itr;\\n        public IntItr(ListIterator<Integer> iterator) {\\n            itr = iterator;\\n            cur = (Integer)itr.next();\\n        }\\n        \\n        public int getCur() {\\n            return cur;\\n        }\\n        \\n        public void next() {\\n            cur = (Integer)itr.next();\\n        }\\n        \\n        public boolean hasNext() {\\n            return itr.hasNext();\\n        }\\n    }\\n    \\n    \\n}```",
                "codeTag": "Java"
            },
            {
                "id": 209659,
                "title": "javascript-naive-solution-with-explanation-and-comments",
                "content": "I recommend watching the following video for an explanation of this approach: [https://www.youtube.com/watch?v=zplklOy7ENo](https://www.youtube.com/watch?v=zplklOy7ENo)\\n\\nSolution also inspired from: https://www.geeksforgeeks.org/find-smallest-range-containing-elements-from-k-lists/\\n\\nNOTE: You can improve this solution by using a heap, but there is no built-in implementation for a heap in ES6. So one would need to implement one prior to writing a solution for the problem. \\n\\n**Approach**\\n1. Maintain a pointer for every list that corresponds to current index for that list.\\n2. Initialize the pointer of every list to 0 (the first element).\\n3. Repeat the following steps until at least one list exhausts:\\n\\t*  Find the minimum and maximum value among the current elements of all the lists.\\n\\t* Advance the pointer (index) that points to the current minimum element.\\n\\t* Update the minRange if current (max - min) is less than minRange.\\n\\n```js\\nvar smallestRange = function(nums) {\\n  // we store an index for each list starting at zero\\n  const pointers = Array(nums.length).fill(0)\\n\\n  let minRangeMin = 0\\n  let minRangeMax = 0\\n  let minRange = Number.MAX_VALUE\\n\\n  let isDone = false\\n\\n  while (true) {\\n    // for every iteration of all the lists, we keep track of these values\\n    let minListIndex = -1\\n    let minValue = Number.MAX_VALUE\\n    let maxValue = Number.MIN_VALUE\\n\\n    // iterates over each list of numbers\\n    for (let listIndex = 0; listIndex < nums.length; listIndex++) {\\n      const list = nums[listIndex]\\n\\n      // if every element in a list is traversed, we terminate\\n      if (pointers[listIndex] === list.length) {\\n        isDone = true\\n        break\\n      }\\n\\n      const value = list[pointers[listIndex]]\\n\\n      // if the current value is less than the min, we update it\\n      // along with its index\\n      if (value < minValue) {\\n        minListIndex = listIndex\\n        minValue = value\\n      }\\n\\n      // if the current value is greater than the max, we update it\\n      if (value > maxValue) {\\n        maxValue = value\\n      }\\n    }\\n\\n    // if any list is exhausted, we cannot improve further\\n    if (isDone) break\\n\\n    // advance the pointer for the min\\n    pointers[minListIndex]++\\n\\n    // update the min range values\\n    if ((maxValue - minValue) < minRange) {\\n      minRangeMin = minValue\\n      minRangeMax = maxValue\\n      minRange = maxValue - minValue\\n    }\\n  }\\n\\n  return [minRangeMin, minRangeMax]\\n}\\n```\\n\\n**Time Complexity:**\\nO(n* k) since we have to loop through n elements of k lists. \\n\\n**Space Complexity:**\\nO(k) since it requires maintaining k pointers/indicies.",
                "solutionTags": [],
                "code": "```js\\nvar smallestRange = function(nums) {\\n  // we store an index for each list starting at zero\\n  const pointers = Array(nums.length).fill(0)\\n\\n  let minRangeMin = 0\\n  let minRangeMax = 0\\n  let minRange = Number.MAX_VALUE\\n\\n  let isDone = false\\n\\n  while (true) {\\n    // for every iteration of all the lists, we keep track of these values\\n    let minListIndex = -1\\n    let minValue = Number.MAX_VALUE\\n    let maxValue = Number.MIN_VALUE\\n\\n    // iterates over each list of numbers\\n    for (let listIndex = 0; listIndex < nums.length; listIndex++) {\\n      const list = nums[listIndex]\\n\\n      // if every element in a list is traversed, we terminate\\n      if (pointers[listIndex] === list.length) {\\n        isDone = true\\n        break\\n      }\\n\\n      const value = list[pointers[listIndex]]\\n\\n      // if the current value is less than the min, we update it\\n      // along with its index\\n      if (value < minValue) {\\n        minListIndex = listIndex\\n        minValue = value\\n      }\\n\\n      // if the current value is greater than the max, we update it\\n      if (value > maxValue) {\\n        maxValue = value\\n      }\\n    }\\n\\n    // if any list is exhausted, we cannot improve further\\n    if (isDone) break\\n\\n    // advance the pointer for the min\\n    pointers[minListIndex]++\\n\\n    // update the min range values\\n    if ((maxValue - minValue) < minRange) {\\n      minRangeMin = minValue\\n      minRangeMax = maxValue\\n      minRange = maxValue - minValue\\n    }\\n  }\\n\\n  return [minRangeMin, minRangeMax]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3725657,
                "title": "beginner-friendly-detailed-explanation-simple-and-intuitive-approach-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAfter reading the title ***Smallest Range Covering Elements from K Lists*** the first thing came in my  mind was sliding window and I started implementing the idea right away and it worked :)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n### Step 1\\nThere are $$k$$ lists. But to implement the sliding window technique all the elements must be in a single list. But if you merge all the lists into a single list, how will you keep track of the original list of an element?\\n\\nAnswer is simple. Just store the element along with the number of the list to which it belongs. You can use $$vector<pair<int,int>>$$ for that.\\n\\n### Step 2\\nNow we have all the elements in a single list. But now they are in jumbled manner. So sort the list by the actual value of the elements in ascending order.\\n\\n### Step 3\\nNow we have to return the smallest possible range. So Initialize two variables, say $$l$$ and $$h$$ to maintain the lower and higher bound of the range. Now the question is what should be the value of the $$l$$ and $$h$$ at the time of initialization.\\n\\nIn the worst case, the smallest range will be from 1st element of the list to the last element of the list. For example, consider the following test case,\\n\\n$$nums = [[1],[2,3],[4]]$$\\n\\nIn this case our sorted merged list will be\\n$$[[1,0],[2,1],[3,1],[4,2]]$$\\n\\nYou can easily see that, in this case, the smallest possible range which covers at least one element from each of the list is $$1$$ to $$4$$ i.e $$[1,4]$$ will be the answer.\\n\\nHence the value of $$l$$ and $$h$$ at the time of initialization should be the ***lowest element*** and the ***highest element*** of the merged list.\\n\\n### Step 4\\nNow as I discussed above, we will be implementing the sliding window technique. Now we have to keep record of the frequency of the elements from each of the lists in the window. So for that we will use $$map<int,int>$$ -> $$[Listnumber,frequency]$$.\\n\\nFor example, consider the above test case.For that the map will look something like this\\n[[0,1],[1,2],[2,1]]\\n\\n### Step 5\\nNow we will implement the sliding window. Initialize two pointers $$p1$$ and $$p2$$. Slide the window point by point and check for the condition $$mp.size()==k$$\\n\\nNow I am tired of explaining the process so refer the code below :p. Code contains the necessary comments.\\n\\nThank you for being patient!\\n\\n# Complexity\\n- Time complexity:$$O(NlogN)$$\\n\\n- Space complexity:$$O(N+K)$$\\n\\nwhere $$N$$ is the total number of elements and $$K$$ is the total number of lists\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int>>v;\\n        int n = nums.size();\\n        //merged all the lists into the single list\\n        //added the list number along with element to keep the track of the list to which the respective element belongs\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                v.push_back({nums[i][j],i});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int k = n;\\n        n = v.size();\\n        int p1 = 0, p2 = 0;\\n        map<int,int>mp;//{list number,count of the numbers belong to the range from that list}\\n        vector<int> ans;\\n        //initial lower limit and upper limit of the range\\n        int l = v[0].first, h = v[n-1].first;\\n        while(p2<n){\\n            mp[v[p2].second]++;\\n            while(mp.size()==k){//range should contain at least 1 element from each of the k lists           \\n                //if we found the range shorter than the previous then update it\\n                if(h-l+1>v[p2].first-v[p1].first+1){\\n                    l = v[p1].first;\\n                    h = v[p2].first;\\n                }\\n                //slide the window forward in order to determine the minimum possible range\\n                mp[v[p1].second]--;\\n                if(mp[v[p1].second]==0)\\n                    mp.erase(v[p1].second);\\n                p1++;\\n            }\\n            p2++;\\n        }\\n        return {l,h};\\n    }\\n};\\n```\\n\\n# If the above shit was helpful then please upvote so that I can post more shit like this :)",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int>>v;\\n        int n = nums.size();\\n        //merged all the lists into the single list\\n        //added the list number along with element to keep the track of the list to which the respective element belongs\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<nums[i].size();j++){\\n                v.push_back({nums[i][j],i});\\n            }\\n        }\\n        sort(v.begin(),v.end());\\n        int k = n;\\n        n = v.size();\\n        int p1 = 0, p2 = 0;\\n        map<int,int>mp;//{list number,count of the numbers belong to the range from that list}\\n        vector<int> ans;\\n        //initial lower limit and upper limit of the range\\n        int l = v[0].first, h = v[n-1].first;\\n        while(p2<n){\\n            mp[v[p2].second]++;\\n            while(mp.size()==k){//range should contain at least 1 element from each of the k lists           \\n                //if we found the range shorter than the previous then update it\\n                if(h-l+1>v[p2].first-v[p1].first+1){\\n                    l = v[p1].first;\\n                    h = v[p2].first;\\n                }\\n                //slide the window forward in order to determine the minimum possible range\\n                mp[v[p1].second]--;\\n                if(mp[v[p1].second]==0)\\n                    mp.erase(v[p1].second);\\n                p1++;\\n            }\\n            p2++;\\n        }\\n        return {l,h};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3547117,
                "title": "easy-c-solution-using-priority-queue",
                "content": "\\n\\n# Approach\\nInitialize a min heap (priority queue) to store tuples of the form (value, list index, element index). The heap will be sorted based on the \"value\" field.\\nInitialize variables: \"minRange\" and \"maxRange\" to keep track of the minimum and maximum values found so far, \"rangeSize\" to a large value or positive infinity.\\nInsert the first element from each list into the min heap along with the list index and element index.\\nFind the tuple with the minimum value in the min heap. This tuple represents the current range.\\nCalculate the current range size as the difference between the maximum and minimum values of the tuple.\\nIf the current range size is smaller than the previous range size, update the \"minRange\" and \"maxRange\" to the minimum and maximum values of the tuple.\\nRemove the tuple with the minimum value from the min heap.\\nIf the list associated with the removed tuple has more elements, insert the next element from that list into the min heap.\\nRepeat steps 4-8 until the end of any list is reached.\\nAt the end, the \"minRange\" and \"maxRange\" will represent the smallest range covering at least one element from each list.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N log K)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    struct node {\\n        int data, row, column;\\n        node(int value, int i, int j) : data(value), row(i), column(j) {}\\n    };\\n    struct comparator {\\n        bool operator() (node a, node b) {\\n            return a.data > b.data;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        // this approach will use a min heap of size k\\n        priority_queue<node, vector<node>, comparator> minHeap;\\n        int currMin = INT_MAX, currMax = INT_MIN, currRange = INT_MAX;\\n        // run a loop for k times and build the min heap\\n        for(int i = 0; i < k; ++i) {\\n            currMax = max(currMax, nums[i][0]);\\n            node temp(nums[i][0], i, 0);\\n            minHeap.push(temp);\\n        }\\n        // the start and end range of our answer\\n        int start = currMin, end = currMax;\\n        while(true) {\\n            node min = minHeap.top();\\n            minHeap.pop();\\n            currMin = min.data;\\n            // if we got a smaller range\\n            if(currMax - currMin < currRange) {\\n                start = currMin;\\n                end = currMax;\\n                currRange = currMax - currMin;\\n            }\\n            // if we don\\'t have anymore elements in the row of min element, we\\'re done\\n            if(min.column + 1 == nums[min.row].size())\\n                break;\\n            // if we still have atleast one element push it inside the min heap\\n            node next(nums[min.row][min.column + 1], min.row, min.column + 1);\\n            minHeap.push(next);\\n            // update the currMax if the next element is bigger than this\\n            if(next.data > currMax)\\n                currMax = next.data;\\n        }\\n        return {start, end};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct node {\\n        int data, row, column;\\n        node(int value, int i, int j) : data(value), row(i), column(j) {}\\n    };\\n    struct comparator {\\n        bool operator() (node a, node b) {\\n            return a.data > b.data;\\n        }\\n    };\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k = nums.size();\\n        // this approach will use a min heap of size k\\n        priority_queue<node, vector<node>, comparator> minHeap;\\n        int currMin = INT_MAX, currMax = INT_MIN, currRange = INT_MAX;\\n        // run a loop for k times and build the min heap\\n        for(int i = 0; i < k; ++i) {\\n            currMax = max(currMax, nums[i][0]);\\n            node temp(nums[i][0], i, 0);\\n            minHeap.push(temp);\\n        }\\n        // the start and end range of our answer\\n        int start = currMin, end = currMax;\\n        while(true) {\\n            node min = minHeap.top();\\n            minHeap.pop();\\n            currMin = min.data;\\n            // if we got a smaller range\\n            if(currMax - currMin < currRange) {\\n                start = currMin;\\n                end = currMax;\\n                currRange = currMax - currMin;\\n            }\\n            // if we don\\'t have anymore elements in the row of min element, we\\'re done\\n            if(min.column + 1 == nums[min.row].size())\\n                break;\\n            // if we still have atleast one element push it inside the min heap\\n            node next(nums[min.row][min.column + 1], min.row, min.column + 1);\\n            minHeap.push(next);\\n            // update the currMax if the next element is bigger than this\\n            if(next.data > currMax)\\n                currMax = next.data;\\n        }\\n        return {start, end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365858,
                "title": "c-easy-solution-using-heap-please",
                "content": "# Complexity\\n- Time complexity:O(Nlogk) .. N is total numbers of elements\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k) .. k is the numbers of lists\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass node{\\n        public:\\n        int data;\\n        int i;\\n        int j;     \\n        node(int data, int row ,int col){\\n            this->data =data;\\n            i = row;\\n            j = col;\\n        }    \\n};\\nclass compare{\\n    public:\\n        bool operator()(node* a , node* b){\\n            return a->data > b->data;\\n        }\\n};\\nclass Solution { \\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {  \\n        priority_queue<node* , vector<node*> ,compare > pq;\\n        int mini = INT_MAX , maxi = INT_MIN;\\n\\n        for(int i = 0 ; i < nums.size() ; i ++){\\n            int element = nums[i][0];\\n            maxi = max(maxi , element);\\n            mini = min(mini , element);\\n            pq.push(new node(element , i , 0));\\n        }\\n\\n        int start = mini , end = maxi;\\n\\n        while(!pq.empty()){\\n\\n            node* temp = pq.top();\\n            pq.pop();\\n\\n            mini = temp->data;\\n\\n            if(maxi - mini < end - start){\\n                start = mini;\\n                end = maxi;\\n            }\\n\\n            if(temp->j + 1 < nums[temp->i].size()){\\n               int element = nums[temp->i][temp->j + 1];\\n               maxi = max(maxi , element);\\n            pq.push(new node(element , temp->i , temp->j + 1));      \\n            }\\n            else break;\\n        }\\n        vector<int>ans;\\n        ans.push_back(start);\\n        ans.push_back(end);\\n        return ans; \\n  \\n    }\\n\\n};\\n```\\n\\n# UPVOTE FOR A COOKIE ;)\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass node{\\n        public:\\n        int data;\\n        int i;\\n        int j;     \\n        node(int data, int row ,int col){\\n            this->data =data;\\n            i = row;\\n            j = col;\\n        }    \\n};\\nclass compare{\\n    public:\\n        bool operator()(node* a , node* b){\\n            return a->data > b->data;\\n        }\\n};\\nclass Solution { \\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {  \\n        priority_queue<node* , vector<node*> ,compare > pq;\\n        int mini = INT_MAX , maxi = INT_MIN;\\n\\n        for(int i = 0 ; i < nums.size() ; i ++){\\n            int element = nums[i][0];\\n            maxi = max(maxi , element);\\n            mini = min(mini , element);\\n            pq.push(new node(element , i , 0));\\n        }\\n\\n        int start = mini , end = maxi;\\n\\n        while(!pq.empty()){\\n\\n            node* temp = pq.top();\\n            pq.pop();\\n\\n            mini = temp->data;\\n\\n            if(maxi - mini < end - start){\\n                start = mini;\\n                end = maxi;\\n            }\\n\\n            if(temp->j + 1 < nums[temp->i].size()){\\n               int element = nums[temp->i][temp->j + 1];\\n               maxi = max(maxi , element);\\n            pq.push(new node(element , temp->i , temp->j + 1));      \\n            }\\n            else break;\\n        }\\n        vector<int>ans;\\n        ans.push_back(start);\\n        ans.push_back(end);\\n        return ans; \\n  \\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3294952,
                "title": "c-code-using-priority-queue-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsed priority queue of vectors.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n->In the priority queue ,\\n->Each input is stored as vector,in which 3 indexes represent in the for loop:\\n0th index: Minimum element of the each list\\n1st index: Index of the element from that vector\\n2nd index: Index of that vector in the 2d vector\\n\\n->And then take the minimum element , compute the maximum element in priority queue\\n->Computer the length then check,if the length of the range is less than previous range \\n->if the length is smaller then update the res[0] and res[1] as the min and max element\\n->now traverse the vector from which the minimum element is taken\\n->now increase the index and then add the element in queue \\n->repeat the process\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int>res={-100000,100000};\\n        int k=nums.size();\\n        int maxi=INT_MIN;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        for(int i=0;i<k;i++){\\n            int num=nums[i][0];\\n            vector<int>vec{num,0,i};\\n            //0th minimum element of list\\n            //1st index of element from the vector\\n            //2nd index of the vector\\n            //1st <4,0,0> 2nd <0,0,1> 3rd <5,0,2>\\n            maxi=max(maxi,num);//took the max of members //5\\n            pq.push(vec);\\n            //<0,0,1><4,0,0><5,0,2>\\n        }\\n        while(true){//until condition breaks\\n            vector<int>minval=pq.top();//<0,0,1>\\n            pq.pop();//<4,0,0><5,0,2>\\n            if(res[1]-res[0]>maxi-minval[0]){//5-0=5\\n                res[0]=minval[0];//res[0]=0\\n                res[1]=maxi;//res[1]=5\\n            }\\n            minval[1]++;//<0,1,1>,now from which we poped element in queue that min element containing vector , we should choose another element\\n            vector<int>vec2=nums[minval[2]];//minval[2]=1,so <0,9,12,20>\\n            if(minval[1]==vec2.size()){//1!=4 \\n                break;\\n            }\\n            else{\\n                minval[0]=vec2[minval[1]];//minival[0]=vec2[1]=9\\n                maxi=max(maxi,vec2[minval[1]]);//maxi=max(5,9)=9\\n                pq.push(minval);//push <9,1,1>\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int>res={-100000,100000};\\n        int k=nums.size();\\n        int maxi=INT_MIN;\\n        priority_queue<vector<int>,vector<vector<int>>,greater<vector<int>>>pq;\\n        for(int i=0;i<k;i++){\\n            int num=nums[i][0];\\n            vector<int>vec{num,0,i};\\n            //0th minimum element of list\\n            //1st index of element from the vector\\n            //2nd index of the vector\\n            //1st <4,0,0> 2nd <0,0,1> 3rd <5,0,2>\\n            maxi=max(maxi,num);//took the max of members //5\\n            pq.push(vec);\\n            //<0,0,1><4,0,0><5,0,2>\\n        }\\n        while(true){//until condition breaks\\n            vector<int>minval=pq.top();//<0,0,1>\\n            pq.pop();//<4,0,0><5,0,2>\\n            if(res[1]-res[0]>maxi-minval[0]){//5-0=5\\n                res[0]=minval[0];//res[0]=0\\n                res[1]=maxi;//res[1]=5\\n            }\\n            minval[1]++;//<0,1,1>,now from which we poped element in queue that min element containing vector , we should choose another element\\n            vector<int>vec2=nums[minval[2]];//minval[2]=1,so <0,9,12,20>\\n            if(minval[1]==vec2.size()){//1!=4 \\n                break;\\n            }\\n            else{\\n                minval[0]=vec2[minval[1]];//minival[0]=vec2[1]=9\\n                maxi=max(maxi,vec2[minval[1]]);//maxi=max(5,9)=9\\n                pq.push(minval);//push <9,1,1>\\n            }\\n        }\\nreturn res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852622,
                "title": "c-easy-sliding-window",
                "content": "\\n\\n# Code\\n```\\n//from manavjain\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> ordered; \\n        for (size_t k = 0; k < nums.size(); ++k)\\n            for (auto n: nums[k]) ordered.push_back({n, k});\\n        sort(ordered.begin(), ordered.end());\\n\\n        int i = 0, k = 0;\\n        vector<int> ans;\\n        unordered_map<int, int> count;\\n        for (size_t j = 0; j < ordered.size(); ++j) {\\n            if (! count[ordered[j].second]++) ++k;\\n            if (k == nums.size()) { \\n                while (count[ordered[i].second] > 1) --count[ordered[i++].second]; \\n                if (ans.empty() || ans[1] - ans[0] > ordered[j].first - ordered[i].first) {\\n                    ans = vector<int>{ordered[i].first, ordered[j].first};\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//from manavjain\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> ordered; \\n        for (size_t k = 0; k < nums.size(); ++k)\\n            for (auto n: nums[k]) ordered.push_back({n, k});\\n        sort(ordered.begin(), ordered.end());\\n\\n        int i = 0, k = 0;\\n        vector<int> ans;\\n        unordered_map<int, int> count;\\n        for (size_t j = 0; j < ordered.size(); ++j) {\\n            if (! count[ordered[j].second]++) ++k;\\n            if (k == nums.size()) { \\n                while (count[ordered[i].second] > 1) --count[ordered[i++].second]; \\n                if (ans.empty() || ans[1] - ans[0] > ordered[j].first - ordered[i].first) {\\n                    ans = vector<int>{ordered[i].first, ordered[j].first};\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562653,
                "title": "c-set-sliding-window-96-31-fast",
                "content": "I am fixing the window of size k equals to number of rows in nums.\\nkeeping track of which column i am tracing of each row in vector idx\\n\\n\\n```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        set<pair<int,int>> s;\\n        \\n        int k = nums.size();\\n        vector<int> idx(k,0);\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k; i++)\\n            s.insert({nums[i][0],i});\\n        \\n        int  df = INT_MAX;\\n        while(true){\\n            int minPos = (*s.begin()).second;\\n            int a = (*s.begin()).first, b = (*(--s.end())).first;\\n            \\n            int diff =  b-a ;\\n            \\n            if(diff<df){\\n                ans.clear();\\n                ans.push_back(a);\\n                ans.push_back(b);\\n                df = diff;\\n            }\\n            \\n            s.erase(s.begin());\\n            idx[minPos]++;\\n            \\n            if(idx[minPos] == nums[minPos].size()){\\n                break;\\n            }\\n            \\n            s.insert({nums[minPos][idx[minPos]],minPos});\\n        } \\n        return ans;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        set<pair<int,int>> s;\\n        \\n        int k = nums.size();\\n        vector<int> idx(k,0);\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k; i++)\\n            s.insert({nums[i][0],i});\\n        \\n        int  df = INT_MAX;\\n        while(true){\\n            int minPos = (*s.begin()).second;\\n            int a = (*s.begin()).first, b = (*(--s.end())).first;\\n            \\n            int diff =  b-a ;\\n            \\n            if(diff<df){\\n                ans.clear();\\n                ans.push_back(a);\\n                ans.push_back(b);\\n                df = diff;\\n            }\\n            \\n            s.erase(s.begin());\\n            idx[minPos]++;\\n            \\n            if(idx[minPos] == nums[minPos].size()){\\n                break;\\n            }\\n            \\n            s.insert({nums[minPos][idx[minPos]],minPos});\\n        } \\n        return ans;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2054624,
                "title": "c-simple-priority-queue-implementation-explained",
                "content": "**Please do upvote if you liked my code ;)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<int> smallestRange(vector<vector<int>>& nums) \\n    {\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<long> ans{INT_MIN, INT_MAX};\\n        int mx = INT_MIN;\\n                \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            pq.push({nums[i][0], 0, i});    // In Pq, store the element, its index in the list & index of list in nums\\n            mx = max(mx, nums[i][0]);\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto minPq = pq.top();\\n            pq.pop();\\n            \\n            if(ans[1]-ans[0] > mx-minPq[0])\\n                ans[1] = mx, ans[0] = minPq[0];\\n            \\n            if(minPq[1] == nums[minPq[2]].size()-1) break; // If we reach end of a list, break\\n            else                                           // Otherwise keep adding elements to Pq\\n            {\\n                int curr = nums[minPq[2]][minPq[1]+1];\\n                mx = max(mx, nums[minPq[2]][minPq[1]+1]);\\n                pq.push({curr, minPq[1]+1, minPq[2]});\\n            }\\n        }\\n        \\n        return {int(ans[0]), int(ans[1])};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int> smallestRange(vector<vector<int>>& nums) \\n    {\\n        priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;\\n        vector<long> ans{INT_MIN, INT_MAX};\\n        int mx = INT_MIN;\\n                \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            pq.push({nums[i][0], 0, i});    // In Pq, store the element, its index in the list & index of list in nums\\n            mx = max(mx, nums[i][0]);\\n        }\\n        \\n        while(!pq.empty())\\n        {\\n            auto minPq = pq.top();\\n            pq.pop();\\n            \\n            if(ans[1]-ans[0] > mx-minPq[0])\\n                ans[1] = mx, ans[0] = minPq[0];\\n            \\n            if(minPq[1] == nums[minPq[2]].size()-1) break; // If we reach end of a list, break\\n            else                                           // Otherwise keep adding elements to Pq\\n            {\\n                int curr = nums[minPq[2]][minPq[1]+1];\\n                mx = max(mx, nums[minPq[2]][minPq[1]+1]);\\n                pq.push({curr, minPq[1]+1, minPq[2]});\\n            }\\n        }\\n        \\n        return {int(ans[0]), int(ans[1])};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1865315,
                "title": "c-with-priority-queue",
                "content": "```\\npublic int[] SmallestRange(IList<IList<int>> nums) {\\n        if (nums.Count == 0) {\\n            return new int[] {};\\n        }\\n        \\n        PriorityQueue<int[], int> queue = new PriorityQueue<int[], int>();\\n        \\n        int max = int.MinValue;\\n        int currentMax = int.MinValue;\\n        for (int i = 0; i < nums.Count; ++i) {\\n            queue.Enqueue(new int[] {nums[i][0], i, 0}, nums[i][0]);\\n            max = Math.Max(max, nums[i][0]);\\n            currentMax = max;\\n        }\\n        \\n        int min = int.MaxValue;\\n        \\n        int minRange = int.MaxValue;\\n        while (queue.Count == nums.Count) {\\n            int[] qMin = queue.Dequeue();\\n            \\n            int newMin = qMin[0];\\n            \\n            if (currentMax - newMin < minRange || (currentMax - newMin == minRange \\n                                                   && newMin < min)) {\\n                min = newMin;\\n                max = currentMax;\\n                minRange = max - min;\\n            }\\n            \\n            if (qMin[2] + 1 < nums[qMin[1]].Count) {\\n              int nextValue = nums[qMin[1]][qMin[2] + 1];\\n              currentMax = Math.Max(currentMax, nextValue);\\n              \\n              queue.Enqueue(new int[] {nums[qMin[1]][qMin[2] + 1],\\n                                       qMin[1], qMin[2] + 1},\\n                                       nums[qMin[1]][qMin[2] + 1]);\\n            }\\n        }\\n        \\n        return new int[] { min, max };\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] SmallestRange(IList<IList<int>> nums) {\\n        if (nums.Count == 0) {\\n            return new int[] {};\\n        }\\n        \\n        PriorityQueue<int[], int> queue = new PriorityQueue<int[], int>();\\n        \\n        int max = int.MinValue;\\n        int currentMax = int.MinValue;\\n        for (int i = 0; i < nums.Count; ++i) {\\n            queue.Enqueue(new int[] {nums[i][0], i, 0}, nums[i][0]);\\n            max = Math.Max(max, nums[i][0]);\\n            currentMax = max;\\n        }\\n        \\n        int min = int.MaxValue;\\n        \\n        int minRange = int.MaxValue;\\n        while (queue.Count == nums.Count) {\\n            int[] qMin = queue.Dequeue();\\n            \\n            int newMin = qMin[0];\\n            \\n            if (currentMax - newMin < minRange || (currentMax - newMin == minRange \\n                                                   && newMin < min)) {\\n                min = newMin;\\n                max = currentMax;\\n                minRange = max - min;\\n            }\\n            \\n            if (qMin[2] + 1 < nums[qMin[1]].Count) {\\n              int nextValue = nums[qMin[1]][qMin[2] + 1];\\n              currentMax = Math.Max(currentMax, nextValue);\\n              \\n              queue.Enqueue(new int[] {nums[qMin[1]][qMin[2] + 1],\\n                                       qMin[1], qMin[2] + 1},\\n                                       nums[qMin[1]][qMin[2] + 1]);\\n            }\\n        }\\n        \\n        return new int[] { min, max };\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1654725,
                "title": "python-heap-solution",
                "content": "```\\nimport heapq as heap\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        pq = []\\n        rangeStart,rangeEnd = float(\"-inf\"),float(\"inf\")\\n        max_number = float(\"-inf\")\\n        for i in range(len(nums)):\\n            heap.heappush(pq,(nums[i][0],0,nums[i]))\\n            max_number = max(max_number,nums[i][0])\\n            \\n        while len(pq)==len(nums):\\n            \\n            val,listindex,cl = heap.heappop(pq)\\n            if max_number - val < rangeEnd - rangeStart:\\n                rangeStart = val\\n                rangeEnd = max_number\\n                \\n            if len(cl) > listindex+1:\\n                heap.heappush(pq,(cl[listindex+1],listindex+1,cl))\\n                max_number = max(max_number,cl[listindex+1])\\n        return [rangeStart,rangeEnd]",
                "solutionTags": [
                    "Python",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport heapq as heap\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        pq = []\\n        rangeStart,rangeEnd = float(\"-inf\"),float(\"inf\")\\n        max_number = float(\"-inf\")\\n        for i in range(len(nums)):\\n            heap.heappush(pq,(nums[i][0],0,nums[i]))\\n            max_number = max(max_number,nums[i][0])\\n            \\n        while len(pq)==len(nums):\\n            \\n            val,listindex,cl = heap.heappop(pq)\\n            if max_number - val < rangeEnd - rangeStart:\\n                rangeStart = val\\n                rangeEnd = max_number\\n                \\n            if len(cl) > listindex+1:\\n                heap.heappush(pq,(cl[listindex+1],listindex+1,cl))\\n                max_number = max(max_number,cl[listindex+1])\\n        return [rangeStart,rangeEnd]",
                "codeTag": "Java"
            },
            {
                "id": 1436596,
                "title": "c-easiest-solution-with-min-heap",
                "content": "```\\n#define pi    pair<int, pair<int, int>>\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n        priority_queue<pi,vector<pi>, greater<pi>> pq;\\n        int mx=0;\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            pq.push({arr[i][0], {i,0}});//no,{i,j}\\n            mx = max(mx, arr[i][0]);//max from 0th idx of all the k lists\\n        }\\n        \\n        int mn = pq.top().first;//min of all from 0 indices of k lists\\n        int max_no=mx;\\n        int min_no=mn;\\n        \\n        while(!pq.empty())\\n        {\\n            pi top = pq.top();\\n            pq.pop();\\n            int row = top.second.first;\\n\\n            //updating the next element to the next of the min element of same row\\n            int col_next = top.second.second + 1;//column index\\n            if(col_next < arr[row].size())\\n            {\\n                pq.push({arr[row][col_next], {row,col_next}});\\n                mx = max(mx, arr[row][col_next]);\\n                mn = pq.top().first;\\n\\n                if(mx-mn < (max_no - min_no))//curr_diff < diff of max and min nos\\n                {\\n                    max_no = mx;\\n                    min_no = mn;\\n                }\\n            }\\n            else //of of bound from any list\\n                break;\\n\\n        }\\n        return {min_no, max_no};\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n        priority_queue<pi,vector<pi>, greater<pi>> pq;\\n        int mx=0;\\n        for(int i=0; i<arr.size(); i++)\\n        {\\n            pq.push({arr[i][0], {i,0}",
                "codeTag": "Java"
            },
            {
                "id": 1338810,
                "title": "c-simple-solution-using-low-and-high-pointers",
                "content": "```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<pair<int,int>> vp;\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            for(auto vbn : nums[i]) \\n                vp.push_back({vbn, i});\\n        }\\n        \\n        sort(vp.begin(), vp.end());\\n        int st = -1, en = -1, len = 100000000;\\n        int lo = 0, hi = -1;\\n        \\n        for(; lo < vp.size(); lo++) {\\n            \\n            while(mpp.size() < nums.size()) {\\n                hi++; \\n                if(hi >= vp.size()) \\n                    return {st, en};\\n                mpp[vp[hi].second]++;\\n            }\\n            \\n            if(len > vp[hi].first - vp[lo].first + 1) {\\n                len = vp[hi].first - vp[lo].first + 1;\\n                st = vp[lo].first, en = vp[hi].first;\\n            }\\n        \\n            if(mpp[vp[lo].second] == 1) mpp.erase(vp[lo].second);\\n            else mpp[vp[lo].second]--;\\n        }\\n        \\n        vector<int> ans = {st, en};\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        vector<pair<int,int>> vp;\\n        map<int, int> mpp;\\n        \\n        for(int i = 0; i < nums.size(); i++) {\\n            for(auto vbn : nums[i]) \\n                vp.push_back({vbn, i});\\n        }\\n        \\n        sort(vp.begin(), vp.end());\\n        int st = -1, en = -1, len = 100000000;\\n        int lo = 0, hi = -1;\\n        \\n        for(; lo < vp.size(); lo++) {\\n            \\n            while(mpp.size() < nums.size()) {\\n                hi++; \\n                if(hi >= vp.size()) \\n                    return {st, en};\\n                mpp[vp[hi].second]++;\\n            }\\n            \\n            if(len > vp[hi].first - vp[lo].first + 1) {\\n                len = vp[hi].first - vp[lo].first + 1;\\n                st = vp[lo].first, en = vp[hi].first;\\n            }\\n        \\n            if(mpp[vp[lo].second] == 1) mpp.erase(vp[lo].second);\\n            else mpp[vp[lo].second]--;\\n        }\\n        \\n        vector<int> ans = {st, en};\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1319842,
                "title": "min-heap-priority-queue-easy-to-understand-java",
                "content": "```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\t\\tint max = Integer.MIN_VALUE;\\n        int minGap = Integer.MAX_VALUE;\\n        int ans[] = new int[2];\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            max  = Math.max(max, nums.get(i).get(0));\\n            pq.add(new int[]{i, 0, nums.get(i).get(0)});  // {List No., current index in the List, List Element}\\n        }\\n        \\n        while(true){\\n            int rem[] = pq.remove();\\n            int lsNo = rem[0];\\n            int idx = rem[1];\\n            int min = rem[2];\\n            \\n            if(minGap > max-min){\\n                minGap = max-min;\\n                ans[0] = min;\\n                ans[1] = max;\\n            }\\n\\t\\t\\tif(++idx == nums.get(lsNo).size()) break;     // breaking the loop as soon as any of the list gets completed\\n            \\n            max = Math.max(nums.get(lsNo).get(idx), max);    // updating the max Element everytime a new Element is added\\n            pq.add(new int[]{lsNo, idx, nums.get(lsNo).get(idx)});\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[2] - b[2]);\\n\\t\\tint max = Integer.MIN_VALUE;\\n        int minGap = Integer.MAX_VALUE;\\n        int ans[] = new int[2];\\n        \\n        for(int i = 0; i<nums.size(); i++){\\n            max  = Math.max(max, nums.get(i).get(0));\\n            pq.add(new int[]{i, 0, nums.get(i).get(0)});  // {List No., current index in the List, List Element}\\n        }\\n        \\n        while(true){\\n            int rem[] = pq.remove();\\n            int lsNo = rem[0];\\n            int idx = rem[1];\\n            int min = rem[2];\\n            \\n            if(minGap > max-min){\\n                minGap = max-min;\\n                ans[0] = min;\\n                ans[1] = max;\\n            }\\n\\t\\t\\tif(++idx == nums.get(lsNo).size()) break;     // breaking the loop as soon as any of the list gets completed\\n            \\n            max = Math.max(nums.get(lsNo).get(idx), max);    // updating the max Element everytime a new Element is added\\n            pq.add(new int[]{lsNo, idx, nums.get(lsNo).get(idx)});\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314680,
                "title": "using-heap-c",
                "content": "```\\n#define ppi pair<int,pair<int,int>>                                                 //// first==element from vector, second =vector number  , third = index on that particular vector\\nclass Solution {\\npublic:#define ppi pair<int,pair<int,int>> \\nclass Solution {\\npublic:\\n    \\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        int k=a.size();\\n        int mx=INT_MIN,mn=INT_MAX;                 ///storing and updating  min and max element   \\n    int range=INT_MAX;\\n\\t\\t\\tint mnel,mxel;                 ///final min and max element to be stored \\n    priority_queue<ppi,vector<ppi>,greater<ppi>> pq;                                            ////min heap \\n\\t\\tfor(int i=0;i<k;i++)                                                         ///inserting all the first element of every vector\\n    {\\n        pq.push({a[i][0],{i,0}});\\n        if(a[i][0]>mx)\\n        mx=a[i][0];\\n    }\\n    \\n    while(!(pq.empty()) && pq.size()==k)\\n    {\\n        ppi z=pq.top();\\n        pq.pop();\\n\\n        if(range>mx-z.first+1)                                                                        ////comparing the range ,if the range get decreases then update it\\n        {\\n            range=mx-z.first+1;\\n            mnel=z.first,mxel=mx;\\n        }\\n\\n        if(z.second.second+1<a[z.second.first].size())                                                       /// check that index does not exceed the vector size , if so then while loop would terminate by comparing size of heap\\n        {\\n            if(mx<a[z.second.first][z.second.second+1])\\n            {\\n                mx=a[z.second.first][z.second.second+1];\\n            }\\n            pq.push({a[z.second.first][z.second.second+1],{z.second.first,z.second.second+1}});\\n        }\\n        else break;\\n\\n    }\\n        return {mnel,mxel};\\n    }\\n};\\n    \\n    \\n```",
                "solutionTags": [],
                "code": "```\\n#define ppi pair<int,pair<int,int>>                                                 //// first==element from vector, second =vector number  , third = index on that particular vector\\nclass Solution {\\npublic:#define ppi pair<int,pair<int,int>> \\nclass Solution {\\npublic:\\n    \\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        int k=a.size();\\n        int mx=INT_MIN,mn=INT_MAX;                 ///storing and updating  min and max element   \\n    int range=INT_MAX;\\n\\t\\t\\tint mnel,mxel;                 ///final min and max element to be stored \\n    priority_queue<ppi,vector<ppi>,greater<ppi>> pq;                                            ////min heap \\n\\t\\tfor(int i=0;i<k;i++)                                                         ///inserting all the first element of every vector\\n    {\\n        pq.push({a[i][0],{i,0}});\\n        if(a[i][0]>mx)\\n        mx=a[i][0];\\n    }\\n    \\n    while(!(pq.empty()) && pq.size()==k)\\n    {\\n        ppi z=pq.top();\\n        pq.pop();\\n\\n        if(range>mx-z.first+1)                                                                        ////comparing the range ,if the range get decreases then update it\\n        {\\n            range=mx-z.first+1;\\n            mnel=z.first,mxel=mx;\\n        }\\n\\n        if(z.second.second+1<a[z.second.first].size())                                                       /// check that index does not exceed the vector size , if so then while loop would terminate by comparing size of heap\\n        {\\n            if(mx<a[z.second.first][z.second.second+1])\\n            {\\n                mx=a[z.second.first][z.second.second+1];\\n            }\\n            pq.push({a[z.second.first][z.second.second+1],{z.second.first,z.second.second+1}});\\n        }\\n        else break;\\n\\n    }\\n        return {mnel,mxel};\\n    }\\n};\\n    \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207411,
                "title": "sliding-window-c",
                "content": "1. Collect all the elements in temp array\\n2. Sort temp array (element of temp array is a pair -> {value, list id to which it belongs})\\n3. Find the window which contains elements from all lists and has lowest range\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int k = nums.size();\\n        int n = 0;\\n        for(auto &e : nums){\\n            n += e.size();\\n        }\\n        \\n        //{val, listnumber}\\n        vector<pair<int, int>> temp(n);\\n        int m = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            for(int j = 0 ; j < nums[i].size(); j++){\\n                temp[m++] = {nums[i][j], i};\\n            }\\n        }\\n        \\n        sort(temp.begin(), temp.end());\\n        //print(temp);\\n        \\n        unordered_map<int, int> map;\\n        int small = INT_MAX;\\n        int e1, e2; // e1 is 1st element and e2 is 2nd element to be returned\\n        int l = 0, r = 0; //l is left and r is right. These are 2 end points of our sliding window\\n        \\n        while(r < n){\\n            \\n            while(r < n and map.size() != k){\\n                map[temp[r].second]++;\\n                r++;\\n            }\\n            \\n            r--;\\n            \\n            while(l <= r && map.size() == k){\\n                \\n                if(temp[r].first - temp[l].first < small){\\n                    e1 = temp[l].first;\\n                    e2 = temp[r].first;\\n                    small = e2 - e1;\\n                }\\n                \\n                map[temp[l].second]--;\\n                \\n                if(map[temp[l].second] == 0){\\n                    map.erase(temp[l].second);\\n                }\\n                \\n                l++;\\n            }\\n            r++;       \\n        }\\n        \\n        //cout<<small<<\" \"<<e1<<\" \"<<e2;\\n        \\n        return {e1, e2};\\n    }\\n    \\n    void print(vector<pair<int, int>> &temp){\\n        for(int i = 0 ; i < temp.size(); i++){\\n            cout<<temp[i].first<<\"\\\\t\";\\n        }\\n        cout<<endl;\\n        for(int i = 0 ; i < temp.size(); i++){\\n            cout<<temp[i].second<<\"\\\\t\";\\n        }\\n        cout<<endl;\\n    }\\n};\\n```\\n\\nUncomment print(temp) to see what it contains\\n\\nThanks",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int k = nums.size();\\n        int n = 0;\\n        for(auto &e : nums){\\n            n += e.size();\\n        }\\n        \\n        //{val, listnumber}\\n        vector<pair<int, int>> temp(n);\\n        int m = 0;\\n        for(int i = 0 ; i < nums.size(); i++){\\n            for(int j = 0 ; j < nums[i].size(); j++){\\n                temp[m++] = {nums[i][j], i};\\n            }\\n        }\\n        \\n        sort(temp.begin(), temp.end());\\n        //print(temp);\\n        \\n        unordered_map<int, int> map;\\n        int small = INT_MAX;\\n        int e1, e2; // e1 is 1st element and e2 is 2nd element to be returned\\n        int l = 0, r = 0; //l is left and r is right. These are 2 end points of our sliding window\\n        \\n        while(r < n){\\n            \\n            while(r < n and map.size() != k){\\n                map[temp[r].second]++;\\n                r++;\\n            }\\n            \\n            r--;\\n            \\n            while(l <= r && map.size() == k){\\n                \\n                if(temp[r].first - temp[l].first < small){\\n                    e1 = temp[l].first;\\n                    e2 = temp[r].first;\\n                    small = e2 - e1;\\n                }\\n                \\n                map[temp[l].second]--;\\n                \\n                if(map[temp[l].second] == 0){\\n                    map.erase(temp[l].second);\\n                }\\n                \\n                l++;\\n            }\\n            r++;       \\n        }\\n        \\n        //cout<<small<<\" \"<<e1<<\" \"<<e2;\\n        \\n        return {e1, e2};\\n    }\\n    \\n    void print(vector<pair<int, int>> &temp){\\n        for(int i = 0 ; i < temp.size(); i++){\\n            cout<<temp[i].first<<\"\\\\t\";\\n        }\\n        cout<<endl;\\n        for(int i = 0 ; i < temp.size(); i++){\\n            cout<<temp[i].second<<\"\\\\t\";\\n        }\\n        cout<<endl;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1097642,
                "title": "java-priorityqueue-23ms-beats-92-o-nlogm",
                "content": "\\n    class Pair {\\n\\n\\t\\tint val;\\n\\t\\tint row;\\n\\t\\tint col;\\n\\n\\t\\tpublic Pair(int val, int row, int col) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.row = row;\\n\\t\\t\\tthis.col = col;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(nlogm)\\n\\t// n is the number of elements in the list and m is the size of the list\\n\\tpublic int[] smallestRange(List<List<Integer>> nums) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tPriorityQueue<Pair> heap = new PriorityQueue<>(new Comparator<Pair>() {\\n\\t\\t\\tpublic int compare(Pair o1, Pair o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint len = nums.size(), range = Integer.MAX_VALUE, si = 0, ei = 0, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint num = nums.get(i).get(0);\\n\\t\\t\\theap.offer(new Pair(num, i, 0));\\n\\t\\t\\tif (num > max)\\n\\t\\t\\t\\tmax = num;\\n\\t\\t}\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tPair min = heap.poll();\\n\\n\\t\\t\\tif (max - min.val + 1 < range) {\\n\\t\\t\\t\\trange = max - min.val + 1;\\n\\t\\t\\t\\tsi = min.val;\\n\\t\\t\\t\\tei = max;\\n\\t\\t\\t}\\n\\t\\t\\tint row = min.row;\\n\\t\\t\\tint col = min.col;\\n\\n\\t\\t\\tif (col + 1 == nums.get(row).size())\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tint val = nums.get(row).get(col + 1);\\n\\t\\t\\tif (val > max)\\n\\t\\t\\t\\tmax = val;\\n\\t\\t\\theap.offer(new Pair(nums.get(row).get(col + 1), row, col + 1));\\n\\t\\t}\\n\\n\\t\\tans[0] = si;\\n\\t\\tans[1] = ei;\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "solutionTags": [],
                "code": "\\n    class Pair {\\n\\n\\t\\tint val;\\n\\t\\tint row;\\n\\t\\tint col;\\n\\n\\t\\tpublic Pair(int val, int row, int col) {\\n\\t\\t\\tthis.val = val;\\n\\t\\t\\tthis.row = row;\\n\\t\\t\\tthis.col = col;\\n\\t\\t}\\n\\n\\t}\\n\\n\\t// O(nlogm)\\n\\t// n is the number of elements in the list and m is the size of the list\\n\\tpublic int[] smallestRange(List<List<Integer>> nums) {\\n\\t\\tint[] ans = new int[2];\\n\\t\\tPriorityQueue<Pair> heap = new PriorityQueue<>(new Comparator<Pair>() {\\n\\t\\t\\tpublic int compare(Pair o1, Pair o2) {\\n\\t\\t\\t\\treturn o1.val - o2.val;\\n\\t\\t\\t}\\n\\t\\t});\\n\\t\\tint len = nums.size(), range = Integer.MAX_VALUE, si = 0, ei = 0, max = Integer.MIN_VALUE;\\n\\t\\tfor (int i = 0; i < len; i++) {\\n\\t\\t\\tint num = nums.get(i).get(0);\\n\\t\\t\\theap.offer(new Pair(num, i, 0));\\n\\t\\t\\tif (num > max)\\n\\t\\t\\t\\tmax = num;\\n\\t\\t}\\n\\n\\t\\twhile (true) {\\n\\t\\t\\tPair min = heap.poll();\\n\\n\\t\\t\\tif (max - min.val + 1 < range) {\\n\\t\\t\\t\\trange = max - min.val + 1;\\n\\t\\t\\t\\tsi = min.val;\\n\\t\\t\\t\\tei = max;\\n\\t\\t\\t}\\n\\t\\t\\tint row = min.row;\\n\\t\\t\\tint col = min.col;\\n\\n\\t\\t\\tif (col + 1 == nums.get(row).size())\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tint val = nums.get(row).get(col + 1);\\n\\t\\t\\tif (val > max)\\n\\t\\t\\t\\tmax = val;\\n\\t\\t\\theap.offer(new Pair(nums.get(row).get(col + 1), row, col + 1));\\n\\t\\t}\\n\\n\\t\\tans[0] = si;\\n\\t\\tans[1] = ei;\\n\\n\\t\\treturn ans;\\n\\t}\\n",
                "codeTag": "Java"
            },
            {
                "id": 977227,
                "title": "python-sliding-window-94",
                "content": "Maintain a hashtable to check that your window has the required elements from all lists. First expand the tail pointer such that we have a window that contains number from all list, then reduce the window from the head pointer. Whenever we reduce the window, keep track of the smallest range seen.\\n\\n```\\ndef smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        allNums = []\\n        ht = {}\\n        for i, nums_ in enumerate(nums):\\n            ht[i] = 0\\n            for n in nums_:\\n                allNums.append((n, i))\\n        \\n        allNums.sort(key=lambda x:x[0])\\n        \\n        minRange = 1000000\\n        count = len(nums)\\n        i = 0\\n        a = 0\\n        b = 0\\n        for j in range(len(allNums)):\\n            x, y = allNums[j]\\n            # x is the value\\n            # y is in the list index\\n            if ht[y] == 0:\\n                count -= 1\\n            ht[y] += 1\\n            while count == 0:\\n                x1, y1 = allNums[i]\\n                if x - x1 < minRange:\\n                    a, b = x1, x\\n                    minRange = x - x1\\n                if ht[y1] == 1:\\n                    count += 1\\n                ht[y1] -= 1\\n                i += 1\\n            \\n        return [a, b]\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        allNums = []\\n        ht = {}\\n        for i, nums_ in enumerate(nums):\\n            ht[i] = 0\\n            for n in nums_:\\n                allNums.append((n, i))\\n        \\n        allNums.sort(key=lambda x:x[0])\\n        \\n        minRange = 1000000\\n        count = len(nums)\\n        i = 0\\n        a = 0\\n        b = 0\\n        for j in range(len(allNums)):\\n            x, y = allNums[j]\\n            # x is the value\\n            # y is in the list index\\n            if ht[y] == 0:\\n                count -= 1\\n            ht[y] += 1\\n            while count == 0:\\n                x1, y1 = allNums[i]\\n                if x - x1 < minRange:\\n                    a, b = x1, x\\n                    minRange = x - x1\\n                if ht[y1] == 1:\\n                    count += 1\\n                ht[y1] -= 1\\n                i += 1\\n            \\n        return [a, b]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 882143,
                "title": "python-minheap-explained",
                "content": "1. The question is asking for a set **s** of candidate elements for which `max(s) - min(s) is smallest`\\n\\n2. So, let\\'s start with the first element in each list\\n\\n```\\nnums = [\\n[1, 2, 3],\\n[4, 5, 6],\\n[7, 8, 9],\\n]\\n\\n\\nAfter taking the first element from each list, we have...\\ncandidate = [1, 4, 7], hence range = 7 - 1 = 6,\\nnums = [\\n[2, 3],\\n[5, 6],\\n[8, 9],\\n]\\n```\\n\\n3. Since we know that each list is **non-decreasing**, we\\'ll try to **reduce the range by increasing the smallest element in candidate**, which in this case, is `1`.\\n\\n4. So, we take the next element after `1`, and update the range\\n\\n```\\ncandidate = [2, 4, 7], hence range=  7 - 2 = 5\\nnums = [\\n[3],\\n[5, 6],\\n[8, 9],\\n]\\n```\\n\\n5. We repeat this process of...\\n\\t* Increasing the smallest element in `candidate`, by taking its next neighbour\\n\\t* Updating the range, by taking `max(candidate) - min(candidate)`\\n\\t* Range updates can be optimized by taking `curr_max - top of heap`, where `curr_max` is updated with every `heappush` \\n\\n\\n<br>\\n\\n```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        # CONVERT NUMS INTO A LIST OF DEQUE\\n        nums = [deque(num) for num in nums]\\n        \\n        # PLACE THE FIRST NUMBER OF EACH ARRAY IN A LIST\\n        min_heap = [(nums[i].popleft(), i) for i in range(len(nums)) if nums[i]]\\n        heapify(min_heap)\\n        \\n        # KEEP TRACK OF THE CURRENT MAXIMUM NUMBER IN THE HEAP\\n        curr_max = max(min_heap)[0]\\n        \\n        # KEEP TRACK OF THE SMALLEST RANGE\\n        range_val = [min_heap[0][0], curr_max]\\n        min_range = curr_max - min_heap[0][0]\\n        \\n        # AT EACH ITERATION\\n        while True:\\n            \\n            # REMOVE THE MIN ELEMENT\\n            n, i = heappop(min_heap)\\n            \\n            # PUSH ITS NEXT NEIGHBOUR INTO THE HEAP\\n            if not nums[i]:\\n                return range_val\\n            neighbour = nums[i].popleft()\\n            heappush(min_heap, (neighbour, i))\\n            \\n            # UPDATE THE MAX ELEMENT WITH THE ELEMENT THAT WAS JUST PUSHED\\n            curr_max = max(curr_max, neighbour)\\n            \\n            # UPDATE THE MIN RANGE\\n            if curr_max - min_heap[0][0] < min_range:\\n                min_range = curr_max - min_heap[0][0]\\n                range_val = [min_heap[0][0], curr_max]\\n            \\n            # print(f\"MIN : {min_heap[0][0]} | MAX : {curr_max}\")\\n\\n        return range_val\\n```",
                "solutionTags": [],
                "code": "```\\nnums = [\\n[1, 2, 3],\\n[4, 5, 6],\\n[7, 8, 9],\\n]\\n\\n\\nAfter taking the first element from each list, we have...\\ncandidate = [1, 4, 7], hence range = 7 - 1 = 6,\\nnums = [\\n[2, 3],\\n[5, 6],\\n[8, 9],\\n]\\n```\n```\\ncandidate = [2, 4, 7], hence range=  7 - 2 = 5\\nnums = [\\n[3],\\n[5, 6],\\n[8, 9],\\n]\\n```\n```\\nfrom heapq import heappush, heappop, heapify\\n\\n\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\n        # CONVERT NUMS INTO A LIST OF DEQUE\\n        nums = [deque(num) for num in nums]\\n        \\n        # PLACE THE FIRST NUMBER OF EACH ARRAY IN A LIST\\n        min_heap = [(nums[i].popleft(), i) for i in range(len(nums)) if nums[i]]\\n        heapify(min_heap)\\n        \\n        # KEEP TRACK OF THE CURRENT MAXIMUM NUMBER IN THE HEAP\\n        curr_max = max(min_heap)[0]\\n        \\n        # KEEP TRACK OF THE SMALLEST RANGE\\n        range_val = [min_heap[0][0], curr_max]\\n        min_range = curr_max - min_heap[0][0]\\n        \\n        # AT EACH ITERATION\\n        while True:\\n            \\n            # REMOVE THE MIN ELEMENT\\n            n, i = heappop(min_heap)\\n            \\n            # PUSH ITS NEXT NEIGHBOUR INTO THE HEAP\\n            if not nums[i]:\\n                return range_val\\n            neighbour = nums[i].popleft()\\n            heappush(min_heap, (neighbour, i))\\n            \\n            # UPDATE THE MAX ELEMENT WITH THE ELEMENT THAT WAS JUST PUSHED\\n            curr_max = max(curr_max, neighbour)\\n            \\n            # UPDATE THE MIN RANGE\\n            if curr_max - min_heap[0][0] < min_range:\\n                min_range = curr_max - min_heap[0][0]\\n                range_val = [min_heap[0][0], curr_max]\\n            \\n            # print(f\"MIN : {min_heap[0][0]} | MAX : {curr_max}\")\\n\\n        return range_val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751911,
                "title": "java-priority-queue",
                "content": "\\t\\t4  10  15  24  26\\n\\t\\t0  9   12  20\\n\\t\\t5  18  22  30\\n\\t\\t\\t  ||\\n\\t\\t\\t  \\\\/\\n\\t\\t4  4  10  10  10  15  15  24 24\\n\\t\\t0  9  9   9   12  12  20  20 20- no more element in list 2\\n\\t\\t5  5  5   18  18  18  18  18 22  \\n\\t\\tmin = 20, max =24 so output is [20,24]\\n\\n\\n\\n\\n\\n    class Solution {\\n       public int[] smallestRange(List<List<Integer>> nums) {\\n     \\n        int n = nums.size();\\n        if(n==1){\\n            int val = nums.get(0).get(0);\\n            return   new int[]{val,val};\\n        }\\n        //create n priority queue for n list \\n        PriorityQueue<Integer> pq[] = new PriorityQueue[n];\\n        //store size of each arr index.\\n        int sizearr[] = new int [n];\\n        for(int i =0;i<n;i++){\\n            pq[i]=new PriorityQueue<>();\\n            sizearr[i]= nums.get(i).size();\\n        }\\n        \\n        //arr to store the index of k items in arr.\\n        //i.e if 3 elements in the arr x,y,z hold the current running index.\\n        int indexarr[] = new int [n];\\n\\n        \\n        //enque first n items to queue.\\n        for(int i =0;i<n;i++){\\n             pq[i].offer(nums.get(i).get(0));\\n            indexarr[i]++;\\n        }\\n        \\n        //to look for terminating condition i.e if min index found in queue does not have next element.\\n        //Input: [[4,10,15,24,26], [0,9,12,20], [5,18,22,30]]\\n        //[4,0,5]\\n        //[4,9,5]\\n        //..\\n        //[24,20,22] // here smallest is 20 which index 1 no more element in queue.\\n            \\n        //here 20 is min index of \\n        \\n        \\n        boolean isExists = true;\\n        \\n        //to persist the range for each n queued records find the min range for each n items in queue\\n        int range[] = new int[2];\\n        \\n        //min & max range.\\n        int min=Integer.MAX_VALUE,max =Integer.MIN_VALUE;\\n        int diff = Integer.MAX_VALUE;\\n        \\n        while(isExists){\\n            isExists = enqueue(pq,nums,sizearr,indexarr,range, n);\\n            int curmin= range[0];\\n            int curmax = range[1];\\n            int curdiff = ( curmax - curmin );\\n            \\n            if( curdiff<diff){\\n                min = curmin;\\n                max = curmax;\\n                diff = curdiff;\\n            }\\n           //System.out.print(\"cur min :\"+min+ \" max:\"+max +\" diff:\"+diff) ;\\n           //System.out.println();\\n        }\\n         \\n        return new int[]{min,max};\\n    }\\n    \\n    private void print(PriorityQueue<Integer> pq[] ,int n){\\n        for(int i =0;i<n;i++){\\n            System.out.print(pq[i] +\" \");\\n        }\\n    }\\n    \\n    \\n    //from first n enqueue records ,find min and for that index row remove enqueued records and\\n    //push next element from list for that index.\\n    private boolean enqueue(PriorityQueue<Integer> pq[] ,List<List<Integer>> nums,\\n                         int sizearr[], int indexarr[],int range[],int n){\\n        \\n        int smallIndex = 0;\\n        int prev = pq[0].peek();\\n        int count = 0;\\n        \\n        int min = Integer.MAX_VALUE;\\n        int max = Integer.MIN_VALUE;\\n\\n        \\n        //calculate min,max and set the range (min,max).\\n        for(int i=0;i<n;i++){\\n            int cur  = pq[i].peek();\\n            if(i>0 && cur == prev)count++;\\n            if(cur<min){\\n                smallIndex = i;\\n            }\\n            min = Math.min(min, Math.min(cur,prev));\\n            max = Math.max(max, Math.max(cur,prev));\\n            prev = cur;\\n        }\\n\\n        range[0]=min;\\n        range[1]=max;\\n        int curindex = indexarr[smallIndex];\\n        boolean isAllsame = (count == n-1)?true:false;\\n        if(isAllsame){\\n            //if first index all 1 then no need to process further return that small index\\n            return false;\\n        }\\n        else if(curindex < sizearr[smallIndex] ){\\n            int val = pq[smallIndex].poll();\\n            pq[smallIndex].offer(  nums.get(smallIndex).get(curindex)  );\\n            indexarr[smallIndex]++;//increment the index of arr i.e smallest index in queue.\\n             // print(pq,n);\\n            \\n            return true;\\n        }\\n       \\n         return false;\\n       }\\n     }",
                "solutionTags": [],
                "code": "class Solution {\\n       public int[] smallestRange(List<List<Integer>> nums) {\\n     \\n        int n = nums.size();\\n        if(n==1){\\n            int val = nums.get(0).get(0);\\n            return   new int[]{val,val}",
                "codeTag": "Java"
            },
            {
                "id": 541172,
                "title": "java-min-heap-solution",
                "content": "1. build a min heap ```pq``` of int array arr: \\n```\\narr[0] = index of the list in nums, \\narr[1] = index of element in the list of nums.get(arr[0]),\\narr[2] = nums.get(arr[0]).get(arr[1])\\n```\\n2. use the ```end``` denotes the current max in the min heap\\n3. The range = ```[pq.peek()[2], end]```\\n4. update the range if ```end - pq.peek()[2]``` is smaller than the length of current range.\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        int end = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.size(); i++) {\\n            pq.add(new int[]{i, 0, nums.get(i).get(0)});\\n            end = Math.max(end, nums.get(i).get(0));\\n        }\\n\\n        int[] result = new int[]{pq.peek()[2], end};\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            if (curr[1] + 1 < nums.get(curr[0]).size()) {\\n                pq.add(new int[]{curr[0], curr[1] + 1, nums.get(curr[0]).get(curr[1] + 1)});\\n                end = Math.max(end, nums.get(curr[0]).get(curr[1] + 1));\\n            } else {\\n                break;\\n            }\\n\\n            if (end - pq.peek()[2] < result[1] - result[0]) {\\n                result[0] = pq.peek()[2];\\n                result[1] = end;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```pq```\n```\\narr[0] = index of the list in nums, \\narr[1] = index of element in the list of nums.get(arr[0]),\\narr[2] = nums.get(arr[0]).get(arr[1])\\n```\n```end```\n```[pq.peek()[2], end]```\n```end - pq.peek()[2]```\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[2]));\\n        int end = Integer.MIN_VALUE;\\n        for (int i = 0; i < nums.size(); i++) {\\n            pq.add(new int[]{i, 0, nums.get(i).get(0)});\\n            end = Math.max(end, nums.get(i).get(0));\\n        }\\n\\n        int[] result = new int[]{pq.peek()[2], end};\\n        while (!pq.isEmpty()) {\\n            int[] curr = pq.poll();\\n            if (curr[1] + 1 < nums.get(curr[0]).size()) {\\n                pq.add(new int[]{curr[0], curr[1] + 1, nums.get(curr[0]).get(curr[1] + 1)});\\n                end = Math.max(end, nums.get(curr[0]).get(curr[1] + 1));\\n            } else {\\n                break;\\n            }\\n\\n            if (end - pq.peek()[2] < result[1] - result[0]) {\\n                result[0] = pq.peek()[2];\\n                result[1] = end;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 510709,
                "title": "java-easy-peasy-caterpillar-sliding-window-using-priorityqueue",
                "content": "Merge the all the input numbers together into a single priority queue. Keep a marker with each number stating which list it is from. Create a normal queue which will simulate a sliding window. Have a hashmap mapping the list number to the number of elements from that list that are currently present in the sliding window. Keep adding elements from pq to sliding window till we have at least one number from each of the k lists in the sliding window (caterpillar sliding window\\'s head advances while tail is fixed).  When this condition is satisfied, keep removing elements from the rear of the sliding window as long as this condition is satisfied (caterpillar\\'s tail advances while its head is fixed). Note the smallest interval embodied by the sliding window.\\n\\n```\\nclass Solution {\\n    private class Element implements Comparable<Element>\\n    {\\n        int num;\\n        int list;\\n        public Element(int num, int list)\\n        {\\n            this.num = num;\\n            this.list = list;\\n        }\\n        @Override\\n        public int compareTo(Element that)\\n        {\\n            int numComp = Integer.compare(this.num, that.num);\\n            if (numComp != 0)\\n                return numComp;\\n            else\\n            {\\n                return Integer.compare(this.list, that.list);\\n            }\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<Element> pq = new PriorityQueue<Element>();\\n        \\n        int k = 0;\\n        for (List<Integer> l: nums)\\n        {\\n            for (Integer num: l)\\n            {\\n                pq.add(new Element(num, k));\\n            }\\n            k++;\\n        }\\n        int minSize = Integer.MAX_VALUE;\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        Queue<Element> window = new LinkedList<Element>();\\n        int[] output = new int[2];\\n        //caterpillar sliding window\\n        while (!pq.isEmpty())\\n        {\\n            Element in = pq.poll();\\n            window.add(in); //increase window size\\n            int freq = map.getOrDefault(in.list, 0);\\n            map.put(in.list, freq+1);\\n            if (map.size() == k)\\n            {\\n                while (map.size() == k)\\n                {\\n                    Element out = window.poll(); //shrink window size\\n                    if ((in.num - out.num) < minSize)\\n                    {\\n                        minSize = in.num - out.num;\\n                        output[0] = out.num;\\n                        output[1] = in.num;\\n                    }\\n                    \\n                    int outFreq = map.get(out.list);\\n                    if (outFreq == 1)\\n                        map.remove(out.list);\\n                    else\\n                        map.put(out.list, outFreq-1);\\n                }\\n            }\\n        }\\n        return output;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private class Element implements Comparable<Element>\\n    {\\n        int num;\\n        int list;\\n        public Element(int num, int list)\\n        {\\n            this.num = num;\\n            this.list = list;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 299082,
                "title": "java-best-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        /* \\u8C01\\u5C0F\\u79FB\\u8C01 https://www.youtube.com/watch?v=csJXQZFYklE&t=1017s */\\n        int numLists = nums.size();\\n        int[] pts = new int[numLists]; \\n        PriorityQueue<Node> pq = new PriorityQueue<>(\\n            /* \\u6BD4\\u8F83\\u7B2Ci\\u4E2Alist\\u91CC\\u9762\\u7B2Cj\\u4E2A\\u5143\\u7D20\\u7684\\u503C */\\n            (a,b)-> nums.get(a.i).get(a.j) - nums.get(b.i).get(b.j));\\n        \\n        int cur_min = Integer.MAX_VALUE, cur_max = Integer.MIN_VALUE, diff = Integer.MAX_VALUE;\\n        /* scan first element of each list */\\n        for (int i=0; i<nums.size(); i++) {\\n            pq.add(new Node(i, 0));\\n            cur_min = Math.min(cur_min, nums.get(i).get(0)); \\n            cur_max = Math.max(cur_max, nums.get(i).get(0));\\n        }\\n        \\n        int[] res = new int[2];\\n        while (!pq.isEmpty()) {\\n            Node cur = pq.poll();\\n            /* update local min */\\n            cur_min = nums.get(cur.i).get(cur.j);\\n            if (cur_max - cur_min < diff) {\\n                diff = cur_max - cur_min; \\n                res[0] = cur_min; res[1] = cur_max; \\n            }\\n            if (cur.j == nums.get(cur.i).size()-1) break; \\n            int next = cur.j + 1;\\n            //update local max\\n            cur_max = Math.max(cur_max, nums.get(cur.i).get(next));\\n            pq.offer(new Node(cur.i, next));\\n        }\\n        return res;\\n    }\\n    \\n    public class Node {\\n        int i; /* list number */\\n        int j;  /* element number within list i */\\n        public Node(int i, int j) {\\n            this.i = i; \\n            this.j = j;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        /* \\u8C01\\u5C0F\\u79FB\\u8C01 https://www.youtube.com/watch?v=csJXQZFYklE&t=1017s */\\n        int numLists = nums.size();\\n        int[] pts = new int[numLists]; \\n        PriorityQueue<Node> pq = new PriorityQueue<>(\\n            /* \\u6BD4\\u8F83\\u7B2Ci\\u4E2Alist\\u91CC\\u9762\\u7B2Cj\\u4E2A\\u5143\\u7D20\\u7684\\u503C */\\n            (a,b)-> nums.get(a.i).get(a.j) - nums.get(b.i).get(b.j));\\n        \\n        int cur_min = Integer.MAX_VALUE, cur_max = Integer.MIN_VALUE, diff = Integer.MAX_VALUE;\\n        /* scan first element of each list */\\n        for (int i=0; i<nums.size(); i++) {\\n            pq.add(new Node(i, 0));\\n            cur_min = Math.min(cur_min, nums.get(i).get(0)); \\n            cur_max = Math.max(cur_max, nums.get(i).get(0));\\n        }\\n        \\n        int[] res = new int[2];\\n        while (!pq.isEmpty()) {\\n            Node cur = pq.poll();\\n            /* update local min */\\n            cur_min = nums.get(cur.i).get(cur.j);\\n            if (cur_max - cur_min < diff) {\\n                diff = cur_max - cur_min; \\n                res[0] = cur_min; res[1] = cur_max; \\n            }\\n            if (cur.j == nums.get(cur.i).size()-1) break; \\n            int next = cur.j + 1;\\n            //update local max\\n            cur_max = Math.max(cur_max, nums.get(cur.i).get(next));\\n            pq.offer(new Node(cur.i, next));\\n        }\\n        return res;\\n    }\\n    \\n    public class Node {\\n        int i; /* list number */\\n        int j;  /* element number within list i */\\n        public Node(int i, int j) {\\n            this.i = i; \\n            this.j = j;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 258895,
                "title": "java-simple-code",
                "content": "````\\n\\tpublic int[] smallestRange(List<List<Integer>> A) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(o -> A.get(o[0]).get(o[1])));\\n        for (int i = 0; i < A.size(); i++) {\\n            pq.offer(new int[] {i, 0});\\n            max = Math.max(max, A.get(i).get(0));\\n            min = Math.min(min, A.get(i).get(0));\\n        }\\n\\n        int start = min, end = max;\\n        while (true) {\\n            int e[] = pq.poll(), i = e[0], j = e[1];\\n            min = A.get(i).get(j);\\n            if (max-min < end-start || (max-min == end-start && min < start)) {\\n                start = min;\\n                end = max;\\n            }\\n            j++;\\n            if (j == A.get(i).size()) break;\\n            pq.offer(new int[] {i, j});\\n            max = Math.max(max, A.get(i).get(j));\\n        }\\n\\n        return new int[] {start, end};\\n    }\\n````",
                "solutionTags": [],
                "code": "````\\n\\tpublic int[] smallestRange(List<List<Integer>> A) {\\n        int max = Integer.MIN_VALUE, min = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(o -> A.get(o[0]).get(o[1])));\\n        for (int i = 0; i < A.size(); i++) {\\n            pq.offer(new int[] {i, 0});\\n            max = Math.max(max, A.get(i).get(0));\\n            min = Math.min(min, A.get(i).get(0));\\n        }\\n\\n        int start = min, end = max;\\n        while (true) {\\n            int e[] = pq.poll(), i = e[0], j = e[1];\\n            min = A.get(i).get(j);\\n            if (max-min < end-start || (max-min == end-start && min < start)) {\\n                start = min;\\n                end = max;\\n            }\\n            j++;\\n            if (j == A.get(i).size()) break;\\n            pq.offer(new int[] {i, j});\\n            max = Math.max(max, A.get(i).get(j));\\n        }\\n\\n        return new int[] {start, end};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 134386,
                "title": "java-o-n-log-n-solution-with-comments-sort-sliding-window",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<NG> list = new ArrayList<>();\\n        for(int g = 0 ; g < nums.size(); g++){\\n            for(Integer i : nums.get(g)){\\n                list.add(new NG(i, g)); // put in the list all the (number, group) pairs\\n            }\\n        }\\n        Collections.sort(list, (a, b) -> Integer.compare(a.num, b.num)); // sort by number\\n\\t\\t\\t\\t\\n        int resL=0; int resR=list.size(); // result left/right pointers. right is not inclusive\\n        int l = 0 ; int r = 0; // window left/right pointers. right is not inclusive\\n        int groups = 0; // number of groups inside of the sliding window\\n        int [] groupsCount = new int[nums.size()]; // index is group, value is how many values of group inside of the window\\n        while(l < list.size()){\\n            if(groups<nums.size() && r < list.size()){ // not all groups in the window\\n                r++;\\n                NG ng = list.get(r-1);\\n                groupsCount[ng.group]++;\\n                if(groupsCount[ng.group] == 1) groups++;\\n            }else{ // all groups in the window\\n                NG ng = list.get(l);\\n                groupsCount[ng.group]--;\\n                if(groupsCount[ng.group] == 0) groups--;\\n                l++;\\n\\n            }\\n\\t// if all the groups in the window check if window is smaller then current result\\n            if(groups == nums.size()){\\n                if(list.get(resR-1).num - list.get(resL).num > \\n                   list.get(r-1).num - list.get(l).num){\\n                    resL=l;resR=r;\\n                }\\n            }\\n        }\\n        return new int[]{list.get(resL).num, list.get(resR-1).num};\\n    }\\n    class NG{\\n        int num;\\n        int group;\\n        NG(int num, int group){\\n            this.num=num;\\n            this.group=group;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<NG> list = new ArrayList<>();\\n        for(int g = 0 ; g < nums.size(); g++){\\n            for(Integer i : nums.get(g)){\\n                list.add(new NG(i, g)); // put in the list all the (number, group) pairs\\n            }\\n        }\\n        Collections.sort(list, (a, b) -> Integer.compare(a.num, b.num)); // sort by number\\n\\t\\t\\t\\t\\n        int resL=0; int resR=list.size(); // result left/right pointers. right is not inclusive\\n        int l = 0 ; int r = 0; // window left/right pointers. right is not inclusive\\n        int groups = 0; // number of groups inside of the sliding window\\n        int [] groupsCount = new int[nums.size()]; // index is group, value is how many values of group inside of the window\\n        while(l < list.size()){\\n            if(groups<nums.size() && r < list.size()){ // not all groups in the window\\n                r++;\\n                NG ng = list.get(r-1);\\n                groupsCount[ng.group]++;\\n                if(groupsCount[ng.group] == 1) groups++;\\n            }else{ // all groups in the window\\n                NG ng = list.get(l);\\n                groupsCount[ng.group]--;\\n                if(groupsCount[ng.group] == 0) groups--;\\n                l++;\\n\\n            }\\n\\t// if all the groups in the window check if window is smaller then current result\\n            if(groups == nums.size()){\\n                if(list.get(resR-1).num - list.get(resL).num > \\n                   list.get(r-1).num - list.get(l).num){\\n                    resL=l;resR=r;\\n                }\\n            }\\n        }\\n        return new int[]{list.get(resL).num, list.get(resR-1).num};\\n    }\\n    class NG{\\n        int num;\\n        int group;\\n        NG(int num, int group){\\n            this.num=num;\\n            this.group=group;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104898,
                "title": "c-priority-queue-solution-with-detailed-explanation",
                "content": "We use the priority_queue to solve this problem. The format of element in priority_queue is pair(pair<int,int> First element represents the value and 2nd element represents the list number). Also we use an array cur[] to preserve the current index of each list. Once we reached the end point of one list, we yield the result.\\nWith priority_queue, we can easily get the smallest element in log(n) time and we get the difference between smallest element and largest element. Then we advance that list until we get to the end point of one particular list. \\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        //bfs\\n        struct compare{\\n          bool operator()(pair<int,int> a, pair<int,int> b){\\n              return a.first > b.first;\\n          }  \\n        };\\n        vector<int> res(2,0);\\n        vector<int> cur(nums.size(),0);\\n        if(nums.size() == 0 || nums[0].size() == 0)\\n            return res;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> pq;\\n        int max=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i][0],i});\\n            if(nums[i][0]>max)\\n                max = nums[i][0];\\n        }\\n        \\n        int diff = INT_MAX;\\n        while(1){\\n            pair<int, int> t = pq.top();\\n            pq.pop();\\n            //cout<<\"line 27 \"<<t.first<<\" \"<<t.second<<endl;\\n            int n_diff = max - t.first;\\n            if(n_diff < diff){\\n                res[0] = t.first;\\n                res[1] = max;\\n                diff = n_diff;\\n            }\\n            cur[t.second]++;\\n            if(cur[t.second] == nums[t.second].size())\\n                break;\\n            else{\\n                pq.push({nums[t.second][cur[t.second]], t.second});\\n                if(nums[t.second][cur[t.second]] > max)\\n                    max = nums[t.second][cur[t.second]];\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        //bfs\\n        struct compare{\\n          bool operator()(pair<int,int> a, pair<int,int> b){\\n              return a.first > b.first;\\n          }  \\n        };\\n        vector<int> res(2,0);\\n        vector<int> cur(nums.size(),0);\\n        if(nums.size() == 0 || nums[0].size() == 0)\\n            return res;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>, compare> pq;\\n        int max=INT_MIN;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i][0],i});\\n            if(nums[i][0]>max)\\n                max = nums[i][0];\\n        }\\n        \\n        int diff = INT_MAX;\\n        while(1){\\n            pair<int, int> t = pq.top();\\n            pq.pop();\\n            //cout<<\"line 27 \"<<t.first<<\" \"<<t.second<<endl;\\n            int n_diff = max - t.first;\\n            if(n_diff < diff){\\n                res[0] = t.first;\\n                res[1] = max;\\n                diff = n_diff;\\n            }\\n            cur[t.second]++;\\n            if(cur[t.second] == nums[t.second].size())\\n                break;\\n            else{\\n                pq.push({nums[t.second][cur[t.second]], t.second});\\n                if(nums[t.second][cur[t.second]] > max)\\n                    max = nums[t.second][cur[t.second]];\\n            }\\n            \\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 104921,
                "title": "python-with-heapy-o-nlogk",
                "content": "This problem is a variant of the *merge k sorted arrays*.  Reference can be found here: [merge](http://algorithms.tutorialhorizon.com/merge-k-sorted-arrays/) and [shortest range](http://algorithms.tutorialhorizon.com/shortest-range-in-k-sorted-lists/).\\n```\\nimport heapq\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        q = []  # element in the heap: val, i, j, where val is nums[i][j]\\n        max_val = nums[0][0]\\n        for i in range(len(nums)):\\n            heapq.heappush(q, (nums[i][0], i, 0))\\n            max_val = max(max_val, nums[i][0])  # also remember max of the heap\\n        min_range = [-10 ** 5, 10 ** 5]\\n        while q:\\n            min_val, i, j = heapq.heappop(q)\\n            if max_val - min_val < min_range[1] - min_range[0] or (\\n                                max_val - min_val == min_range[1] - min_range[0] and min_val < min_range[0]):\\n                min_range = [min_val, max_val]\\n            # push the next value in the ith array if any\\n            if j + 1 < len(nums[i]):\\n                max_val = max(max_val, nums[i][j + 1])\\n                heapq.heappush(q, (nums[i][j + 1], i, j + 1))\\n            else:  # ths ith array is exhausted\\n                return min_range",
                "solutionTags": [],
                "code": "This problem is a variant of the *merge k sorted arrays*.  Reference can be found here: [merge](http://algorithms.tutorialhorizon.com/merge-k-sorted-arrays/) and [shortest range](http://algorithms.tutorialhorizon.com/shortest-range-in-k-sorted-lists/).\\n```\\nimport heapq\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        q = []  # element in the heap: val, i, j, where val is nums[i][j]\\n        max_val = nums[0][0]\\n        for i in range(len(nums)):\\n            heapq.heappush(q, (nums[i][0], i, 0))\\n            max_val = max(max_val, nums[i][0])  # also remember max of the heap\\n        min_range = [-10 ** 5, 10 ** 5]\\n        while q:\\n            min_val, i, j = heapq.heappop(q)\\n            if max_val - min_val < min_range[1] - min_range[0] or (\\n                                max_val - min_val == min_range[1] - min_range[0] and min_val < min_range[0]):\\n                min_range = [min_val, max_val]\\n            # push the next value in the ith array if any\\n            if j + 1 < len(nums[i]):\\n                max_val = max(max_val, nums[i][j + 1])\\n                heapq.heappush(q, (nums[i][j + 1], i, j + 1))\\n            else:  # ths ith array is exhausted\\n                return min_range",
                "codeTag": "Java"
            },
            {
                "id": 4077166,
                "title": "priorityqueue-java",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nCreate a Priority Queue of an Integer array which holds 3 values : \\n1. Minimum element from each of the k lists\\n2. Index of that minimum element in the respective list\\n3. The list number containing that minimum element (or list ID)\\n\\npoll() the Priority Queue based on the 0th index of the array stored in it (i.e. , the minimum element of each of the k lists) to get the min[] array.\\n\\nCheck if the range is lesser than the previous range and modify it accordingly in our res[] array.\\n\\nFinally, get the current list based on the 2nd index in our polled array from the Priority Queue (which is the min[] array), and check if our first pointer reached the end of the list:\\n\\n-> if yes then break out of the list \\n-> else update the 0th element of the min[] array to the next element and update our max variable too.\\n\\nDon\\'t forget to add this updated min[] array to our Priority Queue.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-100000 , 100000};\\n        PriorityQueue<int[]>pq = new PriorityQueue<>((a , b) -> a[0] - b[0]);\\n        int max = Integer.MIN_VALUE;\\n        int k = nums.size();\\n\\n        for(int i = 0; i < k; i++){\\n            int minElem = nums.get(i).get(0);\\n            int[] arr = {minElem , 0 , i};\\n\\n            max = Math.max(max , minElem);\\n            pq.add(arr);\\n\\n        }\\n        while(true){\\n            int min[] = pq.poll();\\n            if(res[1] - res[0] > max - min[0]){\\n                res[1] = max;\\n                res[0] = min[0];\\n            }\\n            min[1]++;\\n\\n            List<Integer>cur = nums.get(min[2]);\\n\\n            if(min[1] == cur.size()){\\n                break;\\n            }\\n            else{\\n                min[0] = cur.get(min[1]);\\n                max = Math.max(max , cur.get(min[1]));\\n                pq.add(min);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-100000 , 100000};\\n        PriorityQueue<int[]>pq = new PriorityQueue<>((a , b) -> a[0] - b[0]);\\n        int max = Integer.MIN_VALUE;\\n        int k = nums.size();\\n\\n        for(int i = 0; i < k; i++){\\n            int minElem = nums.get(i).get(0);\\n            int[] arr = {minElem , 0 , i};\\n\\n            max = Math.max(max , minElem);\\n            pq.add(arr);\\n\\n        }\\n        while(true){\\n            int min[] = pq.poll();\\n            if(res[1] - res[0] > max - min[0]){\\n                res[1] = max;\\n                res[0] = min[0];\\n            }\\n            min[1]++;\\n\\n            List<Integer>cur = nums.get(min[2]);\\n\\n            if(min[1] == cur.size()){\\n                break;\\n            }\\n            else{\\n                min[0] = cur.get(min[1]);\\n                max = Math.max(max , cur.get(min[1]));\\n                pq.add(min);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011101,
                "title": "easy-to-understand-c-solution-with-comments-using-heap",
                "content": "\\n# Complexity\\nk == nums.size()\\n- Time complexity: O(n*klog(n*k))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n// creating a node that will store data and row and column of it\\nclass node{\\npublic:\\n    int data;\\n    int row;\\n    int col;\\n\\n    node(int d, int r,int c){\\n        this->data = d;\\n        row = r;\\n        col = c;\\n    }\\n};\\n\\nclass cmp{\\npublic:\\n    bool operator()(node* &a,node* &b){\\n        return a->data > b->data;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        // create a min heap to store the data column and row of an element \\n        priority_queue<node*,vector<node*>,cmp> pq;\\n        //declare initial range \\n        int mini =  INT_MAX, maxi = INT_MIN;\\n        // push the first element of each list (min element of each list) in the heap and also update the min and max value\\n        for(int i = 0; i < nums.size(); i++){\\n            int val = nums[i][0];\\n            mini = min(mini,val);\\n            maxi = max(maxi,val);\\n            pq.push(new node(val,i,0));\\n        }\\n        // the range for all the first elements of the list will be [mini,maxi] \\n        int start = mini, end = maxi;\\n\\n        while(!pq.empty()){\\n            node* t = pq.top();\\n            pq.pop();\\n\\n            mini = t->data;\\n            \\n            // if the new range is smaller than the previous one then update the new range \\n            if(maxi - mini < end - start){\\n                start = mini;\\n                end = maxi;\\n            }\\n            else if(maxi - mini == end - start){\\n                if(mini < start){\\n                    start = mini;\\n                    end = maxi;\\n                }\\n            }\\n\\n            // if next element exists in the list of mini\\n            if(t->col < nums[t->row].size() - 1){\\n                // update maxi if its greater than prev maxi\\n                maxi = max(maxi,nums[t->row][t->col+1]);\\n                // push the new element in the heap\\n                pq.push(new node(nums[t->row][t->col+1],t->row,t->col+1));\\n            }\\n            else{\\n                // if we have exhausted one of the lists then that means we have considered all possible ranges that will have atleast one member from each list\\n                break;\\n            }\\n        }\\n        return {start,end};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n// creating a node that will store data and row and column of it\\nclass node{\\npublic:\\n    int data;\\n    int row;\\n    int col;\\n\\n    node(int d, int r,int c){\\n        this->data = d;\\n        row = r;\\n        col = c;\\n    }\\n};\\n\\nclass cmp{\\npublic:\\n    bool operator()(node* &a,node* &b){\\n        return a->data > b->data;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        // create a min heap to store the data column and row of an element \\n        priority_queue<node*,vector<node*>,cmp> pq;\\n        //declare initial range \\n        int mini =  INT_MAX, maxi = INT_MIN;\\n        // push the first element of each list (min element of each list) in the heap and also update the min and max value\\n        for(int i = 0; i < nums.size(); i++){\\n            int val = nums[i][0];\\n            mini = min(mini,val);\\n            maxi = max(maxi,val);\\n            pq.push(new node(val,i,0));\\n        }\\n        // the range for all the first elements of the list will be [mini,maxi] \\n        int start = mini, end = maxi;\\n\\n        while(!pq.empty()){\\n            node* t = pq.top();\\n            pq.pop();\\n\\n            mini = t->data;\\n            \\n            // if the new range is smaller than the previous one then update the new range \\n            if(maxi - mini < end - start){\\n                start = mini;\\n                end = maxi;\\n            }\\n            else if(maxi - mini == end - start){\\n                if(mini < start){\\n                    start = mini;\\n                    end = maxi;\\n                }\\n            }\\n\\n            // if next element exists in the list of mini\\n            if(t->col < nums[t->row].size() - 1){\\n                // update maxi if its greater than prev maxi\\n                maxi = max(maxi,nums[t->row][t->col+1]);\\n                // push the new element in the heap\\n                pq.push(new node(nums[t->row][t->col+1],t->row,t->col+1));\\n            }\\n            else{\\n                // if we have exhausted one of the lists then that means we have considered all possible ranges that will have atleast one member from each list\\n                break;\\n            }\\n        }\\n        return {start,end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747499,
                "title": "easy-c-solution-beat-94",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nklogk)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(k)\\nWhere n is the size of max array and k is the the number of different vectors\\n\\n# Code\\n```\\nclass Node{\\n    public:\\n    int data,row,col;\\n    Node(int val,int r, int c){\\n        data=val;\\n        row=r;\\n        col=c;\\n    }\\n};\\nclass compare{\\n    public:\\n    bool operator()(Node* a, Node* b){\\n        return a->data>b->data;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> ans;\\n        int k=nums.size();\\n\\n        priority_queue<Node*, vector<Node*> , compare> minheap;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k;i++){\\n            int ele=nums[i][0];\\n            maxi=max(maxi,ele);\\n            mini=min(mini,ele);\\n            minheap.push(new Node(ele,i,0));\\n        }\\n        int ansStart=mini;\\n        int ansEnd=maxi;\\n        \\n        while(!minheap.empty()){\\n            Node* temp=minheap.top();\\n            int ele=temp->data;\\n            int row=temp->row;\\n            int col=temp->col;\\n            minheap.pop();\\n\\n            mini=ele;\\n            int curr=maxi-mini;\\n            int ansrange=ansEnd-ansStart;\\n            if(curr<ansrange){\\n                ansStart=mini;\\n                ansEnd=maxi;\\n            }\\n            if(col+1<nums[row].size()){\\n                maxi=max(maxi,nums[row][col+1]);\\n                Node* newNode=new Node(nums[row][col+1],row,col+1);\\n                minheap.push(newNode);\\n            }\\n            else\\n            break;\\n        }\\n        ans.push_back(ansStart);\\n        ans.push_back(ansEnd);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Node{\\n    public:\\n    int data,row,col;\\n    Node(int val,int r, int c){\\n        data=val;\\n        row=r;\\n        col=c;\\n    }\\n};\\nclass compare{\\n    public:\\n    bool operator()(Node* a, Node* b){\\n        return a->data>b->data;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<int> ans;\\n        int k=nums.size();\\n\\n        priority_queue<Node*, vector<Node*> , compare> minheap;\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<k;i++){\\n            int ele=nums[i][0];\\n            maxi=max(maxi,ele);\\n            mini=min(mini,ele);\\n            minheap.push(new Node(ele,i,0));\\n        }\\n        int ansStart=mini;\\n        int ansEnd=maxi;\\n        \\n        while(!minheap.empty()){\\n            Node* temp=minheap.top();\\n            int ele=temp->data;\\n            int row=temp->row;\\n            int col=temp->col;\\n            minheap.pop();\\n\\n            mini=ele;\\n            int curr=maxi-mini;\\n            int ansrange=ansEnd-ansStart;\\n            if(curr<ansrange){\\n                ansStart=mini;\\n                ansEnd=maxi;\\n            }\\n            if(col+1<nums[row].size()){\\n                maxi=max(maxi,nums[row][col+1]);\\n                Node* newNode=new Node(nums[row][col+1],row,col+1);\\n                minheap.push(newNode);\\n            }\\n            else\\n            break;\\n        }\\n        ans.push_back(ansStart);\\n        ans.push_back(ansEnd);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3712885,
                "title": "explained-priority-queue-and-set-of-pairs-c",
                "content": "I used a max heap to store the values sorted in a descending order, along with the list they belong to. After they\\'re all inserted in the queue, I start popping the largest values one by one and I increase the counter, which stores the current count of the values in the {mn,mx} range. If there\\'s at least one element from each row, I remove the largest value, decrease the counter and update the answer range. \\nDue to the ```count[top.second]++;``` statement, I don\\'t put duplicate values in the queue since then the counter wouldn\\'t update when I popped the largest pair from the set.\\n\\n<iframe src=\"https://leetcode.com/playground/ESDMdhay/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```count[top.second]++;```",
                "codeTag": "Unknown"
            },
            {
                "id": 3574615,
                "title": "c-easy-using-min-heap-t-c-o-n-k-logk",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing Min Heap (Priority Queue)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*k logk),\\n where k is size of nums\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    class node\\n    {\\n        public:\\n        int data;\\n        int row;\\n        int col;\\n\\n        node(int d, int r, int c)\\n        {\\n            data=d;\\n            row=r;\\n            col=c;\\n        }            \\n    };\\n\\n    class compare\\n    {\\n        public:\\n        bool operator()(node*a, node*b)\\n        {\\n            return a->data > b->data;\\n        }\\n    };\\n\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n\\n        int k=nums.size();\\n\\n        priority_queue<node*, vector<node*>, compare> pq;\\n\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n\\n        // step-1: create a minHeap for starting element of each list\\n        // and track maxi/mini\\n        for(int i=0;i<k;i++)\\n        {\\n            int element=nums[i][0];\\n            maxi=max(maxi, element);\\n            mini=min(mini, element);\\n            pq.push(new node(nums[i][0], i, 0));\\n        }\\n\\n        int start=mini;\\n        int end=maxi;\\n\\n        // process ranges\\n        while(!pq.empty())\\n        {\\n            node* temp=pq.top();\\n            pq.pop();\\n\\n            mini=temp->data;\\n\\n            // ranges or ans updation\\n            if(maxi-mini < end-start)\\n            {\\n                start=mini;\\n                end=maxi;\\n            }\\n\\n            // next element exists, n=nums[temp->row].size();\\n            if(temp->col+1 < nums[temp->row].size())\\n            {\\n                maxi=max(maxi, nums[temp->row][temp->col+1]);\\n                pq.push(new node(nums[temp->row][temp->col+1], temp->row, temp->col+1));\\n            }\\n            else\\n            {\\n                // next element doesn\\'t exists\\n                break;\\n            }\\n        }\\n\\n        return {start,end};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    class node\\n    {\\n        public:\\n        int data;\\n        int row;\\n        int col;\\n\\n        node(int d, int r, int c)\\n        {\\n            data=d;\\n            row=r;\\n            col=c;\\n        }            \\n    };\\n\\n    class compare\\n    {\\n        public:\\n        bool operator()(node*a, node*b)\\n        {\\n            return a->data > b->data;\\n        }\\n    };\\n\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n\\n        int k=nums.size();\\n\\n        priority_queue<node*, vector<node*>, compare> pq;\\n\\n        int mini=INT_MAX;\\n        int maxi=INT_MIN;\\n\\n        // step-1: create a minHeap for starting element of each list\\n        // and track maxi/mini\\n        for(int i=0;i<k;i++)\\n        {\\n            int element=nums[i][0];\\n            maxi=max(maxi, element);\\n            mini=min(mini, element);\\n            pq.push(new node(nums[i][0], i, 0));\\n        }\\n\\n        int start=mini;\\n        int end=maxi;\\n\\n        // process ranges\\n        while(!pq.empty())\\n        {\\n            node* temp=pq.top();\\n            pq.pop();\\n\\n            mini=temp->data;\\n\\n            // ranges or ans updation\\n            if(maxi-mini < end-start)\\n            {\\n                start=mini;\\n                end=maxi;\\n            }\\n\\n            // next element exists, n=nums[temp->row].size();\\n            if(temp->col+1 < nums[temp->row].size())\\n            {\\n                maxi=max(maxi, nums[temp->row][temp->col+1]);\\n                pq.push(new node(nums[temp->row][temp->col+1], temp->row, temp->col+1));\\n            }\\n            else\\n            {\\n                // next element doesn\\'t exists\\n                break;\\n            }\\n        }\\n\\n        return {start,end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479072,
                "title": "typescript-a-brief-and-easy-to-follow-implementation-using-sort",
                "content": "# Code\\n```\\ninterface ArrNode {\\n    group: number;\\n    idx: number;\\n    val: number;\\n}\\n\\nconst compare = (a: ArrNode, b: ArrNode) => a.val - b.val;\\n\\nfunction smallestRange(nums: number[][]): number[] {\\n    const Arr: ArrNode[] = nums.map((e, i) => ({ group: i, idx: 0, val: e[0] })).sort(compare);\\n\\n    let min = 0;\\n    let range = Infinity;\\n\\n    while (1) {\\n        const max = Arr[Arr.length - 1].val;\\n        const { group, idx, val } = Arr.shift() as ArrNode;\\n        const diff = max - val;\\n        if (diff < range) {\\n            min = val;\\n            range = diff;\\n        }\\n        if (idx + 1 > nums[group].length - 1) break;\\n\\n        Arr.push({ group, idx: idx + 1, val: nums[group][idx + 1] });\\n        Arr.sort(compare);\\n    }\\n\\n    return [min, min + range];\\n}\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/93f71222-1ef3-4eff-957d-2b71d4fa2105_1683413158.3855317.png)",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ninterface ArrNode {\\n    group: number;\\n    idx: number;\\n    val: number;\\n}\\n\\nconst compare = (a: ArrNode, b: ArrNode) => a.val - b.val;\\n\\nfunction smallestRange(nums: number[][]): number[] {\\n    const Arr: ArrNode[] = nums.map((e, i) => ({ group: i, idx: 0, val: e[0] })).sort(compare);\\n\\n    let min = 0;\\n    let range = Infinity;\\n\\n    while (1) {\\n        const max = Arr[Arr.length - 1].val;\\n        const { group, idx, val } = Arr.shift() as ArrNode;\\n        const diff = max - val;\\n        if (diff < range) {\\n            min = val;\\n            range = diff;\\n        }\\n        if (idx + 1 > nums[group].length - 1) break;\\n\\n        Arr.push({ group, idx: idx + 1, val: nums[group][idx + 1] });\\n        Arr.sort(compare);\\n    }\\n\\n    return [min, min + range];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3416471,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n  std::vector<int> smallestRange(std::vector<std::vector<int>> const &nums)\\n  {\\n    auto S = nums.size();\\n    std::vector<std::pair<std::vector<int>::const_iterator,\\n                          std::vector<int>::const_iterator>>\\n        ps(S);\\n    std::transform(nums.begin(),\\n                   nums.end(),\\n                   ps.begin(),\\n                   [](auto const &num)\\n                   {\\n                     return std::make_pair(std::begin(num), std::end(num));\\n                   });\\n    auto less_val = [](auto i, auto j)\\n    {\\n      return *(i.first) < *(j.first);\\n    };\\n    auto max_i    = std::max_element(ps.begin(), ps.end(), less_val);\\n    auto best_max = max_i->first;\\n    auto best_min = std::min_element(ps.begin(), ps.end(), less_val)->first;\\n    while (max_i->first != max_i->second)\\n    {\\n      for (auto &[begin, end] : ps)\\n      {\\n        begin = std::upper_bound(begin, end, *(max_i->first)) - 1;\\n      }\\n      auto min_i = std::min_element(ps.begin(), ps.end(), less_val);\\n      if (*max_i->first - *min_i->first < *best_max - *best_min)\\n      {\\n        best_max = max_i->first;\\n        best_min = min_i->first;\\n      }\\n      min_i->first++;\\n      max_i = min_i;\\n    }\\n    return std::vector<int>({ *best_min, *best_max });\\n  }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        d = defaultdict(list)\\n        for i, evs in enumerate(nums):\\n            for v in evs:\\n                d[v].append(i)\\n        keys = sorted(d.keys())\\n        lo = 0\\n        n = len(nums)\\n        dd = defaultdict(int)\\n        le, ri = -1, float(\\'Inf\\')\\n        have = 0\\n        for hi in range(len(keys)):\\n            for x in d[keys[hi]]:\\n                dd[x] += 1\\n                if dd[x] == 1:\\n                    have += 1\\n            while have == n:\\n                curr = keys[hi] - keys[lo]\\n                if ri - le > curr:\\n                    ri = keys[hi]\\n                    le = keys[lo]\\n                for x in d[keys[lo]]:\\n                    dd[x] -= 1\\n                    if dd[x] == 0:\\n                        have -= 1\\n                lo += 1\\n        return [le, ri]\\n```\\n\\n```Java []\\nclass Solution {\\n  private int[] bestRange;\\n  public int[] smallestRange(List<List<Integer>> nums) {\\n    List<Integer> firstList = nums.get(0);\\n    for (int elem : firstList) {\\n      int[] range = new int[2];\\n      range[0] = elem;\\n      range[1] = elem;\\n      expandRange(nums, 1, range);\\n    }\\n    return bestRange;  \\n  }\\n  private void expandRange(List<List<Integer>> nums, int listIndex, int[] currentRange) {\\n    if (listIndex >= nums.size()) {\\n      checkBest(currentRange);\\n      return;\\n    }\\n    if (shouldPrune(currentRange)) {\\n      return;\\n    }\\n    List<Integer> newList = nums.get(listIndex);\\n\\n    int leftIndex = findIndex(newList, currentRange[0], 0, newList.size() - 1);\\n    int rightIndex = findIndex(newList, currentRange[1], 0, newList.size() - 1);\\n\\n    boolean needsExpanding = leftIndex == rightIndex && \\n      (leftIndex == newList.size() || \\n        (newList.get(leftIndex) != currentRange[0] && newList.get(rightIndex) != currentRange[1]));\\n\\n    if (needsExpanding) {\\n      int originalLeft = currentRange[0];\\n      int originalRight = currentRange[1];\\n      \\n      if (rightIndex < newList.size()) {\\n        currentRange[1] = newList.get(rightIndex);\\n        expandRange(nums, listIndex + 1, currentRange);\\n        currentRange[0] = originalLeft;\\n        currentRange[1] = originalRight;\\n      }\\n      if (leftIndex > 0) {\\n        currentRange[0] = newList.get(leftIndex - 1);\\n        expandRange(nums, listIndex + 1, currentRange);\\n      }\\n    } else {\\n      expandRange(nums, listIndex + 1, currentRange);\\n    }\\n  }\\n  private static int findIndex(List<Integer> list, int value, int left, int right) {\\n    if (left > right) {\\n      return left;\\n    }\\n    int mid = right - (right - left) / 2;\\n    int candidate = list.get(mid);\\n\\n    if (candidate >= value) {\\n      if (mid == 0 || list.get(mid - 1) < value) {\\n        return mid;\\n      }\\n      return findIndex(list, value, left, mid - 1);\\n    } else {\\n      return findIndex(list, value, mid + 1, right);\\n    }\\n  }\\n  private void checkBest(int[] currentRange) {\\n    if (isBest(currentRange)) {\\n      if (bestRange == null) {\\n        bestRange = new int[2];\\n      }\\n      bestRange[0] = currentRange[0];\\n      bestRange[1] = currentRange[1];\\n    }\\n  }\\n  private boolean isBest(int[] currentRange) {\\n    if (bestRange == null) {\\n      return true;\\n    }\\n    int currentRangeSize = currentRange[1] - currentRange[0];\\n    int bestRangeSize = bestRange[1] - bestRange[0];\\n    return currentRangeSize < bestRangeSize || (currentRangeSize == bestRangeSize && currentRange[0] < bestRange[0]);\\n  }\\n  private boolean shouldPrune(int[] currentRange) {\\n    return !isBest(currentRange);\\n  }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n  std::vector<int> smallestRange(std::vector<std::vector<int>> const &nums)\\n  {\\n    auto S = nums.size();\\n    std::vector<std::pair<std::vector<int>::const_iterator,\\n                          std::vector<int>::const_iterator>>\\n        ps(S);\\n    std::transform(nums.begin(),\\n                   nums.end(),\\n                   ps.begin(),\\n                   [](auto const &num)\\n                   {\\n                     return std::make_pair(std::begin(num), std::end(num));\\n                   });\\n    auto less_val = [](auto i, auto j)\\n    {\\n      return *(i.first) < *(j.first);\\n    };\\n    auto max_i    = std::max_element(ps.begin(), ps.end(), less_val);\\n    auto best_max = max_i->first;\\n    auto best_min = std::min_element(ps.begin(), ps.end(), less_val)->first;\\n    while (max_i->first != max_i->second)\\n    {\\n      for (auto &[begin, end] : ps)\\n      {\\n        begin = std::upper_bound(begin, end, *(max_i->first)) - 1;\\n      }\\n      auto min_i = std::min_element(ps.begin(), ps.end(), less_val);\\n      if (*max_i->first - *min_i->first < *best_max - *best_min)\\n      {\\n        best_max = max_i->first;\\n        best_min = min_i->first;\\n      }\\n      min_i->first++;\\n      max_i = min_i;\\n    }\\n    return std::vector<int>({ *best_min, *best_max });\\n  }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        d = defaultdict(list)\\n        for i, evs in enumerate(nums):\\n            for v in evs:\\n                d[v].append(i)\\n        keys = sorted(d.keys())\\n        lo = 0\\n        n = len(nums)\\n        dd = defaultdict(int)\\n        le, ri = -1, float(\\'Inf\\')\\n        have = 0\\n        for hi in range(len(keys)):\\n            for x in d[keys[hi]]:\\n                dd[x] += 1\\n                if dd[x] == 1:\\n                    have += 1\\n            while have == n:\\n                curr = keys[hi] - keys[lo]\\n                if ri - le > curr:\\n                    ri = keys[hi]\\n                    le = keys[lo]\\n                for x in d[keys[lo]]:\\n                    dd[x] -= 1\\n                    if dd[x] == 0:\\n                        have -= 1\\n                lo += 1\\n        return [le, ri]\\n```\n```Java []\\nclass Solution {\\n  private int[] bestRange;\\n  public int[] smallestRange(List<List<Integer>> nums) {\\n    List<Integer> firstList = nums.get(0);\\n    for (int elem : firstList) {\\n      int[] range = new int[2];\\n      range[0] = elem;\\n      range[1] = elem;\\n      expandRange(nums, 1, range);\\n    }\\n    return bestRange;  \\n  }\\n  private void expandRange(List<List<Integer>> nums, int listIndex, int[] currentRange) {\\n    if (listIndex >= nums.size()) {\\n      checkBest(currentRange);\\n      return;\\n    }\\n    if (shouldPrune(currentRange)) {\\n      return;\\n    }\\n    List<Integer> newList = nums.get(listIndex);\\n\\n    int leftIndex = findIndex(newList, currentRange[0], 0, newList.size() - 1);\\n    int rightIndex = findIndex(newList, currentRange[1], 0, newList.size() - 1);\\n\\n    boolean needsExpanding = leftIndex == rightIndex && \\n      (leftIndex == newList.size() || \\n        (newList.get(leftIndex) != currentRange[0] && newList.get(rightIndex) != currentRange[1]));\\n\\n    if (needsExpanding) {\\n      int originalLeft = currentRange[0];\\n      int originalRight = currentRange[1];\\n      \\n      if (rightIndex < newList.size()) {\\n        currentRange[1] = newList.get(rightIndex);\\n        expandRange(nums, listIndex + 1, currentRange);\\n        currentRange[0] = originalLeft;\\n        currentRange[1] = originalRight;\\n      }\\n      if (leftIndex > 0) {\\n        currentRange[0] = newList.get(leftIndex - 1);\\n        expandRange(nums, listIndex + 1, currentRange);\\n      }\\n    } else {\\n      expandRange(nums, listIndex + 1, currentRange);\\n    }\\n  }\\n  private static int findIndex(List<Integer> list, int value, int left, int right) {\\n    if (left > right) {\\n      return left;\\n    }\\n    int mid = right - (right - left) / 2;\\n    int candidate = list.get(mid);\\n\\n    if (candidate >= value) {\\n      if (mid == 0 || list.get(mid - 1) < value) {\\n        return mid;\\n      }\\n      return findIndex(list, value, left, mid - 1);\\n    } else {\\n      return findIndex(list, value, mid + 1, right);\\n    }\\n  }\\n  private void checkBest(int[] currentRange) {\\n    if (isBest(currentRange)) {\\n      if (bestRange == null) {\\n        bestRange = new int[2];\\n      }\\n      bestRange[0] = currentRange[0];\\n      bestRange[1] = currentRange[1];\\n    }\\n  }\\n  private boolean isBest(int[] currentRange) {\\n    if (bestRange == null) {\\n      return true;\\n    }\\n    int currentRangeSize = currentRange[1] - currentRange[0];\\n    int bestRangeSize = bestRange[1] - bestRange[0];\\n    return currentRangeSize < bestRangeSize || (currentRangeSize == bestRangeSize && currentRange[0] < bestRange[0]);\\n  }\\n  private boolean shouldPrune(int[] currentRange) {\\n    return !isBest(currentRange);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123700,
                "title": "java-faster-than-98",
                "content": "```\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n           int[] res = {-1000000, 1000000};\\n        int k = nums.size();\\n        int max = Integer.MIN_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        for (int i = 0; i < k; i++) {\\n            int val = nums.get(i).get(0);\\n            max = Math.max(val, max);\\n            pq.add(new int[]{val, i, 0});\\n        }\\n        while (true) {\\n            int[] temp = pq.poll();\\n            int min = temp[0];\\n            if (res[1] - res[0] > max - min) {\\n                res[0] = min;\\n                res[1] = max;\\n            }\\n            temp[2]++;\\n            List curList = nums.get(temp[1]);\\n            if (temp[2] == curList.size()) break;\\n            else {\\n                temp[0] = (int) curList.get(temp[2]);\\n                pq.add(temp);\\n                max = Math.max(max, temp[0]);\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n           int[] res = {-1000000, 1000000};\\n        int k = nums.size();\\n        int max = Integer.MIN_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        for (int i = 0; i < k; i++) {\\n            int val = nums.get(i).get(0);\\n            max = Math.max(val, max);\\n            pq.add(new int[]{val, i, 0});\\n        }\\n        while (true) {\\n            int[] temp = pq.poll();\\n            int min = temp[0];\\n            if (res[1] - res[0] > max - min) {\\n                res[0] = min;\\n                res[1] = max;\\n            }\\n            temp[2]++;\\n            List curList = nums.get(temp[1]);\\n            if (temp[2] == curList.size()) break;\\n            else {\\n                temp[0] = (int) curList.get(temp[2]);\\n                pq.add(temp);\\n                max = Math.max(max, temp[0]);\\n            }\\n        }\\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102482,
                "title": "java-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }\\n        }\\n        \\n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\\n        int[] ans = new int[2];\\n        ans[1] = ans[0] = Integer.MAX_VALUE; \\n        int i = 0,j=0;\\n        List<Integer> store = new ArrayList<>();\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        int totalType = 0;\\n        \\n        while(j<list.size()){\\n            int nu = list.get(j).getKey();\\n            int type = list.get(j).getValue();\\n            store.add(nu);\\n            int val = mp.getOrDefault(type,0);\\n            mp.put(type,val+1);\\n            totalType++;\\n            if(mp.size()<k){\\n                j++;\\n            }else if(mp.size()==k){\\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }\\n                int dif = store.get(store.size()-1)-store.get(0);\\n                if(dif<ans[1]-ans[0]){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }  \\n                \\n                while(mp.size()==k){\\n                    dif = store.get(store.size()-1)-store.get(0);\\n                    if(dif<ans[1]-ans[0]){\\n                        ans[0] = store.get(0);\\n                        ans[1] = store.get(store.size()-1);\\n                    }\\n                    store.remove(0);\\n                    int t = list.get(i).getValue();\\n                    int vv = (int) mp.get(t);\\n                    mp.put(t,vv-1);\\n                    if(vv==1){\\n                        mp.remove(t);\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n                \\n            }\\n   \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<Pair<Integer,Integer>> list = new ArrayList<>();\\n        for(int i = 0;i<k;i++){\\n            List<Integer> l = nums.get(i);\\n            for(int nu : l){\\n                list.add(new Pair(nu,i));\\n            }\\n        }\\n        \\n        Collections.sort(list,(a,b)-> a.getKey()-b.getKey());\\n        int[] ans = new int[2];\\n        ans[1] = ans[0] = Integer.MAX_VALUE; \\n        int i = 0,j=0;\\n        List<Integer> store = new ArrayList<>();\\n        HashMap<Integer,Integer> mp = new HashMap<>();\\n        int totalType = 0;\\n        \\n        while(j<list.size()){\\n            int nu = list.get(j).getKey();\\n            int type = list.get(j).getValue();\\n            store.add(nu);\\n            int val = mp.getOrDefault(type,0);\\n            mp.put(type,val+1);\\n            totalType++;\\n            if(mp.size()<k){\\n                j++;\\n            }else if(mp.size()==k){\\n                if(ans[0]==ans[1] && ans[1] == Integer.MAX_VALUE){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }\\n                int dif = store.get(store.size()-1)-store.get(0);\\n                if(dif<ans[1]-ans[0]){\\n                    ans[0] = store.get(0);\\n                    ans[1] = store.get(store.size()-1);\\n                }  \\n                \\n                while(mp.size()==k){\\n                    dif = store.get(store.size()-1)-store.get(0);\\n                    if(dif<ans[1]-ans[0]){\\n                        ans[0] = store.get(0);\\n                        ans[1] = store.get(store.size()-1);\\n                    }\\n                    store.remove(0);\\n                    int t = list.get(i).getValue();\\n                    int vv = (int) mp.get(t);\\n                    mp.put(t,vv-1);\\n                    if(vv==1){\\n                        mp.remove(t);\\n                    }\\n                    i++;\\n                }\\n                \\n                j++;\\n                \\n            }\\n   \\n        }\\n        \\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2423332,
                "title": "n-pointer-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        int l = -1 , r =-1 ;\\n        int ans = 1e6;\\n        int n = a.size() ; \\n        vector<int>pointer(n,0);\\n        while(1){\\n            int mx = -1e6,mn =1e6;\\n            for(int i = 0 ; i < n ; i++){\\n                mx = max(mx,a[i][pointer[i]]);\\n                mn = min(mn,a[i][pointer[i]]);\\n            }\\n            if(ans > mx - mn){\\n                ans = mx-mn;\\n                l=mn;r=mx;\\n            }\\n            int f=0;\\n            for(int i = 0 ; i < n ; i++){\\n                if(a[i][pointer[i]] <= mn){\\n                    pointer[i]++; \\n                    if(pointer[i] >= a[i].size())f=1;\\n                }\\n            }\\n            if(f)break;\\n        }\\n        return {l,r};\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        int l = -1 , r =-1 ;\\n        int ans = 1e6;\\n        int n = a.size() ; \\n        vector<int>pointer(n,0);\\n        while(1){\\n            int mx = -1e6,mn =1e6;\\n            for(int i = 0 ; i < n ; i++){\\n                mx = max(mx,a[i][pointer[i]]);\\n                mn = min(mn,a[i][pointer[i]]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2339745,
                "title": "c-solution-with-comments",
                "content": "```\\nclass Info{\\n    public:\\n    int data;\\n    int row;\\n    int col;\\n    Info(int d, int r, int c){\\n        this -> data = d;\\n        this -> row = r;\\n        this -> col = c;\\n    }\\n};\\nclass Cmp{\\n    public:\\n    bool operator()(Info* a, Info* b){\\n        return a -> data > b -> data;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        priority_queue<Info*, vector<Info*>, Cmp> minHeap;\\n        // cfirst element of k list push into heap or priority queue\\n        for(int i = 0 ; i < nums.size(); i++){\\n            int element = nums[i][0];\\n            Info* info = new Info(element, i, 0);\\n            maxi = max(maxi, element);\\n            mini = max(mini, element);\\n            minHeap.push(info);\\n        }\\n        // find range using mini and maxi\\n        int start = maxi;\\n        int end = mini;\\n        while(!minHeap.empty()){\\n            //  heap ke top ko store kar lo \\n            Info* temp = minHeap.top();\\n            // heap ke top ko pop kar do\\n            minHeap.pop();\\n            // mini ko update karo , heap ke top per jo element tha vhi minimum tha \\n            mini = temp -> data;\\n            //ager new mini & maxi vali range start & end vali rangev se choti hai to start and end ko update kar do\\n            if(maxi - mini < end - start){\\n                start = mini;\\n                end = maxi;\\n            }\\n            // heap me se jo elemnet nikala tha uske aage vala element ager hai to vo dal do heap me\\n            // else break kar ke bhar aa jao bcs abb jo range aayegi vo confirm nhi hai ki sari list ke elemrnt usme ho\\n            if(temp -> col + 1 < nums[temp -> row].size()){\\n                maxi = max(maxi, nums[temp -> row][temp -> col + 1]);\\n                Info* toPush = new Info(nums[temp -> row][temp -> col + 1], temp -> row, temp -> col + 1);\\n                minHeap.push(toPush);\\n            }else\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        ans.push_back(start);\\n        ans.push_back(end);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        priority_queue<Info*, vector<Info*>, Cmp> minHeap;\\n        // cfirst element of k list push into heap or priority queue\\n        for(int i = 0 ; i < nums.size(); i++){\\n            int element = nums[i][0];\\n            Info* info = new Info(element, i, 0);\\n            maxi = max(maxi, element);\\n            mini = max(mini, element);\\n            minHeap.push(info);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2299483,
                "title": "heap-easy-game-hehe",
                "content": "```\\n// heap item: the num, the array index, the index of num in the array\\nfunc smallestRange(nums [][]int) []int {\\n    var heap [][3]int\\n    \\n    minVal, maxVal := 1<<63-1, -1<<63\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i][0] > maxVal {\\n            maxVal = nums[i][0]\\n        }\\n        \\n        if nums[i][0] < minVal {\\n            minVal = nums[i][0]\\n        }\\n        \\n        heap = append(heap, [3]int{nums[i][0], i, 0})\\n        heapUp(heap, len(heap)-1)\\n    }\\n    \\n    start, end := minVal, maxVal\\n\\n    for len(heap) > 0 {\\n        if maxVal - heap[0][0] < end - start {\\n            end = maxVal\\n            start = heap[0][0]\\n        }\\n        \\n        arrIndex := heap[0][1]\\n        currentIndexInTheSubArr := heap[0][2]\\n        \\n        if currentIndexInTheSubArr+1 < len(nums[arrIndex]) {\\n            heap[0] = [3]int{nums[arrIndex][currentIndexInTheSubArr+1], arrIndex, currentIndexInTheSubArr+1}\\n\\n            if nums[arrIndex][currentIndexInTheSubArr+1] > maxVal {\\n                maxVal = nums[arrIndex][currentIndexInTheSubArr+1]\\n            }\\n            \\n            heapDown(heap, 0, len(heap)-1)\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return []int{start, end}\\n}\\n\\nfunc heapDown(heap [][3]int, p, limit int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l <= limit && heap[l][0] < heap[smaller][0] {\\n        smaller = l\\n    }\\n    \\n    if r <= limit && heap[r][0] < heap[smaller][0] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        heap[smaller], heap[p] = heap[p], heap[smaller]\\n        heapDown(heap, smaller, limit)\\n    }\\n}\\n\\nfunc heapUp(heap [][3]int, p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && heap[p][0] < heap[parent][0] {\\n        heap[parent], heap[p] = heap[p], heap[parent]\\n        heapUp(heap, parent)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// heap item: the num, the array index, the index of num in the array\\nfunc smallestRange(nums [][]int) []int {\\n    var heap [][3]int\\n    \\n    minVal, maxVal := 1<<63-1, -1<<63\\n    \\n    for i := 0; i < len(nums); i++ {\\n        if nums[i][0] > maxVal {\\n            maxVal = nums[i][0]\\n        }\\n        \\n        if nums[i][0] < minVal {\\n            minVal = nums[i][0]\\n        }\\n        \\n        heap = append(heap, [3]int{nums[i][0], i, 0})\\n        heapUp(heap, len(heap)-1)\\n    }\\n    \\n    start, end := minVal, maxVal\\n\\n    for len(heap) > 0 {\\n        if maxVal - heap[0][0] < end - start {\\n            end = maxVal\\n            start = heap[0][0]\\n        }\\n        \\n        arrIndex := heap[0][1]\\n        currentIndexInTheSubArr := heap[0][2]\\n        \\n        if currentIndexInTheSubArr+1 < len(nums[arrIndex]) {\\n            heap[0] = [3]int{nums[arrIndex][currentIndexInTheSubArr+1], arrIndex, currentIndexInTheSubArr+1}\\n\\n            if nums[arrIndex][currentIndexInTheSubArr+1] > maxVal {\\n                maxVal = nums[arrIndex][currentIndexInTheSubArr+1]\\n            }\\n            \\n            heapDown(heap, 0, len(heap)-1)\\n        } else {\\n            break\\n        }\\n    }\\n    \\n    return []int{start, end}\\n}\\n\\nfunc heapDown(heap [][3]int, p, limit int) {\\n    l, r := 2*p+1, 2*p+2\\n    smaller := p\\n    \\n    if l <= limit && heap[l][0] < heap[smaller][0] {\\n        smaller = l\\n    }\\n    \\n    if r <= limit && heap[r][0] < heap[smaller][0] {\\n        smaller = r\\n    }\\n    \\n    if smaller != p {\\n        heap[smaller], heap[p] = heap[p], heap[smaller]\\n        heapDown(heap, smaller, limit)\\n    }\\n}\\n\\nfunc heapUp(heap [][3]int, p int) {\\n    parent := (p-1)/2\\n    \\n    if parent >= 0 && heap[p][0] < heap[parent][0] {\\n        heap[parent], heap[p] = heap[p], heap[parent]\\n        heapUp(heap, parent)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2294674,
                "title": "python-sliding-window-set-hashmap-o-knlog-kn",
                "content": "## Intuition\\n### Flatten and sort\\n- Lets look at the example `[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]`\\n- We want to flatten this to a 1-d array while keeping information of which original array the number belongs to\\n- After flattening, we can efficiently lookup to the array we included in our windows in O(1) time\\n- Original:\\n\\t![image](https://assets.leetcode.com/users/images/671ca72e-b2ca-4e2b-9b84-278b15b77460_1658054391.3532999.png)\\n- Putting array index into each number:\\n\\t![image](https://assets.leetcode.com/users/images/fcddb48d-337e-4723-8fe8-982c2d5c53ed_1658054475.0941255.png)\\n- Flatten it and sort it (sorting here is O(kNlog(kN)):\\n\\t![image](https://assets.leetcode.com/users/images/58ee38dc-7081-40ce-879e-f0d431a31c4c_1658054512.1080801.png)\\n\\n### Sliding Window\\n- Pretty standard sliding window operations, not gonna explain. Leave comments if you still don\\'t understand. \\n\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        # flatten and sort by value\\n        flatten_nums = [(i,x) for i,X in enumerate(nums) for x in X]\\n        flatten_nums.sort(key=lambda x: x[1])\\n        \\n        res = None\\n        \\n        # sliding window\\n        i = 0\\n        remaining = {i: 1 for i in range(len(nums))}\\n        remaining_set = {*range(len(nums))}\\n        for j in range(len(flatten_nums)):\\n            nums_idx_j, v_j = flatten_nums[j]\\n            nums_idx_i, v_i = flatten_nums[i]\\n            remaining[nums_idx_j] -= 1\\n            if remaining[nums_idx_j] == 0:\\n                remaining_set.remove(nums_idx_j)\\n            while not remaining_set:\\n                nums_idx_i, v_i = flatten_nums[i]\\n                if res is None or v_j-v_i < res[1]-res[0]:\\n                    res = [v_i,v_j]\\n                remaining[nums_idx_i] += 1\\n                if remaining[nums_idx_i] > 0:\\n                    remaining_set.add(nums_idx_i)\\n                i += 1\\n                    \\n        return res\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        # flatten and sort by value\\n        flatten_nums = [(i,x) for i,X in enumerate(nums) for x in X]\\n        flatten_nums.sort(key=lambda x: x[1])\\n        \\n        res = None\\n        \\n        # sliding window\\n        i = 0\\n        remaining = {i: 1 for i in range(len(nums))}",
                "codeTag": "Java"
            },
            {
                "id": 2269332,
                "title": "c-min-heap-using-priority-queue-with-tc-o-n-k-logk",
                "content": "Min Heap is used in the form of priority queue. \\n 1. Store all the minimum elements from every array alongwith their index value in their respective rows.\\n 2. Store the max value out of them side by side using mx variable.\\n 3. Keeping the mx fixed until any other maximum element occurs , iterate through the array of the current minimum element taken from the priority queue and compare the range between max and min with every loop and update the ans .\\n 4. If incase current row exhaust , break out of the loop and iterate through another array of the top.\\n\\nHence, taking out every min element and max element out of all the traversed values , we can calculate the smallest range.\\nDo upvote , if you find this helpful.\\n\\n```\\ntypedef pair<int,pair<int,int>>pi;\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        pair<int,int>ans;\\n          int mini=INT_MAX,mx=0,minele=INT_MAX,maxele=INT_MIN,range=INT_MAX;\\n          priority_queue<pi,vector<pi>,greater<pi>>pq;\\n          pair<int,int>min_ind;\\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(make_pair(nums[i][0],make_pair(i,0)));\\n            mx=max(mx,nums[i][0]);\\n        }\\n        while(1)\\n        {\\n            mini=pq.top().first;\\n            min_ind=pq.top().second;\\n            pq.pop();\\n            int n=nums[min_ind.first].size();\\n            if(mx-mini<range)\\n            {\\n                minele=mini;\\n                maxele=mx;\\n                range=mx-mini;\\n                ans=make_pair(mini,mx);\\n            }\\n            int x=min_ind.first;\\n            int y=min_ind.second+1;\\n            if(y==n)\\n            {\\n                break;\\n            }\\n            if(nums[x][y]>mx)\\n            {\\n                mx=nums[x][y];\\n            }\\n            pq.push(make_pair(nums[x][y],make_pair(x,y)));\\n        }\\n        \\n        vector<int>res;\\n        res.push_back(ans.first);\\n        res.push_back(ans.second);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\ntypedef pair<int,pair<int,int>>pi;\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        pair<int,int>ans;\\n          int mini=INT_MAX,mx=0,minele=INT_MAX,maxele=INT_MIN,range=INT_MAX;\\n          priority_queue<pi,vector<pi>,greater<pi>>pq;\\n          pair<int,int>min_ind;\\n        for(int i=0;i<k;i++)\\n        {\\n            pq.push(make_pair(nums[i][0],make_pair(i,0)));\\n            mx=max(mx,nums[i][0]);\\n        }\\n        while(1)\\n        {\\n            mini=pq.top().first;\\n            min_ind=pq.top().second;\\n            pq.pop();\\n            int n=nums[min_ind.first].size();\\n            if(mx-mini<range)\\n            {\\n                minele=mini;\\n                maxele=mx;\\n                range=mx-mini;\\n                ans=make_pair(mini,mx);\\n            }\\n            int x=min_ind.first;\\n            int y=min_ind.second+1;\\n            if(y==n)\\n            {\\n                break;\\n            }\\n            if(nums[x][y]>mx)\\n            {\\n                mx=nums[x][y];\\n            }\\n            pq.push(make_pair(nums[x][y],make_pair(x,y)));\\n        }\\n        \\n        vector<int>res;\\n        res.push_back(ans.first);\\n        res.push_back(ans.second);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2224603,
                "title": "priority-queue-with-a-varaible-related-to-max-tracker",
                "content": "idea is to pop the min element out and get the range with the help of max element . we have to close the gap between min and max so move the min element array index by 1 \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        \\n        \\n        int n = a.size();\\n        priority_queue<pair<int,pair<int , vector<int>>>> pq;\\n        int mx = INT_MIN;\\n        for(auto i:a)\\n        {\\n            int m = i.size();\\n            if(m==0)\\n                return {};\\n            mx = max(mx,i[0]);\\n            pq.push({-i[0],{0,i}});\\n        }\\n        \\n        int range = INT_MAX;\\n        \\n        int first,last;\\n        \\n        while(1)\\n        {\\n            \\n            auto val = pq.top();\\n            pq.pop();\\n            int mn = -val.first;\\n            int temp_range = mx-mn+1;\\n            if(temp_range<range)\\n            {\\n                first = mn;\\n                last = mx;\\n                range = temp_range;\\n            }\\n            \\n            int ind = val.second.first;\\n            ind++;\\n            int m = val.second.second.size();\\n            if(ind<m)\\n            {\\n                int new_val = val.second.second[ind];\\n                mx = max(mx,new_val);\\n                pq.push({-new_val,{ind,val.second.second}});\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return {first,last};\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& a) {\\n        \\n        \\n        int n = a.size();\\n        priority_queue<pair<int,pair<int , vector<int>>>> pq;\\n        int mx = INT_MIN;\\n        for(auto i:a)\\n        {\\n            int m = i.size();\\n            if(m==0)\\n                return {};\\n            mx = max(mx,i[0]);\\n            pq.push({-i[0],{0,i}});\\n        }\\n        \\n        int range = INT_MAX;\\n        \\n        int first,last;\\n        \\n        while(1)\\n        {\\n            \\n            auto val = pq.top();\\n            pq.pop();\\n            int mn = -val.first;\\n            int temp_range = mx-mn+1;\\n            if(temp_range<range)\\n            {\\n                first = mn;\\n                last = mx;\\n                range = temp_range;\\n            }\\n            \\n            int ind = val.second.first;\\n            ind++;\\n            int m = val.second.second.size();\\n            if(ind<m)\\n            {\\n                int new_val = val.second.second[ind];\\n                mx = max(mx,new_val);\\n                pq.push({-new_val,{ind,val.second.second}});\\n            }\\n            else\\n                break;\\n        }\\n        \\n        return {first,last};\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2200697,
                "title": "short-simple-and-concise-sliding-window-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> v;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            for(int j=0; j<nums[i].size(); j++) v.push_back({nums[i][j], i});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        int i = 0, j = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans = {-100000, 100000};\\n        \\n        while(j < v.size()) {\\n            m[v[j].second]++;\\n            \\n            while(m.size() == nums.size()) {\\n                if(v[j].first - v[i].first < ans[1] - ans[0]) ans = {v[i].first, v[j].first};\\n                \\n                m[v[i].second]--;\\n                if(!m[v[i].second]) m.erase(v[i].second);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int, int>> v;\\n        \\n        for(int i=0; i<nums.size(); i++) {\\n            for(int j=0; j<nums[i].size(); j++) v.push_back({nums[i][j], i});\\n        }\\n        sort(v.begin(), v.end());\\n        \\n        int i = 0, j = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans = {-100000, 100000};\\n        \\n        while(j < v.size()) {\\n            m[v[j].second]++;\\n            \\n            while(m.size() == nums.size()) {\\n                if(v[j].first - v[i].first < ans[1] - ans[0]) ans = {v[i].first, v[j].first};\\n                \\n                m[v[i].second]--;\\n                if(!m[v[i].second]) m.erase(v[i].second);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173623,
                "title": "detailed-java-solution-with-comments",
                "content": "class Solution {\\n\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-(int)1e5,(int)1e5};\\n        int k = nums.size();\\n        int max = Integer.MIN_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->(a[0]-b[0]));\\n        for(int i = 0; i<k; i++){\\n            int minOfList = nums.get(i).get(0);\\n            max = Math.max(max,minOfList);\\n            int[] toAdd = {minOfList,0,i};\\n            pq.add(toAdd);\\n            //0th idx we hav min value of list\\n            //1st idx we have the idx of the min value\\n            //2nd idx we have idx of the list\\n        }\\n        while(true){\\n            int[] rem = pq.poll();\\n            if(res[1]-res[0]>max-rem[0]){\\n                res[0] = rem[0];\\n                res[1] = max;\\n            }\\n            rem[1]++;  //element checked so idx increased to add next element from same list to pq\\n            List<Integer> currList = nums.get(rem[2]);\\n            if(rem[1]==currList.size()){\\n                break;  //break since no elements are left to be added to the list so cant do comparison between three\\n            }else{\\n                rem[0] = currList.get(rem[1]);\\n                max = Math.max(rem[0],max);  //if the new element coming in the pq could be greater than max so we checked for it\\n                pq.add(rem);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-(int)1e5,(int)1e5}",
                "codeTag": "Java"
            },
            {
                "id": 2123902,
                "title": "c-esy-to-understand-using-map-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int>> v;\\n        int c=0;\\n        for(auto x:nums)\\n        {\\n            for(auto z:x)\\n            {\\n                v.push_back({z,c});\\n            }\\n            c++;\\n        }\\n        sort(v.begin(),v.end());\\n        int j=0;\\n        int total=0;\\n        int k=nums.size();\\n        int n=v.size();\\n        int mini=INT_MAX;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[v[i].second]++;\\n            if(mp[v[i].second]==1)\\n            {\\n                total++;\\n            }\\n            if(total==k)\\n            {\\n                if(v[i].first-v[j].first+1<mini)\\n                {\\n                    mini=v[i].first-v[j].first+1;\\n                    ans={v[j].first,v[i].first};\\n                }\\n            }\\n            if(total==k)\\n            {\\n                while(j<i&&mp[v[j].second]!=1)\\n                {\\n                    mp[v[j].second]--;\\n                    j++;\\n                }\\n                if(v[i].first-v[j].first+1<mini)\\n                {\\n                    mini=v[i].first-v[j].first+1;\\n                    ans={v[j].first,v[i].first};\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector<pair<int,int>> v;\\n        int c=0;\\n        for(auto x:nums)\\n        {\\n            for(auto z:x)\\n            {\\n                v.push_back({z,c});\\n            }\\n            c++;\\n        }\\n        sort(v.begin(),v.end());\\n        int j=0;\\n        int total=0;\\n        int k=nums.size();\\n        int n=v.size();\\n        int mini=INT_MAX;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[v[i].second]++;\\n            if(mp[v[i].second]==1)\\n            {\\n                total++;\\n            }\\n            if(total==k)\\n            {\\n                if(v[i].first-v[j].first+1<mini)\\n                {\\n                    mini=v[i].first-v[j].first+1;\\n                    ans={v[j].first,v[i].first};\\n                }\\n            }\\n            if(total==k)\\n            {\\n                while(j<i&&mp[v[j].second]!=1)\\n                {\\n                    mp[v[j].second]--;\\n                    j++;\\n                }\\n                if(v[i].first-v[j].first+1<mini)\\n                {\\n                    mini=v[i].first-v[j].first+1;\\n                    ans={v[j].first,v[i].first};\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104988,
                "title": "easiest-c-implementation-with-constant-extra-space-95-faster-100-less-memory",
                "content": "```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        for(int i = 0;i<nums.size();i++)\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        vector<int> ans;\\n        int mine=INT_MAX,maxe = INT_MIN,minr=INT_MAX;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            mine =  min(mine,nums[i].back());\\n            maxe = max(maxe,nums[i].back());\\n        }\\n        if(maxe-mine<minr)\\n        {\\n            ans = {mine,maxe};\\n            minr = maxe-mine;\\n        }\\n        bool flag = true;\\n        while(flag)\\n        {\\n            \\n            int currmin = INT_MAX;\\n            for(int i = 0;i<nums.size();i++)\\n            {\\n                if(nums[i].back()==mine)\\n                {\\n                    nums[i].pop_back();\\n                    if(!nums[i].size())\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    currmin =  min(currmin,nums[i].back());\\n                    maxe = max(maxe,nums[i].back());\\n                   \\n                    \\n                }\\n                else\\n                    currmin =  min(currmin,nums[i].back());\\n            }\\n            if(flag)\\n            {\\n                mine = currmin;\\n                if(maxe-mine<minr)\\n                {\\n                    ans = {mine,maxe};\\n                    minr = maxe-mine;\\n                } \\n            }\\n            \\n        }\\n         return ans;  \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nvector<int> smallestRange(vector<vector<int>>& nums) {\\n        for(int i = 0;i<nums.size();i++)\\n            sort(nums[i].begin(),nums[i].end(),greater<int>());\\n        vector<int> ans;\\n        int mine=INT_MAX,maxe = INT_MIN,minr=INT_MAX;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            mine =  min(mine,nums[i].back());\\n            maxe = max(maxe,nums[i].back());\\n        }\\n        if(maxe-mine<minr)\\n        {\\n            ans = {mine,maxe};\\n            minr = maxe-mine;\\n        }\\n        bool flag = true;\\n        while(flag)\\n        {\\n            \\n            int currmin = INT_MAX;\\n            for(int i = 0;i<nums.size();i++)\\n            {\\n                if(nums[i].back()==mine)\\n                {\\n                    nums[i].pop_back();\\n                    if(!nums[i].size())\\n                    {\\n                        flag = false;\\n                        break;\\n                    }\\n                    currmin =  min(currmin,nums[i].back());\\n                    maxe = max(maxe,nums[i].back());\\n                   \\n                    \\n                }\\n                else\\n                    currmin =  min(currmin,nums[i].back());\\n            }\\n            if(flag)\\n            {\\n                mine = currmin;\\n                if(maxe-mine<minr)\\n                {\\n                    ans = {mine,maxe};\\n                    minr = maxe-mine;\\n                } \\n            }\\n            \\n        }\\n         return ans;  \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1945435,
                "title": "c-code-for-beginners-and-easy-to-understand",
                "content": "We use minHeap as a way to get the start Range and we use maximum value while traversing heap as endRange\\n\\n```\\nstruct Info{\\n    int data;\\n    int x;\\n    int y;\\n};\\n\\nstruct cmp{\\n    bool operator()(Info &inf1, Info &inf2){\\n        return inf1.data>inf2.data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<Info,vector<Info>,cmp> pq;\\n        int low=INT_MAX;\\n        int high=INT_MIN;\\n        int mx=INT_MIN;\\n        int range=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mx=max(nums[i][0],mx);\\n            pq.push({nums[i][0],i,0});\\n        }\\n        \\n        while(!pq.empty()){\\n            auto curr=pq.top();\\n            pq.pop();\\n            int min_temp=curr.data;\\n            int x=curr.x;\\n            int y=curr.y;\\n            if(range>mx-min_temp){\\n                low=min_temp;\\n                high=mx;\\n                range=mx-min_temp;\\n            }\\n            if(y==nums[x].size()-1){\\n                break;\\n            }\\n            pq.push({nums[x][y+1],x,y+1});\\n            mx=max(mx,nums[x][y+1]);\\n        }\\n        return {low,high};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nstruct Info{\\n    int data;\\n    int x;\\n    int y;\\n};\\n\\nstruct cmp{\\n    bool operator()(Info &inf1, Info &inf2){\\n        return inf1.data>inf2.data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<Info,vector<Info>,cmp> pq;\\n        int low=INT_MAX;\\n        int high=INT_MIN;\\n        int mx=INT_MIN;\\n        int range=INT_MAX;\\n        \\n        for(int i=0;i<nums.size();i++){\\n            mx=max(nums[i][0],mx);\\n            pq.push({nums[i][0],i,0});\\n        }\\n        \\n        while(!pq.empty()){\\n            auto curr=pq.top();\\n            pq.pop();\\n            int min_temp=curr.data;\\n            int x=curr.x;\\n            int y=curr.y;\\n            if(range>mx-min_temp){\\n                low=min_temp;\\n                high=mx;\\n                range=mx-min_temp;\\n            }\\n            if(y==nums[x].size()-1){\\n                break;\\n            }\\n            pq.push({nums[x][y+1],x,y+1});\\n            mx=max(mx,nums[x][y+1]);\\n        }\\n        return {low,high};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1916803,
                "title": "python-two-pointers-o-nlogn-easy-to-read",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        d = []\\n        k = len(nums)\\n        count = defaultdict(int)\\n        for i, lst in enumerate(nums):\\n            for e in lst:\\n                d.append([e,i])\\n        d.sort()\\n        res = []\\n        left = 0\\n        for right, e in enumerate(d):\\n            count[e[1]] += 1\\n            while len(count) == k:\\n                if not res or d[right][0]-d[left][0] < res[1]-res[0]:\\n                    res = [d[left][0],d[right][0]]\\n                if count[d[left][1]] > 1:\\n                    count[d[left][1]] -= 1\\n                    left += 1\\n                else:\\n                    break\\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        d = []\\n        k = len(nums)\\n        count = defaultdict(int)\\n        for i, lst in enumerate(nums):\\n            for e in lst:\\n                d.append([e,i])\\n        d.sort()\\n        res = []\\n        left = 0\\n        for right, e in enumerate(d):\\n            count[e[1]] += 1\\n            while len(count) == k:\\n                if not res or d[right][0]-d[left][0] < res[1]-res[0]:\\n                    res = [d[left][0],d[right][0]]\\n                if count[d[left][1]] > 1:\\n                    count[d[left][1]] -= 1\\n                    left += 1\\n                else:\\n                    break\\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 1912782,
                "title": "javascript-minpriorityqueue",
                "content": "```\\nvar smallestRange = function(nums) {\\n    let minHeap = new MinPriorityQueue({\\n        compare: (a,b) => a[0] - b[0]\\n    });\\n    let start = 0, end = Infinity;\\n    let maxSoFar = -Infinity;\\n\\t\\n    for (let num of nums) {\\n        minHeap.enqueue([num[0], 0, num]);\\n        maxSoFar = Math.max(maxSoFar, num[0]);\\n    }\\n\\t\\n    while (minHeap.size() == nums.length) {\\n        let [num, i, list] = minHeap.dequeue();\\n        \\n        if (end - start > maxSoFar - num) {\\n            start = num;\\n            end = maxSoFar;\\n        }\\n        \\n        if (list.length > i + 1) {\\n            minHeap.enqueue([list[i + 1], i + 1, list]);\\n            maxSoFar = Math.max(maxSoFar, list[i + 1]);\\n        }\\n    }\\n    \\n    return [start, end];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallestRange = function(nums) {\\n    let minHeap = new MinPriorityQueue({\\n        compare: (a,b) => a[0] - b[0]\\n    });\\n    let start = 0, end = Infinity;\\n    let maxSoFar = -Infinity;\\n\\t\\n    for (let num of nums) {\\n        minHeap.enqueue([num[0], 0, num]);\\n        maxSoFar = Math.max(maxSoFar, num[0]);\\n    }\\n\\t\\n    while (minHeap.size() == nums.length) {\\n        let [num, i, list] = minHeap.dequeue();\\n        \\n        if (end - start > maxSoFar - num) {\\n            start = num;\\n            end = maxSoFar;\\n        }\\n        \\n        if (list.length > i + 1) {\\n            minHeap.enqueue([list[i + 1], i + 1, list]);\\n            maxSoFar = Math.max(maxSoFar, list[i + 1]);\\n        }\\n    }\\n    \\n    return [start, end];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1873275,
                "title": "c-priority-queue-smallest-range-covering-elements-from-k-lists",
                "content": "```\\nclass node{\\n    public:\\n        int data;\\n        int row;\\n        int col;\\n        int size;\\n        node(int data,int row,int col,int size){\\n            this->data=data;\\n            this->row=row;\\n            this->col=col;\\n            this->size=size;\\n        }\\n};\\n\\nclass compare{\\n  public:\\n    bool operator()(node* a,node* b){\\n        return a->data > b->data;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<node*,vector<node*>,compare> minHeap;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int size = nums.size();\\n        vector<int> ans;\\n        //Step 1 -Pushing 1st element of all lists to minHeap and maintaining min and max element;\\n        \\n        for(int i=0;i<size;i++){\\n            int element = nums[i][0];\\n            minHeap.push(new node(element,i,0,nums[i].size()));\\n            mini = min(mini,element);\\n            maxi = max(maxi,element);\\n        }\\n        \\n        // Initialize start and end to mini and maxi and update it if we found smaller range than this one\\n        int start = mini;\\n        int end = maxi;\\n        while(!minHeap.empty()){\\n            node* temp=minHeap.top();\\n            minHeap.pop();\\n            \\n            mini = temp->data;\\n            \\n            // Update end and start if we found smaller range\\n            if(maxi-mini < end-start){\\n                end = maxi;\\n                start = mini;\\n            }\\n            \\n            if(temp->col + 1<temp->size){\\n                minHeap.push(new node(nums[temp->row][temp->col+1],temp->row,temp->col+1,temp->size));\\n                maxi = max(maxi,nums[temp->row][temp->col+1]);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        ans.push_back(start);\\n        ans.push_back(end);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass node{\\n    public:\\n        int data;\\n        int row;\\n        int col;\\n        int size;\\n        node(int data,int row,int col,int size){\\n            this->data=data;\\n            this->row=row;\\n            this->col=col;\\n            this->size=size;\\n        }\\n};\\n\\nclass compare{\\n  public:\\n    bool operator()(node* a,node* b){\\n        return a->data > b->data;\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<node*,vector<node*>,compare> minHeap;\\n        int mini = INT_MAX;\\n        int maxi = INT_MIN;\\n        int size = nums.size();\\n        vector<int> ans;\\n        //Step 1 -Pushing 1st element of all lists to minHeap and maintaining min and max element;\\n        \\n        for(int i=0;i<size;i++){\\n            int element = nums[i][0];\\n            minHeap.push(new node(element,i,0,nums[i].size()));\\n            mini = min(mini,element);\\n            maxi = max(maxi,element);\\n        }\\n        \\n        // Initialize start and end to mini and maxi and update it if we found smaller range than this one\\n        int start = mini;\\n        int end = maxi;\\n        while(!minHeap.empty()){\\n            node* temp=minHeap.top();\\n            minHeap.pop();\\n            \\n            mini = temp->data;\\n            \\n            // Update end and start if we found smaller range\\n            if(maxi-mini < end-start){\\n                end = maxi;\\n                start = mini;\\n            }\\n            \\n            if(temp->col + 1<temp->size){\\n                minHeap.push(new node(nums[temp->row][temp->col+1],temp->row,temp->col+1,temp->size));\\n                maxi = max(maxi,nums[temp->row][temp->col+1]);\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        ans.push_back(start);\\n        ans.push_back(end);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1861612,
                "title": "best-solution-using-heap",
                "content": "```\\n// class for heap\\nclass node{\\n    public:\\n    int data;\\n    int i;\\n    int j;\\n    node(int data,int row,int col){\\n        this->data = data;\\n        i=row;\\n        j=col;\\n    }\\n};\\n\\nclass compare{\\n    public:\\n    bool operator()(node* a,node* b){\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        \\n        // Defining MIN Heap\\n        priority_queue<node*,vector<node*>,compare> pq;\\n        \\n        //step1 insert 1st element of each lists in heap and tracking max and min\\n        for(int i=0;i<nums.size();i++){\\n            maxi = max(maxi,nums[i][0]);\\n            mini = min(mini,nums[i][0]);\\n            \\n            pq.push(new node(nums[i][0] , i , 0));\\n        }\\n        \\n        int start = mini;\\n        int end = maxi;\\n        \\n        // processing in heap until its empty\\n        while(!pq.empty()){\\n            \\n            node* top = pq.top();\\n            pq.pop();\\n            \\n            mini = top->data;             //fetching min element\\n            \\n            // Updating Answers\\n            if(maxi - mini < end-start){\\n                start = mini;\\n                end=maxi;\\n            }\\n            \\n            // if next element exist of top element then push it into the heap and take track of max element\\n            if(top->j + 1 < nums[top->i].size()){\\n                maxi = max(maxi , nums[top->i][top->j+1]);\\n                pq.push(new node(nums[top->i][top->j+1] , top->i , top->j+1));\\n            }\\n            else{              \\n                break;     \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        ans.push_back(start);\\n        ans.push_back(end);\\n        \\n        return ans;\\n    }\\n    \\n};\\n```\\n\\n# ****PLEASE UPVOTE",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// class for heap\\nclass node{\\n    public:\\n    int data;\\n    int i;\\n    int j;\\n    node(int data,int row,int col){\\n        this->data = data;\\n        i=row;\\n        j=col;\\n    }\\n};\\n\\nclass compare{\\n    public:\\n    bool operator()(node* a,node* b){\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int maxi = INT_MIN;\\n        int mini = INT_MAX;\\n        \\n        // Defining MIN Heap\\n        priority_queue<node*,vector<node*>,compare> pq;\\n        \\n        //step1 insert 1st element of each lists in heap and tracking max and min\\n        for(int i=0;i<nums.size();i++){\\n            maxi = max(maxi,nums[i][0]);\\n            mini = min(mini,nums[i][0]);\\n            \\n            pq.push(new node(nums[i][0] , i , 0));\\n        }\\n        \\n        int start = mini;\\n        int end = maxi;\\n        \\n        // processing in heap until its empty\\n        while(!pq.empty()){\\n            \\n            node* top = pq.top();\\n            pq.pop();\\n            \\n            mini = top->data;             //fetching min element\\n            \\n            // Updating Answers\\n            if(maxi - mini < end-start){\\n                start = mini;\\n                end=maxi;\\n            }\\n            \\n            // if next element exist of top element then push it into the heap and take track of max element\\n            if(top->j + 1 < nums[top->i].size()){\\n                maxi = max(maxi , nums[top->i][top->j+1]);\\n                pq.push(new node(nums[top->i][top->j+1] , top->i , top->j+1));\\n            }\\n            else{              \\n                break;     \\n            }\\n        }\\n        \\n        vector<int> ans;\\n        \\n        ans.push_back(start);\\n        ans.push_back(end);\\n        \\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1860776,
                "title": "c-easy-and-consice",
                "content": "```\\nclass Node\\n{\\n public:\\n    int data;\\n    int row;\\n    int col;\\n    \\n    Node(int data,int row,int col)\\n    {\\n        this->data = data;\\n        this->row = row;\\n        this->col = col;\\n    }\\n    \\n};\\n\\nclass Comparator\\n{\\npublic:\\n    bool operator()(Node* a, Node* b){\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int mini = INT_MAX , maxi = INT_MIN;\\n        priority_queue<Node*,vector<Node*>,Comparator>minHeap;\\n        \\n        int k = nums.size();\\n        \\n    \\n        for(int i=0; i<k; i++)\\n        {\\n            int element = nums[i][0];\\n            mini = min(mini,element);\\n            maxi = max(maxi, element);\\n            Node* node = new Node(element,i,0);\\n            minHeap.push(node);\\n        }\\n        \\n        int start = mini , end = maxi;\\n        \\n        while(!minHeap.empty())\\n        {\\n            Node* top = minHeap.top();\\n            minHeap.pop();\\n            \\n            int n = nums[top->row].size();\\n            \\n            mini = top->data;\\n            \\n            if( (maxi - mini) < (end - start) ){\\n                start = mini;\\n                end = maxi;\\n            }\\n            \\n            if( top->col + 1 < n ){\\n                maxi = max(maxi,nums[top->row][top->col + 1]);\\n                \\n                Node* newNode = new Node(nums[top->row][top->col + 1] , top->row, top->col+1);\\n                minHeap.push(newNode);\\n            }\\n            \\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return vector<int>{start,end};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Node\\n{\\n public:\\n    int data;\\n    int row;\\n    int col;\\n    \\n    Node(int data,int row,int col)\\n    {\\n        this->data = data;\\n        this->row = row;\\n        this->col = col;\\n    }\\n    \\n};\\n\\nclass Comparator\\n{\\npublic:\\n    bool operator()(Node* a, Node* b){\\n        return a->data > b->data;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int mini = INT_MAX , maxi = INT_MIN;\\n        priority_queue<Node*,vector<Node*>,Comparator>minHeap;\\n        \\n        int k = nums.size();\\n        \\n    \\n        for(int i=0; i<k; i++)\\n        {\\n            int element = nums[i][0];\\n            mini = min(mini,element);\\n            maxi = max(maxi, element);\\n            Node* node = new Node(element,i,0);\\n            minHeap.push(node);\\n        }\\n        \\n        int start = mini , end = maxi;\\n        \\n        while(!minHeap.empty())\\n        {\\n            Node* top = minHeap.top();\\n            minHeap.pop();\\n            \\n            int n = nums[top->row].size();\\n            \\n            mini = top->data;\\n            \\n            if( (maxi - mini) < (end - start) ){\\n                start = mini;\\n                end = maxi;\\n            }\\n            \\n            if( top->col + 1 < n ){\\n                maxi = max(maxi,nums[top->row][top->col + 1]);\\n                \\n                Node* newNode = new Node(nums[top->row][top->col + 1] , top->row, top->col+1);\\n                minHeap.push(newNode);\\n            }\\n            \\n            else\\n            {\\n                break;\\n            }\\n        }\\n        \\n        \\n        return vector<int>{start,end};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841813,
                "title": "c-cleanest-heap-code-for-easy-understnading",
                "content": "```\\n    vector<int> smallestRange(vector<vector<int>>& nums)                    {\\n        priority_queue< pair<int, int>, \\n                        vector<pair<int, int>>, \\n                        greater<pair<int, int>>> pq                         ;\\n        \\n        vector<int> list_pointer(nums.size(), 1)                            ;\\n        pair<int, int> min_range = make_pair(-100002, 100002)               ;\\n        int maxi = -100003                                                  ;\\n        for(int i = 0; i < nums.size(); i++)                                {\\n            maxi = max(maxi, nums[i][0])                                    ;\\n            pq.push({nums[i][0], i})                                        ;\\n                                                                            }\\n        while(!pq.empty())                                                  {\\n            int b = maxi                                                    ;\\n            int a = pq.top().first                                          ;\\n            int min_range_length = (min_range.second - min_range.first)+1   ;\\n            int current_range_length = (b-a)+1                              ;\\n            if(current_range_length < min_range_length)                     {\\n                min_range_length = current_range_length                     ;\\n                min_range = make_pair(a,b)                                  ;\\n                                                                            }\\n            int list = pq.top().second; pq.pop()                            ;\\n            if(list_pointer[list] < nums[list].size())                      {\\n                int element = nums[list][list_pointer[list]++]              ;\\n                maxi = max(maxi, element)                                   ;\\n                pq.push({element, list})                                    ;}     \\n            else break                                                      ;\\n                                                                            }\\n        vector<int> range(2)                                                ; \\n        range[0] = min_range.first; range[1] = min_range.second             ;\\n        return range                                                        ;}\\n\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n    vector<int> smallestRange(vector<vector<int>>& nums)                    {\\n        priority_queue< pair<int, int>, \\n                        vector<pair<int, int>>, \\n                        greater<pair<int, int>>> pq                         ;\\n        \\n        vector<int> list_pointer(nums.size(), 1)                            ;\\n        pair<int, int> min_range = make_pair(-100002, 100002)               ;\\n        int maxi = -100003                                                  ;\\n        for(int i = 0; i < nums.size(); i++)                                {\\n            maxi = max(maxi, nums[i][0])                                    ;\\n            pq.push({nums[i][0], i})                                        ;\\n                                                                            }\\n        while(!pq.empty())                                                  {\\n            int b = maxi                                                    ;\\n            int a = pq.top().first                                          ;\\n            int min_range_length = (min_range.second - min_range.first)+1   ;\\n            int current_range_length = (b-a)+1                              ;\\n            if(current_range_length < min_range_length)                     {\\n                min_range_length = current_range_length                     ;\\n                min_range = make_pair(a,b)                                  ;\\n                                                                            }\\n            int list = pq.top().second; pq.pop()                            ;\\n            if(list_pointer[list] < nums[list].size())                      {\\n                int element = nums[list][list_pointer[list]++]              ;\\n                maxi = max(maxi, element)                                   ;\\n                pq.push({element, list})                                    ;}     \\n            else break                                                      ;\\n                                                                            }\\n        vector<int> range(2)                                                ; \\n        range[0] = min_range.first; range[1] = min_range.second             ;\\n        return range                                                        ;}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795760,
                "title": "python-sort-then-use-sliding-window",
                "content": "Very Similar to LC 1675. Minimize Deviation in Array and 1100. Find K-Length Substrings With No Repeated Characters. In fact, I did both in the same month and after digging around found this problem.\\n\\nWe first merge all the numbers and their index list numbers into one list. Then sort. We then use a sliding window to maintain the invariant of having the counts if list indices being at least 1. When shrinking the window, update the smallest range if there is a smaller one.\\n\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\'\\'\\'\\n        i can concatenate all the nums into one list, where each element in the list is [num,idx of list]\\n        we can then use a sliding window to try to first make a window\\n        \\'\\'\\'\\n        #concat list and sort\\n        N = len(nums)\\n        merged = []\\n        for i,l in enumerate(nums):\\n            for num in l:\\n                merged.append([num,i])\\n        \\n        #sort\\n        merged.sort()\\n        \\n        #start sliding window\\n        #keep expanding right until we capture all indicies\\n        #we can keep Counter of the number of list indices taken\\n        captured_indices = Counter()\\n        total_captured = 0\\n        left, right = 0,0\\n        range_ans = [merged[0][0],merged[-1][0]] #minimuze this\\n        #possible ranges\\n        #range_ans = []\\n        \\n        while right < len(merged):\\n            #add in right most element for window\\n            curr = merged[right]\\n            #mark\\n            captured_indices[curr[1]] += 1\\n            #we we have at least k indices in counter, shrink\\n            while len(captured_indices) == N:\\n                #range_ans[0] = max(range_ans[0],merged[left][0])\\n                #range_ans[1] = min(range_ans[1],curr[0])\\n                local_range = [merged[left][0],curr[0]]\\n                if local_range[1] - local_range[0] < range_ans[1] - range_ans[0]:\\n                    range_ans = local_range[:]\\n                if captured_indices[merged[left][1]] > 1:\\n                    captured_indices[merged[left][1]] -= 1\\n                else:\\n                    del captured_indices[merged[left][1]]\\n                left += 1\\n            \\n            right += 1\\n        \\n        #f\\n        return range_ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        \\'\\'\\'\\n        i can concatenate all the nums into one list, where each element in the list is [num,idx of list]\\n        we can then use a sliding window to try to first make a window\\n        \\'\\'\\'\\n        #concat list and sort\\n        N = len(nums)\\n        merged = []\\n        for i,l in enumerate(nums):\\n            for num in l:\\n                merged.append([num,i])\\n        \\n        #sort\\n        merged.sort()\\n        \\n        #start sliding window\\n        #keep expanding right until we capture all indicies\\n        #we can keep Counter of the number of list indices taken\\n        captured_indices = Counter()\\n        total_captured = 0\\n        left, right = 0,0\\n        range_ans = [merged[0][0],merged[-1][0]] #minimuze this\\n        #possible ranges\\n        #range_ans = []\\n        \\n        while right < len(merged):\\n            #add in right most element for window\\n            curr = merged[right]\\n            #mark\\n            captured_indices[curr[1]] += 1\\n            #we we have at least k indices in counter, shrink\\n            while len(captured_indices) == N:\\n                #range_ans[0] = max(range_ans[0],merged[left][0])\\n                #range_ans[1] = min(range_ans[1],curr[0])\\n                local_range = [merged[left][0],curr[0]]\\n                if local_range[1] - local_range[0] < range_ans[1] - range_ans[0]:\\n                    range_ans = local_range[:]\\n                if captured_indices[merged[left][1]] > 1:\\n                    captured_indices[merged[left][1]] -= 1\\n                else:\\n                    del captured_indices[merged[left][1]]\\n                left += 1\\n            \\n            right += 1\\n        \\n        #f\\n        return range_ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793056,
                "title": "simplest-solution-c-pq",
                "content": "For smallest range we shall take elements from list itself\\nso we use min heap and keep  track of max element inserted so far\\nthe range will be\\nmxele-pq.top+1\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {       \\n\\t\\n\\tpriority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        int mx=INT_MIN;\\n        int cans=INT_MAX;\\n        int lo=INT_MIN,hi=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}});\\n        }\\n        while(!pq.empty())\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            int na=mx-x.first+1;\\n            if(cans>na)\\n            {\\n                cans=na;\\n                lo=x.first;\\n                hi=mx;\\n            }\\n            if(x.second.second>=nums[x.second.first].size()-1)\\n                break;\\n            pq.push({nums[x.second.first][x.second.second+1],{x.second.first,x.second.second+1}});\\n            mx=max(mx,nums[x.second.first][x.second.second+1]);\\n        }\\n        return {lo,hi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {       \\n\\t\\n\\tpriority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        int mx=INT_MIN;\\n        int cans=INT_MAX;\\n        int lo=INT_MIN,hi=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mx=max(mx,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}});\\n        }\\n        while(!pq.empty())\\n        {\\n            auto x=pq.top();\\n            pq.pop();\\n            int na=mx-x.first+1;\\n            if(cans>na)\\n            {\\n                cans=na;\\n                lo=x.first;\\n                hi=mx;\\n            }\\n            if(x.second.second>=nums[x.second.first].size()-1)\\n                break;\\n            pq.push({nums[x.second.first][x.second.second+1],{x.second.first,x.second.second+1}});\\n            mx=max(mx,nums[x.second.first][x.second.second+1]);\\n        }\\n        return {lo,hi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674211,
                "title": "java-super-simple-merge-k-lists-approach-with-explanation",
                "content": "The idea here is to start with the first element of every list. Our initial range is then the smallest and biggest elements out of these first elements. Add all the first elements in the priority queue. Poll the queue to get the smallest element at every iteration, and check whether this current smallest element along with our global max forms a new smallest range. Then, iterate to the next element in the List that was popped, see if this element is our new global max, and push the list back into the queue.\\n\\n```\\n\\tclass Element {\\n        int index;\\n        List<Integer> list;\\n        public Element(int index, List<Integer> list) {\\n            this.index = index;\\n            this.list = list;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<Element> pq = new PriorityQueue<>((a, b) -> \\n            Integer.compare(a.list.get(a.index), b.list.get(b.index)));\\n        int max = Integer.MIN_VALUE;\\n        int l = 0;\\n        int r = Integer.MAX_VALUE;\\n        for (List<Integer> list : nums) {\\n            max = Math.max(max, list.get(0));\\n            pq.offer(new Element(0, list));\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            Element minElement = pq.poll();\\n            int min = minElement.list.get(minElement.index);\\n            if (max - min < r - l) {\\n                r = max;\\n                l = min;\\n            }\\n            minElement.index += 1;\\n            if (minElement.list.size() == minElement.index) {\\n                return new int[]{l, r};\\n            } else {\\n                max = Math.max(max, minElement.list.get(minElement.index));\\n                pq.offer(minElement);\\n            }\\n        }\\n        \\n        return new int[]{l, r};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tclass Element {\\n        int index;\\n        List<Integer> list;\\n        public Element(int index, List<Integer> list) {\\n            this.index = index;\\n            this.list = list;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<Element> pq = new PriorityQueue<>((a, b) -> \\n            Integer.compare(a.list.get(a.index), b.list.get(b.index)));\\n        int max = Integer.MIN_VALUE;\\n        int l = 0;\\n        int r = Integer.MAX_VALUE;\\n        for (List<Integer> list : nums) {\\n            max = Math.max(max, list.get(0));\\n            pq.offer(new Element(0, list));\\n        }\\n        \\n        while (!pq.isEmpty()) {\\n            Element minElement = pq.poll();\\n            int min = minElement.list.get(minElement.index);\\n            if (max - min < r - l) {\\n                r = max;\\n                l = min;\\n            }\\n            minElement.index += 1;\\n            if (minElement.list.size() == minElement.index) {\\n                return new int[]{l, r};\\n            } else {\\n                max = Math.max(max, minElement.list.get(minElement.index));\\n                pq.offer(minElement);\\n            }\\n        }\\n        \\n        return new int[]{l, r};\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647039,
                "title": "java-sorting-sliding-window-pair-class",
                "content": "```\\nclass Solution {\\n    //  pair class for storing values of nums and their sublist_index\\n    //  sorting on the basis of values\\n    class Pair implements Comparable<Pair> {\\n        int v, k;\\n        Pair (int v, int k) {\\n            this.v = v;\\n            this.k = k;\\n        }\\n        public int compareTo(Pair o){\\n            return this.v - o.v;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int n = 0;              //  total number of elements in nums\\n        int k = nums.size();    //  total number of sublists in nums\\n        for(int i = 0; i < nums.size(); i++){\\n            n += nums.get(i).size();\\n        }\\n        Pair[] p = new Pair[n];\\n        int idx = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.get(i).size(); j++){\\n                p[idx++] = new Pair(nums.get(i).get(j), i);\\n            }\\n        }\\n        Arrays.sort(p);\\n        //  for storing the sublists in window and frequency count \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] ans = new int[2];\\n        //  default values \\n        ans[0] = -100_000;\\n        ans[1] = 100_000;\\n        int i = 0, j = 0;\\n        //  sliding window\\n        while(j < p.length){\\n            //  aquire\\n            while(j < p.length){\\n                Pair c = p[j];\\n                map.put(c.k, map.getOrDefault(c.k, 0) + 1);\\n                j++;\\n                if(map.size() == k){\\n                    if((ans[1] - ans[0]) > (p[j - 1].v - p[i].v)){\\n                        ans[0] = p[i].v;\\n                        ans[1] = p[j - 1].v;\\n                    }\\n                    break;\\n                }\\n            }\\n            //  release\\n            while(i < j){\\n                Pair c = p[i];\\n                map.put(c.k, map.get(c.k) - 1); //  \\n                if(map.get(c.k) == 0) map.remove(c.k);\\n                i++;\\n                if(map.size() < k){\\n                    break;\\n                }\\n                if((ans[1] - ans[0]) > (p[j - 1].v - p[i].v)){\\n                    ans[0] = p[i].v;\\n                    ans[1] = p[j - 1].v;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n***N*** = total number of Integers in nums\\ntime complexity : ***O(NlogN) + O(N) = O(NlogN)***\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //  pair class for storing values of nums and their sublist_index\\n    //  sorting on the basis of values\\n    class Pair implements Comparable<Pair> {\\n        int v, k;\\n        Pair (int v, int k) {\\n            this.v = v;\\n            this.k = k;\\n        }\\n        public int compareTo(Pair o){\\n            return this.v - o.v;\\n        }\\n    }\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int n = 0;              //  total number of elements in nums\\n        int k = nums.size();    //  total number of sublists in nums\\n        for(int i = 0; i < nums.size(); i++){\\n            n += nums.get(i).size();\\n        }\\n        Pair[] p = new Pair[n];\\n        int idx = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int j = 0; j < nums.get(i).size(); j++){\\n                p[idx++] = new Pair(nums.get(i).get(j), i);\\n            }\\n        }\\n        Arrays.sort(p);\\n        //  for storing the sublists in window and frequency count \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int[] ans = new int[2];\\n        //  default values \\n        ans[0] = -100_000;\\n        ans[1] = 100_000;\\n        int i = 0, j = 0;\\n        //  sliding window\\n        while(j < p.length){\\n            //  aquire\\n            while(j < p.length){\\n                Pair c = p[j];\\n                map.put(c.k, map.getOrDefault(c.k, 0) + 1);\\n                j++;\\n                if(map.size() == k){\\n                    if((ans[1] - ans[0]) > (p[j - 1].v - p[i].v)){\\n                        ans[0] = p[i].v;\\n                        ans[1] = p[j - 1].v;\\n                    }\\n                    break;\\n                }\\n            }\\n            //  release\\n            while(i < j){\\n                Pair c = p[i];\\n                map.put(c.k, map.get(c.k) - 1); //  \\n                if(map.get(c.k) == 0) map.remove(c.k);\\n                i++;\\n                if(map.size() < k){\\n                    break;\\n                }\\n                if((ans[1] - ans[0]) > (p[j - 1].v - p[i].v)){\\n                    ans[0] = p[i].v;\\n                    ans[1] = p[j - 1].v;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1640722,
                "title": "c-straight-forward-small-code-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        long long int l = INT_MIN, r = INT_MAX;\\n        unordered_map<int, int> m;\\n        const int k = nums.size();\\n        for(int x=0;x<k;x++){\\n            for(int i:nums[x]){\\n                if(m[i] == 1) continue;\\n                int lt = i, rt = INT_MIN, f = 1;\\n                for(int j=0;j<k;j++){\\n                    int g = lower_bound(nums[j].begin(), nums[j].end(), i) - nums[j].begin();\\n                    if(g == nums[j].size()){\\n                        f = 0;\\n                    } else rt = max(rt, nums[j][g]);\\n                }\\n                if(f){\\n                    if(r - l > rt - lt){\\n                        l = lt;\\n                        r = rt;\\n                    }\\n                }\\n                m[i] = 1;\\n            }\\n        }\\n        vector<int> ans;\\n        ans = {int(l), int(r)};\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        long long int l = INT_MIN, r = INT_MAX;\\n        unordered_map<int, int> m;\\n        const int k = nums.size();\\n        for(int x=0;x<k;x++){\\n            for(int i:nums[x]){\\n                if(m[i] == 1) continue;\\n                int lt = i, rt = INT_MIN, f = 1;\\n                for(int j=0;j<k;j++){\\n                    int g = lower_bound(nums[j].begin(), nums[j].end(), i) - nums[j].begin();\\n                    if(g == nums[j].size()){\\n                        f = 0;\\n                    } else rt = max(rt, nums[j][g]);\\n                }\\n                if(f){\\n                    if(r - l > rt - lt){\\n                        l = lt;\\n                        r = rt;\\n                    }\\n                }\\n                m[i] = 1;\\n            }\\n        }\\n        vector<int> ans;\\n        ans = {int(l), int(r)};\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1605806,
                "title": "using-min-heap",
                "content": "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-100000,100000};\\n        int max = Integer.MIN_VALUE;\\n        int k =  nums.size();\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]);\\n        for(int i=0;i<k;i++)\\n        {\\n            int mol = nums.get(i).get(0);\\n            int[] tba = {mol,0,i};\\n            // 0th -> minimum of the list.\\n            // 1st -> index of the element of the list\\n            // 2nd -> index of the list.\\n            max = Math.max(mol,max);\\n            pq.add(tba);\\n        }\\n\\n        // jab tak ek list ka size cover na ho tab tak kaam karo\\n\\n        while(true)\\n        {\\n            int[] min = pq.remove();\\n            if(res[1]-res[0]+1 > max - min[0] + 1)\\n            {\\n                res[0] = min[0];\\n                res[1] = max;\\n            }\\n            // sabse chota element jo aaya uska index increase karo\\n            min[1]++;\\n            List<Integer> cl = nums.get(min[2]);\\n            if(min[1] == cl.size())\\n            {\\n                break;\\n            }\\n            else\\n            {\\n                min[0] = cl.get(min[1]);\\n                max = Math.max(min[0],max);\\n                pq.add(min);\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] res = {-100000,100000}",
                "codeTag": "Java"
            },
            {
                "id": 1603955,
                "title": "java-simple-and-easy-smallest-range-covering-elements-from-k-lists",
                "content": "```\\npublic int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]); // create a minheap\\n        int res[] = new int[2]; // result array\\n        int max = Integer.MIN_VALUE; // max value\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t// create min heap from first element of every list\\n\\t\\t// also find max element from those elements\\n            int val = nums.get(i).get(0);\\n            if (val > max) {\\n                max = val;\\n            }\\n            pq.offer(new int[]{val, i, 0});\\n        }\\n        // maintain min range\\n        int minrange = Integer.MAX_VALUE;\\n        while (pq.size() == nums.size()) {\\n\\t\\t// get min value from heap\\n            int[] t = pq.poll();\\n            int row = t[1];\\n            int col = t[2];\\n\\t\\t\\t// compare with minrange\\n            if (max - t[0] < minrange) {\\n\\t\\t\\t// if min range found then update result array\\n                minrange = max - t[0];\\n                res[0] = t[0];\\n                res[1] = max;\\n            }\\n            if (col + 1 < nums.get(row).size()) { // now check other elements of current list\\n\\t\\t\\t// i.e. same row but next column and add to heap\\n                pq.offer(new int[] {nums.get(row).get(col+1), row, col+1});\\n\\t\\t\\t\\t// also update max value \\n                if (max < nums.get(row).get(col+1)) {\\n                    max = nums.get(row).get(col+1);\\n                }\\n            }\\n            \\n        }\\n\\t\\t// return result array\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\npublic int[] smallestRange(List<List<Integer>> nums) {\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b)->a[0]-b[0]); // create a minheap\\n        int res[] = new int[2]; // result array\\n        int max = Integer.MIN_VALUE; // max value\\n        for (int i = 0; i < nums.size(); i++) {\\n\\t\\t// create min heap from first element of every list\\n\\t\\t// also find max element from those elements\\n            int val = nums.get(i).get(0);\\n            if (val > max) {\\n                max = val;\\n            }\\n            pq.offer(new int[]{val, i, 0});\\n        }\\n        // maintain min range\\n        int minrange = Integer.MAX_VALUE;\\n        while (pq.size() == nums.size()) {\\n\\t\\t// get min value from heap\\n            int[] t = pq.poll();\\n            int row = t[1];\\n            int col = t[2];\\n\\t\\t\\t// compare with minrange\\n            if (max - t[0] < minrange) {\\n\\t\\t\\t// if min range found then update result array\\n                minrange = max - t[0];\\n                res[0] = t[0];\\n                res[1] = max;\\n            }\\n            if (col + 1 < nums.get(row).size()) { // now check other elements of current list\\n\\t\\t\\t// i.e. same row but next column and add to heap\\n                pq.offer(new int[] {nums.get(row).get(col+1), row, col+1});\\n\\t\\t\\t\\t// also update max value \\n                if (max < nums.get(row).get(col+1)) {\\n                    max = nums.get(row).get(col+1);\\n                }\\n            }\\n            \\n        }\\n\\t\\t// return result array\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1581638,
                "title": "c-sliding-window-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int n = nums.size(), sz = 0, t = 0;\\n        for(int i = 0; i < n; ++i)\\n            sz += nums[i].size();\\n        \\n\\t\\t// creating the flattened array with jagged array\\n        vector<pair<int, int>> a(sz);\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < nums[i].size(); ++j) {\\n                a[t].first = nums[i][j];\\n                a[t].second = i;\\n                t++;\\n            }\\n        }        \\n        sort(a.begin(), a.end());\\n        \\n        vector<int> vis(n, 0);\\n        int i = 0, j = 0, ri = INT_MAX, rj = 1, cnt = 0;\\n        \\n\\t\\t// sliding window for smallest set of fulfilling set\\n        while(i < a.size() && j < a.size()) {\\n            if(!vis[a[i].second])\\n                cnt++;\\n            vis[a[i].second]++;\\n            \\n\\t\\t\\t// set containing all elements\\n            if(cnt >= n) {\\n\\t\\t\\t// contracting the set\\n                while(j < a.size() && cnt >= n) {\\n                    if(ri - rj > a[i].first - a[j].first) {\\n                        ri = a[i].first;\\n                        rj = a[j].first;\\n                    }\\n                    \\n                    vis[a[j].second]--;\\n                    if(!vis[a[j].second])\\n                        cnt--;\\n                    j++;\\n                } \\n            }\\n            i++;\\n        }\\n        \\n        return vector<int>({rj, ri});\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int n = nums.size(), sz = 0, t = 0;\\n        for(int i = 0; i < n; ++i)\\n            sz += nums[i].size();\\n        \\n\\t\\t// creating the flattened array with jagged array\\n        vector<pair<int, int>> a(sz);\\n        for(int i = 0; i < n; ++i) {\\n            for(int j = 0; j < nums[i].size(); ++j) {\\n                a[t].first = nums[i][j];\\n                a[t].second = i;\\n                t++;\\n            }\\n        }        \\n        sort(a.begin(), a.end());\\n        \\n        vector<int> vis(n, 0);\\n        int i = 0, j = 0, ri = INT_MAX, rj = 1, cnt = 0;\\n        \\n\\t\\t// sliding window for smallest set of fulfilling set\\n        while(i < a.size() && j < a.size()) {\\n            if(!vis[a[i].second])\\n                cnt++;\\n            vis[a[i].second]++;\\n            \\n\\t\\t\\t// set containing all elements\\n            if(cnt >= n) {\\n\\t\\t\\t// contracting the set\\n                while(j < a.size() && cnt >= n) {\\n                    if(ri - rj > a[i].first - a[j].first) {\\n                        ri = a[i].first;\\n                        rj = a[j].first;\\n                    }\\n                    \\n                    vis[a[j].second]--;\\n                    if(!vis[a[j].second])\\n                        cnt--;\\n                    j++;\\n                } \\n            }\\n            i++;\\n        }\\n        \\n        return vector<int>({rj, ri});\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1546784,
                "title": "python3-concise-heap-solution",
                "content": "The key here is to notice that both the left bound and the right bound should be some element in `nums`. Therefore, we can flatten `nums` and sort it in reverse order (we name it `rightCandidate`) and then check every element in `rightCandidate` to see whether it\\'s a proper right bound.\\n\\nHow do we check whether it\\'s a proper right bound? The first thing we need to do is to find its corresponding left bound. For each list in `nums`, we can populate all the elements that are greater than the current right bound (because those elements cannot be the left bound), and after doing so, all the lists in `nums` only contain elements smaller than or equal to the current right bound, and then we can simply take minimum of the last element of each list as the left bound because each list is in non-decreasing order and it\\'s clear that this approach will make sure every list has at least one element in the selected `[left_bound, right_bound]`.\\n\\nFinally, we go through all potential right bounds, find their corresponding left bounds, and find the one with the smallest range (notice that the question has a strict definition of \"smallest\").\\n\\nTime complexity will be O(M * N), which is basically O(len(nums) * len(nums[0])).\\nSpace complexity will be O(M * N) as well since the flattened array `rightCandidate` is the only extra space we use.\\n\\nCredit to @lee215 and @awice for providing such a beautiful solution. I just re-write it in Python3.\\n\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        rightCandidate = sorted(set(x for l in nums for x in l))[::-1]\\n        ans = [float(\\'-inf\\'), float(\\'inf\\')]\\n        for right in rightCandidate:\\n            for num in nums:\\n                while num and right < num[-1]:\\n                    num.pop()\\n                if not num:\\n                    return ans\\n            left = min([num[-1] for num in nums])\\n            if right - left <= ans[1] - ans[0]:\\n                ans = [left, right]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        rightCandidate = sorted(set(x for l in nums for x in l))[::-1]\\n        ans = [float(\\'-inf\\'), float(\\'inf\\')]\\n        for right in rightCandidate:\\n            for num in nums:\\n                while num and right < num[-1]:\\n                    num.pop()\\n                if not num:\\n                    return ans\\n            left = min([num[-1] for num in nums])\\n            if right - left <= ans[1] - ans[0]:\\n                ans = [left, right]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536326,
                "title": "most-readable-with-explanation-c-solution-priority-queue",
                "content": "EXAMPLE:\\n[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\n\\nmake min heap of {int,{int,int}}  for storing min element at top and row and column number \\npush all the first element of k array in pq\\nmake max variable that contain max from the pq \\nin above case 5 will be max and top of priority queue contain 0\\nstep 0. find min range by subtracting max and top of stack \\nsteps 1. take the top of pq pop it and push the next element from the same array\\nstep 2. update your max \\n do above step till our one of the list get exhausted\\n\\n```\\n vector<int> smallestRange(vector<vector<int>>& nums) {\\n       \\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i][0],{i,0}});\\n            mx=max(mx,nums[i][0]);\\n        }\\n       int min_range=INT_MAX;\\n        vector<int>v;\\n        while(pq.size()==nums.size()){\\n       \\n            if(mx-pq.top().first<min_range){\\n                min_range=mx-pq.top().first;\\n                v.clear();\\n                v.push_back(pq.top().first);\\n                v.push_back(mx);\\n            }\\n          \\n            pair<int,int>p=pq.top().second;\\n            int i=p.first;\\n            int j=p.second;\\n            pq.pop();\\n            if(j!=nums[i].size()-1){\\n            pq.push({nums[i][j+1],{i,j+1}});\\n            mx=max(mx,nums[i][j+1]); \\n            }\\n        }\\n        return v;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n vector<int> smallestRange(vector<vector<int>>& nums) {\\n       \\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        int mx=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n            pq.push({nums[i][0],{i,0}});\\n            mx=max(mx,nums[i][0]);\\n        }\\n       int min_range=INT_MAX;\\n        vector<int>v;\\n        while(pq.size()==nums.size()){\\n       \\n            if(mx-pq.top().first<min_range){\\n                min_range=mx-pq.top().first;\\n                v.clear();\\n                v.push_back(pq.top().first);\\n                v.push_back(mx);\\n            }\\n          \\n            pair<int,int>p=pq.top().second;\\n            int i=p.first;\\n            int j=p.second;\\n            pq.pop();\\n            if(j!=nums[i].size()-1){\\n            pq.push({nums[i][j+1],{i,j+1}});\\n            mx=max(mx,nums[i][j+1]); \\n            }\\n        }\\n        return v;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495460,
                "title": "python-solution-faster-than-88-58-of-python-submissions",
                "content": "**Runtime: 220 ms, faster than 88.58% of Python3 online submissions for Smallest Range Covering Elements from K Lists.\\nMemory Usage: 20.4 MB, less than 91.91% of Python3 online submissions for Smallest Range Covering Elements from K Lists.**\\n\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        k=len(nums)\\n        maxx=-float(\\'inf\\')\\n        ans=[0,float(\\'inf\\')]\\n        heap=[]\\n        for i in range(k):\\n            heap.append((nums[i][0],i,0))\\n            if nums[i][0]>maxx:maxx=nums[i][0]\\n        heapq.heapify(heap)\\n        while True:\\n            val,row,col= heapq.heappop(heap)\\n            tmp=maxx-val\\n            if tmp<ans[1]-ans[0]:ans=[val,maxx]\\n            elif tmp==ans[1]-ans[0] and val<ans[0]:ans=[val,maxx]\\n            if col+1==len(nums[row]):break        \\n            if nums[row][col+1]>maxx:maxx=nums[row][col+1]\\n            heapq.heappush(heap,(nums[row][col+1],row,col+1))\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        k=len(nums)\\n        maxx=-float(\\'inf\\')\\n        ans=[0,float(\\'inf\\')]\\n        heap=[]\\n        for i in range(k):\\n            heap.append((nums[i][0],i,0))\\n            if nums[i][0]>maxx:maxx=nums[i][0]\\n        heapq.heapify(heap)\\n        while True:\\n            val,row,col= heapq.heappop(heap)\\n            tmp=maxx-val\\n            if tmp<ans[1]-ans[0]:ans=[val,maxx]\\n            elif tmp==ans[1]-ans[0] and val<ans[0]:ans=[val,maxx]\\n            if col+1==len(nums[row]):break        \\n            if nums[row][col+1]>maxx:maxx=nums[row][col+1]\\n            heapq.heappush(heap,(nums[row][col+1],row,col+1))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1448119,
                "title": "c-sliding-window-99-runtime-problem-breakdown-to-similar-one-clean-commented-code",
                "content": "This problem can be broken down into two steps:\\n1. create a single sorted vector containing numbers from all list with list_IDs.\\n2. Now this problem is reduced to -> find minimum window containing all listIDs - similar to minimum window substring (Leetcode 76)\\n\\n```\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int k = nums.size();            // --> k is total number of lists\\n        \\n        /* ---------------------------------- Part 1 ------------------------------------ \\n         \\n        create a single sorted vector containing numbers from all list  */\\n        \\n        vector<pair<int,int>> v;        // --> vector of pair {num, listID}\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            \\n            for(int num : nums[i])\\n                v.push_back({num, i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        /* ---------------------------------- Part 2 -------------------------------------\\n        \\n        find minimum window containing all listIDs  */\\n        \\n        int i=0, j=0;\\n        vector<int> freq (k, 0);\\n        \\n        int cnt = 0;\\n        int minRange = INT_MAX;\\n        vector<int> ans;\\n        \\n        while(j<v.size()){\\n            int id = v[j].second;\\n            \\n            freq[id]++;\\n            if(freq[id]==1) cnt++;\\n            \\n            while(cnt==k){\\n                \\n                if(v[j].first - v[i].first < minRange){\\n                    minRange = v[j].first - v[i].first;\\n                    ans = {v[i].first, v[j].first};\\n                }\\n                \\n                int idi = v[i].second;\\n                \\n                freq[idi]--;\\n                if(freq[idi]==0) cnt--;\\n                \\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int k = nums.size();            // --> k is total number of lists\\n        \\n        /* ---------------------------------- Part 1 ------------------------------------ \\n         \\n        create a single sorted vector containing numbers from all list  */\\n        \\n        vector<pair<int,int>> v;        // --> vector of pair {num, listID}\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            \\n            for(int num : nums[i])\\n                v.push_back({num, i});\\n        }\\n        \\n        sort(v.begin(), v.end());\\n        \\n        /* ---------------------------------- Part 2 -------------------------------------\\n        \\n        find minimum window containing all listIDs  */\\n        \\n        int i=0, j=0;\\n        vector<int> freq (k, 0);\\n        \\n        int cnt = 0;\\n        int minRange = INT_MAX;\\n        vector<int> ans;\\n        \\n        while(j<v.size()){\\n            int id = v[j].second;\\n            \\n            freq[id]++;\\n            if(freq[id]==1) cnt++;\\n            \\n            while(cnt==k){\\n                \\n                if(v[j].first - v[i].first < minRange){\\n                    minRange = v[j].first - v[i].first;\\n                    ans = {v[i].first, v[j].first};\\n                }\\n                \\n                int idi = v[i].second;\\n                \\n                freq[idi]--;\\n                if(freq[idi]==0) cnt--;\\n                \\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1411513,
                "title": "c-using-priority-queue-well-commented-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<int,int> pp;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        priority_queue<pp,vector<pp>,greater<pp>> pq;    //min Heap  \\n                                                        //first->element //second->index of the array\\n        \\n        \\n        vector<int> pointers(n,0);//pointers to keep track of the indices\\n        vector<int> ans(2);       //we are currently at\\n         \\n        int minimum = INT_MAX;\\n        int maximum = INT_MIN;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            minimum = min(minimum,nums[i][0]);  //minimum of all the arrays\\n            maximum = max(maximum,nums[i][0]);  //maximum of all the arrays\\n            \\n            pq.push({nums[i][0],i});\\n        }\\n        \\n        ans[0]=minimum;  //initial range\\n        ans[1]=maximum;\\n        \\n        \\n        while(pq.size()==n){\\n            \\n            int curr = pq.top().second;   //pop the index of the array which has minimum\\n            pq.pop();\\n            pointers[curr]++;            // update the pointer \\n            \\n            if(pointers[curr]>=nums[curr].size()){//if the pointer points out of the array break\\n                break;\\n            }\\n            \\n            int next = nums[curr][pointers[curr]]; //next element from the array with minimum\\n            \\n            pq.push({next,curr});                //push the element into the pq\\n            \\n            minimum = pq.top().first;            //get the minimum\\n            maximum = max(maximum,next);         //compute maximum\\n            \\n        \\n            if(maximum-minimum < ans[1]-ans[0]){    //check if the range is smaller\\n                ans = {minimum,maximum};\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    typedef pair<int,int> pp;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        int n=nums.size();\\n        \\n        priority_queue<pp,vector<pp>,greater<pp>> pq;    //min Heap  \\n                                                        //first->element //second->index of the array\\n        \\n        \\n        vector<int> pointers(n,0);//pointers to keep track of the indices\\n        vector<int> ans(2);       //we are currently at\\n         \\n        int minimum = INT_MAX;\\n        int maximum = INT_MIN;\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            minimum = min(minimum,nums[i][0]);  //minimum of all the arrays\\n            maximum = max(maximum,nums[i][0]);  //maximum of all the arrays\\n            \\n            pq.push({nums[i][0],i});\\n        }\\n        \\n        ans[0]=minimum;  //initial range\\n        ans[1]=maximum;\\n        \\n        \\n        while(pq.size()==n){\\n            \\n            int curr = pq.top().second;   //pop the index of the array which has minimum\\n            pq.pop();\\n            pointers[curr]++;            // update the pointer \\n            \\n            if(pointers[curr]>=nums[curr].size()){//if the pointer points out of the array break\\n                break;\\n            }\\n            \\n            int next = nums[curr][pointers[curr]]; //next element from the array with minimum\\n            \\n            pq.push({next,curr});                //push the element into the pq\\n            \\n            minimum = pq.top().first;            //get the minimum\\n            maximum = max(maximum,next);         //compute maximum\\n            \\n        \\n            if(maximum-minimum < ans[1]-ans[0]){    //check if the range is smaller\\n                ans = {minimum,maximum};\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407345,
                "title": "javascript-solution-using-heap",
                "content": "my solution using heap, the heap implementation is not the best just to do the solution.\\n\\n```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar smallestRange = function(nums) {\\n    let minHeap = new Heap();\\n    let rangeStart = 0;\\n    let rangeEnd = Infinity;\\n    let maxNumber = -Infinity;\\n\\t\\n    // put first number the smallest numbert of each list to the heap\\n    for (let num of nums) {\\n        minHeap.push([num[0], 0, num]);\\n        maxNumber = Math.max(maxNumber, num[0]);\\n    }\\n\\t\\n    // go through all numbers find the smallest range and update start and end\\n    while (minHeap.size() == nums.length) {\\n        let [num, i, list] = minHeap.pop();\\n        \\n        if (rangeEnd - rangeStart > maxNumber - num) {\\n            rangeStart = num;\\n            rangeEnd = maxNumber;\\n        }\\n        \\n        if (list.length > i + 1) {\\n            minHeap.push([list[i + 1], i + 1, list]);\\n            maxNumber = Math.max(maxNumber, list[i + 1]);\\n        }\\n    }\\n    \\n    return [rangeStart, rangeEnd];\\n};\\n\\n\\n\\nclass Heap {\\n    constructor() {\\n        this.arr = [];\\n    }\\n    \\n    size() {\\n        return this.arr.length;\\n    }\\n    \\n    push(val) {\\n        this.arr.push(val)\\n        this.arr.sort((a, b) => a[0] - b[0]);\\n    }\\n    \\n    pop() {\\n        return this.arr.shift();\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} nums\\n * @return {number[]}\\n */\\nvar smallestRange = function(nums) {\\n    let minHeap = new Heap();\\n    let rangeStart = 0;\\n    let rangeEnd = Infinity;\\n    let maxNumber = -Infinity;\\n\\t\\n    // put first number the smallest numbert of each list to the heap\\n    for (let num of nums) {\\n        minHeap.push([num[0], 0, num]);\\n        maxNumber = Math.max(maxNumber, num[0]);\\n    }\\n\\t\\n    // go through all numbers find the smallest range and update start and end\\n    while (minHeap.size() == nums.length) {\\n        let [num, i, list] = minHeap.pop();\\n        \\n        if (rangeEnd - rangeStart > maxNumber - num) {\\n            rangeStart = num;\\n            rangeEnd = maxNumber;\\n        }\\n        \\n        if (list.length > i + 1) {\\n            minHeap.push([list[i + 1], i + 1, list]);\\n            maxNumber = Math.max(maxNumber, list[i + 1]);\\n        }\\n    }\\n    \\n    return [rangeStart, rangeEnd];\\n};\\n\\n\\n\\nclass Heap {\\n    constructor() {\\n        this.arr = [];\\n    }\\n    \\n    size() {\\n        return this.arr.length;\\n    }\\n    \\n    push(val) {\\n        this.arr.push(val)\\n        this.arr.sort((a, b) => a[0] - b[0]);\\n    }\\n    \\n    pop() {\\n        return this.arr.shift();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1365620,
                "title": "python3-min-heap-with-proof-that-greedy-works",
                "content": "The following Python 3 solution is nothing but an implementation of the official solution. However, what\\'s missing is the proof that the range found by this greedy algo is optimal.\\n\\n**Observation**: Notice that, given any `m = nums[i][j]`, we can find `M` such that `[m, M]` is a covering range as follows: for each `i\\' != i`, find `j\\'` such that `nums[i\\'][j\\'-1] < m <= nums[i\\'][j\\']`, namely `nums[i\\'][j\\']` is the *smallest* element in the list `nums[i\\']` that is at least `m`. Then `M` is the largest value among these smallest elements. Of course, for an arbitrary choice of `m`, `M` may not exist if such `j\\'` can not be found for any list `nums[i\\']`.\\n\\nNow the proof.\\n\\nFIrst of all, at any iteration in the iterative search, let `m = nums[i][j]` be the smallest element that is currently being *reached*.  We show that, for any other list `nums[i\\']`, the reached element `nums[i\\'][j\\']` must be exactly the smallest element in `nums[i\\']` that is at least `m`. Proof by contradiction. Suppose there exists reached element `nums[i\\'][j\\']` such that `m < nums[i\\'][j\\'-1]`. Since the currently reached element in the list `nums[i\\']` is `nums[i\\'][j\\']`, `nums[i\\'][j\\'-1]` exited at some previous iteration. Note that an elment exits only when it was the minimum among all reached elements at that iteration. However, since `m < nums[i\\'][j\\'-1]`, `nums[i][j]` or some previous element in the list `nums[i]` was strictly smaller than `nums[i\\'][j\\'-1]` when it exited, a contradiction.\\n\\nThe proof is not complete yet. The previous statement only proves that at any iteration the range `[m, M]` is optimal if the lower limit `m` is fixed. Suppose the global optimal range is [m*, M*]. It\\'s sufficient to show that `m*` appeared at some iteration as the mimimum among all reached. Let `m* = nums[i*][j*]`.\\n1. **`m*` must have been reached when the search terminates**. Let `nums[i*][j]` be the reached element when the search terminates. Then `nums[i*][j]` must be greater than or equal to ALL the elements in the exghausted list. On the other hand, since some element in the exghausted list is covered by the range `[m*, M*]`, we must have `m* <= nums[i*][j]`, namely `m*` was previously reached in the list `nums[i*]`.\\n2. **`m*` must have been the miminum at some iteration**. Since `m*` was reached, if it\\'s never been the minimum, then it never had the chance to exist, and hence has stayed that way throughout the search. Then at the termination all elments in the exghausted list must be at most `m*`. Unless the last element in the exghausted list is equal to `m*`, none of its elements would be covered by the range `[m*, M*]`, a contradiction.\\n\\nCombining the Observation, (1) and (2) completes the proof.\\n\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        minh = [[nums[lidx][0], 0, lidx] for lidx in range(n)]\\n        heapq.heapify(minh)\\n        max_num = max([l[0] for l in nums])\\n        min_range = [minh[0][0], max_num]\\n        min_dist = min_range[1] - min_range[0]\\n        while True:\\n            min_num, min_idx, min_lidx = heapq.heappop(minh)\\n            min_idx += 1\\n            if min_idx == len(nums[min_lidx]):\\n                break\\n            min_num = nums[min_lidx][min_idx]\\n            heapq.heappush(minh, [min_num, min_idx, min_lidx])\\n            \\n            max_num = max(min_num, max_num)\\n            min_num = minh[0][0]\\n            dist = max_num - min_num\\n            if dist < min_dist:\\n                min_range = [min_num, max_num]\\n                min_dist = dist\\n            \\n        return min_range\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        n = len(nums)\\n        minh = [[nums[lidx][0], 0, lidx] for lidx in range(n)]\\n        heapq.heapify(minh)\\n        max_num = max([l[0] for l in nums])\\n        min_range = [minh[0][0], max_num]\\n        min_dist = min_range[1] - min_range[0]\\n        while True:\\n            min_num, min_idx, min_lidx = heapq.heappop(minh)\\n            min_idx += 1\\n            if min_idx == len(nums[min_lidx]):\\n                break\\n            min_num = nums[min_lidx][min_idx]\\n            heapq.heappush(minh, [min_num, min_idx, min_lidx])\\n            \\n            max_num = max(min_num, max_num)\\n            min_num = minh[0][0]\\n            dist = max_num - min_num\\n            if dist < min_dist:\\n                min_range = [min_num, max_num]\\n                min_dist = dist\\n            \\n        return min_range\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1364392,
                "title": "c-simple-with-explanation-using-sets-thinking-process-interview-friendly",
                "content": "With this post I want to explain the thinking process from approaching the solution while also providing a **SIMPLE code** using sets which I do not see in top upvoted answers for C++.\\n\\n**Intuition**\\n\\nInstead of k lists, let us think about 2 lists. The smallest range covering elements from 2 lists would be covered two elements, one from the first and the other from the second. These would be two values closest in absolute value when picking one from each list. \\n\\n**Initialization**: Since the lists are sorted in non-decreasing order, the end of the range can only increase with increase in element indices. So, if we use a min-heap and store the first element of both lists, the top element would be the range start candidate and the second/last element would be the range end candidate. \\n\\n**Iteration**: We now check if the pair currently being considered make up the minimum range and store the start and end values accordingly. Now, for the next candidate, we do not want to increase the end of the range without considering other starting candidates greater than the one in the first iteration. Hence, we extract the top element, and choose the next element from the list that the top element belonged to, and push it into the min-heap. \\n\\n**Termination**: We keep doing this till the top element is the last element of its array, since at that point, regardless of how many elements are left in the second array, they will only increase the range (since, these elements are all greater than the present top and hence will replace the end of range value, and due to both lists being sorted in non-decreasing order these will be >= the current end of range value)\\n\\nWe can extend this to K lists. The difference is that during initialization the first element of all K lists are inserted into the min-heap. The iteration happens in exactly the same way, only the largest and the smallest element in the min-heap decide the range and the rest are relevant only when the next element of the list of the top element exceeds some existing element. The termination condition is also the same because of the same reason, that no more candidates can be inserted for a smaller range.\\n\\n**Code**\\n\\nIn C++, **set** can be used to easily access both the beginning and end of a collection of sorted values using **begin** and **rbegin** respectively. To store the relevant list along with its index we can use **pair**. Note that we need the set to be sorted by the actual values, hence we can use a nested pair to store the 3 quantities: value, list to which value belongs, index at which value is present in the list. **By default**, set in C++ sorts by the first element of the pair. Using these observations an interview friendly code that flows from the above discussion is as follows:\\n\\n```\\n      vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        if(nums.size() == 1)\\n        {\\n            return {nums[0][0],nums[0][0]};\\n        }\\n        \\n        set<pair<int,pair<int,int>>> range;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            range.insert(make_pair(nums[i][0],make_pair(i,0)));\\n        }\\n        \\n        int min_range = INT_MAX;\\n        int start = -1;\\n        int end = -1;\\n        \\n        int list = 0;\\n        int list_index = 0; \\n\\t\\t\\n\\t\\t// we are guaranteed that each list has size at least 1 \\n\\t\\t// so we will enter the while loop below at least once\\n\\t\\t\\n        while(list_index != nums[list].size())\\n        {\\n            auto s = *range.begin();\\n            auto e = *range.rbegin();\\n            \\n            if(e.first - s.first < min_range)\\n            {\\n                min_range = e.first - s.first;\\n                start = s.first;\\n                end = e.first;\\n            }\\n            \\n            list = s.second.first;\\n            list_index = s.second.second;\\n\\n            range.erase(range.begin());\\n            \\n            list_index++;\\n            \\n            if(list_index < nums[list].size())\\n            range.insert(make_pair(nums[list][list_index], make_pair(list, list_index)));\\n        }\\n        \\n        return {start,end};\\n        \\n    }\\n```\\n\\n**Time and Space Complexity**\\n\\nFor K lists, we always have a set with K elements, hence O(K) space is used. Inserting into a list with K elements is O(logK) and we will insert upto n elements where n is the number of elements in ALL of the lists, hence the time complexity is O(nlogK) where n and K are as defined above.",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Ordered Set"
                ],
                "code": "```\\n      vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        if(nums.size() == 1)\\n        {\\n            return {nums[0][0],nums[0][0]};\\n        }\\n        \\n        set<pair<int,pair<int,int>>> range;\\n        \\n        for(int i = 0; i<nums.size(); i++)\\n        {\\n            range.insert(make_pair(nums[i][0],make_pair(i,0)));\\n        }\\n        \\n        int min_range = INT_MAX;\\n        int start = -1;\\n        int end = -1;\\n        \\n        int list = 0;\\n        int list_index = 0; \\n\\t\\t\\n\\t\\t// we are guaranteed that each list has size at least 1 \\n\\t\\t// so we will enter the while loop below at least once\\n\\t\\t\\n        while(list_index != nums[list].size())\\n        {\\n            auto s = *range.begin();\\n            auto e = *range.rbegin();\\n            \\n            if(e.first - s.first < min_range)\\n            {\\n                min_range = e.first - s.first;\\n                start = s.first;\\n                end = e.first;\\n            }\\n            \\n            list = s.second.first;\\n            list_index = s.second.second;\\n\\n            range.erase(range.begin());\\n            \\n            list_index++;\\n            \\n            if(list_index < nums[list].size())\\n            range.insert(make_pair(nums[list][list_index], make_pair(list, list_index)));\\n        }\\n        \\n        return {start,end};\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1327116,
                "title": "java-my-simple-and-clear-java-solution-with-precise-explanation",
                "content": "So basically we were trying to convert the whole nums lists to merge into one list (I\\'ll explain it further) which contains all values of all nums lists in it\\'s 0th index and the list id\\'s (0, 1, 2, 3,....) in it\\'s second index.\\nThe idea to convert this list into one list is simple that we want a **smallest range** that will contains atleast one element of each list of nums so we will keep track of sum of all elements that we were currently have in our merge list of different lists of nums, once we got a range that will contains all the elements we try to minimize the answer(range) as much as possible so that to get the minimum range of all the ranges that have all the elements of nums lists.\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<int[]> li = new ArrayList<>();\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int x : nums.get(i)){\\n                li.add(new int[]{x, i});\\n            }\\n        }\\n        \\n        Collections.sort(li, (a, b) -> a[0] - b[0]);\\n        int k = nums.size(), sum = 0, range = Integer.MAX_VALUE;\\n        int x = -1, y = -1;\\n        int[] cnt = new int[k];\\n        int j = 0;\\n        for(int i = 0; i < li.size(); i++){\\n            sum += cnt[li.get(i)[1]]++ == 0 ? 1 : 0;\\n            while(sum == k){\\n                if(li.get(i)[0] - li.get(j)[0] < range){\\n                    range = li.get(i)[0] - li.get(j)[0];\\n                    x = li.get(j)[0];\\n                    y = li.get(i)[0];\\n                }\\n                \\n                sum -= cnt[li.get(j)[1]]-- == 1 ? 1 : 0;\\n                j++;\\n            }\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```\\nPlease upvote if you like my solution",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<int[]> li = new ArrayList<>();\\n        for(int i = 0; i < nums.size(); i++){\\n            for(int x : nums.get(i)){\\n                li.add(new int[]{x, i});\\n            }\\n        }\\n        \\n        Collections.sort(li, (a, b) -> a[0] - b[0]);\\n        int k = nums.size(), sum = 0, range = Integer.MAX_VALUE;\\n        int x = -1, y = -1;\\n        int[] cnt = new int[k];\\n        int j = 0;\\n        for(int i = 0; i < li.size(); i++){\\n            sum += cnt[li.get(i)[1]]++ == 0 ? 1 : 0;\\n            while(sum == k){\\n                if(li.get(i)[0] - li.get(j)[0] < range){\\n                    range = li.get(i)[0] - li.get(j)[0];\\n                    x = li.get(j)[0];\\n                    y = li.get(i)[0];\\n                }\\n                \\n                sum -= cnt[li.get(j)[1]]-- == 1 ? 1 : 0;\\n                j++;\\n            }\\n        }\\n        return new int[]{x, y};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1264185,
                "title": "c-632-smallest-range-covering-elements-from-k-lists",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        struct Compare {\\n            bool operator() (array<int,3>&lhs, array<int,3>&rhs) { return lhs[0] > rhs[0]; }\\n        };\\n        \\n        priority_queue<array<int,3>, vector<array<int,3>>, Compare> pq; \\n        int mx = INT_MIN, lo = -100\\'000, hi = 100\\'000; \\n        for (int i = 0; i < size(nums); ++i) {\\n            pq.push({nums[i][0], i, 0}); \\n            mx = max(mx, nums[i][0]); \\n        }\\n        \\n        while (size(pq)) {\\n            if (mx - pq.top()[0] < hi - lo) {\\n                lo = pq.top()[0]; \\n                hi = mx; \\n            }\\n            auto elem = pq.top(); pq.pop(); \\n            int i = elem[1], j = elem[2]; \\n            if (j+1 == size(nums[i])) break;\\n            mx = max(mx, nums[i][j+1]); \\n            pq.push({nums[i][j+1], i, j+1}); \\n        }\\n        return {lo, hi}; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        struct Compare {\\n            bool operator() (array<int,3>&lhs, array<int,3>&rhs) { return lhs[0] > rhs[0]; }\\n        };\\n        \\n        priority_queue<array<int,3>, vector<array<int,3>>, Compare> pq; \\n        int mx = INT_MIN, lo = -100\\'000, hi = 100\\'000; \\n        for (int i = 0; i < size(nums); ++i) {\\n            pq.push({nums[i][0], i, 0}); \\n            mx = max(mx, nums[i][0]); \\n        }\\n        \\n        while (size(pq)) {\\n            if (mx - pq.top()[0] < hi - lo) {\\n                lo = pq.top()[0]; \\n                hi = mx; \\n            }\\n            auto elem = pq.top(); pq.pop(); \\n            int i = elem[1], j = elem[2]; \\n            if (j+1 == size(nums[i])) break;\\n            mx = max(mx, nums[i][j+1]); \\n            pq.push({nums[i][j+1], i, j+1}); \\n        }\\n        return {lo, hi}; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248452,
                "title": "c-using-map-faster-than-99-simple-traversing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        map<int,vector<int>> mp;\\n        \\n        int n=nums.size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<nums[i].size();++j){\\n                mp[nums[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        vector<int> count(n,0);\\n        vector<int> res(2,0);\\n        int len=INT_MAX;\\n        auto j=mp.begin();\\n        \\n        for(auto i=mp.begin();i!=mp.end();++i){\\n            for(auto it: i->second)\\n                ++count[it];\\n            while(find(count.begin(),count.end(),0)==count.end()){\\n                if(len>(i->first-j->first)){\\n                    len=i->first-j->first;\\n                    res[0]=j->first;\\n                    res[1]=i->first;\\n                }\\n                \\n                for(auto it: j->second)\\n                    --count[it];\\n                ++j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        map<int,vector<int>> mp;\\n        \\n        int n=nums.size();\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<nums[i].size();++j){\\n                mp[nums[i][j]].push_back(i);\\n            }\\n        }\\n        \\n        vector<int> count(n,0);\\n        vector<int> res(2,0);\\n        int len=INT_MAX;\\n        auto j=mp.begin();\\n        \\n        for(auto i=mp.begin();i!=mp.end();++i){\\n            for(auto it: i->second)\\n                ++count[it];\\n            while(find(count.begin(),count.end(),0)==count.end()){\\n                if(len>(i->first-j->first)){\\n                    len=i->first-j->first;\\n                    res[0]=j->first;\\n                    res[1]=i->first;\\n                }\\n                \\n                for(auto it: j->second)\\n                    --count[it];\\n                ++j;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233754,
                "title": "c-using-minheap-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/42f99469-5a5a-4932-8206-0d3b03f2d7fb_1622104340.391621.jpeg)\\n\\nclass Solution {\\npublic:\\n\\n    #define ppi pair< int, pair<int,int> > \\n \\n    vector<int> smallestRange(vector<vector<int>>& arr) {\\n      \\n    \\n      int k = arr.size();\\n      priority_queue<ppi,vector<ppi>,greater<ppi>>h;\\n      int range = INT_MAX;\\n      int mn = INT_MAX, mx = INT_MIN;\\n      int s, e;\\n      \\n      for(int i=0;i<k;i++)\\n      {\\n          h.push({ arr[i][0] ,{i,0} }); // { val, row_num, ele_idx}\\n          \\n          mx = max(mx,arr[i][0]);\\n      }\\n      \\n   \\n      while(1)\\n      {\\n          ppi cur = h.top();\\n          mn = cur.first;\\n          if(range > (mx - mn) )\\n          {\\n              range = mx - mn;\\n              s = mn;\\n              e = mx;\\n          }\\n          h.pop();\\n          \\n          int list_no  = cur.second.first;\\n          int idx      = cur.second.second;\\n          \\n          int size = arr[list_no].size();\\n          \\n          if(idx < size - 1)\\n          {\\n            int val = arr[list_no][idx+1];\\n            h.push({ val, {list_no, idx+1} });\\n            \\n            if(val > mx)\\n                mx = val;\\n          }\\n          else\\n            break;\\n          \\n      }\\n      return {s,e}; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    #define ppi pair< int, pair<int,int> > \\n \\n    vector<int> smallestRange(vector<vector<int>>& arr) {\\n      \\n    \\n      int k = arr.size();\\n      priority_queue<ppi,vector<ppi>,greater<ppi>>h;\\n      int range = INT_MAX;\\n      int mn = INT_MAX, mx = INT_MIN;\\n      int s, e;\\n      \\n      for(int i=0;i<k;i++)\\n      {\\n          h.push({ arr[i][0] ,{i,0}",
                "codeTag": "Java"
            },
            {
                "id": 1149560,
                "title": "kotlin-solution-beat-87",
                "content": "```\\nfun smallestRange(nums: List<List<Int>>): IntArray {\\n         val size = nums.size\\n        if (size == 1) return intArrayOf(nums[0][0], nums[0][0])\\n        val nextIndex = IntArray(size) { 0 }\\n        val queue =\\n            PriorityQueue<Pair<Int, Int>>(kotlin.Comparator { o1, o2 -> o1.first.compareTo(o2.first) })\\n        var max = Int.MIN_VALUE\\n        nums.forEachIndexed { index, list ->\\n            queue.offer(list[0] to index)\\n            max = max(max, list[0])\\n        }\\n        var (min, minIndex) = queue.poll()\\n        var result = intArrayOf(min, max)\\n        nextIndex[minIndex]++\\n\\n        while (nextIndex[minIndex] < nums[minIndex].size) {\\n            val nextNum = nums[minIndex][nextIndex[minIndex]]\\n            queue.offer(nextNum to minIndex)\\n            val (m, i) = queue.poll()\\n            min = m\\n            minIndex = i\\n            max = max(max, nextNum)\\n            if (max - min < result[1] - result[0] || min < result[0]) {\\n                result = intArrayOf(min, max)\\n            }\\n            nextIndex[minIndex]++\\n        }\\n        return result\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfun smallestRange(nums: List<List<Int>>): IntArray {\\n         val size = nums.size\\n        if (size == 1) return intArrayOf(nums[0][0], nums[0][0])\\n        val nextIndex = IntArray(size) { 0 }\\n        val queue =\\n            PriorityQueue<Pair<Int, Int>>(kotlin.Comparator { o1, o2 -> o1.first.compareTo(o2.first) })\\n        var max = Int.MIN_VALUE\\n        nums.forEachIndexed { index, list ->\\n            queue.offer(list[0] to index)\\n            max = max(max, list[0])\\n        }\\n        var (min, minIndex) = queue.poll()\\n        var result = intArrayOf(min, max)\\n        nextIndex[minIndex]++\\n\\n        while (nextIndex[minIndex] < nums[minIndex].size) {\\n            val nextNum = nums[minIndex][nextIndex[minIndex]]\\n            queue.offer(nextNum to minIndex)\\n            val (m, i) = queue.poll()\\n            min = m\\n            minIndex = i\\n            max = max(max, nextNum)\\n            if (max - min < result[1] - result[0] || min < result[0]) {\\n                result = intArrayOf(min, max)\\n            }\\n            nextIndex[minIndex]++\\n        }\\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1126457,
                "title": "python-from-two-pointer-to-priority-queue-explained",
                "content": "```\\n# every time we just try to move the left pointer, as we know that if we move it, it might gave us a smaller range. this is the only way to move.\\nclass Solution:\\n    # two pointers, time o(m*n) space o(m)\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        m = len(nums)\\n        nxt = [0]*m\\n        left, right = float(\\'-inf\\'), float(\\'inf\\')\\n        maxlen = max([len(num) for num in nums])\\n        # for t in range(n):\\n        #     for _ in range(len(nums[t])):\\n        # just want to keep run the loop, you could even just say maxlen*m\\n        for _ in range(maxlen*m):\\n            # check the smallest element and largest element for these n elements, this could be optimized by using a PQ.\\n            min_i = 0\\n            curmin, curmax = float(\\'inf\\'), 0\\n            for i in range(m):\\n                if curmin > nums[i][nxt[i]]:\\n                    min_i = i\\n                    curmin = nums[i][nxt[i]]\\n                if curmax < nums[i][nxt[i]]:\\n                    curmax = nums[i][nxt[i]]\\n            # update the ans candidate\\n            if right - left > curmax - curmin:\\n                right = curmax\\n                left = curmin\\n            # advance the smallest element pointer to next one, that\\'s the element we need to compare for next round.\\n            nxt[min_i] += 1\\n            # if the next pointer has already point to the end of one array, we\\'ve finished.\\n            if nxt[min_i] == len(nums[min_i]):\\n                return [left, right]\\n        return [-1, -1]\\n    \\n    # time o(nlogm), space o(m)\\n    # PQ based, it will help check the smallest element and it\\'s index at log(n) time.\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        pq = [(num[0], i, 0) for i, num in enumerate(nums)]\\n        heapq.heapify(pq)\\n        left, right = float(\\'-inf\\'), float(\\'inf\\')\\n        curmax = max([num[0] for num in nums])\\n        while pq:\\n            curmin, arrayIndex, index = heapq.heappop(pq)\\n            if right-left > curmax-curmin:\\n                right, left = curmax, curmin\\n            if index+1 == len(nums[arrayIndex]):\\n                return [left, right]\\n            curmax = max(curmax, nums[arrayIndex][index+1])\\n            heapq.heappush(pq, (nums[arrayIndex][index+1], arrayIndex, index+1))",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n# every time we just try to move the left pointer, as we know that if we move it, it might gave us a smaller range. this is the only way to move.\\nclass Solution:\\n    # two pointers, time o(m*n) space o(m)\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        m = len(nums)\\n        nxt = [0]*m\\n        left, right = float(\\'-inf\\'), float(\\'inf\\')\\n        maxlen = max([len(num) for num in nums])\\n        # for t in range(n):\\n        #     for _ in range(len(nums[t])):\\n        # just want to keep run the loop, you could even just say maxlen*m\\n        for _ in range(maxlen*m):\\n            # check the smallest element and largest element for these n elements, this could be optimized by using a PQ.\\n            min_i = 0\\n            curmin, curmax = float(\\'inf\\'), 0\\n            for i in range(m):\\n                if curmin > nums[i][nxt[i]]:\\n                    min_i = i\\n                    curmin = nums[i][nxt[i]]\\n                if curmax < nums[i][nxt[i]]:\\n                    curmax = nums[i][nxt[i]]\\n            # update the ans candidate\\n            if right - left > curmax - curmin:\\n                right = curmax\\n                left = curmin\\n            # advance the smallest element pointer to next one, that\\'s the element we need to compare for next round.\\n            nxt[min_i] += 1\\n            # if the next pointer has already point to the end of one array, we\\'ve finished.\\n            if nxt[min_i] == len(nums[min_i]):\\n                return [left, right]\\n        return [-1, -1]\\n    \\n    # time o(nlogm), space o(m)\\n    # PQ based, it will help check the smallest element and it\\'s index at log(n) time.\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        pq = [(num[0], i, 0) for i, num in enumerate(nums)]\\n        heapq.heapify(pq)\\n        left, right = float(\\'-inf\\'), float(\\'inf\\')\\n        curmax = max([num[0] for num in nums])\\n        while pq:\\n            curmin, arrayIndex, index = heapq.heappop(pq)\\n            if right-left > curmax-curmin:\\n                right, left = curmax, curmin\\n            if index+1 == len(nums[arrayIndex]):\\n                return [left, right]\\n            curmax = max(curmax, nums[arrayIndex][index+1])\\n            heapq.heappush(pq, (nums[arrayIndex][index+1], arrayIndex, index+1))",
                "codeTag": "Java"
            },
            {
                "id": 1096985,
                "title": "java-two-heaps-solution",
                "content": "This is a modification from one of the solutions in the comments. [OP Credits - @opendrum]\\n```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums.isEmpty()) return new int[0];\\n\\n        int[] range = new int[]{0, Integer.MAX_VALUE};\\n\\n        PriorityQueue<LinkedList<Integer>> minHeap = new PriorityQueue<>((a, b) -> (a.peek() - b.peek()));\\n        PriorityQueue<LinkedList<Integer>> maxHeap = new PriorityQueue<>((a, b) -> (b.peek() - a.peek()));\\n\\n        for(List<Integer> list: nums) {\\n            LinkedList<Integer> linkedList = new LinkedList<>(list);\\n            minHeap.add(linkedList);\\n            maxHeap.add(linkedList);\\n        }\\n\\n        while(minHeap.size() == nums.size()) {\\n            LinkedList<Integer> minList = minHeap.poll();\\n            LinkedList<Integer> maxList = maxHeap.peek();\\n\\n            int min = minList.getFirst();\\n            int max = maxList.getFirst();\\n\\n            minList.removeFirst();\\n\\n            if(minList.size() > 0) {\\n                minHeap.add(minList);\\n                if(!maxList.equals(minList)) {\\n                    maxHeap.remove(minList);\\n                }\\n                maxHeap.add(minList);\\n            }\\n            \\n            if((range[1] - range[0]) > (max - min)) {\\n                range[0] = min;\\n                range[1] = max;\\n            }\\n        }\\n\\n        return range;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums.isEmpty()) return new int[0];\\n\\n        int[] range = new int[]{0, Integer.MAX_VALUE};\\n\\n        PriorityQueue<LinkedList<Integer>> minHeap = new PriorityQueue<>((a, b) -> (a.peek() - b.peek()));\\n        PriorityQueue<LinkedList<Integer>> maxHeap = new PriorityQueue<>((a, b) -> (b.peek() - a.peek()));\\n\\n        for(List<Integer> list: nums) {\\n            LinkedList<Integer> linkedList = new LinkedList<>(list);\\n            minHeap.add(linkedList);\\n            maxHeap.add(linkedList);\\n        }\\n\\n        while(minHeap.size() == nums.size()) {\\n            LinkedList<Integer> minList = minHeap.poll();\\n            LinkedList<Integer> maxList = maxHeap.peek();\\n\\n            int min = minList.getFirst();\\n            int max = maxList.getFirst();\\n\\n            minList.removeFirst();\\n\\n            if(minList.size() > 0) {\\n                minHeap.add(minList);\\n                if(!maxList.equals(minList)) {\\n                    maxHeap.remove(minList);\\n                }\\n                maxHeap.add(minList);\\n            }\\n            \\n            if((range[1] - range[0]) > (max - min)) {\\n                range[0] = min;\\n                range[1] = max;\\n            }\\n        }\\n\\n        return range;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090895,
                "title": "java-solution-priorityqueue-minheap",
                "content": "```\\n// nums =  [ [4,10,15,24,26],[0,9,12,20],[5,18,22,30] ]\\n// list = [4,10,15,24,26] \\n// list = [0,9,12,20]\\n// list = [5,18,22,30]\\n// each minHeap element contains [val, index, pos]\\n// minHeap = [0,0,1] [4,0,0] [5,0,2] currRange = 5, minRange=5, res=[0,5]\\n// minHeap = [9,1,1] [4,0,0] [5,0,2] currRange= 5, minRange=5, res=[0,5]\\n// minHeap = [9,1,1] [10,1,0] [5,0,2] currRange= 5, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [10,1,0] [5,0,2] currRange = 7, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [10,1,0] [18,1,2] currRange = 8, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [15,2,0] [18,1,2] currRange = 6, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [15,2,0] [18,1,2] currRange = 5, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [24,3,0] [18,1,2] currRange= 6, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [24,3,0] [22,2,2] currRange = 4, minRange=4, res=[20,24]\\n// minHeap = [24,3,0] [30,3,2] , we can get out of the loop now, because we have iterated to the end of one list\\n\\n\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a,b)->(a[0]-b[0]));\\n        int n = nums.size();\\n        int maxNum = Integer.MIN_VALUE;\\n        int range = Integer.MAX_VALUE;\\n        int res[] = new int[2];\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(nums.get(i).size()>0){      \\n               minHeap.add(new int[]{nums.get(i).get(0), 0, i});       \\n               maxNum = Math.max(maxNum, nums.get(i).get(0));\\n            }       \\n        }\\n        \\n        while(!minHeap.isEmpty() && minHeap.size() == n){\\n            \\n            int[] arr = minHeap.poll();\\n            int val = arr[0];\\n            int index = arr[1]+1;\\n            int pos = arr[2];\\n            \\n            if(maxNum-val < range){\\n                range = maxNum - val;\\n                res[0] = val;\\n                res[1] = maxNum;\\n            }\\n            \\n            if(index < nums.get(pos).size()){\\n                \\n                minHeap.add(new int[]{nums.get(pos).get(index), index, pos });\\n                \\n                maxNum = Math.max(maxNum, nums.get(pos).get(index));\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n// nums =  [ [4,10,15,24,26],[0,9,12,20],[5,18,22,30] ]\\n// list = [4,10,15,24,26] \\n// list = [0,9,12,20]\\n// list = [5,18,22,30]\\n// each minHeap element contains [val, index, pos]\\n// minHeap = [0,0,1] [4,0,0] [5,0,2] currRange = 5, minRange=5, res=[0,5]\\n// minHeap = [9,1,1] [4,0,0] [5,0,2] currRange= 5, minRange=5, res=[0,5]\\n// minHeap = [9,1,1] [10,1,0] [5,0,2] currRange= 5, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [10,1,0] [5,0,2] currRange = 7, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [10,1,0] [18,1,2] currRange = 8, minRange=5, res=[0,5]\\n// minHeap = [12,2,1] [15,2,0] [18,1,2] currRange = 6, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [15,2,0] [18,1,2] currRange = 5, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [24,3,0] [18,1,2] currRange= 6, minRange=5, res=[0,5]\\n// minHeap = [20,3,1] [24,3,0] [22,2,2] currRange = 4, minRange=4, res=[20,24]\\n// minHeap = [24,3,0] [30,3,2] , we can get out of the loop now, because we have iterated to the end of one list\\n\\n\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        \\n        PriorityQueue<int[]> minHeap = new PriorityQueue<int[]>((a,b)->(a[0]-b[0]));\\n        int n = nums.size();\\n        int maxNum = Integer.MIN_VALUE;\\n        int range = Integer.MAX_VALUE;\\n        int res[] = new int[2];\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            if(nums.get(i).size()>0){      \\n               minHeap.add(new int[]{nums.get(i).get(0), 0, i});       \\n               maxNum = Math.max(maxNum, nums.get(i).get(0));\\n            }       \\n        }\\n        \\n        while(!minHeap.isEmpty() && minHeap.size() == n){\\n            \\n            int[] arr = minHeap.poll();\\n            int val = arr[0];\\n            int index = arr[1]+1;\\n            int pos = arr[2];\\n            \\n            if(maxNum-val < range){\\n                range = maxNum - val;\\n                res[0] = val;\\n                res[1] = maxNum;\\n            }\\n            \\n            if(index < nums.get(pos).size()){\\n                \\n                minHeap.add(new int[]{nums.get(pos).get(index), index, pos });\\n                \\n                maxNum = Math.max(maxNum, nums.get(pos).get(index));\\n            }\\n            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1089549,
                "title": "cpp-o-nlogk-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> ipair;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        priority_queue<pair<int,ipair>, vector<pair<int,ipair>>, greater<pair<int,ipair>>> pq;\\n        \\n        int N=nums.size();\\n        int _max=INT_MIN;\\n        for( int i=0;i<N;i++ ){\\n            pq.push({nums[i][0],{i,0}});\\n            if(_max<nums[i][0])\\n                _max=nums[i][0];\\n        }\\n        \\n        \\n        int len=INT_MAX;\\n        vector<int> v(2);\\n        while(true){\\n            \\n            pair<int,ipair> p=pq.top();\\n            pq.pop();\\n            \\n            int i=p.second.first;\\n            int j=p.second.second;\\n            \\n            if(len>_max-p.first){\\n                len=_max-p.first;\\n                v[0]=p.first;\\n                v[1]=_max;\\n            }\\n            \\n            if(j+1>=nums[i].size())\\n                break;\\n            \\n            pq.push({nums[i][j+1],{i,j+1}});\\n            if(_max<nums[i][j+1])\\n                _max=nums[i][j+1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    typedef pair<int,int> ipair;\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        priority_queue<pair<int,ipair>, vector<pair<int,ipair>>, greater<pair<int,ipair>>> pq;\\n        \\n        int N=nums.size();\\n        int _max=INT_MIN;\\n        for( int i=0;i<N;i++ ){\\n            pq.push({nums[i][0],{i,0}});\\n            if(_max<nums[i][0])\\n                _max=nums[i][0];\\n        }\\n        \\n        \\n        int len=INT_MAX;\\n        vector<int> v(2);\\n        while(true){\\n            \\n            pair<int,ipair> p=pq.top();\\n            pq.pop();\\n            \\n            int i=p.second.first;\\n            int j=p.second.second;\\n            \\n            if(len>_max-p.first){\\n                len=_max-p.first;\\n                v[0]=p.first;\\n                v[1]=_max;\\n            }\\n            \\n            if(j+1>=nums[i].size())\\n                break;\\n            \\n            pq.push({nums[i][j+1],{i,j+1}});\\n            if(_max<nums[i][j+1])\\n                _max=nums[i][j+1];\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1082698,
                "title": "c-priority-queue",
                "content": "```\\nclass Solution {\\npublic:\\n  #define d pair<int,pair<int,int>>\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n      int n=nums.size();\\n    \\n      \\n      priority_queue<d,vector<d>,greater<d>>pq;\\n      int end=INT_MIN;\\n      int ans=INT_MAX;\\n    \\n      for(int i=0;i<n;i++){\\n        pq.push({nums[i][0],{i,0}});\\n        \\n          end=max(nums[i][0],end);\\n        \\n      }\\n      int fir;\\n      int sec;\\n      while(!pq.empty()){\\n        pair<int,pair<int,int>>p=pq.top();\\n        pq.pop();\\n     \\n        if(end-p.first<ans){\\n          fir=p.first;\\n          sec=end;\\n          ans=end-p.first;\\n        }\\n        \\n        if(nums[p.second.first].size()-1>p.second.second){\\n          int idx=p.second.second+1;\\n          pq.push({nums[p.second.first][idx], {p.second.first,idx}});\\n          end=max(end,nums[p.second.first][idx]);\\n          \\n        }else{\\n          break;\\n        }\\n        \\n        \\n      }\\n        return {fir,sec};\\n        \\n        \\n        \\n      }\\n      \\n      \\n      \\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  #define d pair<int,pair<int,int>>\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n      int n=nums.size();\\n    \\n      \\n      priority_queue<d,vector<d>,greater<d>>pq;\\n      int end=INT_MIN;\\n      int ans=INT_MAX;\\n    \\n      for(int i=0;i<n;i++){\\n        pq.push({nums[i][0],{i,0}});\\n        \\n          end=max(nums[i][0],end);\\n        \\n      }\\n      int fir;\\n      int sec;\\n      while(!pq.empty()){\\n        pair<int,pair<int,int>>p=pq.top();\\n        pq.pop();\\n     \\n        if(end-p.first<ans){\\n          fir=p.first;\\n          sec=end;\\n          ans=end-p.first;\\n        }\\n        \\n        if(nums[p.second.first].size()-1>p.second.second){\\n          int idx=p.second.second+1;\\n          pq.push({nums[p.second.first][idx], {p.second.first,idx}});\\n          end=max(end,nums[p.second.first][idx]);\\n          \\n        }else{\\n          break;\\n        }\\n        \\n        \\n      }\\n        return {fir,sec};\\n        \\n        \\n        \\n      }\\n      \\n      \\n      \\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1075914,
                "title": "python-binary-search-solution",
                "content": "Since for any list in nums, the final solution will always include at least one element in this list, we can start with possible smallest range for all elements in one list and keep expand the possible solutions with all lists in nums. The final solution will be the smallest range in all possible solutions.\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        nums.sort(key=lambda x:len(x)) # start with shortest list to have least possible solution\\n        resultList = [(x,x) for x in nums[0]] # the possible solution for each element in this list is just itself with range=0\\n        for i in range(1,len(nums)):\\n            num = nums[i]\\n            newList = []\\n            for result in resultList: # for all possible solutions, check if need to update\\n                left=bisect.bisect_left(num,result[0])\\n                right=bisect.bisect_right(num,result[1])\\n                # if left != right, we know this possible solution don\\'t need to update\\n\\t\\t\\t\\tif left == right:\\n                    if left == 0:    # all elements in num are larger than this possible solution, update the upper bound\\n                        result = (result[0], num[0])\\n                    elif left == len(num): # all elements in num are smaller than this possible solution, update the lower bound\\n                        result = (num[-1],result[1])\\n                    else: # possile solution lower bound and upper bound is in between of two elements. Then possible solution need to update into two possible solutions. One update lower bound, one update upper bound\\n                        newList.append((result[0],num[left]))\\n                        result = (num[left-1],result[1])\\n                newList.append(result)\\n            resultList = newList\\n        resultList.sort(key=lambda x:(x[1]-x[0],x[0])) # find the smallest range in all possible solution\\n        return resultList[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        nums.sort(key=lambda x:len(x)) # start with shortest list to have least possible solution\\n        resultList = [(x,x) for x in nums[0]] # the possible solution for each element in this list is just itself with range=0\\n        for i in range(1,len(nums)):\\n            num = nums[i]\\n            newList = []\\n            for result in resultList: # for all possible solutions, check if need to update\\n                left=bisect.bisect_left(num,result[0])\\n                right=bisect.bisect_right(num,result[1])\\n                # if left != right, we know this possible solution don\\'t need to update\\n\\t\\t\\t\\tif left == right:\\n                    if left == 0:    # all elements in num are larger than this possible solution, update the upper bound\\n                        result = (result[0], num[0])\\n                    elif left == len(num): # all elements in num are smaller than this possible solution, update the lower bound\\n                        result = (num[-1],result[1])\\n                    else: # possile solution lower bound and upper bound is in between of two elements. Then possible solution need to update into two possible solutions. One update lower bound, one update upper bound\\n                        newList.append((result[0],num[left]))\\n                        result = (num[left-1],result[1])\\n                newList.append(result)\\n            resultList = newList\\n        resultList.sort(key=lambda x:(x[1]-x[0],x[0])) # find the smallest range in all possible solution\\n        return resultList[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1067797,
                "title": "smallest-range-covering-elements-from-k-lists-python-o-nlogk-time-heap",
                "content": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        minheap = []\\n        \\n        range_start, range_end = 0, float(\"inf\")\\n        \\n        curr_max = float(\"-inf\")\\n        \\n        # put the 1st element of each array in the max heap\\n        for i, arr in enumerate(nums):\\n            heappush(minheap, (arr[0], 0, i))\\n            curr_max = max(curr_max, arr[0])\\n            \\n        # take the smallest(top) element form the min heap, if it gives us smaller range, \\n        # update the ranges if the array of the top element has more elements, insert the \\n        # next element in the heap    \\n        while len(minheap) == len(nums):\\n            num, i, pos = heappop(minheap)\\n            \\n            if range_end - range_start > curr_max - num:\\n                range_start = num\\n                range_end = curr_max\\n                \\n            arr = nums[pos]\\n            if len(arr) > i + 1:\\n                # insert the next element in the heap\\n                heappush(minheap, (arr[i+1], i+1, pos))\\n                curr_max = max(curr_max, arr[i+1])\\n                \\n        return [range_start, range_end]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush, heappop\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        minheap = []\\n        \\n        range_start, range_end = 0, float(\"inf\")\\n        \\n        curr_max = float(\"-inf\")\\n        \\n        # put the 1st element of each array in the max heap\\n        for i, arr in enumerate(nums):\\n            heappush(minheap, (arr[0], 0, i))\\n            curr_max = max(curr_max, arr[0])\\n            \\n        # take the smallest(top) element form the min heap, if it gives us smaller range, \\n        # update the ranges if the array of the top element has more elements, insert the \\n        # next element in the heap    \\n        while len(minheap) == len(nums):\\n            num, i, pos = heappop(minheap)\\n            \\n            if range_end - range_start > curr_max - num:\\n                range_start = num\\n                range_end = curr_max\\n                \\n            arr = nums[pos]\\n            if len(arr) > i + 1:\\n                # insert the next element in the heap\\n                heappush(minheap, (arr[i+1], i+1, pos))\\n                curr_max = max(curr_max, arr[i+1])\\n                \\n        return [range_start, range_end]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1061108,
                "title": "c-solution-faster-than-100",
                "content": "Time complexity= O(N.K. log(K))\\nSpace Complexity= O(k)\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>pq;\\n        \\n        int n= nums.size(), max=0;\\n        vector<int> ans(2,0);\\n        ans[1]= INT_MAX;\\n        \\n        for(int i=0; i<n; i++) {\\n            pq.push(make_pair(nums[i][0], make_pair(i,0)));\\n            if(nums[i][0]>max) max= nums[i][0];\\n        }\\n        \\n        while(!pq.empty()) {\\n            int min= pq.top().first;\\n            int x= pq.top().second.first;\\n            int y= pq.top().second.second;\\n            pq.pop();\\n            \\n            if(max-min< ans[1]-ans[0]) {\\n                ans[0]= min;\\n                ans[1]= max;\\n            }\\n            \\n            if(y < nums[x].size()-1) {\\n                pq.push(make_pair(nums[x][y+1], make_pair(x, y+1)));\\n                if(nums[x][y+1]>max) max= nums[x][y+1];\\n            }\\n            else break;\\n        }       \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>>pq;\\n        \\n        int n= nums.size(), max=0;\\n        vector<int> ans(2,0);\\n        ans[1]= INT_MAX;\\n        \\n        for(int i=0; i<n; i++) {\\n            pq.push(make_pair(nums[i][0], make_pair(i,0)));\\n            if(nums[i][0]>max) max= nums[i][0];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1057930,
                "title": "python3-90-use-sorting",
                "content": "Sort the list while keeping track of which group the number is coming from. After that just use 2-pointer to see if you have a consecutive sequence which covers all the groups. Return the smallest range.\\n```python\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        m = []\\n        groups = len(nums)\\n        for i,l in enumerate(nums):\\n            for num in l:\\n                m += (num,i),\\n        m.sort()\\n        j = i = 0\\n        size = len(m)\\n        count = defaultdict(int)\\n        ans = defaultdict(int)\\n        while j < size:\\n            count[m[j][1]] += 1\\n            while len(count)==groups:\\n                if m[j][0]-m[i][0] not in ans:\\n                    ans[m[j][0]-m[i][0]] = m[i][0]\\n                count[m[i][1]] -= 1\\n                if count[m[i][1]]==0:\\n                    del count[m[i][1]]\\n                i += 1\\n            j += 1\\n        smallest = min(ans.keys())\\n        return [ans[smallest], ans[smallest]+smallest]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        m = []\\n        groups = len(nums)\\n        for i,l in enumerate(nums):\\n            for num in l:\\n                m += (num,i),\\n        m.sort()\\n        j = i = 0\\n        size = len(m)\\n        count = defaultdict(int)\\n        ans = defaultdict(int)\\n        while j < size:\\n            count[m[j][1]] += 1\\n            while len(count)==groups:\\n                if m[j][0]-m[i][0] not in ans:\\n                    ans[m[j][0]-m[i][0]] = m[i][0]\\n                count[m[i][1]] -= 1\\n                if count[m[i][1]]==0:\\n                    del count[m[i][1]]\\n                i += 1\\n            j += 1\\n        smallest = min(ans.keys())\\n        return [ans[smallest], ans[smallest]+smallest]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037035,
                "title": "c-solution-faster-than-90",
                "content": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n       int n=nums.size();\\n       int i,j;\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        vector<int>v(2,0);\\n        int high=INT_MIN;\\n        int low=0;\\n        for(i=0;i<n;i++)\\n        {\\n            high=max(high,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}});\\n        }\\n        low=pq.top().first;\\n        v[0]=low;\\n        v[1]=high;\\n        while(pq.size()==n)\\n        {\\n            auto it=pq.top();\\n            pq.pop();\\n            int r=it.second.first;\\n            int s=it.second.second;\\n            if(s+1<nums[r].size())\\n            {\\n                pq.push({nums[r][s+1],{r,s+1}});\\n                high=max(nums[r][s+1],high);\\n                low=pq.top().first;\\n                if(high-low<v[1]-v[0])\\n                {\\n                    v[0]=low;\\n                    v[1]=high;\\n                }\\n            }\\n        }\\n        return v;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n       int n=nums.size();\\n       int i,j;\\n       priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>>pq;\\n        vector<int>v(2,0);\\n        int high=INT_MIN;\\n        int low=0;\\n        for(i=0;i<n;i++)\\n        {\\n            high=max(high,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}",
                "codeTag": "Java"
            },
            {
                "id": 972464,
                "title": "java-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] next = new int[nums.size()];\\n        \\n        int rangeMax = Integer.MIN_VALUE;\\n        int rangeMin = Integer.MAX_VALUE;\\n        \\n        boolean hasNext = true;\\n        \\n        while(hasNext) {\\n            int currMax = Integer.MIN_VALUE;\\n            int currMin = Integer.MAX_VALUE;\\n            for(int i=0; i<next.length; i++) {\\n                currMin = Math.min(currMin, nums.get(i).get(next[i]));\\n                currMax = Math.max(currMax, nums.get(i).get(next[i]));\\n            }\\n            \\n            if((rangeMax == Integer.MIN_VALUE && rangeMin == Integer.MAX_VALUE)\\n                   || (currMax - currMin) < (rangeMax - rangeMin)) {\\n                    rangeMax = currMax;\\n                    rangeMin = currMin;\\n                }\\n            \\n            for(int i=0; i<next.length; i++) {\\n                if(currMin == nums.get(i).get(next[i])) next[i]++;\\n                if(next[i] == nums.get(i).size()) hasNext = false;\\n            }\\n        }\\n        return new int[]{rangeMin, rangeMax};\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] next = new int[nums.size()];\\n        \\n        int rangeMax = Integer.MIN_VALUE;\\n        int rangeMin = Integer.MAX_VALUE;\\n        \\n        boolean hasNext = true;\\n        \\n        while(hasNext) {\\n            int currMax = Integer.MIN_VALUE;\\n            int currMin = Integer.MAX_VALUE;\\n            for(int i=0; i<next.length; i++) {\\n                currMin = Math.min(currMin, nums.get(i).get(next[i]));\\n                currMax = Math.max(currMax, nums.get(i).get(next[i]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 954915,
                "title": "cpp14-priority-queue-2-pointers-solution",
                "content": "```\\n\\n\\nstruct object\\n{\\n    int value;\\n    int r;\\n    int c;\\n    object(int value , int r , int c): value(value), r(r), c(c){}\\n};\\n\\n\\nstruct op\\n{\\n    bool operator()(const object& it1 , const object &it2)\\n    {\\n        return it2.value < it1.value;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<object , vector<object> , op> pq;\\n        int n = nums.size();\\n        int high = -1e9;\\n        for(int i = 0 ; i < n ; ++i){\\n            pq.push(object(nums[i][0] , i , 0));\\n            high = max(high , nums[i][0]);\\n        }\\n        int low = pq.top().value;\\n        vector<int> res{low , high};\\n        while(pq.size() == n){\\n            auto it = pq.top();\\n            pq.pop();\\n            if(it.c + 1 < nums[it.r].size()){\\n                pq.push(object(nums[it.r][it.c+1] , it.r , it.c + 1));\\n                high = max(high , nums[it.r][it.c + 1]);\\n                low = pq.top().value;\\n                if(high - low < res[1] - res[0]){\\n                    res[0] = low;\\n                    res[1] = high ;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\n\\nstruct object\\n{\\n    int value;\\n    int r;\\n    int c;\\n    object(int value , int r , int c): value(value), r(r), c(c){}\\n};\\n\\n\\nstruct op\\n{\\n    bool operator()(const object& it1 , const object &it2)\\n    {\\n        return it2.value < it1.value;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        priority_queue<object , vector<object> , op> pq;\\n        int n = nums.size();\\n        int high = -1e9;\\n        for(int i = 0 ; i < n ; ++i){\\n            pq.push(object(nums[i][0] , i , 0));\\n            high = max(high , nums[i][0]);\\n        }\\n        int low = pq.top().value;\\n        vector<int> res{low , high};\\n        while(pq.size() == n){\\n            auto it = pq.top();\\n            pq.pop();\\n            if(it.c + 1 < nums[it.r].size()){\\n                pq.push(object(nums[it.r][it.c+1] , it.r , it.c + 1));\\n                high = max(high , nums[it.r][it.c + 1]);\\n                low = pq.top().value;\\n                if(high - low < res[1] - res[0]){\\n                    res[0] = low;\\n                    res[1] = high ;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 826831,
                "title": "sliding-window-solution-easy-to-understand-and-beats-97",
                "content": "```\\nclass Node {\\n    int value;\\n    int type;\\n    \\n    public Node(int value, int type) {\\n        this.value = value;\\n        this.type = type;\\n    }\\n}\\n\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<Node> list = new ArrayList<Node>();\\n        int[] res = new int[2];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        int counter = 0;\\n        int k = nums.size();\\n        int count[] = new int[k+1]; \\n        int end = 0; int start = 0; int minDiff = Integer.MAX_VALUE;   \\n        \\n        int type = 0;\\n        for(List<Integer> temp: nums) {\\n            type++;\\n            for(int num: temp) {\\n                list.add(new Node(num, type));\\n            }\\n        }\\n        \\n        Collections.sort(list, new Comparator<Node>(){\\n            public int compare(Node n1, Node n2) {\\n                return n1.value - n2.value;\\n            }\\n        });\\n        \\n        while(end < list.size()) {\\n            int curType = list.get(end).type;\\n            if(count[curType] == 0) { counter++; }\\n            count[curType]++;\\n            \\n            while(counter == k) {\\n                int startType = list.get(start).type;\\n                if(count[startType] == 1) { counter--; }\\n                count[startType]--;\\n                \\n                int diff = list.get(end).value - list.get(start).value;\\n                if(diff < minDiff || (diff == minDiff && list.get(start).value < res[0])) {\\n                    minDiff = diff;\\n                    res[0] = list.get(start).value;\\n                    res[1] = list.get(end).value;\\n                }\\n                start++;\\n            }\\n            end++;\\n        }\\n        \\n        return res;    \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        List<Node> list = new ArrayList<Node>();\\n        int[] res = new int[2];\\n        Arrays.fill(res, Integer.MAX_VALUE);\\n        int counter = 0;\\n        int k = nums.size();\\n        int count[] = new int[k+1]; \\n        int end = 0; int start = 0; int minDiff = Integer.MAX_VALUE;   \\n        \\n        int type = 0;\\n        for(List<Integer> temp: nums) {\\n            type++;\\n            for(int num: temp) {\\n                list.add(new Node(num, type));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 808394,
                "title": "c-priority-queue",
                "content": "This is C++ version of this answer https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/discuss/104904/Python-Heap-based-solution.\\n\\n\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstruct T {\\n\\t\\t\\t\\tint val, x, y;\\n\\t\\t\\t\\tT (int a, int b, int c) : val (a), x (b), y (c) {}\\n\\t\\t\\t\\tbool operator< (const T& S) const {\\n\\t\\t\\t\\t\\treturn val > S.val;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tvector<int> smallestRange(vector<vector<int>>& nums) {\\n\\t\\t\\t\\tvector<int> ret = {(int)-1e5, (int)1e5};\\n\\t\\t\\t\\tpriority_queue<T> pq;\\n\\t\\t\\t\\tint n = nums.size();\\n\\t\\t\\t\\tint right = INT_MIN;\\n\\t\\t\\t\\tfor (int i = 0; i < n; ++i){\\n\\t\\t\\t\\t\\tpq.push(T(nums[i][0], i, 0));\\n\\t\\t\\t\\t\\tright = max(right, nums[i][0]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (!pq.empty()){\\n\\t\\t\\t\\t\\tauto [left, i, j] = pq.top(); pq.pop();\\n\\t\\t\\t\\t\\tif (right - left < ret[1] - ret[0]){\\n\\t\\t\\t\\t\\t\\tret[0] = left; ret[1] = right;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif (j + 1 == nums[i].size())\\n\\t\\t\\t\\t\\t\\treturn ret;\\n\\t\\t\\t\\t\\tint val = nums[i][j+1];\\n\\t\\t\\t\\t\\tright = max(right, val);\\n\\t\\t\\t\\t\\tpq.push(T(val, i, j+1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ret;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tstruct T {\\n\\t\\t\\t\\tint val, x, y;\\n\\t\\t\\t\\tT (int a, int b, int c) : val (a), x (b), y (c) {}",
                "codeTag": "Java"
            },
            {
                "id": 777508,
                "title": "c-using-min-heap",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int high=INT_MIN;\\n        int low;\\n        int n=nums.size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        //first will be value\\n        // second will be index of row\\n        // third will be index of col\\n        for(int i=0;i<n;i++){\\n            high=max(high,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}});\\n        }\\n        low=pq.top().first;\\n        vector<int> res{low,high};\\n        while(pq.size()==n){\\n            auto it=pq.top();pq.pop();\\n            int val=it.first;\\n            int row=it.second.first;\\n            int col=it.second.second;\\n            \\n            if(col+1<nums[row].size()){\\n                pq.push({nums[row][col+1],{row,col+1}});\\n                high=max(high,nums[row][col+1]);\\n                low=pq.top().first;\\n                if(high-low<res[1]-res[0]){\\n                    res[1]=high;\\n                    res[0]=low;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int high=INT_MIN;\\n        int low;\\n        int n=nums.size();\\n        priority_queue<pair<int,pair<int,int>>,vector<pair<int,pair<int,int>>>,greater<pair<int,pair<int,int>>>> pq;\\n        //first will be value\\n        // second will be index of row\\n        // third will be index of col\\n        for(int i=0;i<n;i++){\\n            high=max(high,nums[i][0]);\\n            pq.push({nums[i][0],{i,0}});\\n        }\\n        low=pq.top().first;\\n        vector<int> res{low,high};\\n        while(pq.size()==n){\\n            auto it=pq.top();pq.pop();\\n            int val=it.first;\\n            int row=it.second.first;\\n            int col=it.second.second;\\n            \\n            if(col+1<nums[row].size()){\\n                pq.push({nums[row][col+1],{row,col+1}});\\n                high=max(high,nums[row][col+1]);\\n                low=pq.top().first;\\n                if(high-low<res[1]-res[0]){\\n                    res[1]=high;\\n                    res[0]=low;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 759458,
                "title": "java-solution-using-treeset-very-easy-to-read",
                "content": "I didn\\'t saw any post using this method, hence posting it here.\\nThe idea behind this is to store the value, listIndex (index of the list this value belongs to) and index(index of value in current list) as a separate tuple and store them in a treeSet. Min and max of that treeSet is the current sliding window. When me move the smallest element to the next value, we update that value in treeset and update it\\'s index. TreeSet will calculate new min and max in O(lg(k)) time.\\n\\nComparator of treeSet will compare values if they\\'re unequal, else it\\'ll compare listIndexes.\\n\\n```\\nclass Tuple {\\n    public int value;\\n    public int listIndex;\\n    public int index;\\n\\n    public Tuple(int value, int listIndex, int index) {\\n        this.value = value;\\n        this.listIndex = listIndex; // will store which list this value belongs to.\\n        this.index = index; // will store the index in current list this value belongs to.\\n    }\\n}\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        TreeSet<Tuple> set = new TreeSet<>((k1, k2) -> k1.value == k2.value ? k1.listIndex - k2.listIndex : k1.value - k2.value);\\n        Tuple min = null;\\n        Tuple max = null;\\n        int[] result = new int[] {-1, -1};\\n        int minDiff = Integer.MAX_VALUE;\\n        // create the set with first element of all the lists\\n        for (int ctr = 0; ctr < nums.size(); ctr++) {\\n            set.add(new Tuple(nums.get(ctr).get(0), ctr, 0));\\n        }\\n        // calculate diff for new window, save if smaller.\\n        while (true) {\\n            min = set.first();\\n            max = set.last();\\n            if (max.value - min.value < minDiff) {\\n                minDiff = max.value - min.value;\\n                result[0] = min.value;\\n                result[1] = max.value;\\n            }\\n            // move min index to it\\'s next element\\n            min.index += 1;\\n\\t\\t\\t// break if we\\'ve reached at the end of the list\\n            if (min.index >= nums.get(min.listIndex).size()) {\\n                break;\\n            }\\n            // remove old min\\n            set.remove(min);\\n            // add new min\\n            int nextVal = nums.get(min.listIndex).get(min.index);\\n            set.add(new Tuple(nextVal, min.listIndex, min.index));\\n        }\\n        return result;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\nclass Tuple {\\n    public int value;\\n    public int listIndex;\\n    public int index;\\n\\n    public Tuple(int value, int listIndex, int index) {\\n        this.value = value;\\n        this.listIndex = listIndex; // will store which list this value belongs to.\\n        this.index = index; // will store the index in current list this value belongs to.\\n    }\\n}\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        TreeSet<Tuple> set = new TreeSet<>((k1, k2) -> k1.value == k2.value ? k1.listIndex - k2.listIndex : k1.value - k2.value);\\n        Tuple min = null;\\n        Tuple max = null;\\n        int[] result = new int[] {-1, -1};\\n        int minDiff = Integer.MAX_VALUE;\\n        // create the set with first element of all the lists\\n        for (int ctr = 0; ctr < nums.size(); ctr++) {\\n            set.add(new Tuple(nums.get(ctr).get(0), ctr, 0));\\n        }\\n        // calculate diff for new window, save if smaller.\\n        while (true) {\\n            min = set.first();\\n            max = set.last();\\n            if (max.value - min.value < minDiff) {\\n                minDiff = max.value - min.value;\\n                result[0] = min.value;\\n                result[1] = max.value;\\n            }\\n            // move min index to it\\'s next element\\n            min.index += 1;\\n\\t\\t\\t// break if we\\'ve reached at the end of the list\\n            if (min.index >= nums.get(min.listIndex).size()) {\\n                break;\\n            }\\n            // remove old min\\n            set.remove(min);\\n            // add new min\\n            int nextVal = nums.get(min.listIndex).get(min.index);\\n            set.add(new Tuple(nextVal, min.listIndex, min.index));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751059,
                "title": "rust-translated-binaryheap",
                "content": "Runtime: 8 ms, faster than 100.00% of Rust online submissions for Smallest Range Covering Elements from K Lists.\\nMemory Usage: 2.6 MB, less than 100.00% of Rust online submissions for Smallest Range Covering Elements from K Lists.\\n```rust\\n#[derive(Debug, Clone, Ord, Eq)]\\nstruct Point {\\n    val: i32,\\n    group: i32,\\n    idx: i32,\\n}\\n\\nimpl std::cmp::PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl std::cmp::PartialEq for Point {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val.eq(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn smallest_range(nums: Vec<Vec<i32>>) -> Vec<i32> {\\n\\n        let n = nums.len();\\n        let mut heap = std::collections::BinaryHeap::<Point>::new();\\n        let mut max = std::i32::MIN;\\n        for g in 0..n {\\n            let val = nums[g][0];\\n            if val > max {\\n                max = val;\\n            }\\n            heap.push(Point {\\n                val,\\n                group: g as i32,\\n                idx: 0,\\n            })\\n        }\\n        let mut start = -1;\\n        let mut end = -1;\\n        let mut range = std::i32::MAX;\\n\\n        while heap.len() == n {\\n            //            println!(\"{:?}\", heap);\\n            let mut curr = heap.pop().unwrap();\\n            if max - curr.val < range {\\n                range = max - curr.val;\\n                start = curr.val;\\n                end = max;\\n            }\\n            if curr.idx + 1 < nums[curr.group as usize].len() as i32 {\\n                curr.idx += 1;\\n                curr.val = nums[curr.group as usize][curr.idx as usize];\\n                if curr.val > max {\\n                    max = curr.val;\\n                }\\n                heap.push(curr);\\n            }\\n            //            println!(\"start = {}, end = {}\", start, end);\\n        }\\n        vec![start as i32, end as i32]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_smallest_range() {\\n        assert_eq!(\\n            Solution::smallest_range(vec![\\n                vec![4, 10, 15, 24, 26],\\n                vec![0, 9, 12, 20],\\n                vec![5, 18, 22, 30]\\n            ]),\\n            vec![20, 24]\\n        )\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\n#[derive(Debug, Clone, Ord, Eq)]\\nstruct Point {\\n    val: i32,\\n    group: i32,\\n    idx: i32,\\n}\\n\\nimpl std::cmp::PartialOrd for Point {\\n    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {\\n        other.val.partial_cmp(&self.val)\\n    }\\n}\\n\\nimpl std::cmp::PartialEq for Point {\\n    fn eq(&self, other: &Self) -> bool {\\n        self.val.eq(&other.val)\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn smallest_range(nums: Vec<Vec<i32>>) -> Vec<i32> {\\n\\n        let n = nums.len();\\n        let mut heap = std::collections::BinaryHeap::<Point>::new();\\n        let mut max = std::i32::MIN;\\n        for g in 0..n {\\n            let val = nums[g][0];\\n            if val > max {\\n                max = val;\\n            }\\n            heap.push(Point {\\n                val,\\n                group: g as i32,\\n                idx: 0,\\n            })\\n        }\\n        let mut start = -1;\\n        let mut end = -1;\\n        let mut range = std::i32::MAX;\\n\\n        while heap.len() == n {\\n            //            println!(\"{:?}\", heap);\\n            let mut curr = heap.pop().unwrap();\\n            if max - curr.val < range {\\n                range = max - curr.val;\\n                start = curr.val;\\n                end = max;\\n            }\\n            if curr.idx + 1 < nums[curr.group as usize].len() as i32 {\\n                curr.idx += 1;\\n                curr.val = nums[curr.group as usize][curr.idx as usize];\\n                if curr.val > max {\\n                    max = curr.val;\\n                }\\n                heap.push(curr);\\n            }\\n            //            println!(\"start = {}, end = {}\", start, end);\\n        }\\n        vec![start as i32, end as i32]\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_smallest_range() {\\n        assert_eq!(\\n            Solution::smallest_range(vec![\\n                vec![4, 10, 15, 24, 26],\\n                vec![0, 9, 12, 20],\\n                vec![5, 18, 22, 30]\\n            ]),\\n            vec![20, 24]\\n        )\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 682638,
                "title": "evolve-from-brute-force-to-optimal",
                "content": "1. Brute force.Two ends of the range must come from the list values. So we try every range. For each range, we check all lists.\\n1.1 O(n^3) \\n```\\n public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] arr = nums.stream().flatMap(List::stream).mapToInt(i->i).toArray();\\n        int len = arr.length;\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++) {\\n                int l = Math.min(arr[i],arr[j]), r=Math.max(arr[i],arr[j]);\\n                if(r-l>range[1]-range[0]) continue;\\n                boolean isRangeOk=false;\\n                for(List<Integer> lst:nums) {\\n                    isRangeOk = false;\\n                    for(int v:lst) {\\n                        if(v>=l&&v<=r) {\\n                            isRangeOk = true;\\n                            break;\\n                        }\\n                        if(v>r) {\\n                            isRangeOk = false;\\n                            break; \\n                        }\\n                    }\\n                    if(isRangeOk == false) break;\\n                }\\n                if(isRangeOk && (r-l<range[1]-range[0]||l<range[0])) {\\n                    range[0]=l;\\n                    range[1]=r;\\n                }\\n            }\\n        return range;\\n    }\\n```\\n1.2 O(n^2*mlogk)\\nWhen checking a list for a candidate range, since the list is sorted, we can binary search the left end of the range to determine if any value in the list falls into the range.\\n```\\npublic int[] smallestRange(List<List<Integer>> nums) {\\n        int[] arr = nums.stream().flatMap(List::stream).mapToInt(i->i).toArray();\\n        int len = arr.length;\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++) {\\n                int l=Math.min(arr[i],arr[j]), r=Math.max(arr[i],arr[j]);\\n                if(r-l>range[1]-range[0]) continue;\\n                int p,m=nums.size();\\n                for(p=0;p<m;p++) {\\n                    List<Integer> lst=nums.get(p);\\n                    int q=Collections.binarySearch(lst,l);\\n                    if(q<0) q=-1-q;\\n                    if(q==lst.size()||lst.get(q)>r) break;\\n                }\\n                if(p==m&&(r-l<range[1]-range[0]||l<range[0])) {\\n                    range[0]=l;\\n                    range[1]=r;\\n                }\\n            }\\n        return range;\\n    }\\n```\\n2. O(mn)\\nInstead of trying all ranges, we can have an initial range that contains the first/min element of all lists and try to optimize it. To begin with, we cannot decreae the upper bound of the range because it is the min value of a list. If it is decreased, no value in that list falls into the range. So the approach is to increase the lower bound and compute the new range. Once we reach end of a list, we are done because increasing the lower bound to be large than the max value of a list excludes the list from the range.\\nThe approach is not difficult but the chanllege is to prove the optimality. I can see two points\\n* We never need to move backwards. Say we make some forward movements and want to decrease a list index for the first time. When the index is increased, it is the lower bound of the current range. So decreasing the index gives the same lower bound and the upper bound is the same or larger. Thus moving backward does not help reduce the range.\\n* The minimum range covers close elements from the lists and the approach maintains a array of close elements and tries to minimize the range.\\n```\\n public int[] smallestRange(List<List<Integer>> nums) { \\n        int m=nums.size();       \\n        int[] cur = new int[m], range=new int[]{0,Integer.MAX_VALUE};\\n        while(true) {\\n            int min=Integer.MAX_VALUE, max=Integer.MIN_VALUE, mini=0;\\n            for(int i=0;i<m;i++) {\\n                int head = nums.get(i).get(cur[i]);\\n                if(head<min) {\\n                    min=head;\\n                    mini=i;\\n                }\\n                if(head>max) max=head;\\n            }\\n            if(max-min<range[1]-range[0]) {\\n                range[0]=min;\\n                range[1]=max;\\n            }\\n            if(++cur[mini]==nums.get(mini).size()) break;\\n        }\\n        return range;\\n    }\\n```\\n3. O(nlogm), Same idea as #2 with the help of min heap.\\n```\\n  public int[] smallestRange(List<List<Integer>> nums) { \\n        int m = nums.size(),max=Integer.MIN_VALUE;\\n        Queue<int[]> pq=new PriorityQueue<>(m,Comparator.comparingInt(arr->nums.get(arr[0]).get(arr[1])));\\n        for(int i=0;i<m;i++) {\\n            pq.add(new int[]{i,0});\\n            max=Math.max(max,nums.get(i).get(0));\\n        }\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        while(true) {\\n            int[] head = pq.poll();\\n            List<Integer> lst=nums.get(head[0]);\\n            int min = lst.get(head[1]);\\n            if(max-min<range[1]-range[0]) {\\n                range[0]=min;\\n                range[1]=max;\\n            }\\n            if(++head[1]==lst.size()) break;\\n            pq.add(head);\\n            max=Math.max(max,lst.get(head[1]));\\n        }\\n        return range;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public int[] smallestRange(List<List<Integer>> nums) {\\n        int[] arr = nums.stream().flatMap(List::stream).mapToInt(i->i).toArray();\\n        int len = arr.length;\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++) {\\n                int l = Math.min(arr[i],arr[j]), r=Math.max(arr[i],arr[j]);\\n                if(r-l>range[1]-range[0]) continue;\\n                boolean isRangeOk=false;\\n                for(List<Integer> lst:nums) {\\n                    isRangeOk = false;\\n                    for(int v:lst) {\\n                        if(v>=l&&v<=r) {\\n                            isRangeOk = true;\\n                            break;\\n                        }\\n                        if(v>r) {\\n                            isRangeOk = false;\\n                            break; \\n                        }\\n                    }\\n                    if(isRangeOk == false) break;\\n                }\\n                if(isRangeOk && (r-l<range[1]-range[0]||l<range[0])) {\\n                    range[0]=l;\\n                    range[1]=r;\\n                }\\n            }\\n        return range;\\n    }\\n```\n```\\npublic int[] smallestRange(List<List<Integer>> nums) {\\n        int[] arr = nums.stream().flatMap(List::stream).mapToInt(i->i).toArray();\\n        int len = arr.length;\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        for(int i=0;i<len;i++)\\n            for(int j=i;j<len;j++) {\\n                int l=Math.min(arr[i],arr[j]), r=Math.max(arr[i],arr[j]);\\n                if(r-l>range[1]-range[0]) continue;\\n                int p,m=nums.size();\\n                for(p=0;p<m;p++) {\\n                    List<Integer> lst=nums.get(p);\\n                    int q=Collections.binarySearch(lst,l);\\n                    if(q<0) q=-1-q;\\n                    if(q==lst.size()||lst.get(q)>r) break;\\n                }\\n                if(p==m&&(r-l<range[1]-range[0]||l<range[0])) {\\n                    range[0]=l;\\n                    range[1]=r;\\n                }\\n            }\\n        return range;\\n    }\\n```\n```\\n public int[] smallestRange(List<List<Integer>> nums) { \\n        int m=nums.size();       \\n        int[] cur = new int[m], range=new int[]{0,Integer.MAX_VALUE};\\n        while(true) {\\n            int min=Integer.MAX_VALUE, max=Integer.MIN_VALUE, mini=0;\\n            for(int i=0;i<m;i++) {\\n                int head = nums.get(i).get(cur[i]);\\n                if(head<min) {\\n                    min=head;\\n                    mini=i;\\n                }\\n                if(head>max) max=head;\\n            }\\n            if(max-min<range[1]-range[0]) {\\n                range[0]=min;\\n                range[1]=max;\\n            }\\n            if(++cur[mini]==nums.get(mini).size()) break;\\n        }\\n        return range;\\n    }\\n```\n```\\n  public int[] smallestRange(List<List<Integer>> nums) { \\n        int m = nums.size(),max=Integer.MIN_VALUE;\\n        Queue<int[]> pq=new PriorityQueue<>(m,Comparator.comparingInt(arr->nums.get(arr[0]).get(arr[1])));\\n        for(int i=0;i<m;i++) {\\n            pq.add(new int[]{i,0});\\n            max=Math.max(max,nums.get(i).get(0));\\n        }\\n        int[] range=new int[]{0,Integer.MAX_VALUE};\\n        while(true) {\\n            int[] head = pq.poll();\\n            List<Integer> lst=nums.get(head[0]);\\n            int min = lst.get(head[1]);\\n            if(max-min<range[1]-range[0]) {\\n                range[0]=min;\\n                range[1]=max;\\n            }\\n            if(++head[1]==lst.size()) break;\\n            pq.add(head);\\n            max=Math.max(max,lst.get(head[1]));\\n        }\\n        return range;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 542061,
                "title": "java-sol",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int res[]=new int[2];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a1[0]-a2[0];\\n        });\\n        int min=Integer.MAX_VALUE;int max=Integer.MIN_VALUE;\\n        int cnt=0;\\n        for(List<Integer>list:nums){\\n            int a[]=new int[3];\\n            a[0]=list.get(0);a[1]=0;a[2]=cnt++;\\n            min=Math.min(min,a[0]);\\n            max=Math.max(max,a[0]);\\n            pq.add(a);\\n        }\\n        res[0]=min;res[1]=max;\\n        while(true){\\n            int tuple[]=pq.poll();\\n            int kth=tuple[2];\\n            int index=tuple[1];\\n            if(index==nums.get(kth).size()-1)break;\\n            int next[]=new int[3];\\n            next[0]=nums.get(kth).get(index+1);\\n            next[1]=index+1;\\n            next[2]=kth;\\n            max=Math.max(max,next[0]);\\n            pq.add(next);\\n            if(res[1]-res[0]>max-pq.peek()[0]){\\n                res[0]=pq.peek()[0];\\n                res[1]=max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int res[]=new int[2];\\n        PriorityQueue<int[]>pq=new PriorityQueue<>((a1,a2)->{\\n            return a1[0]-a2[0];\\n        });\\n        int min=Integer.MAX_VALUE;int max=Integer.MIN_VALUE;\\n        int cnt=0;\\n        for(List<Integer>list:nums){\\n            int a[]=new int[3];\\n            a[0]=list.get(0);a[1]=0;a[2]=cnt++;\\n            min=Math.min(min,a[0]);\\n            max=Math.max(max,a[0]);\\n            pq.add(a);\\n        }\\n        res[0]=min;res[1]=max;\\n        while(true){\\n            int tuple[]=pq.poll();\\n            int kth=tuple[2];\\n            int index=tuple[1];\\n            if(index==nums.get(kth).size()-1)break;\\n            int next[]=new int[3];\\n            next[0]=nums.get(kth).get(index+1);\\n            next[1]=index+1;\\n            next[2]=kth;\\n            max=Math.max(max,next[0]);\\n            pq.add(next);\\n            if(res[1]-res[0]>max-pq.peek()[0]){\\n                res[0]=pq.peek()[0];\\n                res[1]=max;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 488044,
                "title": "python-using-heap-in-runtime-n-logm",
                "content": "```\\nimport heapq\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        # run time : O(N*log M) where N = total nums, M is len(nums)\\n        rangeStart = 0\\n        rangeEnd = float(\\'inf\\')\\n        currentMax = float(\\'-inf\\')\\n        heap = []\\n        \\n        # put one number from each of k list\\n        for i in range(len(nums)):\\n            heapq.heappush(heap, (nums[i][0], 0, i))\\n            currentMax = max(currentMax, nums[i][0])\\n        \\n        # take the smallest(top) element form the min heap, \\n        # if it gives us smaller range, update the ranges\\n        # if the array of the top element has more elements, \\n        # insert the next element in the heap\\n        while len(heap) == len(nums):\\n            num, idx, row = heapq.heappop(heap)\\n            \\n            if rangeEnd - rangeStart > currentMax - num:\\n                rangeStart = num\\n                rangeEnd = currentMax\\n            \\n            if idx + 1 < len(nums[row]):\\n                heapq.heappush(heap, (nums[row][idx+1], idx+1, row))\\n                currentMax = max(currentMax, nums[row][idx+1])\\n        \\n        return [rangeStart, rangeEnd]\\n```",
                "solutionTags": [],
                "code": "```\\nimport heapq\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        # run time : O(N*log M) where N = total nums, M is len(nums)\\n        rangeStart = 0\\n        rangeEnd = float(\\'inf\\')\\n        currentMax = float(\\'-inf\\')\\n        heap = []\\n        \\n        # put one number from each of k list\\n        for i in range(len(nums)):\\n            heapq.heappush(heap, (nums[i][0], 0, i))\\n            currentMax = max(currentMax, nums[i][0])\\n        \\n        # take the smallest(top) element form the min heap, \\n        # if it gives us smaller range, update the ranges\\n        # if the array of the top element has more elements, \\n        # insert the next element in the heap\\n        while len(heap) == len(nums):\\n            num, idx, row = heapq.heappop(heap)\\n            \\n            if rangeEnd - rangeStart > currentMax - num:\\n                rangeStart = num\\n                rangeEnd = currentMax\\n            \\n            if idx + 1 < len(nums[row]):\\n                heapq.heappush(heap, (nums[row][idx+1], idx+1, row))\\n                currentMax = max(currentMax, nums[row][idx+1])\\n        \\n        return [rangeStart, rangeEnd]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471339,
                "title": "my-java-solution-using-sliding-window",
                "content": "```\\nclass Solution {\\n    class pair{\\n        public int l, r;\\n        public pair(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n        }\\n    }\\n\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int n = 0, m = nums.size();\\n        for (int i=0; i<m; ++i){\\n            n += nums.get(i).size();\\n        }\\n        \\n        pair[] ii = new pair[n];\\n        int last = 0;\\n        for (int i=0; i<m; ++i){\\n            for (int j=0; j<nums.get(i).size(); ++j){\\n                ii[last++] = new pair(nums.get(i).get(j),i);\\n            }\\n        }\\n        \\n        Arrays.sort(ii,(a,b)->a.l-b.l);\\n        \\n        int lb = 0, rb = 0, k = 0, ansl = 0, ansr = 1000000000;\\n        int[] freq = new int[m];\\n        for (; rb<n; ++rb){\\n            if (freq[ii[rb].r]==0) ++k;\\n            ++freq[ii[rb].r];\\n            while (freq[ii[lb].r]>1) --freq[ii[lb++].r];\\n            if (k==m){\\n                if ((ii[rb].l-ii[lb].l<ansr-ansl)){\\n                    ansr = ii[rb].l;\\n                    ansl = ii[lb].l;\\n                }\\n            }\\n        }\\n        return new int[] {ansl, ansr};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    class pair{\\n        public int l, r;\\n        public pair(int l, int r){\\n            this.l = l;\\n            this.r = r;\\n        }\\n    }\\n\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int n = 0, m = nums.size();\\n        for (int i=0; i<m; ++i){\\n            n += nums.get(i).size();\\n        }\\n        \\n        pair[] ii = new pair[n];\\n        int last = 0;\\n        for (int i=0; i<m; ++i){\\n            for (int j=0; j<nums.get(i).size(); ++j){\\n                ii[last++] = new pair(nums.get(i).get(j),i);\\n            }\\n        }\\n        \\n        Arrays.sort(ii,(a,b)->a.l-b.l);\\n        \\n        int lb = 0, rb = 0, k = 0, ansl = 0, ansr = 1000000000;\\n        int[] freq = new int[m];\\n        for (; rb<n; ++rb){\\n            if (freq[ii[rb].r]==0) ++k;\\n            ++freq[ii[rb].r];\\n            while (freq[ii[lb].r]>1) --freq[ii[lb++].r];\\n            if (k==m){\\n                if ((ii[rb].l-ii[lb].l<ansr-ansl)){\\n                    ansr = ii[rb].l;\\n                    ansl = ii[lb].l;\\n                }\\n            }\\n        }\\n        return new int[] {ansl, ansr};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 469860,
                "title": "straightforward-solution-simple-sliding-window-w-o-priorityqueue",
                "content": "**NOTE**: Priority Queue will surely have better time complexity of NlogK, in contrast to my solution of NKlogK\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        vector<pair<int, int>> merge;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(auto num : nums[i])\\n                merge.push_back({ num, i });\\n        }\\n        sort(merge.begin(), merge.end());\\n        int ans = INT_MAX, start = 0;\\n        vector<int> ret;\\n        for(int i = 0; i < merge.size(); i++) {\\n            int val = merge[i].first, idx = merge[i].second;\\n            mp[idx]++;\\n            while(start < merge.size() && mp.size() == n) {\\n                int si = merge[start].second;\\n                bool flag = true;\\n                if(mp[si] == 1) {\\n                    flag = false;\\n                    break;\\n                }\\n                mp[si]--;\\n                start++;\\n            }\\n            int sval = merge[start].first;\\n            if(mp.size() == n && ans > val - sval) {\\n                ans = val - sval;\\n                ret = { sval, val };\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        vector<pair<int, int>> merge;\\n        for(int i = 0; i < nums.size(); i++) {\\n            for(auto num : nums[i])\\n                merge.push_back({ num, i });\\n        }\\n        sort(merge.begin(), merge.end());\\n        int ans = INT_MAX, start = 0;\\n        vector<int> ret;\\n        for(int i = 0; i < merge.size(); i++) {\\n            int val = merge[i].first, idx = merge[i].second;\\n            mp[idx]++;\\n            while(start < merge.size() && mp.size() == n) {\\n                int si = merge[start].second;\\n                bool flag = true;\\n                if(mp[si] == 1) {\\n                    flag = false;\\n                    break;\\n                }\\n                mp[si]--;\\n                start++;\\n            }\\n            int sval = merge[start].first;\\n            if(mp.size() == n && ans > val - sval) {\\n                ans = val - sval;\\n                ret = { sval, val };\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 360952,
                "title": "java-merge-sorted-lists-and-two-pointer-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        // Merge all the lists\\n        List<Integer> list = mergeLists(nums, 0, nums.size() - 1);\\n\\n        // Create map of value to the indexes of list that contains that value\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (Integer item : nums.get(i)) {\\n                Set<Integer> value = map.getOrDefault(item, new HashSet<>());\\n                value.add(i);\\n                map.put(item, value);\\n            }\\n        }\\n\\n        // Two pointer\\n        int start = 0, end = 0, count = 0;\\n        int[] counter = new int[nums.size()];\\n        int[] result = null;\\n\\n        while (end < list.size()) {\\n            // move from right\\n            Integer tmpEnd = list.get(end++);\\n            for (int pos : map.get(tmpEnd)) {\\n                counter[pos] += 1;\\n                if (counter[pos] == 1) count++;\\n            }\\n\\n            while (count == nums.size()) {\\n                // check result\\n                if (result == null) {\\n                    result = new int[]{list.get(start), tmpEnd};\\n                } else {\\n                    updateResult(list.get(start), tmpEnd, result);\\n                }\\n\\n                // move from left\\n                Integer tmp = list.get(start++);\\n                for (int pos : map.get(tmp)) {\\n                    counter[pos] -= 1;\\n                    if (counter[pos] == 0) count--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    private void updateResult(int startItem, int endItem, int[] result) {\\n        if (endItem - startItem < result[1] - result[0]) {\\n            result[0] = startItem;\\n            result[1] = endItem;\\n            return;\\n        }\\n        \\n        if (endItem - startItem == result[1] - result[0] && startItem < result[0]) {\\n            result[0] = startItem;\\n            result[1] = endItem;\\n        }\\n    }\\n    \\n    private List<Integer> mergeLists(List<List<Integer>> nums, int start, int end) {\\n        if (start == end) {\\n            return nums.get(start);\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        List<Integer> l1 = mergeLists(nums, start, mid);\\n        List<Integer> l2 = mergeLists(nums, mid + 1, end);\\n        return mergeTwoLists(l1, l2);\\n    }\\n    \\n    private List<Integer> mergeTwoLists(List<Integer> l1, List<Integer> l2) {\\n        List<Integer> result = new ArrayList<>(l1.size() + l2.size());\\n        int index1 = 0, index2 = 0;\\n        while (index1 < l1.size() || index2 < l2.size()) {\\n            if (index1 >= l1.size()) {\\n                checkAndAdd(result, l2.get(index2++));\\n                continue;\\n            }\\n\\n            if (index2 >= l2.size()) {\\n                checkAndAdd(result, l1.get(index1++));\\n                continue;\\n            }\\n\\n            if (l1.get(index1) <= l2.get(index2)) {\\n                checkAndAdd(result, l1.get(index1++));\\n            } else {\\n                checkAndAdd(result, l2.get(index2++));\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void checkAndAdd(List<Integer> a, Integer value) {\\n        if (a.isEmpty() || !a.get(a.size() - 1).equals(value)) a.add(value);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        // Merge all the lists\\n        List<Integer> list = mergeLists(nums, 0, nums.size() - 1);\\n\\n        // Create map of value to the indexes of list that contains that value\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        for (int i = 0; i < nums.size(); i++) {\\n            for (Integer item : nums.get(i)) {\\n                Set<Integer> value = map.getOrDefault(item, new HashSet<>());\\n                value.add(i);\\n                map.put(item, value);\\n            }\\n        }\\n\\n        // Two pointer\\n        int start = 0, end = 0, count = 0;\\n        int[] counter = new int[nums.size()];\\n        int[] result = null;\\n\\n        while (end < list.size()) {\\n            // move from right\\n            Integer tmpEnd = list.get(end++);\\n            for (int pos : map.get(tmpEnd)) {\\n                counter[pos] += 1;\\n                if (counter[pos] == 1) count++;\\n            }\\n\\n            while (count == nums.size()) {\\n                // check result\\n                if (result == null) {\\n                    result = new int[]{list.get(start), tmpEnd};\\n                } else {\\n                    updateResult(list.get(start), tmpEnd, result);\\n                }\\n\\n                // move from left\\n                Integer tmp = list.get(start++);\\n                for (int pos : map.get(tmp)) {\\n                    counter[pos] -= 1;\\n                    if (counter[pos] == 0) count--;\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n    \\n    private void updateResult(int startItem, int endItem, int[] result) {\\n        if (endItem - startItem < result[1] - result[0]) {\\n            result[0] = startItem;\\n            result[1] = endItem;\\n            return;\\n        }\\n        \\n        if (endItem - startItem == result[1] - result[0] && startItem < result[0]) {\\n            result[0] = startItem;\\n            result[1] = endItem;\\n        }\\n    }\\n    \\n    private List<Integer> mergeLists(List<List<Integer>> nums, int start, int end) {\\n        if (start == end) {\\n            return nums.get(start);\\n        }\\n        \\n        int mid = start + (end - start) / 2;\\n        List<Integer> l1 = mergeLists(nums, start, mid);\\n        List<Integer> l2 = mergeLists(nums, mid + 1, end);\\n        return mergeTwoLists(l1, l2);\\n    }\\n    \\n    private List<Integer> mergeTwoLists(List<Integer> l1, List<Integer> l2) {\\n        List<Integer> result = new ArrayList<>(l1.size() + l2.size());\\n        int index1 = 0, index2 = 0;\\n        while (index1 < l1.size() || index2 < l2.size()) {\\n            if (index1 >= l1.size()) {\\n                checkAndAdd(result, l2.get(index2++));\\n                continue;\\n            }\\n\\n            if (index2 >= l2.size()) {\\n                checkAndAdd(result, l1.get(index1++));\\n                continue;\\n            }\\n\\n            if (l1.get(index1) <= l2.get(index2)) {\\n                checkAndAdd(result, l1.get(index1++));\\n            } else {\\n                checkAndAdd(result, l2.get(index2++));\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private void checkAndAdd(List<Integer> a, Integer value) {\\n        if (a.isEmpty() || !a.get(a.size() - 1).equals(value)) a.add(value);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 289291,
                "title": "python-using-heap-queue",
                "content": "```\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        import heapq\\n        lo = float(\\'inf\\')\\n        hi = float(\\'-inf\\')\\n        heap = []\\n\\n        for idx, num in enumerate(nums):\\n            hi = max(hi, num[0])\\n            heapq.heappush(heap, (num[0], [idx, 1]))\\n        \\n        res = []\\n        while heap:\\n            lo, next = heapq.heappop(heap)\\n            if not res: res = [lo, hi]\\n            if res[1] - res[0] > hi - lo: res = [lo, hi]\\n\\n            if next[1] >= len(nums[next[0]]): return res\\n            new = nums[next[0]][next[1]]\\n            hi = max(hi, new)\\n            heapq.heappush(heap, (new, [next[0], next[1] + 1]))\\n\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def smallestRange(self, nums):\\n        \"\"\"\\n        :type nums: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        import heapq\\n        lo = float(\\'inf\\')\\n        hi = float(\\'-inf\\')\\n        heap = []\\n\\n        for idx, num in enumerate(nums):\\n            hi = max(hi, num[0])\\n            heapq.heappush(heap, (num[0], [idx, 1]))\\n        \\n        res = []\\n        while heap:\\n            lo, next = heapq.heappop(heap)\\n            if not res: res = [lo, hi]\\n            if res[1] - res[0] > hi - lo: res = [lo, hi]\\n\\n            if next[1] >= len(nums[next[0]]): return res\\n            new = nums[next[0]][next[1]]\\n            hi = max(hi, new)\\n            heapq.heappush(heap, (new, [next[0], next[1] + 1]))\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 267486,
                "title": "python-3-solution-94-67",
                "content": "Idea comes from: https://www.youtube.com/watch?v=zplklOy7ENo\\nand @ArizonaTea\\n\\nA Python 3 implementation with small modifications:\\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        from heapq import heappush, heappop, heapify\\n\\n        lens = [len(row) for row in nums]\\n        pointers = [0] * len(nums)\\n\\n        hp = []\\n        min_ = minRangeMin = float(\\'inf\\')\\n        max_ = minRangeMax = -float(\\'inf\\')\\n        range_ = minRange = float(\\'inf\\')\\n\\n        for i, row in enumerate(nums):\\n            heappush(hp, (row[0], i))\\n            max_ = max(max_, row[0])\\n\\n        while True:\\n            min_, idx = heappop(hp)\\n            range_ = max_ - min_\\n            if range_ < minRange:\\n                if range_ == 0:\\n                    return [min_, max_]\\n                minRange = range_\\n                minRangeMin = min_\\n                minRangeMax = max_\\n\\n            pointers[idx] += 1\\n            if pointers[idx] == lens[idx]:\\n                return [minRangeMin, minRangeMax]\\n\\n            max_ = max(max_, nums[idx][pointers[idx]])\\n            heappush(hp, (nums[idx][pointers[idx]], idx))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        from heapq import heappush, heappop, heapify\\n\\n        lens = [len(row) for row in nums]\\n        pointers = [0] * len(nums)\\n\\n        hp = []\\n        min_ = minRangeMin = float(\\'inf\\')\\n        max_ = minRangeMax = -float(\\'inf\\')\\n        range_ = minRange = float(\\'inf\\')\\n\\n        for i, row in enumerate(nums):\\n            heappush(hp, (row[0], i))\\n            max_ = max(max_, row[0])\\n\\n        while True:\\n            min_, idx = heappop(hp)\\n            range_ = max_ - min_\\n            if range_ < minRange:\\n                if range_ == 0:\\n                    return [min_, max_]\\n                minRange = range_\\n                minRangeMin = min_\\n                minRangeMax = max_\\n\\n            pointers[idx] += 1\\n            if pointers[idx] == lens[idx]:\\n                return [minRangeMin, minRangeMax]\\n\\n            max_ = max(max_, nums[idx][pointers[idx]])\\n            heappush(hp, (nums[idx][pointers[idx]], idx))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246377,
                "title": "python-heap-o-n-log-k",
                "content": "N = total # of elements \\n```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        from heapq import heappush, heappop, heapify\\n        \\n        lens = [len(lst) for lst in nums]\\n        pointers = [0 for _ in range(len(nums))]\\n        min_cand, max_cand, range_cand = None, None, float(\\'inf\\')\\n        min_cur, max_cur, range_cur = None, float(\\'-inf\\'), None\\n        \\n        hp = []\\n        for i, lst in enumerate(nums):\\n            heappush(hp, (lst[0], i))\\n            max_cur = max(max_cur, lst[0])\\n            \\n        while True:\\n            min_cur, idx = heappop(hp)\\n            range_cur = max_cur - min_cur\\n            \\n            if range_cur < range_cand:\\n                if min_cur == max_cur:\\n                    return [min_cur, max_cur]\\n                min_cand, max_cand, range_cand = min_cur, max_cur, range_cur\\n                    \\n            pointers[idx] += 1\\n            if pointers[idx] == lens[idx]:\\n                break\\n            \\n            max_cur = max(max_cur, nums[idx][pointers[idx]])\\n            heappush(hp, (nums[idx][pointers[idx]], idx))\\n            \\n        return [min_cand, max_cand]\\n                \\n            \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        from heapq import heappush, heappop, heapify\\n        \\n        lens = [len(lst) for lst in nums]\\n        pointers = [0 for _ in range(len(nums))]\\n        min_cand, max_cand, range_cand = None, None, float(\\'inf\\')\\n        min_cur, max_cur, range_cur = None, float(\\'-inf\\'), None\\n        \\n        hp = []\\n        for i, lst in enumerate(nums):\\n            heappush(hp, (lst[0], i))\\n            max_cur = max(max_cur, lst[0])\\n            \\n        while True:\\n            min_cur, idx = heappop(hp)\\n            range_cur = max_cur - min_cur\\n            \\n            if range_cur < range_cand:\\n                if min_cur == max_cur:\\n                    return [min_cur, max_cur]\\n                min_cand, max_cand, range_cand = min_cur, max_cur, range_cur\\n                    \\n            pointers[idx] += 1\\n            if pointers[idx] == lens[idx]:\\n                break\\n            \\n            max_cur = max(max_cur, nums[idx][pointers[idx]])\\n            heappush(hp, (nums[idx][pointers[idx]], idx))\\n            \\n        return [min_cand, max_cand]\\n                \\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 236073,
                "title": "java-no-extra-class-required-only-one-priority-queue",
                "content": "\\'\\'\\'class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums == null || nums.isEmpty()) {\\n            return null;\\n        }\\n        PriorityQueue<List<Integer>> pq = new PriorityQueue<List<Integer>>(new Comparator<List<Integer>>() {\\n            @Override public int compare(List<Integer> l1, List<Integer> l2){\\n                return l1.get(0)-l2.get(0);\\n            }\\n        });\\n        int max = Integer.MIN_VALUE;\\n        for (List<Integer> list : nums) {\\n            if (list.size()> 0) {\\n                 pq.offer(list); \\n            }\\n            max = Math.max(max,list.get(0));\\n        }\\n        int[] result= new int[2];\\n        int range = Integer.MAX_VALUE;\\n        while (pq.size() == nums.size()) {\\n            if( max-pq.peek().get(0) < range){\\n                range = max - pq.peek().get(0);\\n                result[0]=pq.peek().get(0);\\n                result[1] = max;\\n            }\\n            List<Integer> temp = pq.poll();\\n            temp.remove(0);\\n            if (!temp.isEmpty()) {\\n                pq.offer(temp);\\n                 max = Math.max(max,temp.get(0));\\n            } \\n        }\\n        return result;\\n    }\\n}\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        if(nums == null || nums.isEmpty()) {\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 181561,
                "title": "c-solution-with-priority-queue-and-just-using-iterators",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    using riter = vector<int>::reverse_iterator;\\n    using priter = pair<riter,riter>;\\n    \\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        auto gcomp = [](const priter &p1, const priter &p2)->bool{\\n            int c1 = *p1.first;\\n            int c2 = *p2.first;\\n            return c1 < c2;\\n        };\\n             \\n        int minVal = INT_MAX;\\n        priority_queue<priter,vector<priter>,decltype(gcomp)> maxq(gcomp);\\n        \\n        for(auto &v : nums){\\n            minVal = min(minVal,v.back());\\n            maxq.emplace(v.rbegin(),v.rend());\\n        }\\n        \\n        int maxRange = INT_MAX;\\n        vector<int> res(2,0);\\n        while(1){\\n            auto maxfront = maxq.top();\\n            int range = *(maxfront.first) - minVal;\\n            \\n            if(range <= maxRange){\\n                maxRange = range;\\n                res[0] = minVal;\\n                res[1] = *(maxfront.first);\\n            }\\n                        \\n            maxfront.first++;\\n\\n            if(maxfront.first == maxfront.second){\\n                break;\\n            }\\n            \\n            maxq.pop();\\n            minVal = min(minVal,*(maxfront.first));\\n            maxq.emplace(maxfront.first,maxfront.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    using riter = vector<int>::reverse_iterator;\\n    using priter = pair<riter,riter>;\\n    \\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        \\n        auto gcomp = [](const priter &p1, const priter &p2)->bool{\\n            int c1 = *p1.first;\\n            int c2 = *p2.first;\\n            return c1 < c2;\\n        };\\n             \\n        int minVal = INT_MAX;\\n        priority_queue<priter,vector<priter>,decltype(gcomp)> maxq(gcomp);\\n        \\n        for(auto &v : nums){\\n            minVal = min(minVal,v.back());\\n            maxq.emplace(v.rbegin(),v.rend());\\n        }\\n        \\n        int maxRange = INT_MAX;\\n        vector<int> res(2,0);\\n        while(1){\\n            auto maxfront = maxq.top();\\n            int range = *(maxfront.first) - minVal;\\n            \\n            if(range <= maxRange){\\n                maxRange = range;\\n                res[0] = minVal;\\n                res[1] = *(maxfront.first);\\n            }\\n                        \\n            maxfront.first++;\\n\\n            if(maxfront.first == maxfront.second){\\n                break;\\n            }\\n            \\n            maxq.pop();\\n            minVal = min(minVal,*(maxfront.first));\\n            maxq.emplace(maxfront.first,maxfront.second);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157049,
                "title": "c-merge-list-and-sliding-window",
                "content": "```\\npublic class Solution {\\n    public int[] SmallestRange(IList<IList<int>> nums) {\\n        var list = new List<Tuple<int,int>>();\\n\\n        // merge lists\\n        for (int k=0; k<nums.Count; k++) {\\n            for (int i=0; i<nums[k].Count; i++) {\\n                list.Add(new Tuple<int,int>(nums[k][i],k));\\n            }\\n        }\\n        \\n        list = list.OrderBy(i => i.Item1).ToList();\\n        \\n        var (min, max)=(list[0].Item1,list[list.Count-1].Item1);\\n        int range = max-min;\\n        var f = new int[nums.Count];\\n        \\n        var c = 0;\\n        int left=0; \\n        int right=0;\\n        \\n        \\n        // sliding window\\n        while (right < list.Count) {\\n            if (f[list[right].Item2]++==0) c++;\\n            \\n            //contract\\n            while (c==nums.Count && left<right) {\\n                if (list[right].Item1-list[left].Item1<range) {\\n                    (min, max) = (list[left].Item1, list[right].Item1);\\n                    range = max-min;\\n                }\\n                \\n                if (--f[list[left].Item2]==0) c--;\\n                left++;\\n            }  \\n            right++;\\n        }\\n        \\n        return new int[2] {min,max};\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallestRange(IList<IList<int>> nums) {\\n        var list = new List<Tuple<int,int>>();\\n\\n        // merge lists\\n        for (int k=0; k<nums.Count; k++) {\\n            for (int i=0; i<nums[k].Count; i++) {\\n                list.Add(new Tuple<int,int>(nums[k][i],k));\\n            }\\n        }\\n        \\n        list = list.OrderBy(i => i.Item1).ToList();\\n        \\n        var (min, max)=(list[0].Item1,list[list.Count-1].Item1);\\n        int range = max-min;\\n        var f = new int[nums.Count];\\n        \\n        var c = 0;\\n        int left=0; \\n        int right=0;\\n        \\n        \\n        // sliding window\\n        while (right < list.Count) {\\n            if (f[list[right].Item2]++==0) c++;\\n            \\n            //contract\\n            while (c==nums.Count && left<right) {\\n                if (list[right].Item1-list[left].Item1<range) {\\n                    (min, max) = (list[left].Item1, list[right].Item1);\\n                    range = max-min;\\n                }\\n                \\n                if (--f[list[left].Item2]==0) c--;\\n                left++;\\n            }  \\n            right++;\\n        }\\n        \\n        return new int[2] {min,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 147475,
                "title": "16ms-c-readable-single-loop-priority-queue-solution-beating-100",
                "content": "```\\n#include <queue>\\n#include <vector>\\n#include <limits>\\nstruct Cmp{\\n  // needed to build minHeap (priority queue) with pairs\\n  bool operator()(const pair<int, pair<int, int>> left, const pair<int, pair<int, int>> right) const{\\n    return left.first > right.first;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n      priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, Cmp> pq;\\n      // build up priority queue from front values and identify max element among those numbers\\n      int rangeMax = numeric_limits<int>::min();\\n      int rangeMin = numeric_limits<int>::max();\\n      int curMin, curMax;\\n      int N = nums.size();\\n      for(int k=0; k<N; ++k){\\n        pair<int, pair<int, int>> mypair = make_pair(nums[k][0], make_pair(k,0));\\n        pq.push(mypair);\\n        if(nums[k][0]<rangeMin){rangeMin = nums[k][0];}\\n        if(nums[k][0]>rangeMax){rangeMax = nums[k][0]; curMax = rangeMax;}\\n      }\\n      // iterare through the vectors while updating priority queue\\n      while(true){\\n        // consider current range by looking at minimum element in priority queue\\n        pair<int, pair<int, int>> p = pq.top();\\n        curMin = p.first;\\n        int kVec = p.second.first;\\n        int kIdx = p.second.second;\\n        // check if new range is smaller\\n        if(curMax-curMin < rangeMax-rangeMin){\\n          rangeMin = curMin;\\n          rangeMax = curMax;\\n        }\\n        // pop minimum and push next element of the corresponding vector if exists. Otherwise, we are done.\\n        pq.pop();\\n        if(kIdx+1 >= int(nums[kVec].size())){\\n          break;\\n        }else{\\n          int val = nums[kVec][kIdx+1];\\n          pq.push(make_pair(val, make_pair(kVec, kIdx+1)));\\n          if(val > curMax){\\n            curMax = val;\\n          }\\n        }\\n      }\\n      vector<int> res;\\n      res.push_back(rangeMin);\\n      res.push_back(rangeMax);\\n      return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <queue>\\n#include <vector>\\n#include <limits>\\nstruct Cmp{\\n  // needed to build minHeap (priority queue) with pairs\\n  bool operator()(const pair<int, pair<int, int>> left, const pair<int, pair<int, int>> right) const{\\n    return left.first > right.first;\\n  }\\n};\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n      priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, Cmp> pq;\\n      // build up priority queue from front values and identify max element among those numbers\\n      int rangeMax = numeric_limits<int>::min();\\n      int rangeMin = numeric_limits<int>::max();\\n      int curMin, curMax;\\n      int N = nums.size();\\n      for(int k=0; k<N; ++k){\\n        pair<int, pair<int, int>> mypair = make_pair(nums[k][0], make_pair(k,0));\\n        pq.push(mypair);\\n        if(nums[k][0]<rangeMin){rangeMin = nums[k][0];}\\n        if(nums[k][0]>rangeMax){rangeMax = nums[k][0]; curMax = rangeMax;}\\n      }\\n      // iterare through the vectors while updating priority queue\\n      while(true){\\n        // consider current range by looking at minimum element in priority queue\\n        pair<int, pair<int, int>> p = pq.top();\\n        curMin = p.first;\\n        int kVec = p.second.first;\\n        int kIdx = p.second.second;\\n        // check if new range is smaller\\n        if(curMax-curMin < rangeMax-rangeMin){\\n          rangeMin = curMin;\\n          rangeMax = curMax;\\n        }\\n        // pop minimum and push next element of the corresponding vector if exists. Otherwise, we are done.\\n        pq.pop();\\n        if(kIdx+1 >= int(nums[kVec].size())){\\n          break;\\n        }else{\\n          int val = nums[kVec][kIdx+1];\\n          pq.push(make_pair(val, make_pair(kVec, kIdx+1)));\\n          if(val > curMax){\\n            curMax = val;\\n          }\\n        }\\n      }\\n      vector<int> res;\\n      res.push_back(rangeMin);\\n      res.push_back(rangeMax);\\n      return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 118161,
                "title": "10-lines-merge-k-lists-o-nlogk",
                "content": "Used some C# new languages features to make it readable and concise.\n\n```\n/// <summary>\n/// Time: O(nlogk).\n/// \n/// Use sorted set min max to find current range. Terminate as soon as one of the list is exhausted. This is\n/// optimal because the last element of the exhausted list is the smallest value (`x`) in queue. So the\n/// range was [x, y], y is from some other list. If we were to keep x but enumerate any other list, the range \n/// will become [x, z] where z >= y, which is not optimal than [x,y].\n/// \n/// Also note since the ranges are enumerated from small to large, when U-L == u-l, we don't need to update (L,U),\n/// since l >= u.\n/// </summary>\npublic class Solution\n{\n    public int[] SmallestRange(IList<IList<int>> nums)\n    {\n        int k = nums.Count;\n        var q = new SortedSet<(int V, int I, int G)>();\n        for (int i = 0; i < k; i++) if (0 < nums[i].Count) q.Add((nums[i][0], 0, i));\n        var (L, U) = (0, -1);\n        while (q.Count == k)\n        {\n            var (l, u) = (q.Min.V, q.Max.V);\n            if (L > U || U - L > u - l) (L, U) = (l, u);\n            var (v, i, g) = q.Min; q.Remove((v, i, g));\n            if (i + 1 < nums[g].Count) q.Add((nums[g][i + 1], i + 1, g));\n        }\n\n        return new[] { L, U };\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n/// <summary>\n/// Time: O(nlogk).\n/// \n/// Use sorted set min max to find current range. Terminate as soon as one of the list is exhausted. This is\n/// optimal because the last element of the exhausted list is the smallest value (`x`) in queue. So the\n/// range was [x, y], y is from some other list. If we were to keep x but enumerate any other list, the range \n/// will become [x, z] where z >= y, which is not optimal than [x,y].\n/// \n/// Also note since the ranges are enumerated from small to large, when U-L == u-l, we don't need to update (L,U),\n/// since l >= u.\n/// </summary>\npublic class Solution\n{\n    public int[] SmallestRange(IList<IList<int>> nums)\n    {\n        int k = nums.Count;\n        var q = new SortedSet<(int V, int I, int G)>();\n        for (int i = 0; i < k; i++) if (0 < nums[i].Count) q.Add((nums[i][0], 0, i));\n        var (L, U) = (0, -1);\n        while (q.Count == k)\n        {\n            var (l, u) = (q.Min.V, q.Max.V);\n            if (L > U || U - L > u - l) (L, U) = (l, u);\n            var (v, i, g) = q.Min; q.Remove((v, i, g));\n            if (i + 1 < nums[g].Count) q.Add((nums[g][i + 1], i + 1, g));\n        }\n\n        return new[] { L, U };\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 104919,
                "title": "c-accept-solution",
                "content": "Idea: from end to start, using quick select to insert index. \\nevery time find the biggest value of index(in nums array), remove it and insert it's next small one, until the biggest value of index == 0; \\n\\n```\\npublic class Solution {\\n    public int[] SmallestRange(IList<IList<int>> nums) {\\n        var list = new List<int>();\\n        int len = nums.Count;\\n        var indexArr = new int[len];\\n        for(int i = 0;i<len;i++){\\n            indexArr[i] = nums[i].Count-1;\\n            int index = FindIndex(list,i,nums,indexArr);\\n            list.Insert(index,i);\\n        }\\n        //Console.WriteLine(string.Join(\",\",indexArr));\\n        int[] result = new int[]{nums[list.First()][indexArr[list.First()]],nums[list.Last()][indexArr[list.Last()]]};\\n        \\n        while(true){\\n            var lastIndex = list.Last();\\n            if(--indexArr[lastIndex] == -1)\\n                break;\\n        \\t//Console.WriteLine(j+\",\"+indexArr[j]);\\n            list.RemoveAt(list.Count-1);\\n            \\n        \\tlist.Insert(FindIndex(list,lastIndex,nums,indexArr),lastIndex);\\n            \\n        \\tint n1 = nums[list.First()][indexArr[list.First()]];\\n        \\tint n2 = nums[list.Last()][indexArr[list.Last()]];\\n            \\n            if(n2-n1 < result[1]-result[0] || n2-n1 == result[1]-result[0] && n1 < result[0]){\\n                result[0] = n1;\\n                result[1] = n2;\\n            }   \\n            //Console.WriteLine(string.Join(\",\",list));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int FindIndex(List<int> list,int index,IList<IList<int>> nums,int[] indexArr){\\n        if(list.Count == 0)\\n        \\treturn 0;\\n        \\n        int low = 0;\\n        int high = list.Count-1;\\n        int v = nums[index][indexArr[index]];\\n        while(low < high-1){\\n            int mid = low + (high-low)/2;\\n            \\n            int mid_v = nums[list[mid]][indexArr[list[mid]]];\\n            \\n            if(mid_v == v)\\n                return mid;\\n            else if(mid_v < v)\\n                low = mid;\\n        \\telse\\n                high = mid;\\n        }\\n        if(nums[list[low]][indexArr[list[low]]] >= v)\\n            return low;\\n        else if(nums[list[high]][indexArr[list[high]]]>= v)\\n            return high;\\n        else\\n            return high+1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallestRange(IList<IList<int>> nums) {\\n        var list = new List<int>();\\n        int len = nums.Count;\\n        var indexArr = new int[len];\\n        for(int i = 0;i<len;i++){\\n            indexArr[i] = nums[i].Count-1;\\n            int index = FindIndex(list,i,nums,indexArr);\\n            list.Insert(index,i);\\n        }\\n        //Console.WriteLine(string.Join(\",\",indexArr));\\n        int[] result = new int[]{nums[list.First()][indexArr[list.First()]],nums[list.Last()][indexArr[list.Last()]]};\\n        \\n        while(true){\\n            var lastIndex = list.Last();\\n            if(--indexArr[lastIndex] == -1)\\n                break;\\n        \\t//Console.WriteLine(j+\",\"+indexArr[j]);\\n            list.RemoveAt(list.Count-1);\\n            \\n        \\tlist.Insert(FindIndex(list,lastIndex,nums,indexArr),lastIndex);\\n            \\n        \\tint n1 = nums[list.First()][indexArr[list.First()]];\\n        \\tint n2 = nums[list.Last()][indexArr[list.Last()]];\\n            \\n            if(n2-n1 < result[1]-result[0] || n2-n1 == result[1]-result[0] && n1 < result[0]){\\n                result[0] = n1;\\n                result[1] = n2;\\n            }   \\n            //Console.WriteLine(string.Join(\",\",list));\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private int FindIndex(List<int> list,int index,IList<IList<int>> nums,int[] indexArr){\\n        if(list.Count == 0)\\n        \\treturn 0;\\n        \\n        int low = 0;\\n        int high = list.Count-1;\\n        int v = nums[index][indexArr[index]];\\n        while(low < high-1){\\n            int mid = low + (high-low)/2;\\n            \\n            int mid_v = nums[list[mid]][indexArr[list[mid]]];\\n            \\n            if(mid_v == v)\\n                return mid;\\n            else if(mid_v < v)\\n                low = mid;\\n        \\telse\\n                high = mid;\\n        }\\n        if(nums[list[low]][indexArr[list[low]]] >= v)\\n            return low;\\n        else if(nums[list[high]][indexArr[list[high]]]>= v)\\n            return high;\\n        else\\n            return high+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 104922,
                "title": "slide-window-solution-without-priorityqueue",
                "content": "This is the same idea as https://discuss.leetcode.com/topic/87884/8-lines-slide-window-solution-in-java\\n```\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<int[]> list= new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            for(int x : nums.get(i)) {\\n                list.add(new int[]{x, i});\\n            }\\n        }\\n        Collections.sort(list, (a,b) -> (a[0] - b[0]));\\n        int min = -1, max = 2000000, count = 0, pre = 0;\\n        int[] flag = new int[k];\\n        for(int i = 0; i < list.size(); i++) {\\n            int[] e = list.get(i);\\n            if (flag[e[1]]++ == 0) {\\n                count++;\\n                while(count == k) {\\n                    if (e[0] - list.get(pre)[0] < max - min) {\\n                        min = list.get(pre)[0];\\n                        max = e[0];\\n                    }\\n                    if (--flag[list.get(pre++)[1]] == 0) count--;\\n                }\\n            }\\n        }\\n        \\n        return new int[] {min, max};\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] smallestRange(List<List<Integer>> nums) {\\n        int k = nums.size();\\n        List<int[]> list= new ArrayList<>();\\n        for(int i = 0; i < k; i++) {\\n            for(int x : nums.get(i)) {\\n                list.add(new int[]{x, i});\\n            }\\n        }\\n        Collections.sort(list, (a,b) -> (a[0] - b[0]));\\n        int min = -1, max = 2000000, count = 0, pre = 0;\\n        int[] flag = new int[k];\\n        for(int i = 0; i < list.size(); i++) {\\n            int[] e = list.get(i);\\n            if (flag[e[1]]++ == 0) {\\n                count++;\\n                while(count == k) {\\n                    if (e[0] - list.get(pre)[0] < max - min) {\\n                        min = list.get(pre)[0];\\n                        max = e[0];\\n                    }\\n                    if (--flag[list.get(pre++)[1]] == 0) count--;\\n                }\\n            }\\n        }\\n        \\n        return new int[] {min, max};\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 104913,
                "title": "python-heap-solution-with-explanation",
                "content": "Suppose we have formed a range with one element from each list. We can form another range by advancing one value along its belonging list. If we're not advancing the smallest value, the left bound will remain unchanged and the right bound will be increased. It's impossible to find the smallest range within such searching space. In other words, it's safe to advancing the smallest value in the current range.\\n```\\ndef smallestRange(self, nums):\\n    iters = [iter(l) for l in nums]\\n    heap = [(next(it), i) for i,it in enumerate(iters)]\\n    heapq.heapify(heap)\\n\\n    lo, hi = 0, float('inf')\\n    rbound = max(heap)[0]\\n    while True:\\n        lbound, i = heap[0]\\n        if rbound - lbound < hi - lo:\\n            lo, hi = lbound, rbound\\n        nxt = next(iters[i], None)\\n        if nxt is None:\\n            return [lo, hi]\\n        rbound = max(rbound, nxt)\\n        heapq.heappushpop(heap, (nxt,i))\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallestRange(self, nums):\\n    iters = [iter(l) for l in nums]\\n    heap = [(next(it), i) for i,it in enumerate(iters)]\\n    heapq.heapify(heap)\\n\\n    lo, hi = 0, float('inf')\\n    rbound = max(heap)[0]\\n    while True:\\n        lbound, i = heap[0]\\n        if rbound - lbound < hi - lo:\\n            lo, hi = lbound, rbound\\n        nxt = next(iters[i], None)\\n        if nxt is None:\\n            return [lo, hi]\\n        rbound = max(rbound, nxt)\\n        heapq.heappushpop(heap, (nxt,i))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 104926,
                "title": "my-java-accepted-code-with-priority-queue-revised-easier-to-read",
                "content": "class MyNumber{\\n\\n      int num;\\n      int indexInArray;\\n      int arrNum;\\n      public MyNumber(int num, int indexInArray, int arrNum) {\\n              this.num = num;\\n              this.indexInArray = indexInArray;\\n              this.arrNum = arrNum;\\n       }\\n}\\n\\n'''\\npublic int[] smallestRange(int[][] nums) {\\n\\n    list itemint[] res = new int[2];\\n    int minRangeSize = Integer.MAX_VALUE;\\n    if (nums == null) return res;\\n    PriorityQueue<MyNumber> queue = new PriorityQueue<MyNumber>\\n      (nums.length, new Comparator<MyNumber>(){\\n        public int compare(MyNumber myNum1, MyNumber myNum2) {\\n            return myNum1.num - myNum2.num;\\n        }\\n    });\\n\\n    int maxValue = nums[0][0];\\n    for (int i = 0; i < nums.length; i++) {\\n         maxValue = Math.max(maxValue, nums[i][0]);\\n         MyNumber myNum = new MyNumber(nums[i][0], 0, i);\\n         queue.offer(myNum);\\n    }\\n\\n    while (!queue.isEmpty()) {\\n         MyNumber myNum = queue.poll();\\n         if (maxValue - myNum.num < minRangeSize) {\\n             minRangeSize = maxValue - myNum.num;\\n             res[0] = myNum.num;\\n             res[1] = maxValue;\\n         }\\n    \\n        if (myNum.indexInArray == nums[myNum.arrNum].length - 1) {\\n            break;\\n        } else {\\n            int cur = nums[myNum.arrNum][myNum.indexInArray + 1];\\n            myNum = new MyNumber(cur, myNum.indexInArray + 1, myNum.arrNum);\\n            maxValue = Math.max(maxValue, cur);\\n            queue.offer(myNum);\\n       }\\n    }\\n    return res;\\n}\\n'''",
                "solutionTags": [],
                "code": "class MyNumber{\\n\\n      int num;\\n      int indexInArray;\\n      int arrNum;\\n      public MyNumber(int num, int indexInArray, int arrNum) {\\n              this.num = num;\\n              this.indexInArray = indexInArray;\\n              this.arrNum = arrNum;\\n       }\\n}\\n\\n'''\\npublic int[] smallestRange(int[][] nums) {\\n\\n    list itemint[] res = new int[2];\\n    int minRangeSize = Integer.MAX_VALUE;\\n    if (nums == null) return res;\\n    PriorityQueue<MyNumber> queue = new PriorityQueue<MyNumber>\\n      (nums.length, new Comparator<MyNumber>(){\\n        public int compare(MyNumber myNum1, MyNumber myNum2) {\\n            return myNum1.num - myNum2.num;\\n        }\\n    });\\n\\n    int maxValue = nums[0][0];\\n    for (int i = 0; i < nums.length; i++) {\\n         maxValue = Math.max(maxValue, nums[i][0]);\\n         MyNumber myNum = new MyNumber(nums[i][0], 0, i);\\n         queue.offer(myNum);\\n    }\\n\\n    while (!queue.isEmpty()) {\\n         MyNumber myNum = queue.poll();\\n         if (maxValue - myNum.num < minRangeSize) {\\n             minRangeSize = maxValue - myNum.num;\\n             res[0] = myNum.num;\\n             res[1] = maxValue;\\n         }\\n    \\n        if (myNum.indexInArray == nums[myNum.arrNum].length - 1) {\\n            break;\\n        } else {\\n            int cur = nums[myNum.arrNum][myNum.indexInArray + 1];\\n            myNum = new MyNumber(cur, myNum.indexInArray + 1, myNum.arrNum);\\n            maxValue = Math.max(maxValue, cur);\\n            queue.offer(myNum);\\n       }\\n    }\\n    return res;\\n}\\n'''",
                "codeTag": "Java"
            },
            {
                "id": 104915,
                "title": "my-accepted-java-code-below-using-priorityqueue",
                "content": "My accepted code below using priorityQueue\\n\"\"\\nclass MyNumber{\\n    int num;\\n    int indexInArray;\\n    int arrNum;\\n    \\n    public MyNumber(int num, int indexInArray, int arrNum) {\\n        this.num = num;\\n        this.indexInArray = indexInArray;\\n        this.arrNum = arrNum;\\n    }\\n}\\npublic class Solution {\\n    public int[] smallestRange(int[][] nums) {\\n        int[] res = new int[2];\\n        int minRangeSize = Integer.MAX_VALUE;\\n        if (nums == null) return res;\\n        \\n        PriorityQueue<MyNumber> queue = new PriorityQueue<MyNumber>(nums.length, new Comparator<MyNumber>(){\\n                public int compare(MyNumber myNum1, MyNumber myNum2) {\\n                    return myNum1.num - myNum2.num;\\n                }\\n        });\\n        \\n        int maxValue = nums[0][0];\\n        for (int i = 0; i < nums.length; i++) {\\n            maxValue = Math.max(maxValue, nums[i][0]);\\n            MyNumber myNum = new MyNumber(nums[i][0], 0, i);\\n            queue.offer(myNum);\\n        }\\n        \\n        while (!queue.isEmpty()) {\\n            MyNumber myNum = queue.poll();\\n            if (maxValue - myNum.num < minRangeSize) {\\n                minRangeSize = maxValue - myNum.num;\\n                res[0] = myNum.num;\\n                res[1] = maxValue;\\n            }\\n            \\n            if (myNum.indexInArray == nums[myNum.arrNum].length - 1) {\\n                break;\\n            } else {\\n                int cur = nums[myNum.arrNum][myNum.indexInArray + 1];\\n                myNum = new MyNumber(cur, myNum.indexInArray + 1, myNum.arrNum);\\n                maxValue = Math.max(maxValue, cur);\\n                queue.offer(myNum);\\n            }\\n        }\\n        \\n        \\n        return res;\\n\\n        \\n    }\\n}\\n\"\"",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallestRange(int[][] nums) {\\n        int[] res = new int[2];\\n        int minRangeSize = Integer.MAX_VALUE;\\n        if (nums == null) return res;\\n        \\n        PriorityQueue<MyNumber> queue = new PriorityQueue<MyNumber>(nums.length, new Comparator<MyNumber>(){\\n                public int compare(MyNumber myNum1, MyNumber myNum2) {\\n                    return myNum1.num - myNum2.num;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4098303,
                "title": "solution-using-heap-python",
                "content": "\\n\\n# Complexity\\n# - Time complexity:O(N*k log k)\\n\\n# - Space complexity: O(k)\\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        h=[]\\n        k=len(nums)\\n        maxi=-(1<<31)\\n        mini=1<<31\\n        for i in range(len(nums)):\\n            heapq.heappush(h,(nums[i][0],i,0))\\n            maxi=max(maxi,nums[i][0])\\n            mini=min(mini,nums[i][0])\\n        ansStart=mini\\n        ansEnd=maxi\\n        ansRange=ansEnd-ansStart\\n\\n        while len(h)>=k:\\n            mini,row,col=heapq.heappop(h)\\n            currStart=mini\\n            currEnd=maxi\\n            currRange=currEnd-currStart\\n            ansRange=ansEnd-ansStart\\n            if currRange<ansRange:\\n                ansStart=currStart\\n                ansEnd=currEnd\\n            if col+1<len(nums[row]):\\n                heapq.heappush(h,(nums[row][col+1],row,col+1))\\n                maxi=max(maxi,nums[row][col+1])\\n        return [ansStart,ansEnd]\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def smallestRange(self, nums: List[List[int]]) -> List[int]:\\n        h=[]\\n        k=len(nums)\\n        maxi=-(1<<31)\\n        mini=1<<31\\n        for i in range(len(nums)):\\n            heapq.heappush(h,(nums[i][0],i,0))\\n            maxi=max(maxi,nums[i][0])\\n            mini=min(mini,nums[i][0])\\n        ansStart=mini\\n        ansEnd=maxi\\n        ansRange=ansEnd-ansStart\\n\\n        while len(h)>=k:\\n            mini,row,col=heapq.heappop(h)\\n            currStart=mini\\n            currEnd=maxi\\n            currRange=currEnd-currStart\\n            ansRange=ansEnd-ansStart\\n            if currRange<ansRange:\\n                ansStart=currStart\\n                ansEnd=currEnd\\n            if col+1<len(nums[row]):\\n                heapq.heappush(h,(nums[row][col+1],row,col+1))\\n                maxi=max(maxi,nums[row][col+1])\\n        return [ansStart,ansEnd]\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089624,
                "title": "easy-c-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector <pair<int,int>> f;\\n        for (int i = 0 ;i < nums.size() ; i++){\\n            for (auto j : nums[i]){\\n                f.push_back({j,i + 1});\\n            }\\n        }\\n        int k = nums.size();\\n        vector<int> ans;\\n        int range = INT_MAX;\\n        sort(f.begin(),f.end());\\n        map<int,int> one;\\n        int i = 0;\\n        int j = 0;\\n        while (j < f.size()){\\n            one[f[j].second]++;\\n            if (one.size() == k){\\n                while (one[f[i].second] > 1){\\n                    one[f[i].second]--;\\n                    i++;\\n                }\\n                if (range > f[j].first - f[i].first){\\n                    range = f[j].first - f[i].first;\\n                    ans = {f[i].first,f[j].first};\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        vector <pair<int,int>> f;\\n        for (int i = 0 ;i < nums.size() ; i++){\\n            for (auto j : nums[i]){\\n                f.push_back({j,i + 1});\\n            }\\n        }\\n        int k = nums.size();\\n        vector<int> ans;\\n        int range = INT_MAX;\\n        sort(f.begin(),f.end());\\n        map<int,int> one;\\n        int i = 0;\\n        int j = 0;\\n        while (j < f.size()){\\n            one[f[j].second]++;\\n            if (one.size() == k){\\n                while (one[f[i].second] > 1){\\n                    one[f[i].second]--;\\n                    i++;\\n                }\\n                if (range > f[j].first - f[i].first){\\n                    range = f[j].first - f[i].first;\\n                    ans = {f[i].first,f[j].first};\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1790055,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1571789,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1646350,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 2037903,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1848999,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1725266,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            },
            {
                "id": 1773167,
                "content": [
                    {
                        "username": "raghavrathore7415",
                        "content": "I was able to come up with a pq solution maybe i m getting better:)"
                    },
                    {
                        "username": "Jason_Chu",
                        "content": "Congrats! How did you come up with that approach? Can you share me some insights? I\\'m stuck at this problem even after watching some explanation videos."
                    },
                    {
                        "username": "huluta",
                        "content": "Either I am not getting it right, either my English is not good enough either the problem is not clearly stated.\\n\\nHere is the part that confuses me: **Find the smallest range that includes at least one number from each of the k lists.**\\nIn the provided example the smallest range found is made out of two elements (20 and 24) but none of those elements belongs to all of the provided K lists (that is what I understand by *from each of the k lists*).\\nCan you please shed some light?"
                    },
                    {
                        "username": "pieceofpie",
                        "content": "Hi! Happy to help you clarify the problem statement.\n\nHere's the input:\n$[[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]$\nThe range $[20, 24]$ means that each list contains **at least** one number in the range. For instance, for the first list, $24$ (the fourth element) is in the range. $20$ (the last element) is in the range for the second one. $22$ (the third element) is in the range for the third one.\n\nHope it sheds some light on your side. Good luck!\n\n"
                    },
                    {
                        "username": "avadhut-2",
                        "content": "nums = [[4,10,15,24,26],[0,9,12,20],[5,18,22,30]]\\nThere is one number from each list in [5,9] range.\\n\\nFor the first test case why [5,9] would not work ?"
                    },
                    {
                        "username": "gouravt2002",
                        "content": "[5,9] does not include any number from the first list"
                    },
                    {
                        "username": "saltyboy",
                        "content": "first list doesn\\'t contain anything in the range [5,9]"
                    },
                    {
                        "username": "packle",
                        "content": "really pretty problem... conceptually basically just a k dimensional sliding window"
                    },
                    {
                        "username": "phoeniXharsh",
                        "content": "What\\'s wrong in my code? It shows runtime error.\\n\\n typedef pair<int, pair<int,int>> p;\\nclass Solution{\\n    public:\\n    vector<int> smallestRange(vector<vector<int>>& arr) \\n    {\\n          //code here\\n        int k = arr.size();\\n        int n = arr[0].size();\\n        int mini = INT_MAX, maxi = INT_MIN, range = INT_MAX;\\n        priority_queue<p, vector<p>, greater<p>> pq;\\n        for(int i=0; i<k; i++){\\n            int element = arr[i][0];\\n            // Push first element of every list and update min, max\\n            mini = min(mini, element);\\n            maxi = max(maxi, element);\\n            pq.push({element, {i, 0}});\\n        }\\n        int end = maxi, start = mini;\\n        // Iterate minheap to find the smallest range\\n        while(!pq.empty()){\\n            p temp = pq.top(); \\n            pq.pop();\\n            // Update mini for every iteration to reduce range\\n            int mini = temp.first;\\n            // update range\\n            if(maxi-mini < range){\\n                range = maxi-mini;\\n                start = mini;\\n                end = maxi;\\n            }\\n            int i = temp.second.first; // row number\\n            int j = temp.second.second; // column number\\n            // If there is no column beyond i.e no greater element is present\\n            // then break loop\\n            if(j < n){\\n                // Push the greater element into minheap\\n                pq.push({arr[i][j+1], {i, j+1}});\\n                // Update max if its greater element\\n                if(arr[i][j+1] > maxi) \\n                    maxi = arr[i][j+1];\\n            }\\n            else break;\\n        }\\n        return {start, end};\\n    }\\n};"
                    },
                    {
                        "username": "bparanj",
                        "content": "There\\'s a small issue in your code when you\\'re checking if there are more columns available in your 2D vector. \\n\\nHere\\'s the problematic code snippet:\\n\\n```cpp\\nif(j < n){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nIn this part, you\\'re checking if the current column index `j` is less than `n` (the size of your columns), and if it is, you\\'re accessing the element at index `j+1`. However, when `j` is equal to `n-1` (the last column index), `j+1` will be out of bounds, hence causing the runtime error.\\n\\nTo fix this issue, the `if` condition should be `if(j < n-1)` because you\\'re checking `arr[i][j+1]` inside the `if` block.\\n\\nHere\\'s the corrected code:\\n\\n```cpp\\nif(j < n - 1){\\n  // Push the greater element into minheap\\n  pq.push({arr[i][j+1], {i, j+1}});\\n  // Update max if its greater element\\n  if(arr[i][j+1] > maxi)\\n    maxi = arr[i][j+1];\\n}\\nelse break;\\n```\\n\\nThis change will prevent the program from trying to access an out-of-bounds index in your 2D vector, hence eliminating the runtime error."
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "it\\'s showing heap-buffer-overflow can anyone help me out in here \\n`class Solution {\\npublic:\\n    vector<int> smallestRange(vector<vector<int>>& nums) {\\n        int k=nums.size();\\n        vector<int> pointer(k,0);\\n        int idx1=0,idx2=0;\\n        pair<int,int> result({0,INT_MAX});\\n        multiset<pair<int,int>> queue;\\n            for(int i=0;i<k;i++)\\n            {\\n                queue.insert({nums[i][pointer[i]],i});\\n            }\\n        while(1)\\n        {\\n            int idx1=queue.begin()->second;\\n            int idx2=(--queue.end())->second;\\n            if(abs(result.second-result.first)>(abs(nums[idx2][pointer[idx2]]-nums[idx1][pointer[idx1]])))\\n            {\\n                result.first=nums[idx1][pointer[idx1]];\\n                result.second=nums[idx2][pointer[idx2]];\\n            }\\n            pointer[idx1]++;\\n            queue.erase(queue.begin());\\n            queue.insert({nums[idx1][pointer[idx1]],idx1});\\n            if(nums[idx1].size()==pointer[idx1])\\n            {\\n                break;\\n            }\\n        }\\n        vector<int> ans;\\n        \\n        ans.push_back(result.first);\\n        ans.push_back(result.second);\\n        sort(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};`"
                    },
                    {
                        "username": "abhishektamrakar013",
                        "content": "[@bparanj](/bparanj) yup Thanks alot"
                    },
                    {
                        "username": "bparanj",
                        "content": "The error \"heap-buffer-overflow\" generally means that your code is trying to access memory that is beyond the allocated memory space. In your code, this error occurs in the line:\\n\\n```cpp\\nqueue.insert({nums[idx1][pointer[idx1]],idx1});\\n```\\n\\nRight before this line, you have `pointer[idx1]++;`, which increases the index for the specific row (`idx1`). However, you are not checking whether `pointer[idx1]` exceeds the length of `nums[idx1]` before trying to access `nums[idx1][pointer[idx1]]`. This could lead to accessing an index out of bounds, causing the heap-buffer-overflow error.\\n\\nTo fix the issue, you should ensure that `pointer[idx1]` does not exceed the length of `nums[idx1]`. \\n\\n```cpp\\nif (pointer[idx1] < nums[idx1].size()) {\\n    queue.insert({nums[idx1][pointer[idx1]], idx1});\\n} else {\\n    break;\\n}\\n```\\n\\nThis check will ensure you\\'re not accessing an index beyond the size of the vector `nums[idx1]`. "
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/61i-qpZSfyg"
                    }
                ]
            }
        ]
    }
]