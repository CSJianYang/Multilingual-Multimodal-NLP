[
    {
        "title": "Duplicate Zeros",
        "question_content": "Given a fixed-length integer array arr, duplicate each occurrence of zero, shifting the remaining elements to the right.\nNote that elements beyond the length of the original array are not written. Do the above modifications to the input array in place and do not return anything.\n&nbsp;\nExample 1:\n\nInput: arr = [1,0,2,3,0,4,5,0]\nOutput: [1,0,0,2,3,0,0,4]\nExplanation: After calling your function, the input array is modified to: [1,0,0,2,3,0,0,4]\n\nExample 2:\n\nInput: arr = [1,2,3]\nOutput: [1,2,3]\nExplanation: After calling your function, the input array is modified to: [1,2,3]\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 104\n\t0 <= arr[i] <= 9",
        "solutions": [
            {
                "id": 322576,
                "title": "python-3-real-in-place-solution",
                "content": "Start from the back and adjust items to correct locations. If item is zero then duplicate it.\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        zeroes = arr.count(0)\\n        n = len(arr)\\n        for i in range(n-1, -1, -1):\\n            if i + zeroes < n:\\n                arr[i + zeroes] = arr[i]\\n            if arr[i] == 0: \\n                zeroes -= 1\\n                if i + zeroes < n:\\n                    arr[i + zeroes] = 0\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        zeroes = arr.count(0)\\n        n = len(arr)\\n        for i in range(n-1, -1, -1):\\n            if i + zeroes < n:\\n                arr[i + zeroes] = arr[i]\\n            if arr[i] == 0: \\n                zeroes -= 1\\n                if i + zeroes < n:\\n                    arr[i + zeroes] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312727,
                "title": "c-java-two-pointers-space-o-1",
                "content": "# **Intuition**\\nThe problem can be easy solved:\\n1. with a copy (extra space)\\n2. by inserting zeros (extra time)\\n<br>\\n\\n**Python, with extra space**\\n```\\n    def duplicateZeros(self, A):\\n        A[:] = [x for a in A for x in ([a] if a else [0, 0])][:len(A)]\\n```\\n<br>\\n\\n# **Explanation**\\nWe can improve it to `O(N)` time and `O(1)` space.\\nBasically, we apply two pointers.\\n`i` is the position in the original array,\\n`j` is the position in the new array.\\n(the original and the new are actually the same array.)\\n\\nThe first we pass forward and count the zeros.\\nThe second we pass backward and assign the value from original input to the new array.\\nso that the original value won\\'t be overridden too early.\\n<br>\\n\\n**C++:**\\n```\\n    void duplicateZeros(vector<int>& A) {\\n        int n = A.size(), j = n + count(A.begin(), A.end(), 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (--j < n)\\n                A[j] = A[i];\\n            if (A[i] == 0 && --j < n)\\n                A[j] = 0;\\n        }\\n    }\\n```\\n\\n**Java**\\nVersion suggested by @davidluoyes\\n```java\\n    public void duplicateZeros(int[] arr) {\\n        int countZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) countZero++;\\n        }\\n        int len = arr.length + countZero;\\n        //We just need O(1) space if we scan from back\\n        //i point to the original array, j point to the new location\\n        for (int i = arr.length - 1, j = len - 1; i < j; i--, j--) {\\n            if (arr[i] != 0) {\\n                if (j < arr.length) arr[j] = arr[i];\\n            } else {\\n                if (j < arr.length) arr[j] = arr[i];\\n                j--;\\n                if (j < arr.length) arr[j] = arr[i]; //copy twice when hit \\'0\\'\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, A):\\n        A[:] = [x for a in A for x in ([a] if a else [0, 0])][:len(A)]\\n```\n```\\n    void duplicateZeros(vector<int>& A) {\\n        int n = A.size(), j = n + count(A.begin(), A.end(), 0);\\n        for (int i = n - 1; i >= 0; --i) {\\n            if (--j < n)\\n                A[j] = A[i];\\n            if (A[i] == 0 && --j < n)\\n                A[j] = 0;\\n        }\\n    }\\n```\n```java\\n    public void duplicateZeros(int[] arr) {\\n        int countZero = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) countZero++;\\n        }\\n        int len = arr.length + countZero;\\n        //We just need O(1) space if we scan from back\\n        //i point to the original array, j point to the new location\\n        for (int i = arr.length - 1, j = len - 1; i < j; i--, j--) {\\n            if (arr[i] != 0) {\\n                if (j < arr.length) arr[j] = arr[i];\\n            } else {\\n                if (j < arr.length) arr[j] = arr[i];\\n                j--;\\n                if (j < arr.length) arr[j] = arr[i]; //copy twice when hit \\'0\\'\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 312743,
                "title": "java-c-o-n-o-1",
                "content": "First, go left to right and count how many shifts (```sh```) we can fit in our array.\\nThen, go right to left and move items; if it\\'s zero - duplicate it and decrement the shift.\\n> Note: ```i + sh``` can exceed the array size. We need a check for this case.\\n```\\nvoid duplicateZeros(vector<int>& a, int i = 0, int sh = 0) {\\n  for (i = 0; sh + i < a.size(); ++i) sh += a[i] == 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.size()) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```\\nJava version:\\n```\\npublic void duplicateZeros(int[] a) {\\n  int i = 0, sh = 0;\\n  for (i = 0; sh + i < a.length; ++i) sh += a[i] == 0 ? 1 : 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.length) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```sh```\n```i + sh```\n```\\nvoid duplicateZeros(vector<int>& a, int i = 0, int sh = 0) {\\n  for (i = 0; sh + i < a.size(); ++i) sh += a[i] == 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.size()) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```\n```\\npublic void duplicateZeros(int[] a) {\\n  int i = 0, sh = 0;\\n  for (i = 0; sh + i < a.length; ++i) sh += a[i] == 0 ? 1 : 0;\\n  for (i = i - 1; sh > 0; --i) {\\n    if (i + sh < a.length) a[i + sh] = a[i];\\n    if (a[i] == 0) a[i + --sh] = a[i];\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 315395,
                "title": "java-o-n-time-o-1-space-two-passes-for-loop-and-while-loop",
                "content": "**First pass** to count the number of 0\\'s.\\n**Second pass** is to write in the values in appropriate locations, moving from right to left (backwards from the usual), in which the `write` pointer initially extends outside of the length of the array (as if it was the full sized array without erasing values in the shift).\\n```java\\n  /*\\n  O(n) runtime\\n  O(1) space\\n  */\\n  public void duplicateZeros(int[] A) {\\n    \\n    int n = A.length, count = 0;\\n    \\n    for (int num : A) if (num == 0) count++;\\n    int i = n - 1;\\n    int write = n + count - 1;\\n    \\n    while (i >= 0 && write >= 0)  {\\n      \\n      if (A[i] != 0) { // Non-zero, just write it in\\n        if (write < n) A[write] = A[i];\\n        \\n      } else { // Zero found, write it in twice if we can\\n        if (write < n) A[write] = A[i];\\n        write--;\\n        if (write < n) A[write] = A[i];\\n      }\\n      \\n      i--;\\n      write--;\\n    }\\n  }\\n```",
                "solutionTags": [],
                "code": "```java\\n  /*\\n  O(n) runtime\\n  O(1) space\\n  */\\n  public void duplicateZeros(int[] A) {\\n    \\n    int n = A.length, count = 0;\\n    \\n    for (int num : A) if (num == 0) count++;\\n    int i = n - 1;\\n    int write = n + count - 1;\\n    \\n    while (i >= 0 && write >= 0)  {\\n      \\n      if (A[i] != 0) { // Non-zero, just write it in\\n        if (write < n) A[write] = A[i];\\n        \\n      } else { // Zero found, write it in twice if we can\\n        if (write < n) A[write] = A[i];\\n        write--;\\n        if (write < n) A[write] = A[i];\\n      }\\n      \\n      i--;\\n      write--;\\n    }\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 898225,
                "title": "python-2-solutions-easy-to-understand-time-o-n-space-o-1",
                "content": "**Solution 1: Straigh Forward**\\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        org = arr[:] # Copy values of `arr` to `org`\\n        i = j = 0\\n        n = len(arr)\\n        while j < n:\\n            arr[j] = org[i]\\n            j += 1\\n            if org[i] == 0: # Copy twice if ord[i] == 0\\n                if j < n: arr[j] = org[i]\\n                j += 1\\n            i += 1\\n```\\nComplexity\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n**Solution 2: Copy values from the end to beginning**\\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        n = len(arr)\\n        cntZero = arr.count(0)\\n        newLen = n + cntZero # Length of new array if we don\\'t trim up to length `n`\\n        \\n        # Let\\'s copy values from the end\\n        i = n - 1\\n        j = newLen - 1\\n        while j >= 0:\\n            if j < n: arr[j] = arr[i]\\n            j -= 1\\n            if arr[i] == 0: # Copy twice if arr[i] == 0\\n                if j < n: arr[j] = arr[i]\\n                j -= 1\\n            i -= 1\\n```\\n\\nComplexity\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        org = arr[:] # Copy values of `arr` to `org`\\n        i = j = 0\\n        n = len(arr)\\n        while j < n:\\n            arr[j] = org[i]\\n            j += 1\\n            if org[i] == 0: # Copy twice if ord[i] == 0\\n                if j < n: arr[j] = org[i]\\n                j += 1\\n            i += 1\\n```\n```python\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        n = len(arr)\\n        cntZero = arr.count(0)\\n        newLen = n + cntZero # Length of new array if we don\\'t trim up to length `n`\\n        \\n        # Let\\'s copy values from the end\\n        i = n - 1\\n        j = newLen - 1\\n        while j >= 0:\\n            if j < n: arr[j] = arr[i]\\n            j -= 1\\n            if arr[i] == 0: # Copy twice if arr[i] == 0\\n                if j < n: arr[j] = arr[i]\\n                j -= 1\\n            i -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 505107,
                "title": "c-two-pass-shift-counter-fast-simple-explanation",
                "content": "First pass count `0s` in the array, this is our `shift` variable.\\nSecond reverse pass:\\n* If `arr[i] == 0` reduce `shift` count by 1.\\n* If `arr[i + shift]` within array boundary, then assign `arr[i + shift] = arr[i]` (shift element to it\\'s new position). If `arr[i] == 0` then also assign next element after `arr[i + shift]` to `0`, meaning `arr[i + shift + 1] = 0`, but don\\'t forget to check that `i + shift + 1` is withing array boundary.\\n\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int shift = count(begin(arr), end(arr), 0), size = arr.size();\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (!arr[i]) shift--;\\n            if (i + shift < size) {\\n                arr[i + shift] = arr[i];\\n                if (!arr[i] && i + shift + 1 < size)\\n                    arr[i + shift + 1] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int shift = count(begin(arr), end(arr), 0), size = arr.size();\\n        for (int i = arr.size() - 1; i >= 0; i--) {\\n            if (!arr[i]) shift--;\\n            if (i + shift < size) {\\n                arr[i + shift] = arr[i];\\n                if (!arr[i] && i + shift + 1 < size)\\n                    arr[i + shift + 1] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 314126,
                "title": "python-o-n-time-o-1-space",
                "content": "```\\n# it requires us to do it in place, so we can\\'t use extra space here\\n# we can do it in 2 passes, the first pass record the count of 0s as shifts\\n# the second pass put the shifted elements in the right spot and put 0s in the right spot\\n# e.g, [1,0,2,3,0,4,5,0] will be extended as [1,0,0,2,3,0,0,4],5,0,0, only the first 8 elememnts\\n# fit in the array\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        shift = 0\\n        l = len(arr)\\n        for i in range(l):\\n            if arr[i] == 0:\\n                shift += 1\\n        for i in range(l-1, -1, -1):\\n            # put the shifted number in the right spot\\n            if i + shift < l:\\n                arr[i+shift] = arr[i]\\n            # if we meet a 0, we need to duplicate 0\\n            if arr[i] == 0:\\n                shift -= 1\\n                if i + shift < l:\\n                    arr[i+shift] = 0\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# it requires us to do it in place, so we can\\'t use extra space here\\n# we can do it in 2 passes, the first pass record the count of 0s as shifts\\n# the second pass put the shifted elements in the right spot and put 0s in the right spot\\n# e.g, [1,0,2,3,0,4,5,0] will be extended as [1,0,0,2,3,0,0,4],5,0,0, only the first 8 elememnts\\n# fit in the array\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        shift = 0\\n        l = len(arr)\\n        for i in range(l):\\n            if arr[i] == 0:\\n                shift += 1\\n        for i in range(l-1, -1, -1):\\n            # put the shifted number in the right spot\\n            if i + shift < l:\\n                arr[i+shift] = arr[i]\\n            # if we meet a 0, we need to duplicate 0\\n            if arr[i] == 0:\\n                shift -= 1\\n                if i + shift < l:\\n                    arr[i+shift] = 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 353153,
                "title": "javascript-simple-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for (var i=0; i<arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i+=1\\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for (var i=0; i<arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i+=1\\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 312751,
                "title": "java-from-a-beginner-programmer",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] == 0){\\n                shift(arr,i+1);\\n                if(i != arr.length-1){\\n                arr[i+1] = 0;\\n                    i++;\\n                }\\n            }\\n            }\\n        }\\n    public static void shift(int[] arr, int index){\\n        for(int i = arr.length-1; i > index; i--){\\n            arr[i] = arr[i-1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.length; i++){\\n            if(arr[i] == 0){\\n                shift(arr,i+1);\\n                if(i != arr.length-1){\\n                arr[i+1] = 0;\\n                    i++;\\n                }\\n            }\\n            }\\n        }\\n    public static void shift(int[] arr, int index){\\n        for(int i = arr.length-1; i > index; i--){\\n            arr[i] = arr[i-1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 399944,
                "title": "c-32ms-faster-than-40-04-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 408059,
                "title": "python-simple-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef duplicateZeros(self, arr: List[int]) -> None:\\n\\t\\t\\ti = 0\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\twhile(i<n):\\n\\t\\t\\t\\tif arr[i]==0:\\n\\t\\t\\t\\t\\tarr.pop()\\n\\t\\t\\t\\t\\tarr.insert(i,0)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ti+=1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef duplicateZeros(self, arr: List[int]) -> None:\\n\\t\\t\\ti = 0\\n\\t\\t\\tn = len(arr)\\n\\t\\t\\twhile(i<n):\\n\\t\\t\\t\\tif arr[i]==0:\\n\\t\\t\\t\\t\\tarr.pop()\\n\\t\\t\\t\\t\\tarr.insert(i,0)\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ti+=1",
                "codeTag": "Java"
            },
            {
                "id": 884016,
                "title": "easy-to-understand-no-extra-space-java",
                "content": "```\\n        int n = arr.length;\\n        for(int i = 0; i<arr.length; i++) {\\n            if(arr[i] ==0) {\\n                int j;\\n                for(j = n-2; j>=i+1; j--) {\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[j+1] = 0;\\n                i++;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n        int n = arr.length;\\n        for(int i = 0; i<arr.length; i++) {\\n            if(arr[i] ==0) {\\n                int j;\\n                for(j = n-2; j>=i+1; j--) {\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[j+1] = 0;\\n                i++;\\n            }\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1612544,
                "title": "very-easy-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                i=i+1;\\n            }\\n        }    \\n    }\\n};\\n\\npls upvote if it was helpful :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 316627,
                "title": "java-solution-two-pass-and-o-1-space",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0;\\n        for(int i : arr) {\\n            if(i == 0) {\\n                count++;\\n            }\\n        }\\n        int len = arr.length;\\n        for(int i = len - 1; i >= 0; i--) {\\n            int temp = i + count;\\n            if(temp < len) {\\n                arr[temp] = arr[i];\\n            }\\n            if(arr[i] == 0) {\\n                count--;\\n                temp = i + count;\\n                if(temp < len) {\\n                    arr[temp] = arr[i];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0;\\n        for(int i : arr) {\\n            if(i == 0) {\\n                count++;\\n            }\\n        }\\n        int len = arr.length;\\n        for(int i = len - 1; i >= 0; i--) {\\n            int temp = i + count;\\n            if(temp < len) {\\n                arr[temp] = arr[i];\\n            }\\n            if(arr[i] == 0) {\\n                count--;\\n                temp = i + count;\\n                if(temp < len) {\\n                    arr[temp] = arr[i];\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319872,
                "title": "simple-java-solution-with-a-queue-100-memory",
                "content": "I have used the default LinkedList implementation from java (which could be used as a queue)\\n\\n```\\npublic void duplicateZeros(int[] arr) {\\n\\tLinkedList<Integer> queue=new LinkedList<Integer>();  \\n\\tfor(int i = 0; i < arr.length; i++) {\\n\\t\\tqueue.add(arr[i]);\\n\\t\\tif(arr[i] == 0) {\\n\\t\\t\\t//add another 0\\n\\t\\t\\tqueue.add(arr[i]);\\n\\t\\t}\\n\\t\\tarr[i] = queue.poll();\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic void duplicateZeros(int[] arr) {\\n\\tLinkedList<Integer> queue=new LinkedList<Integer>();  \\n\\tfor(int i = 0; i < arr.length; i++) {\\n\\t\\tqueue.add(arr[i]);\\n\\t\\tif(arr[i] == 0) {\\n\\t\\t\\t//add another 0\\n\\t\\t\\tqueue.add(arr[i]);\\n\\t\\t}\\n\\t\\tarr[i] = queue.poll();\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127380,
                "title": "java-two-approaches-explained-with-codes",
                "content": "```\\n/*\\n     * Naive Approach:-\\n     * (1) Traverse array till length-1.\\n     * (2) If the element where you current at is zero then shift all the elements\\n     * including zero to one step ahead.\\n     * (3) Don\\'t forget increment the pointer by 1 else array will filled by 0s.\\n     * Time Complexity = O(n^2) for traversing & shifting.\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) { // Traversing the array.\\n            if (arr[i] == 0) {\\n                for (int j = n - 2; j >= i; j--) {\\n                    arr[j + 1] = arr[j]; // Shifting The elements\\n                }\\n                i++; // incrementing i by 1\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Better Approach:-\\n     * (1) Calculate the number of zeros in array.\\n     * (2) Create two pointers one is pointing to length-1 & other is pointing to\\n     * length+zeros-1.\\n     * (3) Start modifying array from back.\\n     * Time Complexity = O(n).\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length, count = 0;\\n\\n        for (int num : arr) {\\n            if (num == 0) {\\n                count++;\\n            }\\n        }\\n        int i = n - 1;\\n        int j = n + count - 1;\\n\\n        while (i >= 0 && j >= 0) {\\n\\n            if (arr[i] != 0) {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n\\n            } else {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n                j--;\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n    }\\n\\t\\n\\tPlease Upvote if you find it helpful!\\n\\t```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\n     * Naive Approach:-\\n     * (1) Traverse array till length-1.\\n     * (2) If the element where you current at is zero then shift all the elements\\n     * including zero to one step ahead.\\n     * (3) Don\\'t forget increment the pointer by 1 else array will filled by 0s.\\n     * Time Complexity = O(n^2) for traversing & shifting.\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length;\\n        for (int i = 0; i < n - 1; i++) { // Traversing the array.\\n            if (arr[i] == 0) {\\n                for (int j = n - 2; j >= i; j--) {\\n                    arr[j + 1] = arr[j]; // Shifting The elements\\n                }\\n                i++; // incrementing i by 1\\n            }\\n        }\\n    }\\n\\n    /*\\n     * Better Approach:-\\n     * (1) Calculate the number of zeros in array.\\n     * (2) Create two pointers one is pointing to length-1 & other is pointing to\\n     * length+zeros-1.\\n     * (3) Start modifying array from back.\\n     * Time Complexity = O(n).\\n     * Space Complexity = 0(1).\\n     */\\n\\n    static void duplicateZeros(int[] arr) {\\n        int n = arr.length, count = 0;\\n\\n        for (int num : arr) {\\n            if (num == 0) {\\n                count++;\\n            }\\n        }\\n        int i = n - 1;\\n        int j = n + count - 1;\\n\\n        while (i >= 0 && j >= 0) {\\n\\n            if (arr[i] != 0) {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n\\n            } else {\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n                j--;\\n                if (j < n) {\\n                    arr[j] = arr[i];\\n                }\\n            }\\n\\n            i--;\\n            j--;\\n        }\\n    }\\n\\t\\n\\tPlease Upvote if you find it helpful!\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 3462758,
                "title": "duplicate-zeros-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n/2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/79186693-bccb-4a98-9624-bd73ce99e074_1682665502.374058.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1162030,
                "title": "python-simple",
                "content": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        i = 0\\n        \\n        while i < len(arr) - 1:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        i = 0\\n        \\n        while i < len(arr) - 1:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 313225,
                "title": "different-python-solutions",
                "content": "Solution 1: straightforward solution with O(n) time and O(n) space\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        res = []\\n        for x in arr:\\n            res.append(x)\\n            if x == 0:\\n                res.append(x)\\n        for i in range(len(arr)):\\n            arr[i] = res[i]\\n```\\nSolution 2: creat a map: i <--> i + # zeros in arr[:i]\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        mp = dict()\\n        while i + zeros < n:\\n            mp[i+zeros] = i\\n            if arr[i] == 0:\\n                zeros += 1\\n                mp[i+zeros] = i\\n            i += 1\\n        for i in range(n - 1, -1, -1):\\n            arr[i] = arr[mp[i]]\\n```\\nSolution 3: improved version of solution 2\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        while i + zeros < n:\\n            zeros += arr[i] == 0\\n            i += 1\\n\\t\\t# i + zeros is at most n + 1\\n        i -= 1\\n        while zeros > 0:\\n            if i + zeros < n:\\n                arr[i+zeros] = arr[i]\\n            if arr[i] == 0:\\n                zeros -= 1\\n                arr[i+zeros] = arr[i]\\n            i -= 1\\n```",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        res = []\\n        for x in arr:\\n            res.append(x)\\n            if x == 0:\\n                res.append(x)\\n        for i in range(len(arr)):\\n            arr[i] = res[i]\\n```\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        mp = dict()\\n        while i + zeros < n:\\n            mp[i+zeros] = i\\n            if arr[i] == 0:\\n                zeros += 1\\n                mp[i+zeros] = i\\n            i += 1\\n        for i in range(n - 1, -1, -1):\\n            arr[i] = arr[mp[i]]\\n```\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        zeros = 0\\n        i = 0\\n        while i + zeros < n:\\n            zeros += arr[i] == 0\\n            i += 1\\n\\t\\t# i + zeros is at most n + 1\\n        i -= 1\\n        while zeros > 0:\\n            if i + zeros < n:\\n                arr[i+zeros] = arr[i]\\n            if arr[i] == 0:\\n                zeros -= 1\\n                arr[i+zeros] = arr[i]\\n            i -= 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3101355,
                "title": "easy-python-solution-while",
                "content": "# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        i = 0\\n        while i < l:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 1\\n            i += 1               \\n```\\nDo upvote if you like the solution :)",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        i = 0\\n        while i < l:\\n            if arr[i] == 0:\\n                arr.insert(i+1, 0)\\n                arr.pop()\\n                i += 1\\n            i += 1               \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1648310,
                "title": "java-100-simple-2-steps-solution-explained",
                "content": "Simple solution:\\n1. Count number of zeros.\\n2. Iterate from end of the array,\\n\\ta. Calculate index where current element needs to be shifted.\\n\\tb. Shift current element if index lies within array.\\n\\tc. Check if current element is zero:\\n\\t\\ti. Assign zero to (index-1) to duplicate zero if (index-1) lies within array.\\n\\t\\tii. Decrease zero counter by 1.\\n\\t\\t\\nHope this helps!!! :)\\n\\n\\n```\\npublic void duplicateZeros(int[] arr) \\n    {\\n        int noOfZeros = 0;\\n        int n = arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == 0) noOfZeros++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curIndex = i+noOfZeros;\\n            if(curIndex<n)\\n            {\\n                arr[curIndex] = arr[i];\\n            }\\n            if(arr[i] == 0)\\n            {\\n                if(curIndex-1 < n)\\n                {\\n                    arr[curIndex-1] = arr[i];\\n                }\\n                noOfZeros--;\\n            }\\n        } \\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic void duplicateZeros(int[] arr) \\n    {\\n        int noOfZeros = 0;\\n        int n = arr.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr[i] == 0) noOfZeros++;\\n        }\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int curIndex = i+noOfZeros;\\n            if(curIndex<n)\\n            {\\n                arr[curIndex] = arr[i];\\n            }\\n            if(arr[i] == 0)\\n            {\\n                if(curIndex-1 < n)\\n                {\\n                    arr[curIndex-1] = arr[i];\\n                }\\n                noOfZeros--;\\n            }\\n        } \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 364373,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n        \\tif(arr[i]==0) {\\n        \\t\\tfor(int j=arr.length-1;j>i;j--) {\\n        \\t\\t\\tarr[j]=arr[j-1];\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++) {\\n        \\tif(arr[i]==0) {\\n        \\t\\tfor(int j=arr.length-1;j>i;j--) {\\n        \\t\\t\\tarr[j]=arr[j-1];\\n        \\t\\t}\\n        \\t\\ti++;\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1304795,
                "title": "python-efficient-one-line-code-95-and-85-1089",
                "content": "# Python One Liner <span>1L.py</span>\\nNeat and clean one line code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        [arr.insert(i,0) or arr.pop() for i in range(len(arr)-1,-1,-1) if not arr[i]]\\n```\\n\\n\\n#### Lets look into breadcrumbs!!<br>\\n```python\\n[... for ... in ... if ...]\\n```\\nAnything which looks like something shown above is nothing but [conditional list comprehension](https://realpython.com/list-comprehension-python/#using-conditional-logic \"Real Python\")\\n```python\\narr.insert(i,0)\\n```\\nWell, above function inserts a new zero at ```i```th position. This function returns `None` on successful insertion.\\n```python\\narr.pop()\\n```\\nBut when inserted, the length of the array is one more than the original length. So we need to pop an element from the end.\\n```python\\narr.insert(i,0) or arr.pop()\\n```\\nSince we need to do two function calls, we need to use OR operator between function calls ([why not AND?](#q1), think for a bit on return object from `arr.insert()`).\\n```\\nfor i in range(len(arr)-1,-1,-1)\\n```\\nWe start iterating from the end of the list to avoid infinite insertion of zeros when first zero is encountered.\\n```python\\n# All the below statements are identical\\nif not arr[i]:\\nif arr[i]==0:\\nif arr[i]==None:\\n```\\nWhole point to the algorithm is to add a new zero whenever a zero is encountered. Right? (Well, partially yes)\\n\\n### Q&A\\n<h5 id=\"q1\">1. why not AND?</h5>\\n\\n`arr.insert()` returns `None` upon successful insertion. If we had used AND operator, because of python\\'s [short circuiting](https://stackoverflow.com/a/14892812 \"Stack Overflow\") of AND, the second function would never be executed which results in no elements being popped out and the answer being wrong.\\n### Performance\\n![image](https://assets.leetcode.com/users/images/e6606b28-a04b-4b99-a341-71f1c01b9bc1_1624969176.0958948.png)\\n<!---\\nSubmission time: SESSION_DELETED :(\\n-->",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        [arr.insert(i,0) or arr.pop() for i in range(len(arr)-1,-1,-1) if not arr[i]]\\n```\n```python\\n[... for ... in ... if ...]\\n```\n```python\\narr.insert(i,0)\\n```\n```i```\n```python\\narr.pop()\\n```\n```python\\narr.insert(i,0) or arr.pop()\\n```\n```\\nfor i in range(len(arr)-1,-1,-1)\\n```\n```python\\n# All the below statements are identical\\nif not arr[i]:\\nif arr[i]==0:\\nif arr[i]==None:\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051352,
                "title": "python3-simple-solution-with-explanation",
                "content": "Let\\'s walk through an example: `10230450`.\\n\\nFirst, we count `0`s in the array (`cnt`). In this case, `cnt == 3` => our array needs 3 extra slots for 3 extra `0`s: `10230450|xxx`. We modify the array from the end, and at each index, we copy the element at position `i` to position `i + cnt`. If the element is `0`, we duplicate it, and decrease `cnt`.\\n\\nThe array gets modified as follows:\\n`1023045`**0**`|xxx` -> `1023045xx`**00** (since we copy a 0, we double it.)\\n```102304```**5**```x|x00``` -> ```102304xx|```**5**```00```\\n```10230```**4**```xx|500``` -> ```10230xx```**4**```|500```\\n```1023```**0**```xx4|500``` -> ```1023x```**00**```4|500``` (again, copying a 0 so doubled.)\\n```102```**3**```x004|500``` -> ```102x```**3**```004|500```\\n```10```**2**```x3004|500``` -> ```10x```**2**```3004|500```\\n```1```**0**```x23004|500``` -> ```1```**00**```23004|500```\\nEnd result: ```10023004|500```. We now return everything up to right before the ```|```.\\n\\nBut how do we use no extra space? We simply do not need to copy the elements over if they would end up outside our original array. So the last 3 slots ```|500``` are simulated, but not actually copied over.\\n\\nTime: ```O(n)```. Space: ```O(1)``` (we traverse the array twice (once to count ```0```s, once more to move elements)\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        cnt = arr.count(0)\\n\\n        for i in reversed(range(len(arr))):\\n            if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy the number over to correct position\\n            if arr[i] == 0:\\n                cnt -= 1\\n                if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy again if the number is 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```102304```\n```x|x00```\n```102304xx|```\n```00```\n```10230```\n```xx|500```\n```10230xx```\n```|500```\n```1023```\n```xx4|500```\n```1023x```\n```4|500```\n```102```\n```x004|500```\n```102x```\n```004|500```\n```10```\n```x3004|500```\n```10x```\n```3004|500```\n```1```\n```x23004|500```\n```1```\n```23004|500```\n```10023004|500```\n```|```\n```|500```\n```O(n)```\n```O(1)```\n```0```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        cnt = arr.count(0)\\n\\n        for i in reversed(range(len(arr))):\\n            if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy the number over to correct position\\n            if arr[i] == 0:\\n                cnt -= 1\\n                if i + cnt < len(arr): arr[i + cnt] = arr[i]  # copy again if the number is 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857654,
                "title": "java-duplicate-zeros-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n\\t\\tfor (int i = 0; i < arr.length - 1; i++) { //if we are on the last element it doesn\\'t matter if it is non-zero or not\\n        \\tif (arr[i] == 0) { //if we get a zero we shift everything from the back to the right by one\\n        \\t\\tfor (int j = arr.length - 1; j > i; j--) {\\n        \\t\\t\\tarr[j] = arr[j - 1]; \\n        \\t\\t}\\n                i++; //if we get a zero we need to shift \\'i\\' twice to avoid running into the zero we just duplicated\\n        \\t}\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n\\t\\tfor (int i = 0; i < arr.length - 1; i++) { //if we are on the last element it doesn\\'t matter if it is non-zero or not\\n        \\tif (arr[i] == 0) { //if we get a zero we shift everything from the back to the right by one\\n        \\t\\tfor (int j = arr.length - 1; j > i; j--) {\\n        \\t\\t\\tarr[j] = arr[j - 1]; \\n        \\t\\t}\\n                i++; //if we get a zero we need to shift \\'i\\' twice to avoid running into the zero we just duplicated\\n        \\t}\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002778,
                "title": "o-n-easiest-solution-ever-if-u-finding-other-solution-difficult-plz-refer-this-and-upvote",
                "content": "/*\\n\\nconsider, int [] arr = {1,0,2,3,0,4,5,0};\\nwe need to add one duplicate zero followed by original one\\nso we will use, for loop to check for zeroes,and \\nwe will use extra space ArrayList just to add element of arr and extra zeroes, \\n\\n   if element is non zero we will add it as it is\\n   else we will add extra zero to our ArrayList\\n\\n    after above operation we will get ArrayList as {1,0,0,2,3,0,0,4,5,0,0};\\n    and we will also replace element at index i in arr with element at index i on ArrayList;\\n    arr[i]=ll.get(i);\\n\\nso we will get updated arr ={1,0,0,2,3,0,0,4};  \\n\\n*/\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n    \\n        List <Integer> ll = new ArrayList();\\n\\t    \\n        int index=0;                          \\n        //index increment as we add elements in List\\n\\t    \\n        for(int i=0;i<arr.length;i++) {\\t\\n\\t    \\t\\n            if(arr[i]==0) \\n            {\\n              ll.add(index++,arr[i]);      // zero from array\\n              ll.add(index++,0);           // add duplicate zero \\n            }\\n\\t    \\t\\n            else \\n            { ll.add(index++,arr[i]); }\\n\\t    \\t\\n            arr[i]=ll.get(i);             \\n        // we will update our Arrays form 0 , with respect to our Updated list\\n\\t    }   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n    \\n        List <Integer> ll = new ArrayList();\\n\\t    \\n        int index=0;                          \\n        //index increment as we add elements in List\\n\\t    \\n        for(int i=0;i<arr.length;i++) {\\t\\n\\t    \\t\\n            if(arr[i]==0) \\n            {\\n              ll.add(index++,arr[i]);      // zero from array\\n              ll.add(index++,0);           // add duplicate zero \\n            }\\n\\t    \\t\\n            else \\n            { ll.add(index++,arr[i]); }\\n\\t    \\t\\n            arr[i]=ll.get(i);             \\n        // we will update our Arrays form 0 , with respect to our Updated list\\n\\t    }   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044179,
                "title": "python-easy-solution-with-comment",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n```\\narr = [1,0,2,3,0,4,5,0]\\n         ^\\n        (i=1) & i+2\\n        (insert)\\n    \\narr = [1,0,0,2,3,0,4,5,0]\\n             ^         ^      \\n            (i=3)     (pop) \\n\\narr = [1,0,0,2,3,0,4,5]\\n\\n```\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n            <!-- use while loop to contorl \"i\" -->\\n        i=0\\n        while(i<len(arr)):\\n            if(arr[i]==0):\\n                arr.insert(i,0)\\n\\n            <!-- i+2 for skip the insert index -->\\n                i=i+2\\n                arr.pop()\\n            else:\\n                i=i+1\\n \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\narr = [1,0,2,3,0,4,5,0]\\n         ^\\n        (i=1) & i+2\\n        (insert)\\n    \\narr = [1,0,0,2,3,0,4,5,0]\\n             ^         ^      \\n            (i=3)     (pop) \\n\\narr = [1,0,0,2,3,0,4,5]\\n\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n            <!-- use while loop to contorl \"i\" -->\\n        i=0\\n        while(i<len(arr)):\\n            if(arr[i]==0):\\n                arr.insert(i,0)\\n\\n            <!-- i+2 for skip the insert index -->\\n                i=i+2\\n                arr.pop()\\n            else:\\n                i=i+1\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1024740,
                "title": "python-easy-to-understand-single-pass-brute-force-approach-optimal-in-place-solution",
                "content": "It took me some time to properly understand and get some intuition, so I wrote the brute force approach and the neatest solution as good as i could (hope I don\\'t overengineer it)... I hope this helps newcomers:\\n\\nFor the brute force approach we will do a single pass from left to right (0 to len(array) - 1). Every time we find a zero in the array, we will copy all values to the right. This copying right side is done from right to left in order to not to erase the next iteration value.\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\tcurr_idx = 0\\n\\t\\twhile curr_idx < len(array):\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t        self.copyRightSide(arr, curr_idx)\\n\\t\\t\\t    # We copied the right side including the current value, so the next idx would be the value of the curr_idx and we would get an infinite loop\\n\\t\\t\\t    curr_idx += 1\\n\\t        curr_idx += 1\\n\\n    def copyRightSide(self, arr: List[int], idx) -> None:\\n    \"\"\"   \\n    Insert an element at index idx and keep all values to the right aligned.\\n    E.g. \\n       copyRightSide([1, 0, 3, 7, 8, 5], idx=2) will yield [1, 0, 3, 3, 7, 8, 5]\\n\\t\"\"\"\\n   \\n    for curr_idx in range(len(arr) - 1, idx, -1):\\n       arr[curr_idx] = arr[curr_idx - 1]\\n```\\n\\nThe good thing about the approach above is that it\\'s straight forward and we do not have to consider the edge cases for many zeros. The problem though is that we\\'re iterating from left to right, copying the array, finding the next zero, and recopying elements that were already shifted. This is computationally expensive.\\n\\nAs shown in the solution, a better approach would be to do two passes: first count the amount of zeroes `total_zeroes`, then do another pass from right to left. \\nWe will effectively move the values in the array further to the right. The amount of spaces to the right that are shifted is the idx + amount of zeroes we found so far. That is, it holds `new_idx = curr_idx + total_zeroes` for every iteration. When we find a zero, we reduce the count of `total_zeroes` and recopy the same element a second time.\\nLet\\'s see what it looks like without having to worry about increasing the size of the array:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tarr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n```\\n\\nThis effectively turns an array like `[0, 1, 0, 2, 3, 4, 0]` into `[0, 0, 1, 0, 0, 2, 3, 4, 0, 0]`. In order to comply then with the constraint, we should check first if the new_idx would still be within the length of the array before copying the values to the right i.e. add `if new_idx <= last_idx` before every assignment ```arr[new_idx] = arr[curr_idx]```\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t        arr[new_idx] = arr[curr_idx] # or simply arr[new_idx] = 0\\n```\\n\\nCredit for the last solution goes to @rokanor. See https://leetcode.com/problems/duplicate-zeros/discuss/322576/Python-3-real-in-place-solution\\n\\n\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\tcurr_idx = 0\\n\\t\\twhile curr_idx < len(array):\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t        self.copyRightSide(arr, curr_idx)\\n\\t\\t\\t    # We copied the right side including the current value, so the next idx would be the value of the curr_idx and we would get an infinite loop\\n\\t\\t\\t    curr_idx += 1\\n\\t        curr_idx += 1\\n\\n    def copyRightSide(self, arr: List[int], idx) -> None:\\n    \"\"\"   \\n    Insert an element at index idx and keep all values to the right aligned.\\n    E.g. \\n       copyRightSide([1, 0, 3, 7, 8, 5], idx=2) will yield [1, 0, 3, 3, 7, 8, 5]\\n\\t\"\"\"\\n   \\n    for curr_idx in range(len(arr) - 1, idx, -1):\\n       arr[curr_idx] = arr[curr_idx - 1]\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tarr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n```\n```arr[new_idx] = arr[curr_idx]```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n\\t\\ttotal_zeroes = arr.count(0)\\n\\t\\t\\n\\t\\tlast_idx = len(arr) - 1\\n\\t\\tfor curr_idx in range(last_idx, -1, -1):\\n\\t\\t    \\n\\t\\t\\t# This is the place where the curr_idx gets extended in the array\\n\\t\\t    new_idx = curr_idx + total_zeroes\\n\\t\\t\\t\\n\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t    arr[new_idx] = arr[curr_idx]\\n\\t\\t\\t\\n\\t\\t    if arr[curr_idx] == 0:\\n\\t\\t\\t    total_zeroes -= 1\\n\\t\\t\\t\\tif new_idx <= last_idx:\\n\\t\\t\\t        arr[new_idx] = arr[curr_idx] # or simply arr[new_idx] = 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 589488,
                "title": "go-simple-solution-beats-100-100-o-n-complexity-o-1-space",
                "content": "```go\\nfunc duplicateZeros(arr []int)  {\\n    zeros := 0\\n\\n    for _, v := range arr {\\n        if v == 0 {\\n            zeros++\\n        }\\n    }\\n\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] == 0 {\\n            if zeros + i < len(arr) {\\n                arr[zeros + i] = 0\\n            }\\n            \\n            if zeros - 1 + i < len(arr) {\\n                arr[zeros - 1 + i] = 0\\n            }\\n            \\n            zeros--\\n        } else if i + zeros < len(arr) {\\n            arr[zeros + i] = arr[i]\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc duplicateZeros(arr []int)  {\\n    zeros := 0\\n\\n    for _, v := range arr {\\n        if v == 0 {\\n            zeros++\\n        }\\n    }\\n\\n    for i := len(arr) - 1; i >= 0; i-- {\\n        if arr[i] == 0 {\\n            if zeros + i < len(arr) {\\n                arr[zeros + i] = 0\\n            }\\n            \\n            if zeros - 1 + i < len(arr) {\\n                arr[zeros - 1 + i] = 0\\n            }\\n            \\n            zeros--\\n        } else if i + zeros < len(arr) {\\n            arr[zeros + i] = arr[i]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 543558,
                "title": "very-simple-js-solution-memory-less-than-100",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for (i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for (i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4094396,
                "title": "two-simple-java-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code1\\n```Java\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int zeros = 0;\\n\\n        for (int i = 0; i < length; i++) {\\n            if (arr[i] == 0) {\\n                zeros++;\\n            }\\n        }\\n\\n        int lastIndex = length - 1;\\n        int newIndex = length - 1 + zeros;\\n\\n        while (lastIndex >= 0) {\\n            if (newIndex < length) {\\n                arr[newIndex] = arr[lastIndex];\\n            }\\n\\n            if (arr[lastIndex] == 0) {\\n                newIndex--;\\n\\n                if (newIndex < length) {\\n                    arr[newIndex] = 0;\\n                }\\n            }\\n\\n            lastIndex--;\\n            newIndex--;\\n        }\\n    }\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n\\n        for (int i = 0; i < length ; i++)\\n        {\\n            if (arr[i] == 0 && i+1 < length)\\n            {\\n                for (int j = length - 1; j > i+1; j--)\\n                {\\n                    int temp = arr[j-1];\\n                    arr[j] = temp;\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/8cefe933-b2ba-4b42-801b-1736daaf39b0_1695761536.3744702.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int zeros = 0;\\n\\n        for (int i = 0; i < length; i++) {\\n            if (arr[i] == 0) {\\n                zeros++;\\n            }\\n        }\\n\\n        int lastIndex = length - 1;\\n        int newIndex = length - 1 + zeros;\\n\\n        while (lastIndex >= 0) {\\n            if (newIndex < length) {\\n                arr[newIndex] = arr[lastIndex];\\n            }\\n\\n            if (arr[lastIndex] == 0) {\\n                newIndex--;\\n\\n                if (newIndex < length) {\\n                    arr[newIndex] = 0;\\n                }\\n            }\\n\\n            lastIndex--;\\n            newIndex--;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n\\n        for (int i = 0; i < length ; i++)\\n        {\\n            if (arr[i] == 0 && i+1 < length)\\n            {\\n                for (int j = length - 1; j > i+1; j--)\\n                {\\n                    int temp = arr[j-1];\\n                    arr[j] = temp;\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2951028,
                "title": "basic-approach-easy-solution",
                "content": "# Intuition\\nCreated a temp vector in which elements were pushed according to constraints. But during copying , only limited length was allowed to copy.\\n\\n# Approach\\nCreate a temp vector which accepts \\'0\\' twice and nonzero elements single time. Just copy the elements only till length of arr.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> temp;\\n        for(int i = 0; i<arr.size();i++){\\n            if(arr[i] == 0){\\n                temp.push_back(0);\\n                temp.push_back(0);\\n            }\\n            else temp.push_back(arr[i]);\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            arr[i]=temp[i];\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> temp;\\n        for(int i = 0; i<arr.size();i++){\\n            if(arr[i] == 0){\\n                temp.push_back(0);\\n                temp.push_back(0);\\n            }\\n            else temp.push_back(arr[i]);\\n        }\\n        for(int i = 0;i<arr.size();i++){\\n            arr[i]=temp[i];\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799546,
                "title": "javascript-o-n-beats-90-easy",
                "content": "# Intuition\\nFrequence counter\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function (arr) {\\n  const newArr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    newArr.push(arr[i]);\\n    arr[i] === 0 && newArr.push(0);\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = newArr[i];\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function (arr) {\\n  const newArr = [];\\n  for (let i = 0; i < arr.length; i++) {\\n    newArr.push(arr[i]);\\n    arr[i] === 0 && newArr.push(0);\\n  }\\n  for (let i = 0; i < arr.length; i++) {\\n    arr[i] = newArr[i];\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2496025,
                "title": "simple-python-solution",
                "content": "What the code does\\n1. Iterates through the array.\\n2. If the current element is 0, removes the last element from the array and Insert 0 at the current index.\\n4. Increment the index by 2.\\n5. If the current element is not 0, increment the index by 1\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0: \\n                arr.pop()\\n                arr.insert(i, 0)\\n                i += 2\\n            else:\\n                i += 1\\n```\\n\\nTime complexity is O(n) as it will iterate over the entire array and space complexity is O(1) as we are only inserting and deleting elements from the array.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0: \\n                arr.pop()\\n                arr.insert(i, 0)\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364453,
                "title": "with-explanation-comments-time-67-ms-32-33-space-9-5-mb-99-62",
                "content": "**Like it? ->Upvote please!**\\n\\n**Solution 1:**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elemenst\\n        for(int i=0;i<arr.size();i++){\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //remove one element from the last\\n                arr.pop_back();\\n                //insert 0 in the next position after this 0\\n                arr.insert(arr.begin()+i,0);\\n                //move an extra step, skip the new zero element\\n                i++;\\n            }\\n        }\\n    }\\n};\\n\\'\\'\\'\\n\\n**Solution 2: **\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<arr.size();i++)\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //shift elements from the last to the current element\\n                for(int j=arr.size()-1;j!=i;j--)\\n                    arr[j]=arr[j-1];\\n                    \\n                //move an extra step, skip the new zero element\\n                i++;\\n            }\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        //loop over the whole array elemenst\\n        for(int i=0;i<arr.size();i++){\\n            //if the current one is 0\\n            if(arr[i]==0){\\n                //remove one element from the last\\n                arr.pop_back();\\n                //insert 0 in the next position after this 0\\n                arr.insert(arr.begin()+i,0);\\n                //move an extra step, skip the new zero element\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1486534,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315352,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j=0\\n        while j<len(arr)-1:\\n            if arr[j] == 0:\\n                arr[j+1:] = [0]+arr[j+1:-1]\\n                j+=2\\n            else:\\n                j+=1\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j=0\\n        while j<len(arr)-1:\\n            if arr[j] == 0:\\n                arr[j+1:] = [0]+arr[j+1:-1]\\n                j+=2\\n            else:\\n                j+=1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2607097,
                "title": "java-faster-than-99-34-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int[] res = new int[length];\\n        int j = 0;\\n        \\n        for (int i = 0; i < length && j < length; i++){\\n            if (arr[i] != 0){\\n                res[j] = arr[i];\\n            } else {\\n                j++;\\n            }\\n            j++;\\n        }\\n        \\n        for (int i = 0; i < length; i++){\\n            arr[i] = res[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int length = arr.length;\\n        int[] res = new int[length];\\n        int j = 0;\\n        \\n        for (int i = 0; i < length && j < length; i++){\\n            if (arr[i] != 0){\\n                res[j] = arr[i];\\n            } else {\\n                j++;\\n            }\\n            j++;\\n        }\\n        \\n        for (int i = 0; i < length; i++){\\n            arr[i] = res[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148874,
                "title": "simple-python-sol-with-detailed-explanation",
                "content": "\\n        i = 0\\n        \\n        while i <len(arr): # coz index will be out of range as we are poping the last ele\\n            \\n            # although we the length remains same but we are inserting at i+1  so we need to keep i < len(arr)\\n            \\n            if arr[i]!=0:\\n                i+=1\\n                \\n            else:\\n                arr.insert(i+1, 0) # insert (1 st parameter as the position and then val u want to insert)\\n                \\n                i+=2 # coz we have duplicated 0 in next place \\n                arr.pop()",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "\\n        i = 0\\n        \\n        while i <len(arr): # coz index will be out of range as we are poping the last ele\\n            \\n            # although we the length remains same but we are inserting at i+1  so we need to keep i < len(arr)\\n            \\n            if arr[i]!=0:\\n                i+=1\\n                \\n            else:\\n                arr.insert(i+1, 0) # insert (1 st parameter as the position and then val u want to insert)\\n                \\n                i+=2 # coz we have duplicated 0 in next place \\n                arr.pop()",
                "codeTag": "Unknown"
            },
            {
                "id": 781693,
                "title": "c-one-pass-with-a-queue",
                "content": "Using a queue allows us to remember the elements we need to shift in the right order. \\nWe go through the list, and we add the current element in the queue, if it\\'s a zero we add a zero at the end of the queue. The current element is replaced by the first element of the queue.\\n\\n```\\n    void duplicateZeros(vector<int>& arr) {\\n        std::queue<int> q; \\n        for ( int i{0}; i < arr.size(); i++ ) {\\n            q.push(arr[i]);\\n            if ( arr[i] == 0 )\\n                q.push(0);\\n            arr[i] = q.front();\\n            q.pop();\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void duplicateZeros(vector<int>& arr) {\\n        std::queue<int> q; \\n        for ( int i{0}; i < arr.size(); i++ ) {\\n            q.push(arr[i]);\\n            if ( arr[i] == 0 )\\n                q.push(0);\\n            arr[i] = q.front();\\n            q.pop();\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 529613,
                "title": "golang-98-faster",
                "content": "```\\nfunc duplicateZeros(arr []int)  {\\n    for i:= 0; i < len(arr); i++ {\\n        if arr[i] == 0 {\\n            copy(arr[i+1:], arr[i:])\\n            i++\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    for i:= 0; i < len(arr); i++ {\\n        if arr[i] == 0 {\\n            copy(arr[i+1:], arr[i:])\\n            i++\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528320,
                "title": "100-faster-100-less-memory",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        // Clone the current array as the source of inputs.\\n        int[] original = arr.clone();\\n        \\n        // Create two different counter, one for the original array\\n        // the other for the modified array.\\n        int cO = 0;\\n        int cA = 0;\\n        \\n        // Continue until the modified array counter\\n        // is equal to the length of array.\\n        while (cA < arr.length) {\\n            // Copy the current index of original array\\n            // to the current modified array.\\n            arr[cA] = original[cO];\\n            cA++;\\n            \\n            // Only if the current counter of array is still less than the modified array\\n            // and if the original counter points to a zero.\\n            if (cA < arr.length && original[cO] == 0) {\\n                arr[cA] = 0;\\n                cA++;\\n            }\\n            cO++;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        // Clone the current array as the source of inputs.\\n        int[] original = arr.clone();\\n        \\n        // Create two different counter, one for the original array\\n        // the other for the modified array.\\n        int cO = 0;\\n        int cA = 0;\\n        \\n        // Continue until the modified array counter\\n        // is equal to the length of array.\\n        while (cA < arr.length) {\\n            // Copy the current index of original array\\n            // to the current modified array.\\n            arr[cA] = original[cO];\\n            cA++;\\n            \\n            // Only if the current counter of array is still less than the modified array\\n            // and if the original counter points to a zero.\\n            if (cA < arr.length && original[cO] == 0) {\\n                arr[cA] = 0;\\n                cA++;\\n            }\\n            cO++;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362616,
                "title": "easy-arraylist-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n      ArrayList<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n      ArrayList<Integer> ans = new ArrayList<>();\\n        for(int i = 0 ; i < arr.length ; i++){\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777649,
                "title": "fast-easy-3-approaches-c-time-o-n-space-o-1",
                "content": "\\u2B50 Please upvote if you like the post \\u2B50\\n\\n---\\n\\n### Approach 1 - Brute Force\\n**Time Complexity :** O(n^2)\\n**Space Complexity :**  O(1)\\n**Explanation:**\\n1. Iterate over array\\n2. Check if element is 0\\n3. Shift all remaining elements to right by one\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        for(int i=0; i<ARRAY_LENGTH; i++){\\n            if(arr[i] != VALUE_ZERO)\\n                continue;\\n            \\n            for(int j=ARRAY_LENGTH-1; j>i; j--)\\n                arr[j] = arr[j-1];\\n            \\n            i++;\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n### Approach 2 - Queue\\n**Time Complexity :** O(n)\\n**Space Complexity :**  O(n)\\n**Explanation:**\\n1. Create a queue\\n2. Add element to queue\\n3. Check if element is zero\\n4. Then again add element to queue\\n5. Set frontmost elemnt of queue to array\\n6. Remove element from queue\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        queue<int> data;\\n    \\n        for(int index=0; index<ARRAY_LENGTH; index++){\\n            data.push(arr[index]);\\n            \\n            if(arr[index] == VALUE_ZERO)\\n                data.push(arr[index]);\\n            \\n            arr[index] = data.front();\\n            data.pop();\\n        }\\n    }\\n};\\n```\\n\\n---\\n\\n### Approach 3 - Two Pointers\\n**Time Complexity :** O(n)\\n**Space Complexity :**  O(1)\\n**Explanation:**\\n1. Set start to 0 and end to last index\\n2. Iterate over array until end\\n3. Decrement end occurance of 0\\n4. Later iterate over array in reverse until end pointer\\n5. Set end pointer value to current\\n6. Set previous index to 0 on occurence of 0 if start != end\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        int start = 0;\\n        int end = ARRAY_LENGTH-1;\\n        \\n        while(start < end){\\n            if(arr[start] == VALUE_ZERO)\\n                end--;\\n            start++;\\n        }\\n        \\n        for(int index=ARRAY_LENGTH-1; index>end; index--, end--){\\n            arr[index] = arr[end];\\n            \\n            if(arr[end] == VALUE_ZERO && start != end)\\n                arr[--index] = VALUE_ZERO;\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        for(int i=0; i<ARRAY_LENGTH; i++){\\n            if(arr[i] != VALUE_ZERO)\\n                continue;\\n            \\n            for(int j=ARRAY_LENGTH-1; j>i; j--)\\n                arr[j] = arr[j-1];\\n            \\n            i++;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        queue<int> data;\\n    \\n        for(int index=0; index<ARRAY_LENGTH; index++){\\n            data.push(arr[index]);\\n            \\n            if(arr[index] == VALUE_ZERO)\\n                data.push(arr[index]);\\n            \\n            arr[index] = data.front();\\n            data.pop();\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        const int VALUE_ZERO = 0;\\n        const int ARRAY_LENGTH = arr.size();\\n        \\n        int start = 0;\\n        int end = ARRAY_LENGTH-1;\\n        \\n        while(start < end){\\n            if(arr[start] == VALUE_ZERO)\\n                end--;\\n            start++;\\n        }\\n        \\n        for(int index=ARRAY_LENGTH-1; index>end; index--, end--){\\n            arr[index] = arr[end];\\n            \\n            if(arr[end] == VALUE_ZERO && start != end)\\n                arr[--index] = VALUE_ZERO;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572094,
                "title": "java-my-solution-easy",
                "content": "```\\nclass Solution {\\n\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            if (arr[i] == 0) {\\n                list.add(0);\\n                list.add(0);\\n            } \\n            else list.add(arr[i]);\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> list = new ArrayList<>();\\n        for (int i = 0; i < arr.length ; i++) {\\n            if (arr[i] == 0) {\\n                list.add(0);\\n                list.add(0);\\n            } \\n            else list.add(arr[i]);\\n        }\\n\\n        for (int i = 0; i < arr.length; i++) arr[i] = list.get(i);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523683,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                al.add(0);\\n                al.add(0);\\n            }\\n            else al.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n            arr[i]=al.get(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        int n=arr.length;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                al.add(0);\\n                al.add(0);\\n            }\\n            else al.add(arr[i]);\\n        }\\n        for(int i=0;i<n;i++)\\n            arr[i]=al.get(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2521942,
                "title": "javascript-solution",
                "content": "var duplicateZeros = function(arr) {\\n\\n    for(let i = 0; i<arr.length;i++){\\n        if(arr[i]===0){\\n            arr.pop(); \\n            arr.splice(i+1,0,0);\\n            i++\\n        }\\n    }\\n    return arr; \\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var duplicateZeros = function(arr) {\\n\\n    for(let i = 0; i<arr.length;i++){\\n        if(arr[i]===0){\\n            arr.pop(); \\n            arr.splice(i+1,0,0);\\n            i++\\n        }\\n    }\\n    return arr; \\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2482397,
                "title": "c-two-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.size()-1;j>=i+1;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2342060,
                "title": "very-simple-python-solution",
                "content": "```\\nfrom typing import List\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i]==0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i+=1\\n            i+=1\\n            \\n```\\n\\nfrom typing import List Because in Python bversion above 3.9 we need to import Lists",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i]==0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i+=1\\n            i+=1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831220,
                "title": "easy-to-understand-js-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for(let i=arr.length - 1; i >= 0; i--) {\\n        if (arr[i] == 0) {\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j-1];\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    \\n    for(let i=arr.length - 1; i >= 0; i--) {\\n        if (arr[i] == 0) {\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j-1];\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727461,
                "title": "c-stl",
                "content": "```c++\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 0){\\n                arr.insert(arr.begin()+i, 0);\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i=0; i<n; i++){\\n            if(arr[i] == 0){\\n                arr.insert(arr.begin()+i, 0);\\n                i++;\\n            }\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1713111,
                "title": "java-python-o-n",
                "content": "Its easy to do in O(n2) , but once we know the relationship i.e how many places a non zero element has to jump then one pass is pretty easy\\n\\n![image](https://assets.leetcode.com/users/images/9802d8d1-cc87-471d-99a6-1e8d9e77d8b0_1642946094.5311093.png)\\nJava\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] count = new int[arr.length];\\n        int c=0;\\n        \\n        for( int i =0; i < arr.length; i++ ){\\n            if( arr[i] == 0 )   \\n                c++;\\n            count[i]=c;\\n        }\\n        \\n        for( int end = arr.length-1; end >= 0; end-- ){\\n            int newIndex = end + count[end];\\n            if( newIndex < arr.length )  // new index for the non zero element\\n                arr[newIndex]=arr[end];\\n            if( newIndex != end ) //to handle the case if we havent encountered a zero yet\\n                arr[end]=0;\\n        }\\n    }\\n}\\n```\\nPython\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        count = [0]*len(arr)\\n        c=0\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i] == 0:\\n                c+=1\\n            count[i]=c\\n        \\n        for end in range(len(arr)-1,-1,-1):\\n            \\n            newIndex=end+count[end]\\n            \\n            if(newIndex < len(arr)):\\n                arr[newIndex]=arr[end]\\n            \\n            if(newIndex != end ):\\n                arr[end]=0\\n```\\nPlease **upvote** if you find it **useful**. Thanks.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] count = new int[arr.length];\\n        int c=0;\\n        \\n        for( int i =0; i < arr.length; i++ ){\\n            if( arr[i] == 0 )   \\n                c++;\\n            count[i]=c;\\n        }\\n        \\n        for( int end = arr.length-1; end >= 0; end-- ){\\n            int newIndex = end + count[end];\\n            if( newIndex < arr.length )  // new index for the non zero element\\n                arr[newIndex]=arr[end];\\n            if( newIndex != end ) //to handle the case if we havent encountered a zero yet\\n                arr[end]=0;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        count = [0]*len(arr)\\n        c=0\\n        \\n        for i in range(0,len(arr)):\\n            if arr[i] == 0:\\n                c+=1\\n            count[i]=c\\n        \\n        for end in range(len(arr)-1,-1,-1):\\n            \\n            newIndex=end+count[end]\\n            \\n            if(newIndex < len(arr)):\\n                arr[newIndex]=arr[end]\\n            \\n            if(newIndex != end ):\\n                arr[end]=0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1498916,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                ans.push_back(0);   ans.push_back(0);\\n            }else{\\n                ans.push_back(arr[i]);\\n            }\\n            if(ans.size()>=arr.size()){\\n                break;\\n            }\\n        }\\n        if(ans.size()>arr.size()){\\n            ans.pop_back();\\n        }\\n        arr=ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        vector<int> ans;\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                ans.push_back(0);   ans.push_back(0);\\n            }else{\\n                ans.push_back(arr[i]);\\n            }\\n            if(ans.size()>=arr.size()){\\n                break;\\n            }\\n        }\\n        if(ans.size()>arr.size()){\\n            ans.pop_back();\\n        }\\n        arr=ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1091573,
                "title": "runtime-20-ms-c-3-line-of-code",
                "content": "Runtime: 20 ms, faster than 52.11% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.7 MB, less than 84.61% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nfor(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n\\t\\t\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 52.11% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.7 MB, less than 84.61% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nfor(int i=0; i<arr.size();++i){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n\\t\\t\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 967135,
                "title": "swift-solution",
                "content": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n        var index = 0\\n        while (index < arr.count) {\\n            if arr[index] == 0 {\\n                index += 1\\n                arr.insert(0, at: index)\\n                arr.removeLast()\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n        var index = 0\\n        while (index < arr.count) {\\n            if arr[index] == 0 {\\n                index += 1\\n                arr.insert(0, at: index)\\n                arr.removeLast()\\n            }\\n            index += 1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 894022,
                "title": "c-solution",
                "content": "Runtime: 236 ms, faster than 97.45% of C# online submissions for Duplicate Zeros.\\nMemory Usage: 33.5 MB, less than 5.40% of C# online submissions for Duplicate Zeros.\\n\\n```\\nvar zeros = 0;\\nfor (var i = 0; i < arr.Length; i++)\\n\\tif (arr[i] == 0)\\n\\t\\tzeros++;\\n\\nvar len = arr.Length - 1;\\n\\nwhile (len > 0 && zeros > 0)\\n{\\n\\tif (len + zeros <= arr.Length - 1)\\n\\t\\tarr[len + zeros] = arr[len];\\n\\n\\tif (arr[len] == 0)\\n\\t\\tzeros--;\\n\\n\\tarr[len] = 0;\\n\\tlen--;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar zeros = 0;\\nfor (var i = 0; i < arr.Length; i++)\\n\\tif (arr[i] == 0)\\n\\t\\tzeros++;\\n\\nvar len = arr.Length - 1;\\n\\nwhile (len > 0 && zeros > 0)\\n{\\n\\tif (len + zeros <= arr.Length - 1)\\n\\t\\tarr[len + zeros] = arr[len];\\n\\n\\tif (arr[len] == 0)\\n\\t\\tzeros--;\\n\\n\\tarr[len] = 0;\\n\\tlen--;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750040,
                "title": "javascript-two-pass",
                "content": "```\\nvar duplicateZeros = function (arr) {\\n    if (arr == null || arr.length == 0) throw new Error(\"illegal input\");\\n    //move in place, so no extra space\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            //that means must remove last one in arr\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n        else {\\n            continue;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n    if (arr == null || arr.length == 0) throw new Error(\"illegal input\");\\n    //move in place, so no extra space\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] == 0) {\\n            //that means must remove last one in arr\\n            for (let j = arr.length - 1; j > i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n        else {\\n            continue;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 628470,
                "title": "simple-java-solution-ya-dig",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2; j>=i; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2; j>=i; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 421807,
                "title": "python-solution-72-ms-faster-than-99-39-and-13-5-mb-less-than-100-00",
                "content": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        l = len(arr)\\n        i = 0\\n        \\n        while i < len(arr):\\n            if arr[i] == 0:\\n                i += 1\\n                arr.pop()\\n                arr.insert(i, 0)\\n            i += 1",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        l = len(arr)\\n        i = 0\\n        \\n        while i < len(arr):\\n            if arr[i] == 0:\\n                i += 1\\n                arr.pop()\\n                arr.insert(i, 0)\\n            i += 1",
                "codeTag": "Python3"
            },
            {
                "id": 313208,
                "title": "space-o-1-detailed-explanation",
                "content": "This solution is extended on @lee215 \\'s brilliant solution.\\nTo understand the algorithm better, let\\'s look at the following example:\\n\\nThe given array is\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]` // (A) Duplicating zeros\\n\\n`[1, 0, 0, 2, 3, 0, 0, 4 ] ` // (B) Then cut off the array based on the original array size\\n<br>\\nWe can then generalize the idea above to the following steps:\\n\\nWe can have two pointers - \\npt1 = arr.length - 1\\npt2 = the index after duplicating zeros\\n\\nIterate both pointers from back to front\\nOnce `pt2 < arr.length`, we start assigning `arr[pt1]` to the new index `arr[pt2]`,\\nand duplicate zeros on the way.\\n\\n<br>\\nThe whole process should look like this: \\n\\n...........................................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n\\n............................................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\n\\narr[pt1] == 0, so decrement pt2 twice.\\n.....................................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n.................................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\narr[pt1] == 5.\\n\\n..............................pt1\\n`[1, 0, 2, 3, 0, 4, 5, 0]`\\n..........................................pt2\\n`[1, 0, 0, 2, 3, 0, 0, 4, 5, 0, 0]`\\n\\nNow, `pt2 < arr.length`, so we start assigning\\n\\nAssign 4\\n...............................\\u2193.........\\u2193\\n`[1, 0, 2, 3, 0, 4, 5, 4]`\\n\\nAssign 0\\n..........................\\u2193.........\\u2193\\n`[1, 0, 2, 3, 0, 4, 0, 4]`\\n\\n..........................\\u2193...\\u2193\\n`[1, 0, 2, 3, 0, 0, 0, 4]`\\n\\nAssign 3\\n....................\\u2193...\\u2193\\n`[1, 0, 2, 3, 3, 0, 0, 4]`\\n\\nAssign 2\\n..............\\u2193...\\u2193\\n`[1, 0, 2, 2, 3, 0, 0, 4]`\\n\\nAssign 0\\n........\\u2193...\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\n........\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\nAssign 1\\n\\u2193\\n`[1, 0, 0, 2, 3, 0, 0, 4]`\\n\\n\\nImplenmentation -\\n```\\npublic void duplicateZeros(int[] arr) {\\n\\n        int pt2 = 0; // figuring out pt2\\n        for(int i = 0; i < arr.length; i++){\\n            if (arr[i] == 0) pt2++;\\n            pt2++;\\n        }\\n        \\n        int pt1 = arr.length - 1;\\n        pt2--;\\n        while (pt1 >= 0){\\n            if (pt2 < arr.length) arr[pt2] = arr[pt1];// assign if pt2 is in range\\n            pt2--;\\n            if (arr[pt1] == 0){\\n                if (pt2 < arr.length) arr[pt2] = 0; // duplicate zeros\\n                pt2--;\\n            } \\n            pt1--;\\n        }\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void duplicateZeros(int[] arr) {\\n\\n        int pt2 = 0; // figuring out pt2\\n        for(int i = 0; i < arr.length; i++){\\n            if (arr[i] == 0) pt2++;\\n            pt2++;\\n        }\\n        \\n        int pt1 = arr.length - 1;\\n        pt2--;\\n        while (pt1 >= 0){\\n            if (pt2 < arr.length) arr[pt2] = arr[pt1];// assign if pt2 is in range\\n            pt2--;\\n            if (arr[pt1] == 0){\\n                if (pt2 < arr.length) arr[pt2] = 0; // duplicate zeros\\n                pt2--;\\n            } \\n            pt1--;\\n        }\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 313118,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        x = 0\\n        while x < len(arr):\\n            if arr[x] == 0:\\n                arr.insert(x, 0)\\n                arr.pop(-1)\\n                x+=1\\n            x += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        x = 0\\n        while x < len(arr):\\n            if arr[x] == 0:\\n                arr.insert(x, 0)\\n                arr.pop(-1)\\n                x+=1\\n            x += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3634221,
                "title": "c-solution-java-solution-beat-100-in-runtime-tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe function scans the vector, identifies the positions where zeros need to be duplicated, shifts the elements accordingly, and inserts the duplicated zeros in the correct positions.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialization of variables:\\n\\npos is initialized to 0, representing the position in the arr vector.\\nptr is initialized to 0, representing the index in the for loop.\\nFirst for loop:\\n\\nIt iterates over the elements of the arr vector using the index i.\\nIt also keeps track of the number of iterations in the ct variable.\\nInside the loop, it checks if the current element at index ct is equal to 0.\\nIf it is 0, it increments i by 1 to skip the next element.\\nOtherwise, it updates pos to the current value of ct and ptr to the current value of i.\\nSecond for loop:\\n\\nIt iterates backward starting from ptr and continues until index 0.\\nInside the loop, it assigns the value at index pos to the current element at index i.\\nIf the value at index pos is 0 and i is not 0, it decrements i by 1 and assigns 0 to the previous index.\\nIt then decrements pos to move to the previous element.\\nThird for loop:\\n\\nIt iterates over the elements of the arr vector starting from index ptr + 1.\\nInside the loop, it assigns 0 to each element.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the duplicateZeros function can be analyzed as follows:\\n\\nThe first for loop iterates over the elements of the arr vector once, so its time complexity is O(n), where n is the size of the vector.\\n\\nThe second for loop iterates backward from ptr to 0, which can have at most n iterations. Therefore, its time complexity is O(n).\\n\\nThe third for loop iterates over the elements from ptr + 1 to the end of the arr vector, which also has at most n iterations. Thus, its time complexity is O(n).\\n\\nAs a result, the overall time complexity of the function is O(n), where n is the size of the input vector arr.\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nRegarding space complexity, the function does not use any additional data structures that grow with the input size. It only uses a constant amount of extra space for the variables pos and ptr. Therefore, the space complexity of the function is O(1), indicating constant space usage.\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int pos = 0;  // Variable to track the position of the last non-zero element\\n        int ptr = 0;  // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.size(); i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++;  // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct;  // Update `pos` with the index of the last non-zero element\\n                ptr = i;   // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos];  // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0;  // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--;  // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.size(); i++) {\\n            arr[i] = 0;  // Set the remaining elements to 0\\n        }\\n    }\\n};\\n\\n```\\n```Java []\\npublic class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int pos = 0; // Variable to track the position of the last non-zero element\\n        int ptr = 0; // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.length; i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++; // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct; // Update `pos` with the index of the last non-zero element\\n                ptr = i;  // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos]; // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0; // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--; // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.length; i++) {\\n            arr[i] = 0; // Set the remaining elements to 0\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int pos = 0;  // Variable to track the position of the last non-zero element\\n        int ptr = 0;  // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.size(); i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++;  // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct;  // Update `pos` with the index of the last non-zero element\\n                ptr = i;   // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos];  // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0;  // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--;  // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.size(); i++) {\\n            arr[i] = 0;  // Set the remaining elements to 0\\n        }\\n    }\\n};\\n\\n```\n```Java []\\npublic class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int pos = 0; // Variable to track the position of the last non-zero element\\n        int ptr = 0; // Variable to track the current index in the for loop\\n\\n        // First loop: Find positions for duplicating zeros and update `pos` and `ptr`\\n        for (int i = 0, ct = 0; i < arr.length; i++, ct++) {\\n            if (arr[ct] == 0) {\\n                i++; // Increment `i` to skip the next element when a zero is encountered\\n            } else {\\n                pos = ct; // Update `pos` with the index of the last non-zero element\\n                ptr = i;  // Update `ptr` with the current index in the for loop\\n            }\\n        }\\n\\n        // Second loop: Perform duplication and shifting\\n        for (int i = ptr; i >= 0; i--) {\\n            arr[i] = arr[pos]; // Shift the elements to the right by assigning the value of the last non-zero element\\n\\n            // Duplicate zeros by inserting 0 in the correct position\\n            if (arr[pos] == 0 && i != 0) {\\n                arr[--i] = 0; // Decrement `i` and assign 0 to the previous index\\n            }\\n\\n            pos--; // Move to the previous non-zero element\\n        }\\n\\n        // Third loop: Set remaining elements to 0\\n        for (int i = ptr + 1; i < arr.length; i++) {\\n            arr[i] = 0; // Set the remaining elements to 0\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057945,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n\\n        var i = 0\\n        \\n        while i < arr.count {\\n            if arr[i] == 0 {\\n                arr.insert(0, at: i)\\n                arr.removeLast()\\n                i += 2\\n            }\\n            else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func duplicateZeros(_ arr: inout [Int]) {\\n\\n        var i = 0\\n        \\n        while i < arr.count {\\n            if arr[i] == 0 {\\n                arr.insert(0, at: i)\\n                arr.removeLast()\\n                i += 2\\n            }\\n            else {\\n                i += 1\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2838928,
                "title": "python-one-pass-with-o-n-space-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse a new pointer to record index with duplicated zero.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreate a pointer `j=0`. When we encounter a `0`, add j twice.\\nOne thing to note is that in case of out of bound error, break is necessary in the for loop.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j = 0\\n        for n in arr[:]:\\n            if n == 0:\\n                arr[j] = 0\\n                j += 1\\n                if j == len(arr):\\n                    break\\n                arr[j] = 0\\n            else:\\n                arr[j] = n\\n            j += 1\\n            if j == len(arr):\\n                break\\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        j = 0\\n        for n in arr[:]:\\n            if n == 0:\\n                arr[j] = 0\\n                j += 1\\n                if j == len(arr):\\n                    break\\n                arr[j] = 0\\n            else:\\n                arr[j] = n\\n            j += 1\\n            if j == len(arr):\\n                break\\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641801,
                "title": "js-very-easy-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0 ; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0 ; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0);\\n            arr.pop();\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2593862,
                "title": "java-solution-simple-solution-duplicate-zeros",
                "content": "```\\nclass Solution {\\n       public static void shift(int[] arr,int i)\\n    {\\n        for(int k=arr.length-1;k>i+1;k--)\\n        {\\n            arr[k]=arr[k-1];\\n        }\\n        \\n    }\\n    public void duplicateZeros(int[] arr) {\\n        \\n        \\n   for(int i=0;i<arr.length-1;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                shift(arr,i);\\n                arr[i+1]=0;\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    \\n \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n       public static void shift(int[] arr,int i)\\n    {\\n        for(int k=arr.length-1;k>i+1;k--)\\n        {\\n            arr[k]=arr[k-1];\\n        }\\n        \\n    }\\n    public void duplicateZeros(int[] arr) {\\n        \\n        \\n   for(int i=0;i<arr.length-1;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                shift(arr,i);\\n                arr[i+1]=0;\\n                i++;\\n            }\\n        }\\n        \\n    }\\n    \\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458136,
                "title": "kotlin-with-queue",
                "content": "```\\nclass Solution {\\n    fun duplicateZeros(arr: IntArray) {\\n        var possibleDups = 0\\n        var length_ = arr.size - 1\\n\\n        // Find the number of zeros to be duplicated\\n        // Stopping when left points beyond the last element in the original array\\n        // which would be part of the modified array\\n        var left = 0\\n        while (left <= length_ - possibleDups) {\\n            // Count the zeros\\n            if (arr[left] == 0) {\\n                // Edge case: This zero can\\'t be duplicated. We have no more space,\\n                // as left is pointing to the last element which could be included\\n                if (left == length_ - possibleDups) {\\n                    // For this zero we just copy it without duplication.\\n                    arr[length_] = 0\\n                    length_ -= 1\\n                    break\\n                }\\n                possibleDups++\\n            }\\n            left++\\n        }\\n\\n        // Start backwards from the last element which would be part of the new array.\\n        var last = length_ - possibleDups\\n\\n        // Copy zero twice, and non-zero once.\\n        var i = last\\n        while (i >= 0) {\\n            if (arr[i] == 0) {\\n                arr[i + possibleDups] = 0\\n                possibleDups--\\n                arr[i + possibleDups] = 0\\n            } else {\\n                arr[i + possibleDups] = arr[i]\\n            }\\n            i--\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun duplicateZeros(arr: IntArray) {\\n        var possibleDups = 0\\n        var length_ = arr.size - 1\\n\\n        // Find the number of zeros to be duplicated\\n        // Stopping when left points beyond the last element in the original array\\n        // which would be part of the modified array\\n        var left = 0\\n        while (left <= length_ - possibleDups) {\\n            // Count the zeros\\n            if (arr[left] == 0) {\\n                // Edge case: This zero can\\'t be duplicated. We have no more space,\\n                // as left is pointing to the last element which could be included\\n                if (left == length_ - possibleDups) {\\n                    // For this zero we just copy it without duplication.\\n                    arr[length_] = 0\\n                    length_ -= 1\\n                    break\\n                }\\n                possibleDups++\\n            }\\n            left++\\n        }\\n\\n        // Start backwards from the last element which would be part of the new array.\\n        var last = length_ - possibleDups\\n\\n        // Copy zero twice, and non-zero once.\\n        var i = last\\n        while (i >= 0) {\\n            if (arr[i] == 0) {\\n                arr[i + possibleDups] = 0\\n                possibleDups--\\n                arr[i + possibleDups] = 0\\n            } else {\\n                arr[i + possibleDups] = arr[i]\\n            }\\n            i--\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456817,
                "title": "go-o-n-2-with-shifting",
                "content": "```\\nfunc duplicateZeros(arr []int)  {\\n    i := 0\\n    \\n    for i < len(arr) {\\n        if arr[i] == 0 {\\n            for j := len(arr)-2; j > i; j-- {\\n                arr[j+1] = arr[j]\\n            }\\n            \\n            if i+1 < len(arr) {\\n                arr[i+1] = 0\\n            }\\n            \\n            i += 2\\n        } else {\\n            i++            \\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    i := 0\\n    \\n    for i < len(arr) {\\n        if arr[i] == 0 {\\n            for j := len(arr)-2; j > i; j-- {\\n                arr[j+1] = arr[j]\\n            }\\n            \\n            if i+1 < len(arr) {\\n                arr[i+1] = 0\\n            }\\n            \\n            i += 2\\n        } else {\\n            i++            \\n        }\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2253051,
                "title": "javascript-o-n-solution-faster-than-98",
                "content": "## Solution description:\\nIterate from the beginning of the array\\n\\nWhen we see a zero:\\n1. minus `lastKeepIdx` by one (move one index back), which means we\\'ll add duplicate the zero and remove item at `lastKeepIdx`. Keep items before the index of `lastKeepIdx`.\\n2. Set `lastDuplicatedZero` value to be current index to indicate the last index of zero we want to duplicate.\\n\\nRepeat the above process until current index is the last index we want to keep (`lastKeepIdx`). Note, if the current index has 0 value but it equals to the last index we want to keep, we don\\'t mark it as `lastDuplicatedZero` because we don\\'t have more space to duplicate a zero for it.\\n\\nWe only change the array when `lastKeepIdx` is not the last index of the array. If it\\'s the last index of the array, which means we want to keep the whole array and do nothing. (When no zeros in the array)\\n\\nIterate from the end of the array to shift whole array to the end and duplicate zeros\\n1. Replace the current index element with the element at `lastKeepIdx` (the last element that we want to keep)\\n2. If the element we want to keep is zero AND its index is less or equal to `lastDuplicatedZero` index -> duplicate the zero by replacing previous index with zero and reduce index by one\\n3. Reduce `lastKeepIdx` by one\\n\\nRepeat the process until `lastKeepIdx` is less than 0\\n\\n## Variables Declare:\\n`lastKeepIdx ` : last element\\'s index to keep in the array.\\n`lastDuplicatedZero` : last index of zero to duplicate(sometimes the last zero can\\'t be duplicated because there\\'s no more space). Default to be `undefined` because there may be no zero in the array.\\n\\n```\\nvar duplicateZeros = function(arr) {\\n    let lastKeepIdx = arr.length-1\\n    let lastDuplicatedZero\\n    \\n    for (let i = 0; i <= lastKeepIdx; i++) {\\n        if (arr[i] === 0 && i !== lastKeepIdx) {\\n            lastKeepIdx--\\n            lastDuplicatedZero = i\\n        }\\n    }\\n    if (lastKeepIdx < arr.length-1) {\\n        for (let i = arr.length - 1; lastKeepIdx >= 0; i--) {\\n            arr[i] = arr[lastKeepIdx]\\n            if (arr[lastKeepIdx] === 0 && lastKeepIdx <= lastDuplicatedZero) {\\n                arr[i-1] = 0\\n                i--\\n            }\\n            lastKeepIdx--\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let lastKeepIdx = arr.length-1\\n    let lastDuplicatedZero\\n    \\n    for (let i = 0; i <= lastKeepIdx; i++) {\\n        if (arr[i] === 0 && i !== lastKeepIdx) {\\n            lastKeepIdx--\\n            lastDuplicatedZero = i\\n        }\\n    }\\n    if (lastKeepIdx < arr.length-1) {\\n        for (let i = arr.length - 1; lastKeepIdx >= 0; i--) {\\n            arr[i] = arr[lastKeepIdx]\\n            if (arr[lastKeepIdx] === 0 && lastKeepIdx <= lastDuplicatedZero) {\\n                arr[i-1] = 0\\n                i--\\n            }\\n            lastKeepIdx--\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2009080,
                "title": "python-faster-than-69-04-one-loop-solution",
                "content": "![image](https://assets.leetcode.com/users/images/67c595c7-1097-43f1-adf2-ee00ff0447dc_1651712212.6238477.png)\\n**Code:**\\n```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        index = 0\\n        while index < len(arr):\\n            if arr[index] == 0:\\n                index += 1\\n                arr.insert(index - 1, 0)\\n                arr.pop()\\n            index += 1\\n```\\n______________________________________\\nKindly upvote the solution if you liked it. Any questions/suggestions are welcome, have a nice day :)\\n\\n**My GitHub with Leetcode Solutions --->** https://github.com/Krsmanovic-S/Leetcode-Exercises",
                "solutionTags": [],
                "code": "```\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        index = 0\\n        while index < len(arr):\\n            if arr[index] == 0:\\n                index += 1\\n                arr.insert(index - 1, 0)\\n                arr.pop()\\n            index += 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1852747,
                "title": "python-3-in-place-easy-to-understand-using-two-pointers-o-n",
                "content": "I beleive this code will be helpful to you. \\n1. Count zeroes in the array\\n2. Define two pointers,  i and  j \\n3. iterate from the end of the array while i < j\\n4. if j is within the array\\'s range put arr[i] in arr[j]\\n5. if arr[i] ==0, move j one step to the left and if j is within the array\\'s range put arr[i] in arr[j]\\n\\nHere is an example:\\narr = [1,0,2,3,0,4,5,0]\\n\\ni = 7 and j = 10  --->   if arr[i] == 0  :  [1, 0, 2, 3, 0, 4, 5, 0]\\ni = 6 and j = 8\\ni = 5 and j = 7   --->  if j < len(arr) :  [1, 0, 2, 3, 0, 4, 5, 4]\\ni = 4 and j = 6   --->  if j < len(arr) :  [1, 0, 2, 3, 0, 4, 0, 4]\\n----------------->  if arr[i] == 0  :  [1, 0, 2, 3, 0, 0, 0, 4]\\ni = 3 and j = 4   --->  if j < len(arr) :  [1, 0, 2, 3, 3, 0, 0, 4]\\ni = 2 and j = 3   --->  if j < len(arr) :  [1, 0, 2, 2, 3, 0, 0, 4]\\ni = 1 and j = 2   --->  if j < len(arr) :  [1, 0, 0, 2, 3, 0, 0, 4]\\n----------------->  if arr[i] == 0  :  [1, 0, 0, 2, 3, 0, 0, 4]\\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr): #if j is within the array\\'s range\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: #if arr[i] has zero \\n                j -= 1\\n                if j < len(arr): #if j is within the array\\'s range\\n                    arr[j] = arr[i]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#move one step to the left\\n            i -=1\\n            j -=1\\n```\\n\\t\\t\\t\\nI figured when we put zero in the second if condiction instead of arr[i] it\\'s going to be faster. I recommend the second one better but the above code is good to first understand the code.\\n\\n\\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr):\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: \\n                j -= 1\\n                if j < len(arr):\\n                    arr[j] = 0\\n\\n\\t\\t\\t#moving two pointers one step to the left\\n            i -=1\\n            j -=1\\n```\\n\\nplease **UPVOTE** if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr): #if j is within the array\\'s range\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: #if arr[i] has zero \\n                j -= 1\\n                if j < len(arr): #if j is within the array\\'s range\\n                    arr[j] = arr[i]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t#move one step to the left\\n            i -=1\\n            j -=1\\n```\n```\\n\\t\\tzeroes = arr.count(0) #count the number of zeroes in the arr\\n        i , j = len(arr) - 1, len(arr) -1 + zeroes #define i and j pointers\\n        \\n        while i<j:\\n            if j < len(arr):\\n                arr[j] = arr[i]\\n                \\n            if arr[i] == 0: \\n                j -= 1\\n                if j < len(arr):\\n                    arr[j] = 0\\n\\n\\t\\t\\t#moving two pointers one step to the left\\n            i -=1\\n            j -=1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1741074,
                "title": "python3-99-03-faster-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = 0\\n        while(left<len(arr)):\\n            if arr[left]==0:\\n                arr.pop()\\n                arr.insert(left,0)\\n                left+=2\\n            else:\\n                left+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = 0\\n        while(left<len(arr)):\\n            if arr[left]==0:\\n                arr.pop()\\n                arr.insert(left,0)\\n                left+=2\\n            else:\\n                left+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1620603,
                "title": "java-0ms-100-explanations",
                "content": "```\\nclass Solution {\\n    /** Algorithm :\\n     *  1. Create a new array (shifted[]) of the same Size. The correct elements from arr[] will be copied to shifted[]\\n     *  2. Loop with 2 indexes: i over arr[] and j over shifted[].\\n     *     - If arr[i] is != 0, copy it to shifted[j]. Increment i and j\\n     *     - If arr[i] == 0, increment i by 1 and j by 2 as shifted[j,j+1] are already 0.\\n     *     - Incrementing by 2 will simulate the insertion of a 0 in shifted\\n     */\\n    public void duplicateZeros(int[] arr) {\\n        int[] shifted = new int[arr.length];\\n        for (int i = 0, j = 0; i < arr.length && j < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                shifted[j++] = arr[i];\\n            } else {\\n                j += 2;\\n            }\\n        }\\n        System.arraycopy(shifted, 0, arr, 0, arr.length);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    /** Algorithm :\\n     *  1. Create a new array (shifted[]) of the same Size. The correct elements from arr[] will be copied to shifted[]\\n     *  2. Loop with 2 indexes: i over arr[] and j over shifted[].\\n     *     - If arr[i] is != 0, copy it to shifted[j]. Increment i and j\\n     *     - If arr[i] == 0, increment i by 1 and j by 2 as shifted[j,j+1] are already 0.\\n     *     - Incrementing by 2 will simulate the insertion of a 0 in shifted\\n     */\\n    public void duplicateZeros(int[] arr) {\\n        int[] shifted = new int[arr.length];\\n        for (int i = 0, j = 0; i < arr.length && j < arr.length; i++) {\\n            if (arr[i] != 0) {\\n                shifted[j++] = arr[i];\\n            } else {\\n                j += 2;\\n            }\\n        }\\n        System.arraycopy(shifted, 0, arr, 0, arr.length);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1463052,
                "title": "easy-javascript-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let len = arr.length;\\n    \\n    if(!arr.includes(0)) return arr;\\n    \\n    for(let i = 0; i<len; i++) {\\n        if(arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            i++;\\n        }\\n        arr.length = len;\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let len = arr.length;\\n    \\n    if(!arr.includes(0)) return arr;\\n    \\n    for(let i = 0; i<len; i++) {\\n        if(arr[i] === 0) {\\n            arr.splice(i, 0, 0);\\n            i++;\\n        }\\n        arr.length = len;\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1435919,
                "title": "javascript",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n  const len = arr.length\\n  for ( let i = 0; i < len; i++ ) {\\n      if (arr[i] === 0) {\\n        arr.splice(i, 0, 0)\\n        i++\\n      }\\n  }\\n  arr.length = len\\n};\\n```\\n\\nRuntime: 97 ms\\nMemory Usage: 39.8 MB",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n  const len = arr.length\\n  for ( let i = 0; i < len; i++ ) {\\n      if (arr[i] === 0) {\\n        arr.splice(i, 0, 0)\\n        i++\\n      }\\n  }\\n  arr.length = len\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1346853,
                "title": "java-simple-solution-2-approach-o-n-space-o-1-space",
                "content": "Approch One \\n```\\n// Without using extra space \\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n\\t\\t\\t//if we found zero we have to shift all by one place to right till where we found zero\\n                for(int j=arr.length-1;j>i;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t\\t// i is incremented because if we shift by one next we be zero only that\\'s we have skip that\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\\nApproch Two\\n```\\n// Using Extra Space\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                li.add(arr[i]);\\n            }\\n            else\\n            {\\n                li.add(arr[i]);\\n                li.add(arr[i]);\\n            }\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i]=li.get(i);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Without using extra space \\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n\\t\\t\\t//if we found zero we have to shift all by one place to right till where we found zero\\n                for(int j=arr.length-1;j>i;j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t\\t// i is incremented because if we shift by one next we be zero only that\\'s we have skip that\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```\n```\\n// Using Extra Space\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        List<Integer> li=new ArrayList<>();\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]!=0)\\n            {\\n                li.add(arr[i]);\\n            }\\n            else\\n            {\\n                li.add(arr[i]);\\n                li.add(arr[i]);\\n            }\\n        }\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            arr[i]=li.get(i);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331769,
                "title": "c-solution-brute-force-26-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n-1; i++)\\n            if(arr[i] == 0){\\n                for(int j = n-1; j > i; j--) \\n                    arr[j] = arr[j-1];\\n                arr[i+1] = 0;\\n                i++;\\n            }     \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        for(int i = 0; i < n-1; i++)\\n            if(arr[i] == 0){\\n                for(int j = n-1; j > i; j--) \\n                    arr[j] = arr[j-1];\\n                arr[i+1] = 0;\\n                i++;\\n            }     \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161240,
                "title": "runtime-52-ms-faster-than-84-20-python-simple-and-easy-to-understand",
                "content": "```\\n\\ni = 0\\nlength = len(arr)\\nwhile(i < length - 1):\\n\\tif arr[i] == 0:\\n\\t\\tarr.pop(-1)\\n\\t\\tarr.insert(i, 0)\\n\\t\\ti+=1\\n\\ti+=1\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\ni = 0\\nlength = len(arr)\\nwhile(i < length - 1):\\n\\tif arr[i] == 0:\\n\\t\\tarr.pop(-1)\\n\\t\\tarr.insert(i, 0)\\n\\t\\ti+=1\\n\\ti+=1\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1089597,
                "title": "java-commented-o-n-solution-with-two-pointers",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int newArraySize = 0;\\n        int iterator = 0;\\n        \\n        // count how many zeros should we duplicate\\n        // when \\'newArraySize\\' is the same as `arr.length` we stop our search because future zeroes will be out the array range\\n        while(iterator < arr.length && newArraySize < arr.length) { \\n            int val = arr[iterator];\\n            \\n            if(val == 0) {\\n                zeroCount++;\\n                newArraySize += 2; // 2 because we should add 2 zeroes to the result array\\n            } else {\\n                newArraySize++;\\n            }\\n            \\n            iterator++;\\n        }\\n        \\n        // two pointers which we will use to copy \\n        // pointer when the first array should be ended after we add necessary zeroes\\n        int copyFrom = iterator - 1; // \"-1\" because we increased \\'iterator\\' at the last step on our previous loop\\n        // where we will copy\\n        int copyTo = arr.length - 1;\\n        \\n        // if the last number is zero and if we copy it our new array will be longer than original one\\n        boolean isTrailingZero = newArraySize > arr.length;\\n        \\n        // go from the tail of array and move numbers\\n        while(copyFrom >= 0) {\\n            int val = arr[copyFrom];\\n            \\n            // if this numer is zero\\n            if(val == 0) {\\n                if(isTrailingZero && copyTo == arr.length - 1) {\\n                    // if it\\'s the last number is zero we shouldn\\'t add two zeroes to the result array\\n                    arr[copyTo] = val;\\n                } else {\\n                    // add two zeroes in a row \\n                    arr[copyTo] = val;\\n                    copyTo--;\\n                    arr[copyTo] = val;\\n                }\\n            } else {\\n                // just copy the number\\n                arr[copyTo] = val;\\n            }\\n            \\n            // move pointers\\n            copyFrom--;\\n            copyTo--;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int newArraySize = 0;\\n        int iterator = 0;\\n        \\n        // count how many zeros should we duplicate\\n        // when \\'newArraySize\\' is the same as `arr.length` we stop our search because future zeroes will be out the array range\\n        while(iterator < arr.length && newArraySize < arr.length) { \\n            int val = arr[iterator];\\n            \\n            if(val == 0) {\\n                zeroCount++;\\n                newArraySize += 2; // 2 because we should add 2 zeroes to the result array\\n            } else {\\n                newArraySize++;\\n            }\\n            \\n            iterator++;\\n        }\\n        \\n        // two pointers which we will use to copy \\n        // pointer when the first array should be ended after we add necessary zeroes\\n        int copyFrom = iterator - 1; // \"-1\" because we increased \\'iterator\\' at the last step on our previous loop\\n        // where we will copy\\n        int copyTo = arr.length - 1;\\n        \\n        // if the last number is zero and if we copy it our new array will be longer than original one\\n        boolean isTrailingZero = newArraySize > arr.length;\\n        \\n        // go from the tail of array and move numbers\\n        while(copyFrom >= 0) {\\n            int val = arr[copyFrom];\\n            \\n            // if this numer is zero\\n            if(val == 0) {\\n                if(isTrailingZero && copyTo == arr.length - 1) {\\n                    // if it\\'s the last number is zero we shouldn\\'t add two zeroes to the result array\\n                    arr[copyTo] = val;\\n                } else {\\n                    // add two zeroes in a row \\n                    arr[copyTo] = val;\\n                    copyTo--;\\n                    arr[copyTo] = val;\\n                }\\n            } else {\\n                // just copy the number\\n                arr[copyTo] = val;\\n            }\\n            \\n            // move pointers\\n            copyFrom--;\\n            copyTo--;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057060,
                "title": "c-few-lines",
                "content": "```public void DuplicateZeros(int[] arr) {        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] == 0){\\n                int right = arr.Length - 1;\\n                while(right > i){\\n                    arr[right] = arr[right -1];\\n                    right--;\\n                }\\n                 i = i + 1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "```public void DuplicateZeros(int[] arr) {        \\n        for(int i = 0; i < arr.Length; i++){\\n            if(arr[i] == 0){\\n                int right = arr.Length - 1;\\n                while(right > i){\\n                    arr[right] = arr[right -1];\\n                    right--;\\n                }\\n                 i = i + 1;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1054947,
                "title": "java-two-pass-easy-to-understand-two-pointers-o-1-space",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0, n = arr.length;\\n        for(int num : arr) count += (num == 0) ? 1 : 0;\\n        int lastIndex = n + count - 1;\\n        \\n        for(int i = n-1; i >= 0 && lastIndex >= 0; i--) {\\n            if(arr[i] == 0) { // set zeroes and move two places backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = 0;\\n                if((lastIndex-1) < n && lastIndex > 0)\\n\\t\\t\\t\\t   arr[lastIndex-1] = 0;\\n                lastIndex -= 2;\\n            } else { // set same value and move one place backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = arr[i];\\n                lastIndex -= 1;\\n            }\\n        }\\n    }\\n}\\n```\\n\\nIdea using an example:\\n- Consider the array: `[8,4,5,0,0,0,0,7]`\\n- Consider an **imaginary additional length** next to the array that can accommodate the additional zeroes.\\n- With that idea in mind, the `lastIndex` will be at `length(arr) + count(zeroes) - 1` (in this case, it would be `lastIndex = 11` for `[8,4,5,0,0,0,0,7..0,0,0,0]`)\\n- Now loop through backwards with `i` being the last element of **actual** array and update the array with **valid** `lastIndex` value decrements.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int count = 0, n = arr.length;\\n        for(int num : arr) count += (num == 0) ? 1 : 0;\\n        int lastIndex = n + count - 1;\\n        \\n        for(int i = n-1; i >= 0 && lastIndex >= 0; i--) {\\n            if(arr[i] == 0) { // set zeroes and move two places backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = 0;\\n                if((lastIndex-1) < n && lastIndex > 0)\\n\\t\\t\\t\\t   arr[lastIndex-1] = 0;\\n                lastIndex -= 2;\\n            } else { // set same value and move one place backwards (via lastIndex)\\n                if(lastIndex < n)\\n\\t\\t\\t\\t   arr[lastIndex] = arr[i];\\n                lastIndex -= 1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 944706,
                "title": "python3-solution-hard-to-be-simpler-than-this",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        n = len(arr)\\n        for i in reversed(range(len(arr))):\\n            if arr[i] == 0:\\n                arr.insert(i, 0)\\n                arr.pop()\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        n = len(arr)\\n        for i in reversed(range(len(arr))):\\n            if arr[i] == 0:\\n                arr.insert(i, 0)\\n                arr.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 939707,
                "title": "java-single-pass",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2;j>i;j--){\\n                    arr[j+1]=arr[j];\\n                }\\n                i++;\\n                arr[i]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length-1;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-2;j>i;j--){\\n                    arr[j+1]=arr[j];\\n                }\\n                i++;\\n                arr[i]=0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 916247,
                "title": "javascript-99-simple-short-comments",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0); // Insert new 0\\n            i++; // Increase pointer so that newly inserted 0 gets skipped\\n            arr.pop(); // Remove last element to maintain length\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (let i = 0; i < arr.length; i++) {\\n        if (!arr[i]) {\\n            arr.splice(i, 0, 0); // Insert new 0\\n            i++; // Increase pointer so that newly inserted 0 gets skipped\\n            arr.pop(); // Remove last element to maintain length\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 903520,
                "title": "python-two-pass-in-place-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        w = len(arr) - 1 + arr.count(0)  # \\'write to\\' index\\n        \\n        for r in range(len(arr) - 1, -1, -1): # \\'read from\\' index\\n            if arr[r] == 0:  # insert extra 0\\n                if w < len(arr):\\n                    arr[w] = 0\\n                w -= 1\\n                \\n            if w < len(arr):\\n                arr[w] = arr[r]\\n            w -= 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        w = len(arr) - 1 + arr.count(0)  # \\'write to\\' index\\n        \\n        for r in range(len(arr) - 1, -1, -1): # \\'read from\\' index\\n            if arr[r] == 0:  # insert extra 0\\n                if w < len(arr):\\n                    arr[w] = 0\\n                w -= 1\\n                \\n            if w < len(arr):\\n                arr[w] = arr[r]\\n            w -= 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 772472,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]==0){                   //if we bump into 0 \\n\\t\\t\\t  for(int j=arr.size()-1;j>i+1;j--){  //move all elements (from a[i+2] to end) to the left once \\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t  arr[i+1]=0;    //duplicate a[i]\\n                i++;    //skip arr[i+1] and go on\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size()-1;i++){\\n            if(arr[i]==0){                   //if we bump into 0 \\n\\t\\t\\t  for(int j=arr.size()-1;j>i+1;j--){  //move all elements (from a[i+2] to end) to the left once \\n                    arr[j]=arr[j-1];\\n                }\\n\\t\\t\\t  arr[i+1]=0;    //duplicate a[i]\\n                i++;    //skip arr[i+1] and go on\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 577431,
                "title": "simple-while-loop-python-beginner-solution-48ms-beat-96",
                "content": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] != 0:\\n                i += 1\\n            else:\\n                arr.insert(i+1,0)\\n                i += 2\\n                arr.pop()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] != 0:\\n                i += 1\\n            else:\\n                arr.insert(i+1,0)\\n                i += 2\\n                arr.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565310,
                "title": "javascript",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let length = arr.length;\\n    let snake = [];\\n    let part = 0;\\n    for (let i = 0; i < length; i++) {\\n        let cur = arr[i];\\n        if (cur === 0) {\\n            snake.push(0);\\n            snake.push(0);\\n        } else {\\n            snake.push(cur);\\n        };\\n        arr[i] = snake[part++];\\n    };\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let length = arr.length;\\n    let snake = [];\\n    let part = 0;\\n    for (let i = 0; i < length; i++) {\\n        let cur = arr[i];\\n        if (cur === 0) {\\n            snake.push(0);\\n            snake.push(0);\\n        } else {\\n            snake.push(cur);\\n        };\\n        arr[i] = snake[part++];\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 369747,
                "title": "simple-c-98-28-100-inplace",
                "content": "Runtime: 16 ms, faster than 98.28% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int countZero = 0;\\n        for(int i=0; i<n; i++)\\n            countZero += (arr[i] == 0 ? 1 : 0);\\n        \\n        int newLen = n + countZero - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n                \\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n            }\\n            else\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = arr[i];\\n                newLen--;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Runtime: 16 ms, faster than 98.28% of C++ online submissions for Duplicate Zeros.\\nMemory Usage: 9.1 MB, less than 100.00% of C++ online submissions for Duplicate Zeros.\\n\\n```\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        int countZero = 0;\\n        for(int i=0; i<n; i++)\\n            countZero += (arr[i] == 0 ? 1 : 0);\\n        \\n        int newLen = n + countZero - 1;\\n        for(int i=n-1; i>=0; i--)\\n        {\\n            if(arr[i] == 0)\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n                \\n                if(newLen < n)\\n                    arr[newLen] = 0;\\n                newLen--;\\n            }\\n            else\\n            {\\n                if(newLen < n)\\n                    arr[newLen] = arr[i];\\n                newLen--;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 369620,
                "title": "java-1ms-2-passes",
                "content": "Sharing my solution, glad to hear opinions\\n```\\n    public void duplicateZeros(int[] arr) {\\n        int numOfZeroes = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                numOfZeroes++;\\n            }\\n        }\\n        if (numOfZeroes == 0) {\\n            return;\\n        }\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (i + numOfZeroes < arr.length) {\\n\\t\\t\\t\\t//moving number forward by number of remaining zeros\\n                arr[i + numOfZeroes] = arr[i];\\n            }\\n            if (arr[i] == 0) {\\n\\t\\t\\t\\t//decreasing number of zeros to correct future movements\\n                numOfZeroes--;\\n            } else {\\n\\t\\t\\t\\t//making current element 0 (it could be updated later)\\n                arr[i] = 0;\\n            }\\n            if (numOfZeroes == 0) {\\n                break;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "Sharing my solution, glad to hear opinions\\n```\\n    public void duplicateZeros(int[] arr) {\\n        int numOfZeroes = 0;\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                numOfZeroes++;\\n            }\\n        }\\n        if (numOfZeroes == 0) {\\n            return;\\n        }\\n        for (int i = arr.length - 1; i >= 0; i--) {\\n            if (i + numOfZeroes < arr.length) {\\n\\t\\t\\t\\t//moving number forward by number of remaining zeros\\n                arr[i + numOfZeroes] = arr[i];\\n            }\\n            if (arr[i] == 0) {\\n\\t\\t\\t\\t//decreasing number of zeros to correct future movements\\n                numOfZeroes--;\\n            } else {\\n\\t\\t\\t\\t//making current element 0 (it could be updated later)\\n                arr[i] = 0;\\n            }\\n            if (numOfZeroes == 0) {\\n                break;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 354942,
                "title": "python-3-faster-than-98-less-space-than-100",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        if not arr or len(arr) < 1:\\n            return\\n        \\n        zero_count = arr.count(0)\\n        p_short, p_long = len(arr) - 1, len(arr) + zero_count - 1\\n        while p_short >= 0:\\n            if arr[p_short] != 0:\\n                if p_long < len(arr):\\n                    arr[p_long] = arr[p_short]\\n            else:\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                p_long -= 1\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                    \\n            p_short -= 1\\n            p_long -= 1\\n                    \\n        \\n                \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        \\n        if not arr or len(arr) < 1:\\n            return\\n        \\n        zero_count = arr.count(0)\\n        p_short, p_long = len(arr) - 1, len(arr) + zero_count - 1\\n        while p_short >= 0:\\n            if arr[p_short] != 0:\\n                if p_long < len(arr):\\n                    arr[p_long] = arr[p_short]\\n            else:\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                p_long -= 1\\n                if p_long < len(arr):\\n                    arr[p_long] = 0\\n                    \\n            p_short -= 1\\n            p_long -= 1\\n                    \\n        \\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 332083,
                "title": "python-solution",
                "content": "Python solution using temporary list (100 % in memory)\\n\\t\\t\\t\\n\\t\\tlis=[]\\n        n=len(arr)\\n        for i in range(n):\\n            if(arr[i]==0):\\n                lis.append(0)    \\n            lis.append(arr[i])\\n        \\n        for i in range(n):\\n            arr[i]=lis[i]",
                "solutionTags": [],
                "code": "Python solution using temporary list (100 % in memory)\\n\\t\\t\\t\\n\\t\\tlis=[]\\n        n=len(arr)\\n        for i in range(n):\\n            if(arr[i]==0):\\n                lis.append(0)    \\n            lis.append(arr[i])\\n        \\n        for i in range(n):\\n            arr[i]=lis[i]",
                "codeTag": "Unknown"
            },
            {
                "id": 323122,
                "title": "2ms-java-solution",
                "content": "Ideas:\\n* Hold values from the original array in a queue and pop elements one by one\\n* If a 0 is at the front of the queue when popping, place it in the array twice\\n* This technique can easily be modified for placing zeros 3 times or 4 times or etc. Most of the two pointer \\nsolutions here would require significant changes. Most interviews have follow up questions/requirements so make robust solutions!\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i : arr) queue.add(i);\\n        int i = 0;\\n        while(i <= arr.length - 1) {\\n            int top = queue.poll();\\n            if(top != 0) {\\n                arr[i++] = top;\\n            } else {\\n                arr[i++] = top;\\n                if(i > arr.length - 1) return;\\n                arr[i++] = top;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for(int i : arr) queue.add(i);\\n        int i = 0;\\n        while(i <= arr.length - 1) {\\n            int top = queue.poll();\\n            if(top != 0) {\\n                arr[i++] = top;\\n            } else {\\n                arr[i++] = top;\\n                if(i > arr.length - 1) return;\\n                arr[i++] = top;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 312986,
                "title": "c-faster-than-100-of-all-submissions",
                "content": "```\\nvoid duplicateZeros(vector<int>& a) {\\n        \\n        int i,j,n=a.size();\\n        for(i=0;i<n;i++)\\n        {\\n            if(a[i]==0)\\n            {\\n                a.insert(a.begin()+i, 0);\\n                a.pop_back();\\n                i++;\\n            }\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvoid duplicateZeros(vector<int>& a) {\\n        \\n        int i,j,n=a.size();\\n        for(i=0;i<n;i++)\\n        {\\n            if(a[i]==0)\\n            {\\n                a.insert(a.begin()+i, 0);\\n                a.pop_back();\\n                i++;\\n            }\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3678498,
                "title": "2-easy-c-solution-beginner-friendly-approach-using-swap-insert-and-resize",
                "content": "\\n\\n# Code\\n```\\n// Solution (using swap())\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==0 && (i+1)<n){\\n                for(int j=n-1; j>i+1; j--)\\n                    swap(nums[j], nums[j-1]);\\n                nums[++i]=0;\\n            }\\n        }\\n    }\\n};\\n\\n// Solution 2 (Using insert and resize)\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n                i++;\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// Solution (using swap())\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& nums) {\\n        int count=0, n=nums.size();\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i]==0 && (i+1)<n){\\n                for(int j=n-1; j>i+1; j--)\\n                    swap(nums[j], nums[j-1]);\\n                nums[++i]=0;\\n            }\\n        }\\n    }\\n};\\n\\n// Solution 2 (Using insert and resize)\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int i=0, n=arr.size();\\n        while(i<n)\\n        {\\n            if(arr[i]==0)\\n            {\\n                arr.insert(arr.begin()+i, 0);\\n                i += 2;\\n            }\\n            else\\n                i++;\\n        }\\n        arr.resize(n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550951,
                "title": "easy-approach-using-string",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Use String and then update the element of array\\n\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        String s=\"\";\\n        StringBuilder t= new StringBuilder(); \\n        for(int a: arr) s+=a;\\n\\n        for(int i=0;i<s.length();i++){\\n            //if encounter 0 append one more zero and delete the last element\\n\\n            if(s.charAt(i)==\\'0\\'){\\n                t.append(\\'0\\');\\n                t.append(\\'0\\');\\n\\n            }else t.append(s.charAt(i));\\n\\n                    \\n            }\\n            String u= t.toString();\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=u.charAt(i)-\\'0\\';\\n            }\\n         return ;\\n    }\\n   \\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        String s=\"\";\\n        StringBuilder t= new StringBuilder(); \\n        for(int a: arr) s+=a;\\n\\n        for(int i=0;i<s.length();i++){\\n            //if encounter 0 append one more zero and delete the last element\\n\\n            if(s.charAt(i)==\\'0\\'){\\n                t.append(\\'0\\');\\n                t.append(\\'0\\');\\n\\n            }else t.append(s.charAt(i));\\n\\n                    \\n            }\\n            String u= t.toString();\\n            for(int i=0;i<arr.length;i++){\\n                arr[i]=u.charAt(i)-\\'0\\';\\n            }\\n         return ;\\n    }\\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436746,
                "title": "easy-solution-with-explanation",
                "content": "# Duplicate Zeros Solution\\n\\nWe are going to duplicate each occurrence of zero and shift the remaining elements to the right.\\n\\nTo get started, let\\'s iterate over the array from left to right and check each element. Whenever we come across a zero, we\\'ll need to do a little bit of magic. We\\'ll shift all the remaining elements from one position to the right and the current position is already zero. \\n\\nIt may sound a bit complicated, but trust me, it\\'s easier than it sounds! With just a few lines of code, you\\'ll be able to duplicate those zeros in no time. \\n\\nNow, let\\'s put this into action with some JavaScript code:\\n\\n```\\nfor (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            for (let j = arr.length - 1; j > i; j--) arr[j] = arr[j-1];\\n            i++\\n        }\\n    }\\n```\\n\\nThis code will loop through the array and check each element. If it encounters a zero, it will shift all the remaining elements one position to the right and duplicate the zero in the current position.\\n\\nAnd there you have it! With this algorithm, you can easily duplicate each occurrence of zero and shift the remaining elements to the right. Happy coding!",
                "solutionTags": [],
                "code": "```\\nfor (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            for (let j = arr.length - 1; j > i; j--) arr[j] = arr[j-1];\\n            i++\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3319754,
                "title": "easy-python-solution-beats-91",
                "content": "# Intuition\\nEasy solution \\n\\n# Approach\\nusing insert in python\\n\\n# Complexity\\n- Time complexity:\\n  O(m) where m = length of final array\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = len(arr)\\n        a= []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                a.append(i)\\n        k =0\\n        for i in range(len(a)):\\n            arr.insert(a[i]+k,0)\\n            k+=1\\n        m = len(arr)\\n        for i in range(m-n):\\n            arr.pop()\\n        return arr\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = len(arr)\\n        a= []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                a.append(i)\\n        k =0\\n        for i in range(len(a)):\\n            arr.insert(a[i]+k,0)\\n            k+=1\\n        m = len(arr)\\n        for i in range(m-n):\\n            arr.pop()\\n        return arr\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3123265,
                "title": "java-easy-solution-100-faster-2-approach",
                "content": "\\n\\n# 1st approach (Java Code))\\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(n)\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        int i =0;\\n        int j =0;\\n        while(j<nums.length && i<arr.length) {\\n            if(arr[i] == 0) {\\n                nums[j] =0;\\n                if(j+1<arr.length) {\\n                    nums[j+1] =0;\\n                }\\n                j +=2;\\n                i++;\\n            } \\n            else {\\n                nums[j] = arr[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(int k =0;k<arr.length;k++) {\\n            arr[k] = nums[k];\\n        }\\n        \\n    }\\n}\\n```\\n# 2nd approach (Java Code))\\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(1)\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nZe =0;\\n        for(int i : arr) {\\n            if(i==0) nZe++;\\n        }\\n        int i = arr.length-1;\\n        int j = arr.length+nZe-1;\\n        while(i!=j) {\\n            insert(arr,i,j);\\n            j--;\\n            if(arr[i]==0) {\\n                insert(arr,i,j);\\n                j--;\\n            }\\n            i--;\\n        }\\n    }\\n    void insert(int[] arr, int i, int j) {\\n        if(j<arr.length) {\\n            arr[j] = arr[i];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nTime complexity: O(n)\\n\\nSpace complexity: O(n)\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int[] nums = new int[arr.length];\\n        int i =0;\\n        int j =0;\\n        while(j<nums.length && i<arr.length) {\\n            if(arr[i] == 0) {\\n                nums[j] =0;\\n                if(j+1<arr.length) {\\n                    nums[j+1] =0;\\n                }\\n                j +=2;\\n                i++;\\n            } \\n            else {\\n                nums[j] = arr[i];\\n                i++;\\n                j++;\\n            }\\n        }\\n        for(int k =0;k<arr.length;k++) {\\n            arr[k] = nums[k];\\n        }\\n        \\n    }\\n}\\n```\n```\\nTime complexity: O(n)\\n\\nSpace complexity: O(1)\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nZe =0;\\n        for(int i : arr) {\\n            if(i==0) nZe++;\\n        }\\n        int i = arr.length-1;\\n        int j = arr.length+nZe-1;\\n        while(i!=j) {\\n            insert(arr,i,j);\\n            j--;\\n            if(arr[i]==0) {\\n                insert(arr,i,j);\\n                j--;\\n            }\\n            i--;\\n        }\\n    }\\n    void insert(int[] arr, int i, int j) {\\n        if(j<arr.length) {\\n            arr[j] = arr[i];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082372,
                "title": "duplicate-zeros-java-solution",
                "content": "# Complexity\\n- Time complexity: (N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: (1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        if(len == 1)\\n            return;\\n       int start = 0, end = len-1;\\n       while(start < end){\\n            if(arr[start] == 0)\\n                end--;\\n            start++;\\n        }\\n        if(end == len-1)\\n            return;\\n        for(int i = len-1; i >= 0 && end >= 0; i--, end--){\\n            arr[i] = arr[end];    \\n            if(arr[end] == 0 && end != start){\\n                arr[i-1] = 0;\\n                i--;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        if(len == 1)\\n            return;\\n       int start = 0, end = len-1;\\n       while(start < end){\\n            if(arr[start] == 0)\\n                end--;\\n            start++;\\n        }\\n        if(end == len-1)\\n            return;\\n        for(int i = len-1; i >= 0 && end >= 0; i--, end--){\\n            arr[i] = arr[end];    \\n            if(arr[end] == 0 && end != start){\\n                arr[i-1] = 0;\\n                i--;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952717,
                "title": "java-1-ms-o-n-time-complexity-efficient",
                "content": "\\n# Complexity\\n- Time complexity:\\nO ( n )\\n\\n- Space complexity:\\nO ( n )\\n\\n# Code\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nums[]=new int[arr.length];\\n        int i=0;\\n        int j=0;\\n        while(j<nums.length && i<arr.length){\\n            if(arr[i]==0){\\n                nums[j]=0;\\n                if(j+1<nums.length){\\n                    nums[j+1]=0;\\n                }\\n                j+=2;\\n                i++;\\n            }\\n            else{\\n                nums[j]=arr[i];\\n                j++;\\n                i++;\\n            }\\n        }\\n        for(int k=0; k<nums.length; k++){\\n            arr[k]=nums[k];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int nums[]=new int[arr.length];\\n        int i=0;\\n        int j=0;\\n        while(j<nums.length && i<arr.length){\\n            if(arr[i]==0){\\n                nums[j]=0;\\n                if(j+1<nums.length){\\n                    nums[j+1]=0;\\n                }\\n                j+=2;\\n                i++;\\n            }\\n            else{\\n                nums[j]=arr[i];\\n                j++;\\n                i++;\\n            }\\n        }\\n        for(int k=0; k<nums.length; k++){\\n            arr[k]=nums[k];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2877660,
                "title": "my-solution-i-m-learning-kindly-check-the-code-and-advice-how-can-i-improve",
                "content": "```\\n\\n```class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        l = len(arr)\\n        lst = []\\n        for i in range(len(arr)):\\n            if arr[i]==0:\\n                lst.append(i)\\n        lst\\n        for x,y in enumerate(lst):\\n            lst[x] = lst[x] + x\\n            arr.insert(lst[x-1],0)\\n        while l != len(arr):\\n            arr.pop(-1)",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2734016,
                "title": "duplicate-zeros",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i =0;\\n        while(i<arr.length){\\n        if(arr[i]==0){\\n        int j=arr.length-1;\\n         while(j>i){\\n         arr[j]=arr[j-1];  \\n         j--;\\n     }\\n         i=i+1;\\n     }\\n         i++;\\n     }\\n    }\\n}\\n      ```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i =0;\\n        while(i<arr.length){\\n        if(arr[i]==0){\\n        int j=arr.length-1;\\n         while(j>i){\\n         arr[j]=arr[j-1];  \\n         j--;\\n     }\\n         i=i+1;\\n     }\\n         i++;\\n     }\\n    }\\n}\\n      ```",
                "codeTag": "Java"
            },
            {
                "id": 2732666,
                "title": "java-duplicate-zeros",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int a[]=new int[arr.length];\\n        int j=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(j==arr.length)break;\\n            if(arr[i]==0){\\n                a[j++]=0;\\n                 if(j==arr.length)break;\\n                a[j++]=0;\\n            }\\n            else{\\n                a[j++]=arr[i];\\n            }\\n            \\n        }\\n        \\n        j=0;\\n        for(int ele:a){\\n            arr[j++]=ele;\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int a[]=new int[arr.length];\\n        int j=0;\\n        for(int i=0;i<arr.length;i++){\\n            if(j==arr.length)break;\\n            if(arr[i]==0){\\n                a[j++]=0;\\n                 if(j==arr.length)break;\\n                a[j++]=0;\\n            }\\n            else{\\n                a[j++]=arr[i];\\n            }\\n            \\n        }\\n        \\n        j=0;\\n        for(int ele:a){\\n            arr[j++]=ele;\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2705763,
                "title": "python-two-pointers",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        oldLen = len(arr) \\n        i = 0\\n        j = len(arr)\\n        \\n        while i < j :\\n            if arr[i] == 0 :\\n                arr.insert(i+1 , 0)\\n                i += 1\\n            i += 1\\n        \\n        arr[:] = arr[:oldLen]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        oldLen = len(arr) \\n        i = 0\\n        j = len(arr)\\n        \\n        while i < j :\\n            if arr[i] == 0 :\\n                arr.insert(i+1 , 0)\\n                i += 1\\n            i += 1\\n        \\n        arr[:] = arr[:oldLen]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507113,
                "title": "in-place-javascript-solution-using-splice",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar duplicateZeros = function (arr) {\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0)  \\n            arr.pop()\\n            i++\\n        }\\n    }\\n\\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n\\n    for (let i = 0; i < arr.length; i++) {\\n        if (arr[i] === 0) {\\n            arr.splice(i, 0, 0)  \\n            arr.pop()\\n            i++\\n        }\\n    }\\n\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2494950,
                "title": "java-simple-and-easy-solution-beats-69",
                "content": "```\\n ArrayList<Integer> ans = new ArrayList<>();\\n        //first we make an arryalist ;\\n        \\n        //then we iterate through the arr and\\n        for(int i = 0 ; i < arr.length ; i++){\\n            //we add the element as it is if it is not equalls to 0 ;\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                //if not then we add two zeroes ;\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        \\n        //then we use a for loop for changing the elements of arr array ;\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n    //we don\\'t return anything bcz it\\'s a void function",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n ArrayList<Integer> ans = new ArrayList<>();\\n        //first we make an arryalist ;\\n        \\n        //then we iterate through the arr and\\n        for(int i = 0 ; i < arr.length ; i++){\\n            //we add the element as it is if it is not equalls to 0 ;\\n            if(arr[i] != 0){\\n                ans.add(arr[i]);\\n            }else{\\n                //if not then we add two zeroes ;\\n                ans.add(0);\\n                ans.add(0);\\n            }\\n        }\\n        \\n        //then we use a for loop for changing the elements of arr array ;\\n        for(int i = 0 ; i < arr.length ;i++){\\n            arr[i] = ans.get(i);\\n        }\\n    //we don\\'t return anything bcz it\\'s a void function",
                "codeTag": "Unknown"
            },
            {
                "id": 2409322,
                "title": "c-easiest-and-short-solution-for-duplicate-zeros",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i=0;i<arr.size();i++){\\n            if(arr[i]==0){\\n                arr.pop_back();\\n                arr.insert(arr.begin()+i,0);\\n                ++i;\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2400164,
                "title": "java-solution",
                "content": "**If we encounter a zero in the array we move the last but one element to the last position ans the last element is removed automatically so the void place created after zero is filled by zero as defalut int value**\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                for(int j=arr.length-1;j>i;j--){\\n                    arr[j]=arr[j-1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359986,
                "title": "javascript-solution",
                "content": "The solution is based on the leetcode definition for array insertion and it followed all the criteria from the question.\\n\\n```\\nvar duplicateZeros = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--) {\\n        if(arr[i] === 0) {\\n            for(let j=arr.length-1; j>=i; j--) {\\n             if(j+1 <= arr.length-1) { \\n                 arr[j+1] = arr[j] \\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for(let i=arr.length-1; i>=0; i--) {\\n        if(arr[i] === 0) {\\n            for(let j=arr.length-1; j>=i; j--) {\\n             if(j+1 <= arr.length-1) { \\n                 arr[j+1] = arr[j] \\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2319878,
                "title": "python-o-n-solution",
                "content": "#### **Final Code:**\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        count = 0\\n        while count < len(arr):\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n            else:\\n                count += 1\\n```\\n\\n#### **Steps:**\\n* **Step1:**\\nCreate a count variable and set it to 0 (this will act as out index value)\\n```count = 0```\\n\\n* **Step2:**\\nRun a while loop till the count is not greater than the length of our array.\\n```while count < len(arr):```\\n\\n* **Step2:** At each position check if the element is 0 or not, and\\n**If it is zero**:\\ninsert a 0 in the place element at index value of our count.\\nafter this we will have 2 zeros now we need to jump ahead 2 steps so that we dont encounter the same \\nzero again,\\nAnd we also have to remove the element at last position of the array to kepp it the same size.\\n```\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n```\\n**If it is Not zero**:\\njust increase the count by 1 and check again for zeros.\\n```\\n            else:\\n                count += 1\\n```\\n\\n* **Step3:**\\nAfter all this we shoud have modified our array in place : )\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        count = 0\\n        while count < len(arr):\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n            else:\\n                count += 1\\n```\n```count = 0```\n```while count < len(arr):```\n```\\n            if arr[count] == 0:\\n                arr.insert(count, 0)\\n                arr.pop()\\n                count += 2\\n```\n```\\n            else:\\n                count += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2243218,
                "title": "python-o-n-arr-in-place",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        count_zero = 0\\n        for x in arr:\\n            if x ==0:\\n                count_zero +=1\\n        for i in range(n-1,-1, -1):\\n            if i+count_zero < n:\\n                arr[i+count_zero] = arr[i]\\n            if arr[i] == 0:\\n                count_zero -= 1\\n                if i + count_zero < n:\\n                    arr[i + count_zero] = arr[i]\\n```\\t\\t\\t\\t\\t",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        count_zero = 0\\n        for x in arr:\\n            if x ==0:\\n                count_zero +=1\\n        for i in range(n-1,-1, -1):\\n            if i+count_zero < n:\\n                arr[i+count_zero] = arr[i]\\n            if arr[i] == 0:\\n                count_zero -= 1\\n                if i + count_zero < n:\\n                    arr[i + count_zero] = arr[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160356,
                "title": "hex-python3-two-pointers",
                "content": "## Solution\\n### Simulation\\n- A combination of python\\'s built-in functions pop and insert is used.\\n\\n- The time complexity of insert is O(n)\\n\\n```\\nLists:\\n                               Complexity\\nOperation     | Example      | Class         | Notes\\n--------------+--------------+---------------+-------------------------------\\nIndex         | l[i]         | O(1)          |\\nStore         | l[i] = 0     | O(1)          |\\nLength        | len(l)       | O(1)          |\\nAppend        | l.append(5)  | O(1)          |\\nClear         | l.clear()    | O(1)          | similar to l = []\\n\\nSlice         | l[a:b]       | O(b-a)        | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)\\nExtend        | l.extend(...)| O(len(...))   | depends only on len of extension\\nConstruction  | list(...)    | len(...)      | depends on lenghth of argument\\n\\ncheck ==, !=  | l1 == l2     | O(N)          |\\nInsert        | l[a:b] = ... | O(N)          |\\nDelete        | del l[i]     | O(N)          |\\nRemove        | l.remove(...)| O(N)          |\\nContainment   | x in/not in l| O(N)          | searches list\\nCopy          | l.copy()     | O(N)          | Same as l[:] which is O(N)\\nPop           | l.pop(...)   | O(N)          |\\nPop           | l.pop()      | O(1)          | same as l.pop(-1), popping at end\\nExtreme value | min(l)/max(l)| O(N)          |\\nReverse       | l.reverse()  | O(N)          |\\nIteration     | for v in l:  | O(N)          |\\n\\nSort          | l.sort()     | O(N Log N)    | key/reverse doesn\\'t change this\\nMultiply      | k*l          | O(k N)        | 5*l is O(N): len(l)*l is O(N**2)\\n```\\n\\n```python\\n# O(n^2) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        idx = 0\\n        while idx < len(arr):\\n            if arr[idx] == 0:\\n                arr.pop()\\n                arr.insert(idx, 0)\\n                idx+=1\\n            idx+=1\\n```\\n\\n### Two Pointers\\nTraverse the number of zeros and the end position of the data,\\nImagine that each zero is pushed onto the stack twice, and the traversal ends when the stack is as long as the array. Pops elements from the top of the stack in order.\\n\\nA pointer left represents the data position (the top of the stack), and a pointer represents the write position (the current write position of the original array)\\n\\n```python\\n# O(n) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = -1\\n        top_idx = 0\\n        \\n        while top_idx < len(arr):\\n            left+=1\\n            if arr[left]:\\n                top_idx+=1\\n            else:\\n                top_idx+=2\\n            \\n        right = len(arr)-1\\n        if top_idx == len(arr) +1:\\n            arr[right] = 0\\n            right -=1\\n            left -=1\\n        \\n        while right >=0:\\n            arr[right] = arr[left]\\n            right -=1\\n            if arr[left] == 0:\\n                arr[right] = arr[left]\\n                right -=1\\n            left-=1\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers",
                    "Simulation"
                ],
                "code": "```\\nLists:\\n                               Complexity\\nOperation     | Example      | Class         | Notes\\n--------------+--------------+---------------+-------------------------------\\nIndex         | l[i]         | O(1)          |\\nStore         | l[i] = 0     | O(1)          |\\nLength        | len(l)       | O(1)          |\\nAppend        | l.append(5)  | O(1)          |\\nClear         | l.clear()    | O(1)          | similar to l = []\\n\\nSlice         | l[a:b]       | O(b-a)        | l[1:5]:O(l)/l[:]:O(len(l)-0)=O(N)\\nExtend        | l.extend(...)| O(len(...))   | depends only on len of extension\\nConstruction  | list(...)    | len(...)      | depends on lenghth of argument\\n\\ncheck ==, !=  | l1 == l2     | O(N)          |\\nInsert        | l[a:b] = ... | O(N)          |\\nDelete        | del l[i]     | O(N)          |\\nRemove        | l.remove(...)| O(N)          |\\nContainment   | x in/not in l| O(N)          | searches list\\nCopy          | l.copy()     | O(N)          | Same as l[:] which is O(N)\\nPop           | l.pop(...)   | O(N)          |\\nPop           | l.pop()      | O(1)          | same as l.pop(-1), popping at end\\nExtreme value | min(l)/max(l)| O(N)          |\\nReverse       | l.reverse()  | O(N)          |\\nIteration     | for v in l:  | O(N)          |\\n\\nSort          | l.sort()     | O(N Log N)    | key/reverse doesn\\'t change this\\nMultiply      | k*l          | O(k N)        | 5*l is O(N): len(l)*l is O(N**2)\\n```\n```python\\n# O(n^2) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        idx = 0\\n        while idx < len(arr):\\n            if arr[idx] == 0:\\n                arr.pop()\\n                arr.insert(idx, 0)\\n                idx+=1\\n            idx+=1\\n```\n```python\\n# O(n) time | O(1) space\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        left = -1\\n        top_idx = 0\\n        \\n        while top_idx < len(arr):\\n            left+=1\\n            if arr[left]:\\n                top_idx+=1\\n            else:\\n                top_idx+=2\\n            \\n        right = len(arr)-1\\n        if top_idx == len(arr) +1:\\n            arr[right] = 0\\n            right -=1\\n            left -=1\\n        \\n        while right >=0:\\n            arr[right] = arr[left]\\n            right -=1\\n            if arr[left] == 0:\\n                arr[right] = arr[left]\\n                right -=1\\n            left-=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143771,
                "title": "c-easy-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        //int val=count(arr.begin(),arr.end(),1);\\n        \\n        vector<int>aksh;\\n        // just removing the base case ............\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] !=0)\\n            {\\n             aksh.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                aksh.push_back(0);\\n                aksh.push_back(0);\\n            }\\n            if(aksh.size()==n)\\n            {\\n                break;\\n            }\\n        }\\n        aksh.resize(n);\\n        arr=aksh;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        //int val=count(arr.begin(),arr.end(),1);\\n        \\n        vector<int>aksh;\\n        // just removing the base case ............\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            if(arr[i] !=0)\\n            {\\n             aksh.push_back(arr[i]);\\n            }\\n            else\\n            {\\n                aksh.push_back(0);\\n                aksh.push_back(0);\\n            }\\n            if(aksh.size()==n)\\n            {\\n                break;\\n            }\\n        }\\n        aksh.resize(n);\\n        arr=aksh;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076271,
                "title": "c-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        stack<int> st,st2 ;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.push(arr[i]);\\n            if(st.top()==0)\\n            {\\n                st.push(0);\\n            }\\n            \\n        }\\n        int k = st.size();\\n        while(k!=n)\\n        {\\n           st.pop(); \\n            k--;\\n        }\\n        int arr2[n];\\n        int i=0;\\nwhile(st.empty()!=true)\\n{\\n    st2.push(st.top());\\n    st.pop();\\n}\\n          while(st2.empty()!=true)\\n          {\\n              arr[i]=st2.top();\\n              st2.pop();\\n              i++;\\n          }\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        stack<int> st,st2 ;\\n\\n        for(int i=0;i<arr.size();i++)\\n        {\\n            st.push(arr[i]);\\n            if(st.top()==0)\\n            {\\n                st.push(0);\\n            }\\n            \\n        }\\n        int k = st.size();\\n        while(k!=n)\\n        {\\n           st.pop(); \\n            k--;\\n        }\\n        int arr2[n];\\n        int i=0;\\nwhile(st.empty()!=true)\\n{\\n    st2.push(st.top());\\n    st.pop();\\n}\\n          while(st2.empty()!=true)\\n          {\\n              arr[i]=st2.top();\\n              st2.pop();\\n              i++;\\n          }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2025687,
                "title": "java-multiple-approaches-easy-understanding-brute-force-to-optimal",
                "content": "\\n\\tpublic class DuplicateZeros {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {1, 0, 2, 3, 0, 4, 5, 0};\\n        duplicateZerosApproach3Optimal(arr);\\n        System.out.println(\"\");\\n    }\\n\\n    // TC: O(N^2) SC: O(1)\\n    private static void duplicateZerosApproach1(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                shiftRight(arr, i);\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private static void shiftRight(int[] arr, int i) {\\n        for (int j = arr.length - 1; j > i; j--) {\\n            arr[j] = arr[j - 1];\\n        }\\n    }\\n\\n    // TC: O(N) SC: O(N)\\n    private static void duplicateZerosApproach2UsingQueue(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            queue.add(arr[i]);\\n            if (arr[i] == 0) {\\n                queue.add(0);\\n            }\\n            arr[i] = queue.remove();\\n        }\\n    }\\n\\n\\n    // TC: O(N) SC: O(1)\\n    private static void duplicateZerosApproach3Optimal(int[] arr) {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                count++;\\n            }\\n        }\\n        int i=arr.length-1, j=arr.length+count-1;\\n        while(i!=j){\\n            insert(arr,i,j--);\\n            if(arr[i]==0){\\n                insert(arr,i,j--);\\n            }\\n            i--;\\n        }\\n\\n    }\\n\\n    private static void insert(int[] arr, int i, int j) {\\n        if(j<arr.length){\\n            arr[j]=arr[i];\\n        }\\n    }\\n\\n\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "\\n\\tpublic class DuplicateZeros {\\n\\n    public static void main(String[] args) {\\n        int[] arr = {1, 0, 2, 3, 0, 4, 5, 0};\\n        duplicateZerosApproach3Optimal(arr);\\n        System.out.println(\"\");\\n    }\\n\\n    // TC: O(N^2) SC: O(1)\\n    private static void duplicateZerosApproach1(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                shiftRight(arr, i);\\n                i++;\\n            }\\n        }\\n    }\\n\\n    private static void shiftRight(int[] arr, int i) {\\n        for (int j = arr.length - 1; j > i; j--) {\\n            arr[j] = arr[j - 1];\\n        }\\n    }\\n\\n    // TC: O(N) SC: O(N)\\n    private static void duplicateZerosApproach2UsingQueue(int[] arr) {\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 0; i < arr.length; i++) {\\n            queue.add(arr[i]);\\n            if (arr[i] == 0) {\\n                queue.add(0);\\n            }\\n            arr[i] = queue.remove();\\n        }\\n    }\\n\\n\\n    // TC: O(N) SC: O(1)\\n    private static void duplicateZerosApproach3Optimal(int[] arr) {\\n        int count =0;\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i]==0){\\n                count++;\\n            }\\n        }\\n        int i=arr.length-1, j=arr.length+count-1;\\n        while(i!=j){\\n            insert(arr,i,j--);\\n            if(arr[i]==0){\\n                insert(arr,i,j--);\\n            }\\n            i--;\\n        }\\n\\n    }\\n\\n    private static void insert(int[] arr, int i, int j) {\\n        if(j<arr.length){\\n            arr[j]=arr[i];\\n        }\\n    }\\n\\n\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1883014,
                "title": "c-solution",
                "content": "```\\n public void DuplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                for(int j = arr.Length - 1; j > i; j--)\\n                {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public void DuplicateZeros(int[] arr) {\\n        for(int i = 0; i < arr.Length; i++)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                for(int j = arr.Length - 1; j > i; j--)\\n                {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1862515,
                "title": "java-time-o-n-space-o-n",
                "content": "\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int n = arr.length;\\n        \\n        //if input = [1,0,2,3,0,4,5,0]\\n            //zeroCount = 3\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n        \\n        // temptArray size = n + 3\\n        int[] temptArray = new int[n + zeroCount];\\n        int index = 0;\\n        \\n        //temptArray = [1,0,0,2,3,0,0,4,5,0,0]\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                temptArray[++index] = 0;\\n            }\\n            else {\\n                temptArray[index] = arr[i];\\n            }\\n            \\n            index++;\\n        }\\n        \\n        // arr = [1,0,0,2,3,0,0,4]  won\\'t add in [5, 0, 0]\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = temptArray[i];\\n        }\\n        \\n        //Time: O(n)\\n        //Space: O(n)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int zeroCount = 0;\\n        int n = arr.length;\\n        \\n        //if input = [1,0,2,3,0,4,5,0]\\n            //zeroCount = 3\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                zeroCount++;\\n            }\\n        }\\n        \\n        // temptArray size = n + 3\\n        int[] temptArray = new int[n + zeroCount];\\n        int index = 0;\\n        \\n        //temptArray = [1,0,0,2,3,0,0,4,5,0,0]\\n        for (int i = 0; i < n; i++) {\\n            if (arr[i] == 0) {\\n                temptArray[++index] = 0;\\n            }\\n            else {\\n                temptArray[index] = arr[i];\\n            }\\n            \\n            index++;\\n        }\\n        \\n        // arr = [1,0,0,2,3,0,0,4]  won\\'t add in [5, 0, 0]\\n        for (int i = 0; i < n; i++) {\\n            arr[i] = temptArray[i];\\n        }\\n        \\n        //Time: O(n)\\n        //Space: O(n)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724484,
                "title": "easy-java-solution-in-o-n",
                "content": "```class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i = 0 , len = arr.length;\\n        \\n       while(i < len-1){\\n            if(arr[i] == 0){\\n                for(int j = len - 2 ; j > i ; j--){\\n                    arr[j+1] = arr[j];\\n                }\\n                arr[i+1] = 0;\\n                i++;\\n            }\\n           i++;\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int i = 0 , len = arr.length;\\n        \\n       while(i < len-1){\\n            if(arr[i] == 0){\\n                for(int j = len - 2 ; j > i ; j--){\\n                    arr[j+1] = arr[j];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1688467,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for(let i=0; i<arr.length; i++) {\\n        if(arr[i] == 0) {\\n            for(let j=arr.length-1; j>i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    for(let i=0; i<arr.length; i++) {\\n        if(arr[i] == 0) {\\n            for(let j=arr.length-1; j>i; j--) {\\n                arr[j] = arr[j - 1];\\n            }\\n            i++;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650941,
                "title": "two-pointers-python-with-easy-to-understand",
                "content": "```py\\nclass Solution:\\n    @staticmethod\\n    def duplicateZeros(arr: List[int]) -> None:\\n        N = len(arr)\\n        cnz = count(arr)\\n\\n        write_idx = N + cnz - 1\\n        curr = N - 1\\n        \\n        while curr >= 0 and write_idx >= 0:\\n            if write_idx < N:\\n                arr[write_idx] = arr[curr]\\n            write_idx -=1\\n            \\n            if arr[curr] == 0:\\n                if write_idx < N:\\n                    arr[write_idx] = arr[curr]\\n                write_idx -= 1\\n            curr-=1\\n    \\n    @staticmethod\\n    def count(arr: List[int]) -> int:\\n        count = 0\\n        for e in arr:\\n            if e == 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    @staticmethod\\n    def duplicateZeros(arr: List[int]) -> None:\\n        N = len(arr)\\n        cnz = count(arr)\\n\\n        write_idx = N + cnz - 1\\n        curr = N - 1\\n        \\n        while curr >= 0 and write_idx >= 0:\\n            if write_idx < N:\\n                arr[write_idx] = arr[curr]\\n            write_idx -=1\\n            \\n            if arr[curr] == 0:\\n                if write_idx < N:\\n                    arr[write_idx] = arr[curr]\\n                write_idx -= 1\\n            curr-=1\\n    \\n    @staticmethod\\n    def count(arr: List[int]) -> int:\\n        count = 0\\n        for e in arr:\\n            if e == 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1622200,
                "title": "javascript-efficient-solution-w-o-splice-beats-99",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    let zeroesCount = arr.filter(x => x === 0).length;\\n    const len = arr.length;\\n    for (let i = len-1; i>= 0; i--) {\\n        if (i + zeroesCount < len) {\\n            arr[i + zeroesCount] = arr[i];\\n        }\\n        if (arr[i] === 0) {\\n            zeroesCount--;\\n            if (i + zeroesCount < len) {\\n                arr[i + zeroesCount] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    let zeroesCount = arr.filter(x => x === 0).length;\\n    const len = arr.length;\\n    for (let i = len-1; i>= 0; i--) {\\n        if (i + zeroesCount < len) {\\n            arr[i + zeroesCount] = arr[i];\\n        }\\n        if (arr[i] === 0) {\\n            zeroesCount--;\\n            if (i + zeroesCount < len) {\\n                arr[i + zeroesCount] = 0;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1584515,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut i=0;\\n        while i < arr.len()-1{\\n            if arr[i] == 0{\\n                for j in (i+1..=arr.len()-1).rev(){\\n                    arr[j] = arr[j-1]\\n                }\\n                arr[i+1] = 0;\\n                i +=1;\\n            }\\n            i+=1\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut i=0;\\n        while i < arr.len()-1{\\n            if arr[i] == 0{\\n                for j in (i+1..=arr.len()-1).rev(){\\n                    arr[j] = arr[j-1]\\n                }\\n                arr[i+1] = 0;\\n                i +=1;\\n            }\\n            i+=1\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1532914,
                "title": "python3-simple-and-easy-one-faster-than-94",
                "content": "class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \\n        \"\"\"\\n        i = 0 \\n        n = len(arr)\\n        while i < n :\\n            \\n            if arr[i] == 0:\\n                ## remove the last one \\n                arr.pop()\\n                ### insert 0 next to 0 \\n                arr.insert(i+1, 0)\\n                i += 2\\n            else:\\n                i += 1\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \\n        \"\"\"\\n        i = 0 \\n        n = len(arr)\\n        while i < n :\\n            \\n            if arr[i] == 0:\\n                ## remove the last one \\n                arr.pop()\\n                ### insert 0 next to 0 \\n                arr.insert(i+1, 0)\\n                i += 2\\n            else:\\n                i += 1\\n",
                "codeTag": "Java"
            },
            {
                "id": 1421031,
                "title": "c-o-n-o-1-simple-solution-explained-faster-94-25-memory-99-85",
                "content": "Steps:\\n* First find how many elements will cover up the whole array if we duplicate 0. let, till index `i`.\\n* Then try to stretch the subarray `[0,i]` to the right.\\n[ if the value at index `i` is 0, duplicating it may exceed the array length ]\\n\\nConsider the given example:\\n`[1,0,2,3,0,4,5,0]`, array length is 8.\\n\\t\\t\\t\\t\\t\\t\\t\\tindex: `0 1 2 3 4 5 6 7`\\ncontribution in final array: `1 2 1 1 2 1 1 2`\\n\\nSo the  the subarray [0,5] will cover up the array of length 8.\\n\\nNow, stretch the array to the right:\\nput value of index \\n* 5 to index 7              ` [ -, -, -, -, -, -, -, 4]`\\n* 4 to index 6 & 5  ` [ -, -, -, -, -, 0, 0, 4]`\\n*  3 to index 4   `[ -, -, -, -,3, 0, 0, 4]`\\n*   2 to index 3   ` [ -, -, -, 2,3, 0, 0, 4]`\\n*   1 to index 2 & 1  ` [ -, 0, 0, 2,3, 0, 0, 4]`\\n*   0 to index 0   `[ 1, 0, 0, 2,3, 0, 0, 4]`\\n\\nConsider another case: [1,0,2,3,0,4]\\nHere, stretching range [0,4] will cover the full array. But duplicating all 0 will exceed the given array length.\\nI handled this case manually.\\n\\nHere is my solution:\\n```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        int cnt = 0, idx;\\n        for(idx=0;idx<n; idx++ ){\\n            cnt++;\\n            if(!arr[idx]) cnt++;\\n            if(cnt>=n) break;\\n        }\\n        int pos = n-1;\\n        if(cnt>n){\\n            arr[pos--] = 0;\\n            idx--;\\n        }\\n        while(idx>=0){\\n            if(arr[i]){\\n                arr[pos--] = arr[i];\\n            }\\n            else{\\n                arr[pos--] = 0;\\n                arr[pos--] = 0;\\n            }\\n            idx--;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        int n = arr.size();\\n        int cnt = 0, idx;\\n        for(idx=0;idx<n; idx++ ){\\n            cnt++;\\n            if(!arr[idx]) cnt++;\\n            if(cnt>=n) break;\\n        }\\n        int pos = n-1;\\n        if(cnt>n){\\n            arr[pos--] = 0;\\n            idx--;\\n        }\\n        while(idx>=0){\\n            if(arr[i]){\\n                arr[pos--] = arr[i];\\n            }\\n            else{\\n                arr[pos--] = 0;\\n                arr[pos--] = 0;\\n            }\\n            idx--;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399539,
                "title": "simple-and-short-java-solution-must-check",
                "content": "```\\nclass Solution {\\n    public static void duplicateZeros(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                for (int j = arr.length - 1; j > i; j--) {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public static void duplicateZeros(int[] arr) {\\n        for (int i = 0; i < arr.length; i++) {\\n            if (arr[i] == 0) {\\n                for (int j = arr.length - 1; j > i; j--) {\\n                    arr[j] = arr[j - 1];\\n                }\\n                i++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352622,
                "title": "java-optimal-solution",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=3 i=8\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=3 i=8\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1351369,
                "title": "duplicate-zeroes-java-solutiion",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=2 i=6\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        /*\\n        Ip:[1,0,2,3,0,4,5,0]\\n        convert: [1,0,0,2,3,0,0,4]\\n        */\\n         int i = 0, sh = 0;\\n         for (i = 0; sh + i < arr.length; i++){\\n             sh += arr[i] == 0 ? 1 : 0;  //count shift required because of 0\\n         } \\n        //i at end ..traverse from end \\n        //sh=2 i=6\\n        //System.out.println(sh+\":\"+i);\\n         for (i = i - 1; sh > 0; i--) {\\n            if (i + sh < arr.length){\\n                arr[i + sh] = arr[i];\\n            }\\n            if (arr[i] == 0){\\n                sh--;\\n                arr[i + sh] = arr[i];\\n            } \\n          }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1350348,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n    for(int i=0 ; i<arr.size() ; i++)\\n    {if(arr[i]==0)\\n        { arr.pop_back();\\n         arr.insert(arr.begin()+ i , 0 );\\n          i++;}}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n    for(int i=0 ; i<arr.size() ; i++)\\n    {if(arr[i]==0)\\n        { arr.pop_back();\\n         arr.insert(arr.begin()+ i , 0 );\\n          i++;}}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332592,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i=0\\n        while i<len(arr):\\n\\n            if arr[i] ==0:\\n                arr.pop()\\n                arr.insert(i+1,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i=0\\n        while i<len(arr):\\n\\n            if arr[i] ==0:\\n                arr.pop()\\n                arr.insert(i+1,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1332132,
                "title": "java-solution-beginner-friendly-easy-to-follow",
                "content": "Here is my java solution that made the most sense to me after following the tutorial\\'s train of thinking. Any suggestions or thoughts? And may someone tell me the runtime of this.\\n```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for (int i=0; i<arr.length-1; i++) {\\n            if(arr[i]==0){ \\n                for(int j=arr.length-1; j>i; j--){ \\n                    arr[j]=arr[j-1];\\n                }\\n                i+=1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        for (int i=0; i<arr.length-1; i++) {\\n            if(arr[i]==0){ \\n                for(int j=arr.length-1; j>i; j--){ \\n                    arr[j]=arr[j-1];\\n                }\\n                i+=1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1300703,
                "title": "javascript-faster-than-96",
                "content": "Runtime: 80 ms, faster than 96.35% of JavaScript online submissions for Duplicate Zeros.\\nMemory Usage: 40.6 MB, less than 25.67% of JavaScript online submissions for Duplicate Zeros.\\n```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    const res = []\\n    let count = 0\\n    let p = 0\\n    while (count < arr.length) {\\n        const cur = arr[p++]\\n        if (cur !== 0) {\\n            res.push(cur)\\n            count++\\n        } else {\\n            res.push(cur)\\n            res.push(cur)\\n            count += 2\\n        }\\n    }\\n    for (let i = 0; i < arr.length; i++) {\\n        arr[i] = res[i]\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} arr\\n * @return {void} Do not return anything, modify arr in-place instead.\\n */\\nvar duplicateZeros = function(arr) {\\n    const res = []\\n    let count = 0\\n    let p = 0\\n    while (count < arr.length) {\\n        const cur = arr[p++]\\n        if (cur !== 0) {\\n            res.push(cur)\\n            count++\\n        } else {\\n            res.push(cur)\\n            res.push(cur)\\n            count += 2\\n        }\\n    }\\n    for (let i = 0; i < arr.length; i++) {\\n        arr[i] = res[i]\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1295323,
                "title": "java-easy-to-understand-for-beginners-space-o-1",
                "content": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        for(int i=0; i<len; i++){\\n            if(arr[i]==0){\\n                for(int j=len-1; j>i; j--){\\n                    arr[j] = arr[j-1];\\n                }\\n                i++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        int len = arr.length;\\n        for(int i=0; i<len; i++){\\n            if(arr[i]==0){\\n                for(int j=len-1; j>i; j--){\\n                    arr[j] = arr[j-1];\\n                }\\n                i++;\\n            }\\n            \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1265119,
                "title": "simple-c-solution",
                "content": "simple c++ solution. Hoping it\\'s helpful for someone.\\n```\\nvoid duplicateZeros(vector<int> &arr)\\n{\\n    for (int i = 0; i < arr.size() - 1; i++)\\n    {\\n        if (arr[i] == 0)\\n        {\\n            for (int j = arr.size() - 1; j > i + 1; j--)\\n            {\\n                arr[j] = arr[j - 1];\\n            }\\n            arr[i + 1] = 0;\\n            i++;\\n        }\\n    }\\n    return;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid duplicateZeros(vector<int> &arr)\\n{\\n    for (int i = 0; i < arr.size() - 1; i++)\\n    {\\n        if (arr[i] == 0)\\n        {\\n            for (int j = arr.size() - 1; j > i + 1; j--)\\n            {\\n                arr[j] = arr[j - 1];\\n            }\\n            arr[i + 1] = 0;\\n            i++;\\n        }\\n    }\\n    return;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1201839,
                "title": "python-simple-solution",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        i=0\\n        n = len(arr)\\n        while i < n-1:\\n            if arr[i]==0:\\n                arr[:] = arr[:i+1] + [0] + arr[i+1: n-1]\\n                i+=1\\n            i+=1\\n\\t\\t\\t\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        i=0\\n        n = len(arr)\\n        while i < n-1:\\n            if arr[i]==0:\\n                arr[:] = arr[:i+1] + [0] + arr[i+1: n-1]\\n                i+=1\\n            i+=1\\n\\t\\t\\t\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1181438,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i = i + 2\\n            else:\\n                i = i + 1\\n                \\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i = i + 2\\n            else:\\n                i = i + 1\\n                \\n",
                "codeTag": "Java"
            },
            {
                "id": 1172179,
                "title": "python3-simple-and-easy-to-understand-solution-using-while-loop",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i+1,0)\\n                arr.pop()\\n                i += 2\\n            else:\\n                i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143716,
                "title": "python-a-very-short-simple-and-intuitive-approach",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        i=0\\n        while(i<n):\\n            if arr[i] == 0:\\n                for j in range(n-1, i, -1):\\n                    arr[j] = arr[j-1]\\n                i=i+1\\n            i+=1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        n = len(arr)\\n        i=0\\n        while(i<n):\\n            if arr[i] == 0:\\n                for j in range(n-1, i, -1):\\n                    arr[j] = arr[j-1]\\n                i=i+1\\n            i+=1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1143127,
                "title": "javascript-splice-pop",
                "content": "```\\nvar duplicateZeros = function (arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i] === 0) {\\n      arr.splice(i + 1, 0, 0);\\n      arr.pop();\\n      i++;\\n    }\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar duplicateZeros = function (arr) {\\n  for (let i = 0; i < arr.length; i++) {\\n    if (arr[i] === 0) {\\n      arr.splice(i + 1, 0, 0);\\n      arr.pop();\\n      i++;\\n    }\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1110170,
                "title": "rust-solution-o-n-no-extra-space-0ms-2-1mb",
                "content": "Notice: In Rust, we must convert usize to i32 to minus it, if not it will cause error.\\n```\\nimpl Solution {\\n    fn to_usize(value: i32) -> usize {\\n        value as usize\\n    }\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut pos_dups: i32 = 0;\\n        let mut len: i32 = (arr.len() as i32) - 1;\\n        let mut index: i32 = 0;\\n        while index <= len - pos_dups {\\n            if arr[index as usize] == 0 {\\n\\t\\t\\t\\t// Edge-case: Can\\'t add more item. Ex: [0], [0, 0, 3], etc.\\n                if index == len - pos_dups {\\n                    arr[len as usize] = 0;\\n                    len -= 1;\\n                    break;\\n                }\\n                pos_dups += 1;\\n            }\\n            index += 1;\\n        }\\n        \\n        let mut latest = len - pos_dups;\\n        let mut index = latest;\\n        while index >= 0 {\\n            if arr[index as usize] == 0 {\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n                pos_dups -= 1;\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n            } else {\\n                arr[Solution::to_usize(index + pos_dups)] = arr[index as usize];\\n            }\\n            index -= 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    fn to_usize(value: i32) -> usize {\\n        value as usize\\n    }\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut pos_dups: i32 = 0;\\n        let mut len: i32 = (arr.len() as i32) - 1;\\n        let mut index: i32 = 0;\\n        while index <= len - pos_dups {\\n            if arr[index as usize] == 0 {\\n\\t\\t\\t\\t// Edge-case: Can\\'t add more item. Ex: [0], [0, 0, 3], etc.\\n                if index == len - pos_dups {\\n                    arr[len as usize] = 0;\\n                    len -= 1;\\n                    break;\\n                }\\n                pos_dups += 1;\\n            }\\n            index += 1;\\n        }\\n        \\n        let mut latest = len - pos_dups;\\n        let mut index = latest;\\n        while index >= 0 {\\n            if arr[index as usize] == 0 {\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n                pos_dups -= 1;\\n                arr[Solution::to_usize(index + pos_dups)] = 0;\\n            } else {\\n                arr[Solution::to_usize(index + pos_dups)] = arr[index as usize];\\n            }\\n            index -= 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1071588,
                "title": "easy-java-solution",
                "content": "```\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        \\n        for(int i=0 ; i<arr.length-1 ; i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.length-1 ; j>i ; j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                arr[i+1]=0;\\n                i=i+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public void duplicateZeros(int[] arr) {\\n        \\n        for(int i=0 ; i<arr.length-1 ; i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                for(int j=arr.length-1 ; j>i ; j--)\\n                {\\n                    arr[j]=arr[j-1];\\n                }\\n                arr[i+1]=0;\\n                i=i+1;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033831,
                "title": "c-simple-o-n-2-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                arr.insert(arr.begin() + i, 0);\\n                ++i;\\n            }\\n        }\\n        arr.erase(arr.begin() + n, arr.end());\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr)\\n    {\\n        int n = arr.size();\\n        for (int i = 0; i < n; ++i)\\n        {\\n            if (arr[i] == 0)\\n            {\\n                arr.insert(arr.begin() + i, 0);\\n                ++i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 997995,
                "title": "go-solution",
                "content": "Simple solution:\\n```\\nfunc duplicateZeros(arr []int)  {\\n    zerosCount := 0\\n    for _, v := range arr {\\n        if v == 0 {\\n            zerosCount++\\n        }\\n    }\\n    \\n    for i := len(arr)-1; i>=0; i-- {\\n        if arr[i] == 0 {\\n            if i + zerosCount < len(arr) {\\n                arr[i+zerosCount] = 0\\n            }\\n            zerosCount--\\n        } \\n        if i + zerosCount < len(arr) {\\n            arr[i+zerosCount] = arr[i]\\n        }\\n    } \\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc duplicateZeros(arr []int)  {\\n    zerosCount := 0\\n    for _, v := range arr {\\n        if v == 0 {\\n            zerosCount++\\n        }\\n    }\\n    \\n    for i := len(arr)-1; i>=0; i-- {\\n        if arr[i] == 0 {\\n            if i + zerosCount < len(arr) {\\n                arr[i+zerosCount] = 0\\n            }\\n            zerosCount--\\n        } \\n        if i + zerosCount < len(arr) {\\n            arr[i+zerosCount] = arr[i]\\n        }\\n    } \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 972050,
                "title": "simple-python-code",
                "content": "loop through the list and i am doing this:\\n**when i find zero:** insert zero at next index and increament the index by two as we need to skip the next value. delete the last index from `arr`\\n\\n**when you dont find zero:** just move on to next value and increament the index by one\\n\\n\\n```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i + 1, 0)\\n                i += 1\\n                del arr[-1]\\n            i += 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def duplicateZeros(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: None Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr.insert(i + 1, 0)\\n                i += 1\\n                del arr[-1]\\n            i += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970218,
                "title": "simple-javascript-solution",
                "content": "```\\nvar duplicateZeros = function(arr) {\\n    for (var i = 0; i < arr.length; ++i) {\\n        if (arr[i] == 0) {\\n            arr.splice(arr.indexOf(0, i), 0, 0)\\n            arr.pop()\\n            i ++\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar duplicateZeros = function(arr) {\\n    for (var i = 0; i < arr.length; ++i) {\\n        if (arr[i] == 0) {\\n            arr.splice(arr.indexOf(0, i), 0, 0)\\n            arr.pop()\\n            i ++\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 970156,
                "title": "easy-python-code-w-video-explanation",
                "content": "Easy Python code w/ video explanation!\\n\\nhttps://www.youtube.com/watch?v=FPumX-iLtlo&t=182s\\n\\n```python\\nclass Solution:\\ndef duplicateZeros(self, arr: [int]) -> None:\\n        n = len(arr)\\n        zeros = arr.count(0)\\n\\n        i = n - 1\\n\\n        while i >= 0:\\n            if i + zeros < n:\\n                arr[i + zeros] = arr[i]\\n                if arr[i] == 0 and i + zeros - 1 >= 0:\\n                    zeros -= 1\\n                    arr[i + zeros] = 0\\n            elif arr[i] == 0:\\n                zeros -= 1\\n            else:\\n                arr[i] = 0\\n            i -= 1\\n\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\ndef duplicateZeros(self, arr: [int]) -> None:\\n        n = len(arr)\\n        zeros = arr.count(0)\\n\\n        i = n - 1\\n\\n        while i >= 0:\\n            if i + zeros < n:\\n                arr[i + zeros] = arr[i]\\n                if arr[i] == 0 and i + zeros - 1 >= 0:\\n                    zeros -= 1\\n                    arr[i + zeros] = 0\\n            elif arr[i] == 0:\\n                zeros -= 1\\n            else:\\n                arr[i] = 0\\n            i -= 1\\n\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967481,
                "title": "python-eye-candy-solution",
                "content": "Looks like a bit repetitive code, but very easy on eyes and brain cells; song to ears, breeze to the face...\\n```\\ndef duplicateZeros(self, arr):\\n        \\n        numzeros = len([n for n in arr if n == 0])\\n        for i in reversed(range(len(arr))):\\n            \\n            if i + numzeros < len(arr):\\n                arr[i + numzeros] = arr[i]\\n                \\n            if arr[i] == 0:\\n                numzeros -= 1\\n                \\n                if i + numzeros < len(arr):\\n                    arr[i + numzeros] = arr[i]\\n```\\n\\nThis one below is a python specific solution since lists are flexible in python. Definitely more flexible than my back... Gosh I should start doing yoga again.\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr[i:i] = [0]\\n                arr.pop()\\n                i += 1\\n            i += 1\\n            \\n \\n\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\ndef duplicateZeros(self, arr):\\n        \\n        numzeros = len([n for n in arr if n == 0])\\n        for i in reversed(range(len(arr))):\\n            \\n            if i + numzeros < len(arr):\\n                arr[i + numzeros] = arr[i]\\n                \\n            if arr[i] == 0:\\n                numzeros -= 1\\n                \\n                if i + numzeros < len(arr):\\n                    arr[i + numzeros] = arr[i]\\n```\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                arr[i:i] = [0]\\n                arr.pop()\\n                i += 1\\n            i += 1\\n            \\n \\n\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 902566,
                "title": "python-deque-a-single-forward-pass-time-o-n-space-o-n",
                "content": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:        \\n        d = deque()\\n        \\n        for idx, n in enumerate(arr):\\n            if n == 0:\\n                d.append(0)                \\n            d.append(n)    \\n            \\n            arr[idx] = d.popleft()\\n            \\n        return arr\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:        \\n        d = deque()\\n        \\n        for idx, n in enumerate(arr):\\n            if n == 0:\\n                d.append(0)                \\n            d.append(n)    \\n            \\n            arr[idx] = d.popleft()\\n            \\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 889298,
                "title": "simple-rust-implementation",
                "content": "Haven\\'t seen a rust tagged implementation in the dicussion so wanted to put my basic solution here. Been using leetcode exercises to learn rust and this one was suprisingly difficult if you are a rust newby and don\\'t realize you can\\'t modify iterator value in `for` loops. (like I didn\\'t for an embarssingly long amount of time). \\n\\n```rust\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut index = 0;\\n        let total_len = arr.len();\\n        \\n        while index < total_len {\\n            if (arr[index] == 0 && (index + 1) <= arr.len()) {\\n                arr.insert(index + 1, 0);\\n                arr.remove(arr.len() - 1);\\n                index += 2;\\n                continue;\\n            }\\n            \\n            index += 1;\\n        }\\n    }\\n}\\n```\\n\\nUsing rust vectors builtin `insert` and `remove` functions felt a bit like cheating the spirit of the exercise (which seems to be to implement those methods). However it seems implementing these requires(?) the use of rust\\'s `unsafe` keyword which I hadn\\'t had experince with yet. See The Rustonomicon section on [implementing vector insert and remove](https://doc.rust-lang.org/nomicon/vec-insert-remove.html) for more details.",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn duplicate_zeros(arr: &mut Vec<i32>) {\\n        let mut index = 0;\\n        let total_len = arr.len();\\n        \\n        while index < total_len {\\n            if (arr[index] == 0 && (index + 1) <= arr.len()) {\\n                arr.insert(index + 1, 0);\\n                arr.remove(arr.len() - 1);\\n                index += 2;\\n                continue;\\n            }\\n            \\n            index += 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 861379,
                "title": "different-python-solution-o-n-time-o-1-with-full-explantion-easier-to-understand",
                "content": "Let\\'s think about all possible scenarios. The tricky part is which one is the last element we need to fill in the array. For example, In `[1,0,2,0]`, we are looking for `2`\\'s position because `[1,0,0,2],0,0]`. In another example, `[1,0,2,0,1]`, we are looking for `0`\\'s position because `[1,0,0,2,0],0,1]`. If we loop from the beginning and increase `zeros` if we met a `0`, then there will be 2 possible scenarios:\\n1. `i+zeros == len(arr)-1`, which is the first example `[1,0,2,0,1]`->`[1,0,0,2],0,0]`. In this situation, `2+1=3`\\n2. `i+zeros > len(arr)-1`, which is the second example  `[1,0,2,0,1]`->`[1,0,0,2,0],0,1]`. In this situation, `3+2>4`. This is because `0` happens to be last one in the array, we increase `zeros` once we immediately found it.\\nBased on these two senarios, we determine the way how we filled in  from backwards. In the second scenario, we don\\'t need to replicate the last `0` .\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        zeros = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                zeros += 1\\n            if i + zeros == len(arr)-1:\\n                last = i\\n                j = len(arr) - 1\\n                break            \\n            elif i + zeros > len(arr)-1:\\n                arr[-1] = arr[i]\\n                last = i - 1\\n                j = len(arr)-2\\n                break\\n        for i in range(last, -1, -1):\\n            if arr[i] == 0:\\n                arr[j] = 0\\n                arr[j-1] = 0\\n                j -= 2\\n            else:\\n                arr[j] = arr[i]\\n                j -= 1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        zeros = 0\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                zeros += 1\\n            if i + zeros == len(arr)-1:\\n                last = i\\n                j = len(arr) - 1\\n                break            \\n            elif i + zeros > len(arr)-1:\\n                arr[-1] = arr[i]\\n                last = i - 1\\n                j = len(arr)-2\\n                break\\n        for i in range(last, -1, -1):\\n            if arr[i] == 0:\\n                arr[j] = 0\\n                arr[j-1] = 0\\n                j -= 2\\n            else:\\n                arr[j] = arr[i]\\n                j -= 1\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568350,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1566971,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1740224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1722995,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2000211,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1876680,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1822838,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1777965,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2069360,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2048224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1568350,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1566971,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1740224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1722995,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2000211,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1876680,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1822838,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 1777965,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2069360,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2048224,
                "content": [
                    {
                        "username": "reachapexadvert",
                        "content": "Bump THIS to MEDIUM :)"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "It wasnt that hard to be honest. I have solved 60 easy questions and this was easy tooo"
                    },
                    {
                        "username": "sagarbarapatre",
                        "content": "I am really sorry to ask this kind of question in the discuss but i am not getting what do we exactly need to do in this question.\\nPlease don\\'t get offended. I am really sorry if someone feels bad.\\nPlease help me out"
                    },
                    {
                        "username": "nabeelcodes001",
                        "content": "Dont feel sorry bruh!!!!!!, If sm1 gets offended to help sm1, then their downfall is near,!!!!!!!!!!!!!!:)"
                    },
                    {
                        "username": "JDgoat",
                        "content": "What they asked is confused(I agree). So basically, they are asking you to put extra zero next to the zero that existed before. you can sort of see non zero number shifting to the right. Since the array size is fixed, some non zero number will be removed from the array if it is necessary(Ex. in the example 1, in the output, 5 is removed eventually due to extra zero is applied)"
                    },
                    {
                        "username": "KurtusKobeck",
                        "content": "Just a casual reminder: Read the description VERY carefully.\\nThis assignment specifically wants you to duplicate the zeros without changing the length of the vector!"
                    },
                    {
                        "username": "Jaber1028",
                        "content": "If you keep overriding every value with 0:\\nMake sure to add 1 to your loop variable after you do the first whole swap/insert. "
                    },
                    {
                        "username": "hemant_dhiman",
                        "content": "[@Jaber1028](/Jaber1028) Your tip helped 😁\n\ni know not the best but will reduce the runtime.\n\n```\nclass Solution {\n    public void shiftAndInsertAtIndex(int[] arr, int index){\n        if(index > 0){\n            for(int i = arr.length-1; i >= index; i--){\n                arr[i] = arr[i-1];\n            }\n            arr[index] = 0;\n        }\n    }\n    \n    public void duplicateZeros(int[] arr) {\n        for(int i = 0 ; i < arr.length ; i++) {\n            if (arr[i] == 0 && i < arr.length + 1) {\n                if (i == 0){\n                    shiftAndInsertAtIndex(arr, i+1);\n                }\n                shiftAndInsertAtIndex(arr, i);\n                i++;\n            }\n        }\n    }\n}\n```"
                    },
                    {
                        "username": "user5732L",
                        "content": "Thanks! :)"
                    },
                    {
                        "username": "Ali2023",
                        "content": "void duplicateZeros(List<int> arr) {\\n  int start = 0;\\n  int end = arr.length;\\n  while (start < end) {\\n    if (arr[start] == 0) {\\n      arr.removeLast();\\n      arr.insert(start, 0);\\n      start++;\\n    }\\n    start++;\\n  }\\n  print(arr);\\n} i used stack with pointers "
                    },
                    {
                        "username": "Mahesh_Bambhaniya",
                        "content": "i think leetcode provide to more explaination and give 3rd example to understand this question ."
                    },
                    {
                        "username": "undercovercoder_",
                        "content": " class Solution:\\n    def duplicateZeros(self, arr):\\n        x = arr.copy()\\n        length = len(x)\\n        for i in range(length):\\n            if x[i]==0:\\n                arr.insert(i+1,0)\\n        return arr[:length]\\n       \\nWhat\\'s the problem with this code?"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "This has one more logical problem: If you insert 0 at i+1 th in for loop, again in the next iteration it will find the inserted 0 and it will insert one more, so in this above code. Once it finds 0 rest all elements will be 0"
                    },
                    {
                        "username": "marwanmusa",
                        "content": "just don\\'t return anything and modify the inputted array instead"
                    },
                    {
                        "username": "aakriti__awasthi",
                        "content": "When i am using Arrays.toString it is returing the correct answer but when i am using return it is returning wrong output. why ??"
                    },
                    {
                        "username": "chloezhang1030",
                        "content": "I think we are modifying the `arr`, not returning one. The signature suggests that the return type is void."
                    },
                    {
                        "username": "beach_slav",
                        "content": "i also tried to declare the new array to the original array per Reference, and in intelliJ it functions perfectly when i print out the original array aswell. Strange"
                    },
                    {
                        "username": "beach_slav",
                        "content": "same problem over here"
                    },
                    {
                        "username": "sethupathi8",
                        "content": "Interesting!!\\n"
                    },
                    {
                        "username": "Denbruh",
                        "content": "Hi\\nCould anyone please help me out with this?\\n\\n `\\n\\n     void duplicateZeros(vector<int>& arr) {\\n        vector<int> newArr;\\n\\n        //arr = [1,0,2,3,0,4,5,0] (Input)\\n        for(int i = 0;i < arr.size();i++){\\n            newArr.push_back(arr[i]);\\n            if(arr[i] == 0){\\n                newArr.push_back(0);\\n            }\\n        }\\n        for(int j = 0;j < newArr.size() - arr.size();j++){\\n            newArr.pop_back();\\n        }\\n\\n        arr = newArr;\\n        //arr = [1,0,0,2,3,0,0,4,5] (Output)\\n        //Expected [1,0,0,2,3,0,0,4]\\n    }`\\n\\nIt works fine on Case 2 but it seems to forget to remove an element in Case 1\\nI\\'ve already used other successful methods but I still wanna know why this specific piece of code doesn\\'t work"
                    }
                ]
            },
            {
                "id": 2045622,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2039475,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2039474,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 2032837,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1998212,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1991616,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1984861,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1957691,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1950692,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1933071,
                "content": [
                    {
                        "username": "iuri0072",
                        "content": "Hi! does anyone knows why my solution won\\'t work? I\\'m not talking about how easier or harder it would be, or more efficient. but i modified my input, and for some reason it is not reflecting on the output:\\n\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        arrSize = len(arr)\\n        i = 0\\n        while i < arrSize:\\n            if arr[i] == 0:\\n                aux = arr[i+1 : arrSize - 1]\\n                arr = arr[:i+1]\\n                arr.append(0)\\n                for j in aux:\\n                    arr.append(j)\\n                i += 1\\n            i += 1\\n        #print (arr)"
                    },
                    {
                        "username": "iuri0072",
                        "content": "[@ChethanKailashnath](/ChethanKailashnath) \nthanks a lot for the reply. I think i understood what's going on by your explanation. managed to solve the problem using arr.insert and it works well :)"
                    },
                    {
                        "username": "ChethanKailashnath",
                        "content": "Here you are trying to re assign the \"arr\" variable. which means you are creating a new list and modifying it. which does not affect the original arr list. To solve you need to manipulate the original array. Instead of slicing the array, you can try index manipulation."
                    },
                    {
                        "username": "Applethal",
                        "content": "<details>\\n  <summary>Spoiler warning</summary>\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        n = arr.count(0)\\n        arr1 = arr.copy()\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                arr1.insert(i+1,0)\\n                \\n                arr1.pop(-1)\\n        \\n        \\n        \\n        arr[:] = arr1\\n        \\n\\n</details>\\nMade it to testcase 13/31"
                    },
                    {
                        "username": "skavale",
                        "content": "this is not easy its a mdeium"
                    },
                    {
                        "username": "shailesh_rajpurohit",
                        "content": "This sh*t needs to be Medium level."
                    },
                    {
                        "username": "RiGa7",
                        "content": "I\\'m getting a runtime error with [8,4,5,0,0,0,0,7] test case. Can anyone figure out the mistake in the code?\\n\\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n        for(int i = 0 ; i<arr.size() ;i++)\\n        {\\n             if(arr[i]==0){\\n                 for (int j = arr.size()-2; j > i; j-- )\\n                 {\\n                    arr[j + 1] = arr[j];   \\n                 } \\n                 arr[i+1] = 0;\\n                 i++;\\n             }\\n        }\\n    }\\n};"
                    },
                    {
                        "username": "kennyhml",
                        "content": "Should be a medium question and just let the ugly solutions TLE"
                    },
                    {
                        "username": "vianj26",
                        "content": "the no return value makes it complicated."
                    },
                    {
                        "username": "mochiball",
                        "content": "Easy problem to use O(n) space. Medium if we do O(1) space "
                    },
                    {
                        "username": "kartikey090803",
                        "content": "\\n// can someone tell me what\\'s wrong with this ??\\n\\nvoid duplicateZeros(vector<int>& arr) {\\n        \\n        vector<int>N;\\n        for(int i=0; i<N.size(); i++)\\n        {\\n            N.push_back(arr[i]);\\n        }\\n\\n        int i,j;\\n        int n=arr.size();\\n\\n        for(i=0,j=0;i<n,j<n;i++,j++)\\n        {\\n            if(N[j]==0)\\n            {\\n                arr[i]=0;\\n                arr[i+1]=0;\\n                i++;\\n            }\\n            else\\n            {\\n                arr[i]=N[j];\\n            }\\n        }\\n\\n    } "
                    },
                    {
                        "username": "user2740qi",
                        "content": "You need to perform in place update."
                    },
                    {
                        "username": "rishabhtomar2014",
                        "content": "Can anyone tell me what\\'s wrong with my approach?\\nI tried printing the arr at the end and it\\'s value is exactly what\\'s expected.\\n`       \\n        \\n        left = 0\\n        size = len(arr)\\n\\n        if 0 in arr:\\n            while left < size:\\n                if arr[left] == 0 and left + 1 < size:\\n                    temp = arr[left + 1:]\\n                    arr[left + 1] = 0\\n                    arr = arr[:left + 2] + temp\\n                    left += 2\\n                else:\\n                    left += 1\\n            arr = arr[:size]\\n            #print(arr)`"
                    }
                ]
            },
            {
                "id": 1910065,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1841553,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1832922,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1810742,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1803112,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1779046,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1771851,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1750097,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1740168,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            },
            {
                "id": 1734362,
                "content": [
                    {
                        "username": "lokesh_uppala_G4",
                        "content": "lis=\"\".join([str(i) for i in arr])\\nlis=lis.replace(\\'0\\',\\'00\\')\\narr = list(map(int,lis))[:len(arr)]\\nreturn arr\\n\\ncan I know where the code is wrong\\n"
                    },
                    {
                        "username": "a_andreasian",
                        "content": "no need to return anything. you need to modify the array `arr` itself (using methods, don\\'t try to reassign it) "
                    },
                    {
                        "username": "abj_32",
                        "content": "I saw people writing a very complex code here. Here is what I have written and I think its pretty simple \\nclass Solution {\\npublic:\\n    void duplicateZeros(vector<int>& arr) {\\n     int i,j,n;\\n     i=0;\\n     n=arr.size();\\n     while(i<n)\\n     {\\n         if(arr[i]==0)\\n         {\\n             j=n-1;\\n             while(j>i)\\n             {\\n                 arr[j]=arr[j-1];\\n                 j--;\\n             }\\n             if(i+1 < n) \\n             { \\n                    arr[i+1] = 0;\\n                    i++;\\n             }\\n         }\\n         i++;\\n     }   \\n    }\\n};\\n"
                    },
                    {
                        "username": "Bhashkar_3241",
                        "content": "i am unable to understand how he is deleting element &inserting zeroes.\nplease explain anyone"
                    },
                    {
                        "username": "debjeetsarkar",
                        "content": "Golang sol doesnt get accepted. \\n\\n `import (\\n\"fmt\"\\n)\\n\\nfunc shiftRight(arr []int, pos int) []int{\\nnew_arr := append(arr, 0) // Make space\\ncopy(new_arr[pos+1:], new_arr[pos:]) // shift elements\\nreturn new_arr\\n}\\n\\nfunc duplicateZeros(arr []int) {\\nl := len(arr)\\nfor i := 0; i < l; i++ {\\nif arr[i] == 0 {\\narr = shiftRight(arr, i+1)\\narr[i+1] = 0\\ni +=1 // Move position beacuse i+1 has now been replaced by a 0\\n}\\n}\\narr = arr[:l]\\nfmt.Println(arr)\\n}`\\n\\n"
                    },
                    {
                        "username": "geckguy",
                        "content": "\\n class Solution: \\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        z=set()\\n        n = len(arr)\\n        for i in range(len(arr)):\\n            if arr[i] == 0:\\n                z.add(i)\\n        i=0\\n        while i < n + len(z) and len(z) > 0:\\n            if arr[i] ==  0:\\n                arr.insert(i,0)\\n                i=i+2\\n            else:\\n                i=i+1\\n        arr = arr[0:n]\\n\\nwhy isnt this code working in LC, it works fine in vscode"
                    },
                    {
                        "username": "timyang2333",
                        "content": "If you getting an output of [1,0,0,0,0,0,0,0] like this, don\\'t forget to skip next one which already duplicated as zero by your code, so skip the next one and focus on next next one"
                    },
                    {
                        "username": "coddar",
                        "content": "I have a working solution, but I do not like it. It seems O(n^2) in worst case. The runtime is also beating only 7% or so. Does anybody have a better solution? Mine is below:\\n\\n```\\nclass Solution:\\n    def duplicateZeros(self, arr: List[int]) -> None:\\n        \"\"\"\\n        Do not return anything, modify arr in-place instead.\\n        \"\"\"\\n        i = 0\\n        while i < len(arr):\\n            if arr[i] == 0:\\n                for j in range(len(arr)-1, i+1, -1):\\n                    arr[j] = arr[j-1]\\n                if i+1 < len(arr): arr[i+1] = 0\\n                i += 1\\n            i += 1\\n```"
                    },
                    {
                        "username": "rahulsanjayshah",
                        "content": "Can anyone help me find the error in this?\\nFor an input of arr =[1,0,2,3,0,4,5,0], getting an output of [1,0,0,0,0,0,0,0] instead of [1,0,0,2,3,0,0,4]\\n\\n`for i in range(len(arr)):\\n            if(arr[i]==0):\\n                j=len(arr)-1\\n                while(j>i):\\n                    arr[j] = arr[j-1]\\n                    j=j-1\\n                I+=1\\n        return arr`"
                    },
                    {
                        "username": "Bhanu_009",
                        "content": "Your not skipping the additional zero. like after the first zero the iteration should go to 2 but in your case it coming to the duplicate zero that is added it goes until the loop ends. Solution is to skip the iteration after adding zero encountered."
                    },
                    {
                        "username": "Mradul_singh0100-",
                        "content": "    `def duplicateZeros(self, arr: List[int]) -> None:`\n        `l = len(arr)`\n        `d = [i for i in range(l) if arr[i] == 0]`\n       ` [arr.insert(j+d[j], 0) for j in range(len(d))]  `\n        `arr[:] = arr[:l]`"
                    },
                    {
                        "username": "ajinkode",
                        "content": "Good question!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
        "question_content": "<p>Given two arrays of integers <code>nums1</code> and <code>nums2</code>, return the number of triplets formed (type 1 and type 2) under the following rules:</p>\n\n<ul>\n\t<li>Type 1: Triplet (i, j, k) if <code>nums1[i]<sup>2</sup> == nums2[j] * nums2[k]</code> where <code>0 &lt;= i &lt; nums1.length</code> and <code>0 &lt;= j &lt; k &lt; nums2.length</code>.</li>\n\t<li>Type 2: Triplet (i, j, k) if <code>nums2[i]<sup>2</sup> == nums1[j] * nums1[k]</code> where <code>0 &lt;= i &lt; nums2.length</code> and <code>0 &lt;= j &lt; k &lt; nums1.length</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [7,4], nums2 = [5,2,8,9]\n<strong>Output:</strong> 1\n<strong>Explanation:</strong> Type 1: (1, 1, 2), nums1[1]<sup>2</sup> = nums2[1] * nums2[2]. (4<sup>2</sup> = 2 * 8). \n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [1,1], nums2 = [1,1,1]\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> All Triplets are valid, because 1<sup>2</sup> = 1 * 1.\nType 1: (0,0,1), (0,0,2), (0,1,2), (1,0,1), (1,0,2), (1,1,2).  nums1[i]<sup>2</sup> = nums2[j] * nums2[k].\nType 2: (0,0,1), (1,0,1), (2,0,1). nums2[i]<sup>2</sup> = nums1[j] * nums1[k].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums1 = [7,7,8,3], nums2 = [1,2,9,7]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> There are 2 valid triplets.\nType 1: (3,0,2).  nums1[3]<sup>2</sup> = nums2[0] * nums2[2].\nType 2: (3,0,1).  nums2[3]<sup>2</sup> = nums1[0] * nums1[1].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums1.length, nums2.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 831467,
                "title": "c-java-two-sum-o-n-m",
                "content": "This looks very similar to Two Sum, and we will use [Two Sum: Approach 3](https://leetcode.com/problems/two-sum/solution/).\\n\\nWe just need to call our function \"Two Product\" :)\\n\\n> Update: see below for the optimized version!\\n\\n**C++**\\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return accumulate(begin(n1), end(n1), 0, [&](int s, long n) { return s + twoProduct(n * n, n2); }) \\n        + accumulate(begin(n2), end(n2), 0, [&](int s, long n) { return s +  twoProduct(n * n, n1); });\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```\\n\\n**Java**\\n```java\\npublic int numTriplets(int[] n1, int[] n2) {\\n    long res = 0;\\n    for (long n : n1)\\n        res += twoProduct(n * n, n2);\\n    for (long n : n2)\\n        res += twoProduct(n * n, n1);\\n    return (int)res;\\n}\\nlong twoProduct(long i, int[] n) {\\n    Map<Long, Long> m = new HashMap<>();\\n    long cnt = 0;\\n    for (long v : n) {\\n        if (i % v == 0)\\n            cnt += m.getOrDefault(i / v, 0l);\\n        m.put(v, m.getOrDefault(v, 0l) + 1);\\n    }\\n    return cnt;\\n}  \\n```\\n\\n#### Optimized Version\\nWe can memoise the result for a given `n`. This will speed up things quite a bit if there is a lot of duplicates. We can use a hashmap, or we can sort the array so duplicates are next to each other. The solution below is an improvement from ~800 ms to ~280 ms.\\n\\n**C++**\\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return countForArray(n1, n2) + countForArray(n2, n1);\\n}\\nint countForArray(vector<int>& n1, vector<int>& n2) {\\n    int res = 0, last_res = 0, last_n = 0;\\n    sort(begin(n1), end(n1));\\n    for (auto i = 0; i < n1.size(); last_n = n1[i++])\\n        if (n1[i] == last_n)\\n            res += last_res;\\n        else\\n            res += last_res = twoProduct((long)n1[i] * n1[i], n2);\\n    return res;\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```",
                "solutionTags": [],
                "code": "```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return accumulate(begin(n1), end(n1), 0, [&](int s, long n) { return s + twoProduct(n * n, n2); }) \\n        + accumulate(begin(n2), end(n2), 0, [&](int s, long n) { return s +  twoProduct(n * n, n1); });\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```\n```java\\npublic int numTriplets(int[] n1, int[] n2) {\\n    long res = 0;\\n    for (long n : n1)\\n        res += twoProduct(n * n, n2);\\n    for (long n : n2)\\n        res += twoProduct(n * n, n1);\\n    return (int)res;\\n}\\nlong twoProduct(long i, int[] n) {\\n    Map<Long, Long> m = new HashMap<>();\\n    long cnt = 0;\\n    for (long v : n) {\\n        if (i % v == 0)\\n            cnt += m.getOrDefault(i / v, 0l);\\n        m.put(v, m.getOrDefault(v, 0l) + 1);\\n    }\\n    return cnt;\\n}  \\n```\n```cpp\\nint numTriplets(vector<int>& n1, vector<int>& n2) {\\n    return countForArray(n1, n2) + countForArray(n2, n1);\\n}\\nint countForArray(vector<int>& n1, vector<int>& n2) {\\n    int res = 0, last_res = 0, last_n = 0;\\n    sort(begin(n1), end(n1));\\n    for (auto i = 0; i < n1.size(); last_n = n1[i++])\\n        if (n1[i] == last_n)\\n            res += last_res;\\n        else\\n            res += last_res = twoProduct((long)n1[i] * n1[i], n2);\\n    return res;\\n}\\nint twoProduct(long i, vector<int> &n) {\\n    unordered_map<int, int> m;\\n    int cnt = 0;\\n    for (auto v : n) {\\n        if (i % v == 0)\\n            cnt += m[i / v];\\n        ++m[v];\\n    }\\n    return cnt;\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831519,
                "title": "c-o-mn-with-explanation",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1.\\n\\nType 1 and Type 2 are symmetrical so we can define a function `count(A, B)` which returns the count of the Type 1 triples. The answer is `count(A, B) + count(B, A)`.\\n\\nFor `count(A, B)`, we can use a `unordered_map<int, int> m` to store the frequency of the numbers in `B`. Then for each number `a` in `A`, the `target` value is `a * a`. We traverse the map `m` to count the triplets.\\n\\nFor each entry `(b, cnt)` in `m`:\\n* If `target` is not divisible by `b` or `target / b` is not in `m`, there is no triplets, skip.\\n* If `target / b == b`, we need to pick 2 out of `cnt` numbers so we can add `cnt * (cnt - 1)` triplets to the answer.\\n* Otherwise, we can add `cnt * m[target / b]` triplets to the answer.\\n\\nSince we count the the pairs in `B` twice, we need to divide the answer by 2 before returning.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(N)\\nclass Solution {\\n    int count(vector<int> &A, vector<int> &B) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for (int n : B) m[n]++;\\n        for (int a : A) {\\n            long target = (long)a * a;\\n            for (auto &[b, cnt] : m) {\\n                if (target % b || m.count(target / b) == 0) continue;\\n                if (target / b == b) ans += cnt * (cnt - 1);\\n                else ans += cnt * m[target / b];\\n            }\\n        }\\n        return ans / 2;\\n    }\\npublic:\\n    int numTriplets(vector<int>& A, vector<int>& B) {\\n        return count(A, B) + count(B, A);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(N)\\nclass Solution {\\n    int count(vector<int> &A, vector<int> &B) {\\n        int ans = 0;\\n        unordered_map<int, int> m;\\n        for (int n : B) m[n]++;\\n        for (int a : A) {\\n            long target = (long)a * a;\\n            for (auto &[b, cnt] : m) {\\n                if (target % b || m.count(target / b) == 0) continue;\\n                if (target / b == b) ans += cnt * (cnt - 1);\\n                else ans += cnt * m[target / b];\\n            }\\n        }\\n        return ans / 2;\\n    }\\npublic:\\n    int numTriplets(vector<int>& A, vector<int>& B) {\\n        return count(A, B) + count(B, A);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831684,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td1 = collections.defaultdict(int)\\n\\t\\t\\td2 = collections.defaultdict(int)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num1 in nums1:\\n\\t\\t\\t\\td1[num1 * num1] += 1\\n\\t\\t\\tfor num2 in nums2:\\n\\t\\t\\t\\td2[num2 * num2] += 1        \\n\\t\\t\\tfor i in range(len(nums1) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums1)):\\n\\t\\t\\t\\t\\tres += d2[nums1[i] * nums1[j]]\\n\\t\\t\\tfor i in range(len(nums2) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums2)):\\n\\t\\t\\t\\t\\tres += d1[nums2[i] * nums2[j]]\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\td1 = collections.defaultdict(int)\\n\\t\\t\\td2 = collections.defaultdict(int)\\n\\t\\t\\tres = 0\\n\\t\\t\\tfor num1 in nums1:\\n\\t\\t\\t\\td1[num1 * num1] += 1\\n\\t\\t\\tfor num2 in nums2:\\n\\t\\t\\t\\td2[num2 * num2] += 1        \\n\\t\\t\\tfor i in range(len(nums1) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums1)):\\n\\t\\t\\t\\t\\tres += d2[nums1[i] * nums1[j]]\\n\\t\\t\\tfor i in range(len(nums2) - 1):\\n\\t\\t\\t\\tfor j in range(i + 1, len(nums2)):\\n\\t\\t\\t\\t\\tres += d1[nums2[i] * nums2[j]]\\n\\t\\t\\treturn res",
                "codeTag": "Java"
            },
            {
                "id": 831566,
                "title": "python-instructions-to-code-intuitive",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def is_perf_sqrt(n): \\n            \"\"\"\\n            returns bool if a number is a perfect square\\n            like 4, 16, 25 --> True\\n            \"\"\"\\n            return int(math.sqrt(n) + 0.5) ** 2 == n\\n\\n        nums1_cntr, nums2_cntr = Counter(nums1), Counter(nums2)\\n\\n        s = 0\\n        for x, y in itertools.combinations(nums2, 2):\\n            if is_perf_sqrt(x * y): \\n\\t\\t\\t\\t# if product is perfect square, get count of sqrt(of_product)\\n\\t\\t\\t\\ts += nums1_cntr[math.sqrt(x * y)]\\n\\t\\t\\n\\t\\t# similar vice-versa logic\\n        for x, y in itertools.combinations(nums1, 2):\\n            if is_perf_sqrt(x * y): s += nums2_cntr[math.sqrt(x * y)]\\n\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def is_perf_sqrt(n): \\n            \"\"\"\\n            returns bool if a number is a perfect square\\n            like 4, 16, 25 --> True\\n            \"\"\"\\n            return int(math.sqrt(n) + 0.5) ** 2 == n\\n\\n        nums1_cntr, nums2_cntr = Counter(nums1), Counter(nums2)\\n\\n        s = 0\\n        for x, y in itertools.combinations(nums2, 2):\\n            if is_perf_sqrt(x * y): \\n\\t\\t\\t\\t# if product is perfect square, get count of sqrt(of_product)\\n\\t\\t\\t\\ts += nums1_cntr[math.sqrt(x * y)]\\n\\t\\t\\n\\t\\t# similar vice-versa logic\\n        for x, y in itertools.combinations(nums1, 2):\\n            if is_perf_sqrt(x * y): s += nums2_cntr[math.sqrt(x * y)]\\n\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831508,
                "title": "java-simple-sort",
                "content": "An easy way to sort and count:\\n1, sort all arrays by non-decreasing order;\\n2, for each i, shrink from left and right as j and k, then find each triples\\n3, handle special case for  dups, such as[1, 1], [1, 1, 1]\\nTime: O(M*N)\\nSpace: O(1)\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length, n = b.length;\\n        for (int i = 0; i < m; i++) {\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (int l = 0, r = n - 1; l < n - 1; l++) { // finding pairs for i, l, r;\\n                if (((long) b[l]) * ((long) b[r]) < t) continue;\\n                while (r >= l && ((long) b[l]) * ((long) b[r]) > t) r--;\\n                if (r <= l) break;\\n                if (((long) b[l]) * ((long) b[r]) == t) {\\n                    int orig = r;\\n                    while(r > l && b[r] == b[orig]) {  // [1, 1], [1, 1, 1]\\n                        r--;\\n                        res++;\\n                    }\\n                    r = orig;  // reset to next cont;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\nThere is a better solution to use HashMap turn the l, r findings to O(n) 2-sum ones:\\nThat is straightforward and easy understanding.\\nAnother good point is that you don\\'t have to sort the arrays.\\nTime: O(M * N)\\nspace: O(max(M, N));\\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length;\\n        for (int i = 0; i < m; i++) {\\n            Map<Long, Integer> map = new HashMap<>();\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (long n : b) {  //must transferred to long\\n                if (t % n == 0) res += map.getOrDefault(t / n, 0); //new pair formed btw n and previous found t / n\\n                map.put(n, map.getOrDefault(n, 0) + 1); // cached the count found;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length, n = b.length;\\n        for (int i = 0; i < m; i++) {\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (int l = 0, r = n - 1; l < n - 1; l++) { // finding pairs for i, l, r;\\n                if (((long) b[l]) * ((long) b[r]) < t) continue;\\n                while (r >= l && ((long) b[l]) * ((long) b[r]) > t) r--;\\n                if (r <= l) break;\\n                if (((long) b[l]) * ((long) b[r]) == t) {\\n                    int orig = r;\\n                    while(r > l && b[r] == b[orig]) {  // [1, 1], [1, 1, 1]\\n                        r--;\\n                        res++;\\n                    }\\n                    r = orig;  // reset to next cont;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int numTriplets(int[] a, int[] b) {\\n        return cnt(a, b) + cnt(b, a);\\n    }\\n    \\n    private int cnt(int[] a, int[] b) {\\n        int res = 0, m = a.length;\\n        for (int i = 0; i < m; i++) {\\n            Map<Long, Integer> map = new HashMap<>();\\n            long t = ((long) a[i]) * ((long) a[i]);\\n            for (long n : b) {  //must transferred to long\\n                if (t % n == 0) res += map.getOrDefault(t / n, 0); //new pair formed btw n and previous found t / n\\n                map.put(n, map.getOrDefault(n, 0) + 1); // cached the count found;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1087997,
                "title": "c-solution-o-n-m-using-hash-map",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        ll count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i];\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        ll count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i];\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831781,
                "title": "java-solution-using-sorting-with-explanation-and-comments-4-ms-faster-than-100",
                "content": "1. Sort both arrays.\\n2. Similar to the Two sum we have to find all the pairs that matches to the target. Target is the Square number. \\n3. Start with left pointer set to 0, and right pointer set to length-1.\\n4. Must handle duplicates. \\n\\t* \\te.g. Target: 4, nums = [1,1,4,4]\\n\\t* \\tSo, total 4 pairs with indexes (0,2), (1,2), (0,3), (1,3)\\n\\t* \\twhen left = 0, and right = 3, we found one pair. (0,3)\\n\\t\\t* \\tNow before updating left or right pointer, travesre through all values from left+1 to right whose value is same as nums[left]. It will give us the multiplication equals to target.\\n\\t\\t* \\tThis way we will find next pair (1,3).\\n\\t* Decrement right pointer, and reset left pointer.\\n4. Repeat this process for all values in both arrays.\\n\\nRead the code comments for some added optimization.\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int count = 0;\\n        count += triplets(nums1, nums2);\\n        count += triplets(nums2, nums1);\\n        \\n        return count;        \\n    }\\n    \\n    public int triplets(int[] nums1, int[] nums2) {\\n        \\n\\t\\tMap<Long, Integer> seen = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0; i<nums1.length; i++) {\\n            long sqr = (long) nums1[i] * nums1[i];  //Target Value. Don\\'t forget to convert to Long\\n            if(seen.containsKey(sqr)) { //If we have already seen the target value, then no need to repeat the process and find the pairs.  \\n                count += seen.get(sqr);\\n                continue;\\n            }\\n            \\n            int localCount = 0;  //Find the pairs for current Target\\n            int left = 0, right = nums2.length-1; \\n\\t\\t\\t\\n            while(left < right) {  //Similar to Two sum, find all pairs whose multiplication equals to Target\\n                if(nums2[left] > sqr)  // For optimization. If the lowest value is larger than target then break the loop.\\n                    break;\\n                long multiple = (long) nums2[left] * nums2[right];\\n                \\n                if(sqr == multiple) {\\n                    if(nums2[left] == nums2[right]) { //Special Case: when numbers from left to right are same. \\n\\t\\t\\t\\t\\t\\tint n = right - left+1;      // In the case the total pairs will be n*(n-1)/2.\\n                        localCount += n * (n-1)/2;\\n                        break;\\n                    }\\n                    localCount++;  // Found one pair: Increament the counter.\\n                    int newL = left+1;  //To handle duplicates pairs, we will check all numbers from left side. Numbers must be same as the left number for equal multiplication.\\n                    for(newL = left+1; newL < right && nums2[newL] == nums2[left]; newL++) {\\n                            localCount++;                        \\n                    }\\n                    right--;\\n                    \\n                } else if (multiple < sqr)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tcount += localCount;\\n            seen.put(sqr, localCount);  //Add the pairs for target value in seen.\\n\\t\\t\\t\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n** Thanks to nanwu6805 for optimization suggestion. We do no need to repeat the same process and can use the count. I changed it a bit and instead used hashmap.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int count = 0;\\n        count += triplets(nums1, nums2);\\n        count += triplets(nums2, nums1);\\n        \\n        return count;        \\n    }\\n    \\n    public int triplets(int[] nums1, int[] nums2) {\\n        \\n\\t\\tMap<Long, Integer> seen = new HashMap<>();\\n        int count = 0;\\n        \\n        for(int i=0; i<nums1.length; i++) {\\n            long sqr = (long) nums1[i] * nums1[i];  //Target Value. Don\\'t forget to convert to Long\\n            if(seen.containsKey(sqr)) { //If we have already seen the target value, then no need to repeat the process and find the pairs.  \\n                count += seen.get(sqr);\\n                continue;\\n            }\\n            \\n            int localCount = 0;  //Find the pairs for current Target\\n            int left = 0, right = nums2.length-1; \\n\\t\\t\\t\\n            while(left < right) {  //Similar to Two sum, find all pairs whose multiplication equals to Target\\n                if(nums2[left] > sqr)  // For optimization. If the lowest value is larger than target then break the loop.\\n                    break;\\n                long multiple = (long) nums2[left] * nums2[right];\\n                \\n                if(sqr == multiple) {\\n                    if(nums2[left] == nums2[right]) { //Special Case: when numbers from left to right are same. \\n\\t\\t\\t\\t\\t\\tint n = right - left+1;      // In the case the total pairs will be n*(n-1)/2.\\n                        localCount += n * (n-1)/2;\\n                        break;\\n                    }\\n                    localCount++;  // Found one pair: Increament the counter.\\n                    int newL = left+1;  //To handle duplicates pairs, we will check all numbers from left side. Numbers must be same as the left number for equal multiplication.\\n                    for(newL = left+1; newL < right && nums2[newL] == nums2[left]; newL++) {\\n                            localCount++;                        \\n                    }\\n                    right--;\\n                    \\n                } else if (multiple < sqr)\\n                    left++;\\n                else\\n                    right--;\\n            }\\n\\t\\t\\t\\n\\t\\t\\tcount += localCount;\\n            seen.put(sqr, localCount);  //Add the pairs for target value in seen.\\n\\t\\t\\t\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831720,
                "title": "c-two-pointer-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int>& nums1, vector<int>& nums2) {\\n        int count = 0, left, right;\\n        long num1Val, num2Val;\\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < nums2.size(); i++) freq[nums2[i]]++;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            left = 0;\\n            right = nums2.size()-1;\\n            num1Val = (long)nums1[i] * nums1[i];\\n            while(left < right) {\\n                num2Val = (long)nums2[left] * nums2[right];\\n                if(num1Val == num2Val) {\\n                    if(nums2[right] == nums2[left]) {\\n                        count += (freq[nums2[right]] * (freq[nums2[right]]-1))/2;\\n                        break;\\n                    }\\n                    count += freq[nums2[right]] * freq[nums2[left]];\\n                    left  += freq[nums2[left]];\\n                    right -= freq[nums2[right]];\\n                } else if(num1Val > num2Val) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return countTriplet(nums1, nums2) + countTriplet(nums2, nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int>& nums1, vector<int>& nums2) {\\n        int count = 0, left, right;\\n        long num1Val, num2Val;\\n        unordered_map<int, int> freq;\\n        \\n        for(int i = 0; i < nums2.size(); i++) freq[nums2[i]]++;\\n        \\n        for(int i = 0; i < nums1.size(); i++) {\\n            left = 0;\\n            right = nums2.size()-1;\\n            num1Val = (long)nums1[i] * nums1[i];\\n            while(left < right) {\\n                num2Val = (long)nums2[left] * nums2[right];\\n                if(num1Val == num2Val) {\\n                    if(nums2[right] == nums2[left]) {\\n                        count += (freq[nums2[right]] * (freq[nums2[right]]-1))/2;\\n                        break;\\n                    }\\n                    count += freq[nums2[right]] * freq[nums2[left]];\\n                    left  += freq[nums2[left]];\\n                    right -= freq[nums2[right]];\\n                } else if(num1Val > num2Val) {\\n                    left++;\\n                } else {\\n                    right--;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return countTriplet(nums1, nums2) + countTriplet(nums2, nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831642,
                "title": "python3-using-counter",
                "content": "For both nums1 and nums2, aggregate all the squares in nums1 and nums2. We will use this to easily track all occurences of nums1[i] * nums1[j]  in nums2 and nums2[i] * nums2[j] in nums1. Then just use nested loops to generate possible combinations that could be in either frequency table.\\n\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    \\n    # nums will be where nums[j] and nums[k] come from\\n    # Look for nums[j] * nums[k] in counts, if it exists grab count from frequency table \"counts\"\\n    def aggregateType(self, nums, counts):\\n        total = 0\\n        \\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                target = nums[i] * nums[j]\\n                total += counts[target]\\n                \\n        return total\\n    \\n    def numTriplets(self, nums1, nums2):\\n        \\n        #Build frequency table of the squares you can form from num1 and num2\\n        counter1 = collections.Counter([num ** 2 for num in nums1])\\n        counter2 = collections.Counter([num ** 2 for num in nums2])\\n        \\n        return self.aggregateType(nums1, counter2) + self.aggregateType(nums2, counter1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\n\\nclass Solution:\\n    \\n    # nums will be where nums[j] and nums[k] come from\\n    # Look for nums[j] * nums[k] in counts, if it exists grab count from frequency table \"counts\"\\n    def aggregateType(self, nums, counts):\\n        total = 0\\n        \\n        for i in range(0, len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                target = nums[i] * nums[j]\\n                total += counts[target]\\n                \\n        return total\\n    \\n    def numTriplets(self, nums1, nums2):\\n        \\n        #Build frequency table of the squares you can form from num1 and num2\\n        counter1 = collections.Counter([num ** 2 for num in nums1])\\n        counter2 = collections.Counter([num ** 2 for num in nums2])\\n        \\n        return self.aggregateType(nums1, counter2) + self.aggregateType(nums2, counter1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831548,
                "title": "straightforward-solution-brute-force-with-optimized-search-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    bool perfectSquare(long long int n) {\\n        long long int ans = sqrt(n);\\n        return n == ans*ans;\\n    }\\n    \\n    int squareRoot(long long int n) {\\n        int ans = sqrt(n);\\n        return ans;\\n    }\\n    \\n    int findTriplets(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        unordered_map<int, int> frequency;\\n        for (auto &y: b) {\\n            frequency[y]++;\\n        }\\n        int n = a.size();\\n        for (int i=0; i<n-1; i++) { \\n            for (int j=i+1; j<n; j++) {\\n                long long int num = a[i];\\n                num *= a[j];\\n                if (perfectSquare(num)) {\\n                    ans += frequency[squareRoot(num)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return findTriplets(nums1, nums2) + findTriplets(nums2, nums1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool perfectSquare(long long int n) {\\n        long long int ans = sqrt(n);\\n        return n == ans*ans;\\n    }\\n    \\n    int squareRoot(long long int n) {\\n        int ans = sqrt(n);\\n        return ans;\\n    }\\n    \\n    int findTriplets(vector<int> a, vector<int> b) {\\n        int ans = 0;\\n        unordered_map<int, int> frequency;\\n        for (auto &y: b) {\\n            frequency[y]++;\\n        }\\n        int n = a.size();\\n        for (int i=0; i<n-1; i++) { \\n            for (int j=i+1; j<n; j++) {\\n                long long int num = a[i];\\n                num *= a[j];\\n                if (perfectSquare(num)) {\\n                    ans += frequency[squareRoot(num)];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return findTriplets(nums1, nums2) + findTriplets(nums2, nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531661,
                "title": "c-two-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countTriplet(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        int ans=0,left,right;\\n        unordered_map<int,int> freq;\\n        for(auto &n:nums2)\\n        {\\n            freq[n]++;\\n        }\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long t=(long long)nums1[i]*nums1[i];\\n            left=0;\\n            right=nums2.size()-1;\\n            while(left<right)\\n            {\\n                long long temp=(long long)nums2[left]*nums2[right];\\n                if(t==temp)\\n                {\\n                    if(nums2[left]==nums2[right])\\n                    {\\n                        ans+=(freq[nums2[left]]*(freq[nums2[left]]-1))/2;\\n                            break;\\n                    }\\n                    ans+=freq[nums2[left]]*freq[nums2[right]];\\n                    left+=freq[nums2[left]];\\n                    right-=freq[nums2[right]];\\n                }\\n                else if(t>temp)\\n                {\\n                    left+=freq[nums2[left]];\\n                }\\n                else\\n                {\\n                    right-=freq[nums2[right]];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        return countTriplet(nums1,nums2)+countTriplet(nums2,nums1);\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    int countTriplet(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        int ans=0,left,right;\\n        unordered_map<int,int> freq;\\n        for(auto &n:nums2)\\n        {\\n            freq[n]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1298187,
                "title": "2-pointer-approach-o-1-space-complexity-98-faster",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return count(nums1 , nums2) + count(nums2 , nums1);\\n    }\\n    \\n    public int count(int a[] , int b[]){\\n        int n = a.length;\\n        int m = b.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            long x = (long)a[i]*a[i];\\n            int j = 0;\\n            int k = m-1;\\n            while(j<k){\\n                long prod = (long)b[j]*b[k];\\n                if(prod<x)\\n                    j++;\\n                else if(prod>x)\\n                    k--;\\n                else if(b[j] != b[k]){\\n                    int jNew = j;\\n                    int kNew = k;\\n                    \\n                    while(b[j] == b[jNew])\\n                        jNew++;\\n                    while(b[k] == b[kNew])\\n                        kNew--;\\n                    count += (jNew-j)*(k-kNew);\\n                    j = jNew;\\n                    k = kNew;\\n                }\\n                else{\\n                    int q = k-j+1;\\n                    count += (q)*(q-1)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return count(nums1 , nums2) + count(nums2 , nums1);\\n    }\\n    \\n    public int count(int a[] , int b[]){\\n        int n = a.length;\\n        int m = b.length;\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            long x = (long)a[i]*a[i];\\n            int j = 0;\\n            int k = m-1;\\n            while(j<k){\\n                long prod = (long)b[j]*b[k];\\n                if(prod<x)\\n                    j++;\\n                else if(prod>x)\\n                    k--;\\n                else if(b[j] != b[k]){\\n                    int jNew = j;\\n                    int kNew = k;\\n                    \\n                    while(b[j] == b[jNew])\\n                        jNew++;\\n                    while(b[k] == b[kNew])\\n                        kNew--;\\n                    count += (jNew-j)*(k-kNew);\\n                    j = jNew;\\n                    k = kNew;\\n                }\\n                else{\\n                    int q = k-j+1;\\n                    count += (q)*(q-1)/2;\\n                    break;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831826,
                "title": "c-20ms-12mb-max-o-n1-n2-o-d1-d2-d1-d2-are-number-of-distinct-numbers-in-nums1-and-nums2",
                "content": "Firstly we count how many times each number appeared in each vector.\\n\\nFor each distinct number n1 in one set, we try to find in the other set:\\n  1. `n2 == n1` and n2 appeared at least twice\\n  2. `n2 < n1` and exists n2x that `n2*n2x == n1*n1` => `n2x == n1*n1/n2`\\n\\nFor `1`, if n1 appeared f1 times and n2 appeared f2 times, the total number of combinations is: `f1 * C(f2, 2)` = `f1 * (f2*(f2-1)/2)`\\nFor `2`, if we can find both n2 and n2x, appeared f2 and f2x times respectively, the total number of combinations is: `f1 * (f2*f2x)` (note when n2 < n1, n2x > n1, we don\\'t want to double count, so only check n2 < n1)\\n\\nWe count for type 1, switch them over and count for type 2, finally return the sum.\\n\\n----\\n\\nComplexity analysis:\\n\\n1. Counting number frequency is `O(n1 + n2)`\\n2. Counting combinations, for each distinct number in one set, we check all numbers in the other set, then switch over and do it again: `O(freq1.size() * freq2.size() * 2)`, let d1=freq1.size(), d2=freq2.size() => `O(d1*d2)`\\n\\nEither `1` or `2` can take longer time, for example, if we have all same numbers like `[1,1,1,1,...,1,1]` and `[1,1,1,1,...,1,1]`, `1` takes much longer time than `2`. On the other hand if we have a lot of distinct numbers then `2` will be longer.\\nSo the overall time complexity is `max(O(n1+n2), O(d1*d2))`.\\n\\nWe use 2 hash maps to store the frequencies, so space complexity is `O(d1+d2)`.\\n\\n```cpp\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_map<int64_t, int> freq1, freq2;\\n    for (int n : nums1) freq1[n]++;\\n    for (int n : nums2) freq2[n]++;\\n\\n    auto Count = [](unordered_map<int64_t, int> &freqX, unordered_map<int64_t, int> &freqY) {\\n        int cnt = 0;\\n        for (auto [n1, f1] : freqX) {\\n            int c = 0;\\n            int64_t n1sq = n1*n1;\\n            for (auto [n2, f2] : freqY) {\\n                if (n2 == n1) {\\n                    if (f2 > 1) c += f2*(f2 - 1)/2;\\n                } else if (n2 < n1 && n1sq % n2 == 0) {\\n                    int n2x = n1sq/n2;\\n                    if (freqY.count(n2x)) c += f2*freqY[n2x];\\n                }\\n            }\\n            cnt += c*f1;\\n        }\\n        return cnt;\\n    };\\n\\n    return Count(freq1, freq2) + Count(freq2, freq1);\\n}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n    unordered_map<int64_t, int> freq1, freq2;\\n    for (int n : nums1) freq1[n]++;\\n    for (int n : nums2) freq2[n]++;\\n\\n    auto Count = [](unordered_map<int64_t, int> &freqX, unordered_map<int64_t, int> &freqY) {\\n        int cnt = 0;\\n        for (auto [n1, f1] : freqX) {\\n            int c = 0;\\n            int64_t n1sq = n1*n1;\\n            for (auto [n2, f2] : freqY) {\\n                if (n2 == n1) {\\n                    if (f2 > 1) c += f2*(f2 - 1)/2;\\n                } else if (n2 < n1 && n1sq % n2 == 0) {\\n                    int n2x = n1sq/n2;\\n                    if (freqY.count(n2x)) c += f2*freqY[n2x];\\n                }\\n            }\\n            cnt += c*f1;\\n        }\\n        return cnt;\\n    };\\n\\n    return Count(freq1, freq2) + Count(freq2, freq1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831722,
                "title": "5-line-java-solution-using-hashmap-with-explanation",
                "content": "**1. Store the value of num1*num1 from the first Array in a map.\\n2. Using two for loops generate all possible combination of num2 and check if the set contains those value.\\n3. If it contains add it to the sum and return it.**\\n```\\npublic int calculate(int[] num1, int[] num2) {\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        long n = num1.length,  m = num2.length, ans = 0;\\n        for(int i=0; i<n; i++) map.put((long)num1[i]*num1[i],map.getOrDefault((long)num1[i]*num1[i],0)+1);\\n        for(int j=0; j<m; j++)  for(int k=j+1; k<m; k++)   ans += (long)map.getOrDefault((long)num2[j]*num2[k],0);\\n        return (int)ans;\\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return calculate(nums1,nums2) + calculate(nums2,nums1);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int calculate(int[] num1, int[] num2) {\\n        HashMap<Long, Integer> map = new HashMap<>();\\n        long n = num1.length,  m = num2.length, ans = 0;\\n        for(int i=0; i<n; i++) map.put((long)num1[i]*num1[i],map.getOrDefault((long)num1[i]*num1[i],0)+1);\\n        for(int j=0; j<m; j++)  for(int k=j+1; k<m; k++)   ans += (long)map.getOrDefault((long)num2[j]*num2[k],0);\\n        return (int)ans;\\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return calculate(nums1,nums2) + calculate(nums2,nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831634,
                "title": "c-explanation-approach-and-code-and-time-complexity",
                "content": "Approach\\n    0. Sort the arrays since you need to search\\n    For type 1:\\n\\t\\n    1. select first number from nums1\\n    2. Square it\\n    3. Select number from nums2 and divide it by square of nums1[i]\\n    4. If divisible, search for all occurences of the other pair in nums2\\n    5. Lets there be x occurences then add x to ans.\\n    6. But the intresting thing to note is if the numbers selected in nums2 is square root of \\n    number selected in nums1 then we have one extra occurence, so subtract one from answer.\\n    \\nRepeat this for type 2.\\nFinally return answer.\\n\\nSince we sort the array use upper_bound and lower_bound to search in log(n);\\n\\nOverall time Complexity =mlog(n)+nlog(m)\\nwhich is overall nlog(n)\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int count(vector<int> &arr, long long int x, int n)\\n    {\\n\\n        auto low = lower_bound(arr.begin(), arr.end(), x);\\n        if (low == arr.end() || *low != x)\\n            return 0;\\n        auto high = upper_bound(low, arr.end(), x);\\n        return high - low;\\n    }\\n\\n    int numTriplets(vector<int> &nums1, vector<int> &nums2)\\n    {\\n        int m = nums1.size();\\n        int n = nums2.size();\\n        int i, j;\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        int trip = 0;\\n        for (i = 0; i < m; i++)\\n        {\\n            long long toSearch = (long long)nums1[i] * (long long)nums1[i];\\n            for (j = 0; j < n; j++)\\n            {\\n                long long int num1 = nums2[j];\\n                if (toSearch % num1 == 0)\\n                {\\n\\n                    int c = count(nums2, toSearch / num1, n);\\n                    if (c > 0)\\n                        trip += c;\\n                    if (num1 * num1 == toSearch)\\n                        trip -= 1;\\n                }\\n            }\\n        }\\n        for (i = 0; i < n; i++)\\n        {\\n            long long toSearch = (long long)nums2[i] * (long long)nums2[i];\\n            for (j = 0; j < m; j++)\\n            {\\n                long long int num1 = nums1[j];\\n                if (toSearch % num1 == 0)\\n                {\\n\\n                    int c = count(nums1, toSearch / num1, m);\\n                    if (c > 0)\\n                        trip += c;\\n                    if (num1 * num1 == toSearch)\\n                        trip -= 1;\\n                }\\n            }\\n        }\\n        return trip / 2;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution\\n{\\npublic:\\n    int count(vector<int> &arr, long long int x, int n)\\n    {\\n\\n        auto low = lower_bound(arr.begin(), arr.end(), x);\\n        if (low == arr.end() || *low != x)\\n            return 0;\\n        auto high = upper_bound(low, arr.end(), x);\\n        return high - low;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2315875,
                "title": "python-3-o-mn-short-and-concise",
                "content": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\tdef get_res(a,b):\\n\\t\\t\\t\\tres,n=0,len(b)\\n\\t\\t\\t\\tprod=Counter([x*x for x in a])\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\t\\tres+=prod[b[i]*b[j]]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn get_res(nums1,nums2)+get_res(nums2,nums1)",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\t\\t\\tdef get_res(a,b):\\n\\t\\t\\t\\tres,n=0,len(b)\\n\\t\\t\\t\\tprod=Counter([x*x for x in a])\\n\\t\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t\\tfor j in range(i+1,n):\\n\\t\\t\\t\\t\\t\\tres+=prod[b[i]*b[j]]\\n\\t\\t\\t\\treturn res\\n\\t\\t\\treturn get_res(nums1,nums2)+get_res(nums2,nums1)",
                "codeTag": "Java"
            },
            {
                "id": 1806238,
                "title": "brute-force-approach-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<long, int> m1, m2;\\n        for(int i : nums1) m1[(long long)i*i]++;\\n        for(int i : nums2) m2[(long long)i*i]++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums2.size()-1; i++){\\n            for(int j=i+1; j<nums2.size(); j++){\\n                if(m1[(long long)nums2[i] * nums2[j]]){\\n                    ans += m1[(long long)nums2[i] * nums2[j]];\\n                }\\n            }\\n        }\\n        for(int i=0; i<nums1.size()-1; i++){\\n            for(int j=i+1; j<nums1.size(); j++){\\n                if(m2[(long long)nums1[i] * nums1[j]]){\\n                    ans += m2[(long long)nums1[i] * nums1[j]];\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<long, int> m1, m2;\\n        for(int i : nums1) m1[(long long)i*i]++;\\n        for(int i : nums2) m2[(long long)i*i]++;\\n        \\n        int ans = 0;\\n        \\n        for(int i=0; i<nums2.size()-1; i++){\\n            for(int j=i+1; j<nums2.size(); j++){\\n                if(m1[(long long)nums2[i] * nums2[j]]){\\n                    ans += m1[(long long)nums2[i] * nums2[j]];\\n                }\\n            }\\n        }\\n        for(int i=0; i<nums1.size()-1; i++){\\n            for(int j=i+1; j<nums1.size(); j++){\\n                if(m2[(long long)nums1[i] * nums1[j]]){\\n                    ans += m2[(long long)nums1[i] * nums1[j]];\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1658113,
                "title": "python-intuitive-hashmap-solution-o-n-m-time",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sqr1, sqr2 = defaultdict(int), defaultdict(int)\\n        m, n = len(nums1), len(nums2)\\n        for i in range(m):\\n            sqr1[nums1[i]**2] += 1\\n        for j in range(n):\\n            sqr2[nums2[j]**2] += 1\\n            \\n        res = 0 \\n        for i in range(m-1):\\n            for j in range(i+1, m):\\n                if nums1[i]*nums1[j] in sqr2:\\n                    res += sqr2[nums1[i]*nums1[j]]\\n                    \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if nums2[i]*nums2[j] in sqr1:\\n                    res += sqr1[nums2[i]*nums2[j]]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sqr1, sqr2 = defaultdict(int), defaultdict(int)\\n        m, n = len(nums1), len(nums2)\\n        for i in range(m):\\n            sqr1[nums1[i]**2] += 1\\n        for j in range(n):\\n            sqr2[nums2[j]**2] += 1\\n            \\n        res = 0 \\n        for i in range(m-1):\\n            for j in range(i+1, m):\\n                if nums1[i]*nums1[j] in sqr2:\\n                    res += sqr2[nums1[i]*nums1[j]]\\n                    \\n        for i in range(n-1):\\n            for j in range(i+1, n):\\n                if nums2[i]*nums2[j] in sqr1:\\n                    res += sqr1[nums2[i]*nums2[j]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1305961,
                "title": "c-a-very-simple-two-sum-like-approach",
                "content": "```\\n//Approach-1 (Simple solution)\\nclass Solution {\\npublic:\\n    void twoProduct(ull target, vector<int> & nums, int &count) {\\n        unordered_map<int, int> mp;\\n        mp[1] = 0;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if(target%nums[i] == 0) {\\n                int remain= target/nums[i];\\n                count += mp[remain];\\n            }\\n            mp[nums[i]]++;\\n        }\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int count = 0;\\n        for(int i = 0; i<n1; i++) {\\n            twoProduct((long)nums1[i]*nums1[i], nums2, count);\\n        }\\n        \\n        for(int i = 0; i<n2; i++) {\\n            twoProduct((long)nums2[i]*nums2[i], nums1, count);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using C++ STL for a concise code)\\n//However the concept of both solution are exactly same.\\n//This approach just teaces on how to use STL in C++ to make life easy\\n\\nclass Solution {\\npublic:\\n    int twoProduct(long target, vector<int> &nums) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int &x : nums) {\\n            if(target%x == 0) {\\n                count += mp[target/x];\\n            }\\n            mp[x]++;\\n        }\\n        return count;\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        auto lambda1 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums2);\\n        };\\n\\n        auto lambda2 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums1);\\n        };\\n\\n        return accumulate(begin(nums1), end(nums1), 0, lambda1) +\\n               accumulate(begin(nums2), end(nums2), 0, lambda2);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Simple solution)\\nclass Solution {\\npublic:\\n    void twoProduct(ull target, vector<int> & nums, int &count) {\\n        unordered_map<int, int> mp;\\n        mp[1] = 0;\\n        for(int i = 0; i<nums.size(); i++) {\\n            if(target%nums[i] == 0) {\\n                int remain= target/nums[i];\\n                count += mp[remain];\\n            }\\n            mp[nums[i]]++;\\n        }\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n1 = nums1.size();\\n        int n2 = nums2.size();\\n        \\n        int count = 0;\\n        for(int i = 0; i<n1; i++) {\\n            twoProduct((long)nums1[i]*nums1[i], nums2, count);\\n        }\\n        \\n        for(int i = 0; i<n2; i++) {\\n            twoProduct((long)nums2[i]*nums2[i], nums1, count);\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using C++ STL for a concise code)\\n//However the concept of both solution are exactly same.\\n//This approach just teaces on how to use STL in C++ to make life easy\\n\\nclass Solution {\\npublic:\\n    int twoProduct(long target, vector<int> &nums) {\\n        unordered_map<int, int> mp;\\n        int count = 0;\\n        \\n        for(int &x : nums) {\\n            if(target%x == 0) {\\n                count += mp[target/x];\\n            }\\n            mp[x]++;\\n        }\\n        return count;\\n    }\\n\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        auto lambda1 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums2);\\n        };\\n\\n        auto lambda2 = [&](int s, long n) {\\n            return s + twoProduct(n*n, nums1);\\n        };\\n\\n        return accumulate(begin(nums1), end(nums1), 0, lambda1) +\\n               accumulate(begin(nums2), end(nums2), 0, lambda2);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1177779,
                "title": "javascript-solution",
                "content": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const squaredFreq1 = countSquareFreq(nums1);\\n    const squaredFreq2 = countSquareFreq(nums2);\\n    \\n    return countProdFreq(nums1, squaredFreq2) + countProdFreq(nums2, squaredFreq1);\\n\\t\\n    \\n    function countSquareFreq(nums) {\\n        const freq = new Map();\\n        \\n        for (const num of nums) {\\n            const squared = num * num;\\n        \\n            if (!freq.has(squared)) freq.set(squared, 0);\\n            freq.set(squared, freq.get(squared) + 1);\\n         }\\n       \\n        return freq;\\n    }\\n    \\n    function countProdFreq(nums, freqMap) {\\n        let count = 0;\\n        \\n        for (let i = 0;  i < nums.length - 1; i++) {\\n            for (let j = i + 1; j < nums.length; j++) {\\n                const prod = nums[i] * nums[j];\\n            \\n                if (freqMap.has(prod)) count += freqMap.get(prod);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const squaredFreq1 = countSquareFreq(nums1);\\n    const squaredFreq2 = countSquareFreq(nums2);\\n    \\n    return countProdFreq(nums1, squaredFreq2) + countProdFreq(nums2, squaredFreq1);\\n\\t\\n    \\n    function countSquareFreq(nums) {\\n        const freq = new Map();\\n        \\n        for (const num of nums) {\\n            const squared = num * num;\\n        \\n            if (!freq.has(squared)) freq.set(squared, 0);\\n            freq.set(squared, freq.get(squared) + 1);\\n         }\\n       \\n        return freq;\\n    }\\n    \\n    function countProdFreq(nums, freqMap) {\\n        let count = 0;\\n        \\n        for (let i = 0;  i < nums.length - 1; i++) {\\n            for (let j = i + 1; j < nums.length; j++) {\\n                const prod = nums[i] * nums[j];\\n            \\n                if (freqMap.has(prod)) count += freqMap.get(prod);\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 850735,
                "title": "93-91-python3-hash-table",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def helper(A, B):\\n            ans = 0\\n            C = Counter([a*a for a in A])\\n            D = Counter()\\n            for b in B:\\n                for k, v in D.items():\\n                    if k*b in C:\\n                        ans += v * C[k*b]\\n                D[b] += 1\\n            return ans\\n        \\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def helper(A, B):\\n            ans = 0\\n            C = Counter([a*a for a in A])\\n            D = Counter()\\n            for b in B:\\n                for k, v in D.items():\\n                    if k*b in C:\\n                        ans += v * C[k*b]\\n                D[b] += 1\\n            return ans\\n        \\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831956,
                "title": "c-code-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int get(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        unordered_map<long long int,long long int>m;int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[(long long )nums1[i]*nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                if(m.find((long long)nums2[i]*nums2[j])!=m.end())ans+=m[(long long)nums2[i]*nums2[j]];\\n            }\\n        }return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      return get(nums1,nums2)+get(nums2,nums1);}\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int get(vector<int>& nums1, vector<int>& nums2)\\n    {\\n        unordered_map<long long int,long long int>m;int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            m[(long long )nums1[i]*nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                if(m.find((long long)nums2[i]*nums2[j])!=m.end())ans+=m[(long long)nums2[i]*nums2[j]];\\n            }\\n        }return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      return get(nums1,nums2)+get(nums2,nums1);}\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 831557,
                "title": "c-easy-3-sum-2-pointer-with-comments-o-n-m-time-o-1-space",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n\\t// returns count of valids triplets (i, j, K) of type 1\\n\\t// note that to find of type 2, just swap nums1 and nums2 while calling \\n    int returnCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int count = 0;\\n        \\n        for(int k=0; k<n; k++) {\\n            ll target = nums1[k]*1ll*nums1[k];\\n\\t\\t\\t// we\\'ll find two numbers in nums2 such that their product equals target \\n            int i=0, j=m-1;\\n            while(i<j) {\\n                ll prod = nums2[i]*1ll*nums2[j];\\n                if(prod == target) {\\n\\t\\t\\t\\t\\t// case 1 : nums[i] == nums[j]\\n\\t\\t\\t\\t\\t// this means all numbers in between i & j are same and\\n\\t\\t\\t\\t\\t// we can choose any two out of all of them, hence Nc2 possibilities\\n                    if(nums2[i] == nums2[j]) {\\n                        int len = j-i+1;\\n                        count += len*(len-1)/2;\\n                        i = j+1;\\n                    }\\n\\t\\t\\t\\t\\t// case 2 : if not so\\n\\t\\t\\t\\t\\t// find the number of elements equal to nums2[i] (say n1) and\\n\\t\\t\\t\\t\\t// that equal to nums2[j] ( ssay n2)\\n\\t\\t\\t\\t\\t// add n1*n2 to ans\\n                    else {\\n                        int left_len = 1, right_len = 1;\\n                        while(i<j && nums2[i] == nums2[i+1]) {\\n                            i++;\\n                            left_len++;\\n                        }\\n                        while(j>i && nums2[j-1] == nums2[j]) {\\n                            j--;\\n                            right_len++;\\n                        }\\n                        \\n                        count += left_len * right_len;\\n                        i++; j--;\\n                    }\\n                    \\n                }\\n\\t\\t\\t\\t// accordingly move pointer i or j\\n                else if(prod < target)\\n                    i++;\\n                else\\n                    j--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        return returnCount(nums1, nums2) + returnCount(nums2, nums1);\\n        \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n\\t// returns count of valids triplets (i, j, K) of type 1\\n\\t// note that to find of type 2, just swap nums1 and nums2 while calling \\n    int returnCount(vector<int>& nums1, vector<int>& nums2) {\\n        int n = nums1.size(), m = nums2.size();\\n        int count = 0;\\n        \\n        for(int k=0; k<n; k++) {\\n            ll target = nums1[k]*1ll*nums1[k];\\n\\t\\t\\t// we\\'ll find two numbers in nums2 such that their product equals target \\n            int i=0, j=m-1;\\n            while(i<j) {\\n                ll prod = nums2[i]*1ll*nums2[j];\\n                if(prod == target) {\\n\\t\\t\\t\\t\\t// case 1 : nums[i] == nums[j]\\n\\t\\t\\t\\t\\t// this means all numbers in between i & j are same and\\n\\t\\t\\t\\t\\t// we can choose any two out of all of them, hence Nc2 possibilities\\n                    if(nums2[i] == nums2[j]) {\\n                        int len = j-i+1;\\n                        count += len*(len-1)/2;\\n                        i = j+1;\\n                    }\\n\\t\\t\\t\\t\\t// case 2 : if not so\\n\\t\\t\\t\\t\\t// find the number of elements equal to nums2[i] (say n1) and\\n\\t\\t\\t\\t\\t// that equal to nums2[j] ( ssay n2)\\n\\t\\t\\t\\t\\t// add n1*n2 to ans\\n                    else {\\n                        int left_len = 1, right_len = 1;\\n                        while(i<j && nums2[i] == nums2[i+1]) {\\n                            i++;\\n                            left_len++;\\n                        }\\n                        while(j>i && nums2[j-1] == nums2[j]) {\\n                            j--;\\n                            right_len++;\\n                        }\\n                        \\n                        count += left_len * right_len;\\n                        i++; j--;\\n                    }\\n                    \\n                }\\n\\t\\t\\t\\t// accordingly move pointer i or j\\n                else if(prod < target)\\n                    i++;\\n                else\\n                    j--;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        \\n        return returnCount(nums1, nums2) + returnCount(nums2, nums1);\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831523,
                "title": "python3-solution",
                "content": "```python\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\trev, n1, n2 = 0, Counter(nums1), Counter(nums2)\\n\\n\\tfor i in range(len(nums1)-1):\\n\\t\\tfor j in range(i+1, len(nums1)):\\n\\t\\t\\tt = (nums1[i] * nums1[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n2:\\n\\t\\t\\t\\trev += n2[t]\\n\\n\\tfor i in range(len(nums2)-1):\\n\\t\\tfor j in range(i+1, len(nums2)):\\n\\t\\t\\tt = (nums2[i] * nums2[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n1:\\n\\t\\t\\t\\trev += n1[t]\\n\\n\\treturn rev\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\trev, n1, n2 = 0, Counter(nums1), Counter(nums2)\\n\\n\\tfor i in range(len(nums1)-1):\\n\\t\\tfor j in range(i+1, len(nums1)):\\n\\t\\t\\tt = (nums1[i] * nums1[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n2:\\n\\t\\t\\t\\trev += n2[t]\\n\\n\\tfor i in range(len(nums2)-1):\\n\\t\\tfor j in range(i+1, len(nums2)):\\n\\t\\t\\tt = (nums2[i] * nums2[j])**(1/2)\\n\\n\\t\\t\\tif t == int(t) and t in n1:\\n\\t\\t\\t\\trev += n1[t]\\n\\n\\treturn rev\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2387605,
                "title": "c-easy-explanation-o-n-2",
                "content": "//        long long temp,t,help are used to keep the product within limits (prevent overflow)\\n        \\n// The idea is to store all the squares in a map(not set because duplicates may be present an dnot even multiset because we won\\'t get the number of times the duplicates appears)\\n        \\n//         Use nested loop then and check which pairs product is present as square in another map  and add its occurences\\n        \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n            map<long long,int> st1,st2;             \\n            long long temp,t;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    t=nums1[i];\\n                    temp=t*t;\\n                   \\n                    \\n                    \\n                     st1[t*t]++;\\n            }\\n                   \\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    t=nums2[i];\\n                    temp=t*t;\\n                   \\n                    \\n                     st2[t*t]++;\\n            }\\n            \\n            int cnt=0;\\n            long long help1,help2;\\n           for(int i=0;i<nums1.size();i++)\\n           {\\n                   for(int j=i+1;j<nums1.size();j++)\\n                   {\\n                           help1=nums1[i];\\n                           help2=nums1[j];\\n                           temp=help1*help2;\\n                          \\n                           if(st2.find(temp)!=st2.end())\\n                           {\\n                                   cnt+=st2[temp];\\n                           }\\n                   }\\n           }\\n            \\n             for(int i=0;i<nums2.size();i++)\\n           {\\n                   for(int j=i+1;j<nums2.size();j++)\\n                   {\\n                           help1=nums2[i];\\n                           help2=nums2[j];\\n                           temp=help1*help2;\\n                           \\n                           \\n                           if(st1.find(temp)!=st1.end())\\n                           {\\n                                   cnt+=st1[temp];\\n                           }\\n                   }\\n           }\\n            return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "//        long long temp,t,help are used to keep the product within limits (prevent overflow)\\n        \\n// The idea is to store all the squares in a map(not set because duplicates may be present an dnot even multiset because we won\\'t get the number of times the duplicates appears)\\n        \\n//         Use nested loop then and check which pairs product is present as square in another map  and add its occurences\\n        \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n            map<long long,int> st1,st2;             \\n            long long temp,t;\\n            for(int i=0;i<nums1.size();i++)\\n            {\\n                    t=nums1[i];\\n                    temp=t*t;\\n                   \\n                    \\n                    \\n                     st1[t*t]++;\\n            }\\n                   \\n            for(int i=0;i<nums2.size();i++)\\n            {\\n                    t=nums2[i];\\n                    temp=t*t;\\n                   \\n                    \\n                     st2[t*t]++;\\n            }\\n            \\n            int cnt=0;\\n            long long help1,help2;\\n           for(int i=0;i<nums1.size();i++)\\n           {\\n                   for(int j=i+1;j<nums1.size();j++)\\n                   {\\n                           help1=nums1[i];\\n                           help2=nums1[j];\\n                           temp=help1*help2;\\n                          \\n                           if(st2.find(temp)!=st2.end())\\n                           {\\n                                   cnt+=st2[temp];\\n                           }\\n                   }\\n           }\\n            \\n             for(int i=0;i<nums2.size();i++)\\n           {\\n                   for(int j=i+1;j<nums2.size();j++)\\n                   {\\n                           help1=nums2[i];\\n                           help2=nums2[j];\\n                           temp=help1*help2;\\n                           \\n                           \\n                           if(st1.find(temp)!=st1.end())\\n                           {\\n                                   cnt+=st1[temp];\\n                           }\\n                   }\\n           }\\n            return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2204732,
                "title": "javascript-two-approaches-hashmap-two-pointers",
                "content": "**Solution 1: Hashmap**\\n\\nThis approach is similar to the two sum problem.\\nWe use a hashmap to keep track of the frequencies of past numbers.\\nCount the number of `target / nums2[j]` in the hashmap.\\n\\n`n = length of nums1`, `m = length of nums2`\\nTime Complexity: `O(nm)` 498ms\\nSpace Complexity: `O(n + m)` 48.3MB\\n```\\nvar numTriplets = function(nums1, nums2) {\\n  return getTriplets(nums1, nums2) + getTriplets(nums2, nums1);\\n  \\n  function getTriplets(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i], map = new Map();\\n      for (let j = 0; j < nums2.length; j++) {\\n        ans += map.get(target / nums2[j]) || 0;\\n        map.set(nums2[j], (map.get(nums2[j]) || 0) + 1);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```\\n\\n\\n**Solution 2: Three Pointers**\\n\\n1. Sort both arrays. This is so that we can use two pointers to calculate the pairs.\\n2. For each `nums1[i] `\\n  Use two pointers (`start = 0`, `end = n - 1`) in `nums2`\\n  Count the number of pairs where `nums2[j] * nums2[k] === nums1[i] * nums1[i]`\\n  There are two special cases to consider:\\n\\n    Case 1. `nums2[j] !== nums2[k]`.\\n      An array like `[1,1,3,3]`. \\n      Count the number of repeated `nums2[j]` and repeated `nums2[k]`.\\n      Multiply the two counts together to get the number of combinations.\\n\\n    Case 2. `[nums2[j], ..., nums2[k]]` are all equal\\n      e.g: `[1,1,1,1,1]`\\n      For each `nums2[j]`, we can pair it with any number on the right.\\n      For the above example this would be: `4 + 3 + 2 + 1`\\n      Use the formula `(n-1)*n/2 `to calculate the sum of `1 + 2 + 3 + ... + n-1`\\n\\nTime Complexity: `O(nm + n log(n) + m log(m))` 153ms\\nSpace Complexity: `O(log(n) + log(m))` (space for sorting) 43.1MB\\n```\\nvar numTriplets = function(nums1, nums2) {\\n  nums1.sort((a, b) => a - b);\\n  nums2.sort((a, b) => a - b);\\n  return calc(nums1, nums2) + calc(nums2, nums1);\\n  \\n  function calc(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i];\\n      let j = 0, k = nums2.length - 1;\\n      while (j < k) {\\n        if (nums2[j] * nums2[k] === target) {\\n          if (nums2[j] === nums2[k]) { // case 2: [nums2[j], ..., nums2[k]] are all equal\\n            ans += (k - j) * (k - j + 1) / 2;\\n            j = k;\\n          } else { // case 1: nums2[j] !== nums2[k]\\n            let left = j, right = k;\\n            while (j < k && nums2[j] === nums2[left]) j++;\\n            while (k >= 0 && nums2[k] === nums2[right]) k--;\\n            ans += (j - left) * (right - k);\\n          }\\n        }\\n        else if (nums2[j] * nums2[k] < target) j++;\\n        else k--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n  return getTriplets(nums1, nums2) + getTriplets(nums2, nums1);\\n  \\n  function getTriplets(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i], map = new Map();\\n      for (let j = 0; j < nums2.length; j++) {\\n        ans += map.get(target / nums2[j]) || 0;\\n        map.set(nums2[j], (map.get(nums2[j]) || 0) + 1);\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```\n```\\nvar numTriplets = function(nums1, nums2) {\\n  nums1.sort((a, b) => a - b);\\n  nums2.sort((a, b) => a - b);\\n  return calc(nums1, nums2) + calc(nums2, nums1);\\n  \\n  function calc(nums1, nums2) {\\n    let ans = 0;\\n    for (let i = 0; i < nums1.length; i++) {\\n      let target = nums1[i] * nums1[i];\\n      let j = 0, k = nums2.length - 1;\\n      while (j < k) {\\n        if (nums2[j] * nums2[k] === target) {\\n          if (nums2[j] === nums2[k]) { // case 2: [nums2[j], ..., nums2[k]] are all equal\\n            ans += (k - j) * (k - j + 1) / 2;\\n            j = k;\\n          } else { // case 1: nums2[j] !== nums2[k]\\n            let left = j, right = k;\\n            while (j < k && nums2[j] === nums2[left]) j++;\\n            while (k >= 0 && nums2[k] === nums2[right]) k--;\\n            ans += (j - left) * (right - k);\\n          }\\n        }\\n        else if (nums2[j] * nums2[k] < target) j++;\\n        else k--;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1661853,
                "title": "python-soln",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        hash1=defaultdict(int)\\n        hash2=defaultdict(int)\\n        \\n        for x in nums1:\\n            hash1[x*x]+=1\\n        \\n        for x in nums2:\\n            hash2[x*x]+=1\\n        \\n        res=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                \\n                res+=hash2[nums1[i]*nums1[j]]\\n        \\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                \\n                res+=hash1[nums2[i]*nums2[j]]\\n        return res\\n        \\n                \\n                \\n        \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        hash1=defaultdict(int)\\n        hash2=defaultdict(int)\\n        \\n        for x in nums1:\\n            hash1[x*x]+=1\\n        \\n        for x in nums2:\\n            hash2[x*x]+=1\\n        \\n        res=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                \\n                res+=hash2[nums1[i]*nums1[j]]\\n        \\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                \\n                res+=hash1[nums2[i]*nums2[j]]\\n        return res\\n        \\n                \\n                \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1660254,
                "title": "c-brute-force-using-hash-map",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        // O(n^2)\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        \\n        ll count=0;\\n        // square of a number\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i]; // square of num1\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```\\n**please hit upvote if you like it : )**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    int find(vector<int>nums1,vector<int>nums2)\\n    {\\n        unordered_map<ll,ll>mp;\\n        // O(n^2)\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                ll p=(long long)nums2[i]*nums2[j];\\n                mp[p]++;\\n            }\\n        }\\n        \\n        ll count=0;\\n        // square of a number\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll p=(long long)nums1[i]*nums1[i]; // square of num1\\n            if(mp.find(p)!=mp.end())\\n            {\\n                count+=mp[p];\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        return find(nums1,nums2)+find(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1480249,
                "title": "c-bruteforce",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        map<ll,ll>mp1;\\n        map<ll,ll>mp2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i = 0 ; i < a.size();i++)\\n        {\\n            ll p = (ll)a[i]*a[i];\\n            mp1[p]++;\\n        }\\n         for(int i = 0 ; i < b.size();i++)\\n        {\\n            ll p = (ll)b[i]*b[i];\\n            mp2[p]++;\\n        }\\n    ll ans = 0  ;\\n        for(int i = 0 ; i  < b.size();i++)\\n        {\\n            for(int j=i+1;j<b.size();j++){\\n            ll p = (ll)b[i]*b[j];\\n                ans+=mp1[p];\\n                }\\n        }\\n        for(int i = 0 ; i  < a.size();i++)\\n        {\\n            for(int j=i+1;j<a.size();j++){\\n            ll p = (ll)a[i]*a[j];\\n                ans+=mp2[p];\\n                }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long int\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        map<ll,ll>mp1;\\n        map<ll,ll>mp2;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        for(int i = 0 ; i < a.size();i++)\\n        {\\n            ll p = (ll)a[i]*a[i];\\n            mp1[p]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1199846,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n       return res(nums1,nums2)+res(nums2,nums1);\\n    }\\n    public static int res(int[] nums1,int[] nums2)\\n    {\\n        int count=0;\\n\\t\\tHashMap<Long,Integer> map=new HashMap<Long,Integer>();\\n\\t\\tfor(long i:nums1)\\n\\t\\t\\tmap.put((i*i), map.getOrDefault(i*i,0)+1);\\n\\t\\tfor(int i=0;i<nums2.length-1;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i+1;j<nums2.length;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong prod=(long)nums2[i]*nums2[j];\\n\\t\\t\\t\\tif(map.containsKey(prod))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount=count+map.get(prod);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n       return res(nums1,nums2)+res(nums2,nums1);\\n    }\\n    public static int res(int[] nums1,int[] nums2)\\n    {\\n        int count=0;\\n\\t\\tHashMap<Long,Integer> map=new HashMap<Long,Integer>();\\n\\t\\tfor(long i:nums1)\\n\\t\\t\\tmap.put((i*i), map.getOrDefault(i*i,0)+1);\\n\\t\\tfor(int i=0;i<nums2.length-1;i++)\\n\\t\\t{\\n\\t\\t\\tfor(int j=i+1;j<nums2.length;j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tlong prod=(long)nums2[i]*nums2[j];\\n\\t\\t\\t\\tif(map.containsKey(prod))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount=count+map.get(prod);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1068741,
                "title": "python-o-n-2-function",
                "content": "* How do we approach such a question?\\n* You can try the brute force, but it will TLE\\n* I always try to fall back to the **Two Sum problem**\\n\\t* Can we build dictionaries in linear or n^2 time to avoid n^3 time?\\n\\t\\t* We can count the number of `nums1[i]^2` for example\\n\\t\\t* We can also count the number of `nums2[j] * nums2[k]` too\\n\\t\\t* Then, we can loop in linear time over the `nums1[i]^2` values, and access the count of `j * k` in O(1)\\n\\t\\t* \\n* **Ultimately, don\\'t be afraid of having multiple `O(n)` loops**, or doing anytype of `k * O(n)` or `k * O(n^2)`.\\n\\t* The biggest concern is **reducing the upper bound** as much as possible, e.g, achieving `O(n^2)` instead of `O(n^3)`\\n\\n* So, next time, think of two sum, and see if you can have multiple loops (e.g `k * O(x)`) but reduce the upper bound, (`x` in this case) as much as possible!\\n\\n```python\\nclass Solution:\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \"\"\"\\n        O(n^2)\\n        \"\"\"\\n        \\n        def check(nums1, nums2):\\n            \\n            # Initialize a dict: value->(value^2, count)\\n            a = {}\\n            for i in nums1:\\n                if i not in a:\\n                    a[i] = [i**2, 1]\\n                else:\\n                    a[i][-1] += 1\\n                               \\n            # Initialize a dict: nums2[i] * nums[j] -> count\\n            b = collections.defaultdict(int)\\n            for i in range(len(nums2)):\\n                for j in range(i+1, len(nums2)):\\n                    b[nums2[i]*nums2[j]] += 1\\n                    \\n            # Calculate the result\\n            # result += i^2 count * j*k count for each combination\\n            result = 0            \\n            for (i, amount) in a.values():                \\n                result += b[i]*amount\\n            \\n            return result\\n        \\n                                \\n        # Call above function twice\\n        return check(nums1, nums2) + check(nums2, nums1)\\n```\\n\\n---\\n\\nIf you want to get a bit fancy, you can always spend time trying to optimize or clean up your code two \\uD83D\\uDE06\\n\\n```python\\ndef calculate(a, b):\\n    square_counts = collections.Counter(i**2 for i in a)\\n    return sum(square_counts[b[j] * b[k]] for j in range(len(b)) for k in range(j+1, len(b)))\\n\\nreturn calculate(nums1, nums2) + calculate(nums2, nums1)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \"\"\"\\n        O(n^2)\\n        \"\"\"\\n        \\n        def check(nums1, nums2):\\n            \\n            # Initialize a dict: value->(value^2, count)\\n            a = {}\\n            for i in nums1:\\n                if i not in a:\\n                    a[i] = [i**2, 1]\\n                else:\\n                    a[i][-1] += 1\\n                               \\n            # Initialize a dict: nums2[i] * nums[j] -> count\\n            b = collections.defaultdict(int)\\n            for i in range(len(nums2)):\\n                for j in range(i+1, len(nums2)):\\n                    b[nums2[i]*nums2[j]] += 1\\n                    \\n            # Calculate the result\\n            # result += i^2 count * j*k count for each combination\\n            result = 0            \\n            for (i, amount) in a.values():                \\n                result += b[i]*amount\\n            \\n            return result\\n        \\n                                \\n        # Call above function twice\\n        return check(nums1, nums2) + check(nums2, nums1)\\n```\n```python\\ndef calculate(a, b):\\n    square_counts = collections.Counter(i**2 for i in a)\\n    return sum(square_counts[b[j] * b[k]] for j in range(len(b)) for k in range(j+1, len(b)))\\n\\nreturn calculate(nums1, nums2) + calculate(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1039384,
                "title": "python-count-beats-100-o-n-m",
                "content": "First count the elements in each array, then find the number of triplets for each element.\\nIt is faster if there are lots of duplicates.\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt1 = collections.defaultdict(int)\\n        cnt2 = collections.defaultdict(int)\\n        for n in nums1:\\n            cnt1[n] += 1\\n        for n in nums2:\\n            cnt2[n] += 1\\n\\n        def triplets(arr1, arr2):\\n            ans = 0\\n            for t, v in arr1.items():\\n                k = arr2.get(t, 0)\\n                tmp = k * (k - 1) // 2\\n                sq = t * t\\n                for m in arr2:\\n                    if m < t and sq % m == 0:\\n                        tmp += arr2.get(m, 0) * arr2.get(sq // m, 0)\\n                ans += tmp * v\\n            return ans\\n        return triplets(cnt1, cnt2) + triplets(cnt2, cnt1)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"\\n        cnt1 = collections.defaultdict(int)\\n        cnt2 = collections.defaultdict(int)\\n        for n in nums1:\\n            cnt1[n] += 1\\n        for n in nums2:\\n            cnt2[n] += 1\\n\\n        def triplets(arr1, arr2):\\n            ans = 0\\n            for t, v in arr1.items():\\n                k = arr2.get(t, 0)\\n                tmp = k * (k - 1) // 2\\n                sq = t * t\\n                for m in arr2:\\n                    if m < t and sq % m == 0:\\n                        tmp += arr2.get(m, 0) * arr2.get(sq // m, 0)\\n                ans += tmp * v\\n            return ans\\n        return triplets(cnt1, cnt2) + triplets(cnt2, cnt1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835642,
                "title": "python-solution-based-on-binary-search-and-memorization",
                "content": "Time Complexity = O ( N * N * Log N )\\n\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:      \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        def lowerbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n\\n                if nums[mid] == target:\\n                    right = mid\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n        \\n        def higherbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                \\n                if nums[mid] == target:\\n                    left = mid + 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n            \\n    \\n        def helper(n, nums, memo):\\n            if n in memo:\\n                return memo[n]\\n            \\n            result = 0\\n            \\n            for i in range(len(nums)):\\n                if n % nums[i] != 0:\\n                    continue\\n                    \\n                target = n // nums[i]\\n                \\n                # find total number of target in nums[i+1:]\\n                lower = lowerbound(target, i+1, len(nums), nums)\\n                higher = higherbound(target, i+1, len(nums), nums)\\n                \\n                result += (higher - lower)\\n            \\n            memo[n] = result\\n            return result\\n        \\n        result = 0\\n        \\n        memo1 = {}\\n        for n in nums1:\\n            result += helper(n*n, nums2, memo1)\\n        \\n        memo2 = {}\\n        for n in nums2:\\n            result += helper(n*n, nums1, memo2)\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:      \\n        nums1.sort()\\n        nums2.sort()\\n        \\n        def lowerbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n\\n                if nums[mid] == target:\\n                    right = mid\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n        \\n        def higherbound(target, left, right, nums):\\n            while left < right:\\n                mid = left + (right - left) // 2\\n                \\n                if nums[mid] == target:\\n                    left = mid + 1\\n                elif nums[mid] < target:\\n                    left = mid + 1\\n                else:\\n                    right = mid\\n            \\n            return left\\n            \\n    \\n        def helper(n, nums, memo):\\n            if n in memo:\\n                return memo[n]\\n            \\n            result = 0\\n            \\n            for i in range(len(nums)):\\n                if n % nums[i] != 0:\\n                    continue\\n                    \\n                target = n // nums[i]\\n                \\n                # find total number of target in nums[i+1:]\\n                lower = lowerbound(target, i+1, len(nums), nums)\\n                higher = higherbound(target, i+1, len(nums), nums)\\n                \\n                result += (higher - lower)\\n            \\n            memo[n] = result\\n            return result\\n        \\n        result = 0\\n        \\n        memo1 = {}\\n        for n in nums1:\\n            result += helper(n*n, nums2, memo1)\\n        \\n        memo2 = {}\\n        for n in nums2:\\n            result += helper(n*n, nums1, memo2)\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835527,
                "title": "python3-3-liner-number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq1 = Counter(map(mul, nums1, nums1))\\n        sq2 = Counter(map(mul, nums2, nums2))\\n        return sum(sq2[a * b] for a, b in combinations(nums1, 2)) +  sum(sq1[a * b] for a, b in combinations(nums2, 2))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq1 = Counter(map(mul, nums1, nums1))\\n        sq2 = Counter(map(mul, nums2, nums2))\\n        return sum(sq2[a * b] for a, b in combinations(nums1, 2)) +  sum(sq1[a * b] for a, b in combinations(nums2, 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 834480,
                "title": "java-factorization-solution-o-n-m",
                "content": "Algorithm:\\n1. Create a map  key: (num * num), value: count basing on first array\\n2. Go throug the second array, for every number calculate a key containing factors that are represented odd number of times in number. For example, 60 is 2 * 2 * 3 * 5, the key is \"3,5\"\\n3. Search for the values with the same key processed on previous iterations - they will form squares\\n4. Check if the map based on the first array contains corresponding square. Update count if match is found\\n5. Store store num under the same key\\n\\n<pre>\\nclass Solution {\\n    // Cached factors\\n    private final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; factorsCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Calculates factors for num. Returns a map where\\n     * key is prime factor, value is number of times the factor is used.\\n     *\\n     *  For example, 60 will be represented as\\n     * 2 -&gt; 2\\n     * 3 -&gt; 1\\n     * 5 -&gt; 1\\n     */\\n    private Map&lt;Integer, Integer&gt; factors(int num) {\\n        Map&lt;Integer, Integer&gt; cached = factorsCache.get(num);\\n        if (cached != null) {\\n            // return cached value (if any)\\n            return cached;\\n        }\\n\\n        // handle case num == 1 separately\\n        if (num == 1) {\\n            Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n            ret.put(1, 1);\\n            factorsCache.put(1, ret);\\n            return ret;\\n        }\\n\\n        // calculate factors recursively\\n        for (int i = 2; i * i &lt;= num; i++) {\\n            if (num % i == 0) {\\n                Map&lt;Integer, Integer&gt; f1 = factors(i);\\n                Map&lt;Integer, Integer&gt; f2 = factors(num / i);\\n\\n                Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n                for (Map.Entry&lt;Integer, Integer&gt; entry : f1.entrySet()) {\\n                    Integer key = entry.getKey();\\n                    Integer value = entry.getValue();\\n                    ret.put(key, ret.getOrDefault(key, 0) + value);\\n                }\\n                for (Map.Entry&lt;Integer, Integer&gt; entry : f2.entrySet()) {\\n                    Integer key = entry.getKey();\\n                    Integer value = entry.getValue();\\n                    ret.put(key, ret.getOrDefault(key, 0) + value);\\n                }\\n\\n                factorsCache.put(num, ret);\\n                return ret;\\n            }\\n        }\\n\\n        // cache the results\\n        Map&lt;Integer, Integer&gt; ret = new HashMap&lt;&gt;();\\n        ret.put(num, 1);\\n        factorsCache.put(num, ret);\\n        return ret;\\n    }\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Map&lt;Long, Integer&gt; squaresMap1 = new HashMap&lt;&gt;();\\n        Map&lt;Long, Integer&gt; squaresMap2 = new HashMap&lt;&gt;();\\n        for (int n : nums1) {\\n            long sq = ((long) n) * n;\\n            squaresMap1.put(sq, squaresMap1.getOrDefault(sq, 0) + 1);\\n        }\\n        for (int n : nums2) {\\n            long sq = ((long) n) * n;\\n            squaresMap2.put(sq, squaresMap2.getOrDefault(sq, 0) + 1);\\n        }\\n\\n        int ret = 0;\\n\\n        // check nums1 against squares in nums2\\n        ret += count(nums1, squaresMap2);\\n\\n        // check nums2 against squares in nums1\\n        ret += count(nums2, squaresMap1);\\n\\n        return ret;\\n    }\\n\\n    // cached keys\\n    private final Map&lt;Integer, String&gt; keyCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Key consists of factors (greater than 1) that are represented odd number of times in num\\n     * For example, 60 is 2 * 2 * 3 * 5, the key is \"3,5\"\\n     * 1 -&gt; \"\"\\n     * 2 -&gt; \"2\"\\n     * 3 -&gt; \"3\"\\n     * 4 -&gt; \"\"\\n     * 5 -&gt; \"5\"\\n     * 6 -&gt; \"2,3\"\\n     * ...\\n     */\\n    private String calculateKey(int num) {\\n        String cachedKey = keyCache.get(num);\\n        if (cachedKey != null) {\\n            return cachedKey;\\n        }\\n\\n        String key = \"\";\\n        if (num &gt; 1) {\\n            Map&lt;Integer, Integer&gt; f = factors(num);\\n            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\\n            for (Map.Entry&lt;Integer, Integer&gt; entry : f.entrySet()) {\\n                if (entry.getValue() % 2 != 0) {\\n                    list.add(entry.getKey());\\n                }\\n            }\\n            Collections.sort(list);\\n            StringBuilder sb = new StringBuilder();\\n            for (int j = 0; j &lt; list.size(); j++) {\\n                if (j &gt; 0) {\\n                    sb.append(\",\");\\n                }\\n                sb.append(list.get(j));\\n            }\\n            key = sb.toString();\\n        }\\n\\n        keyCache.put(num, key);\\n\\n        return key;\\n    }\\n\\n\\n    private int count(int[] nums, Map&lt;Long, Integer&gt; complementary) {\\n        int ret = 0;\\n\\n        // Examples:\\n        // key \"3,5\" -&gt;\\n        //               15 -&gt; 2 (number of times this value was seen previously)\\n        //               60 -&gt; 1 (number of times this value was seen previously)\\n        // key \"3,7\" -&gt;\\n        //               21 -&gt; 1 (number of times this value was seen previously)\\n        //               2100 -&gt; 4 (number of times this value was seen previously)\\n        Map&lt;String, Map&lt;Integer, Integer&gt;&gt; previousNumbers = new HashMap&lt;&gt;();\\n\\n        for (int num : nums) {\\n            String key = calculateKey(num);\\n\\n            // we need to find previously previously seen values with the same key\\n            // if current value is 60, the key is \"3,5\", every value that has the same key will represent a square,\\n            // 15, 60, 135 etc.\\n            Map&lt;Integer, Integer&gt; counts = previousNumbers.computeIfAbsent(key, k -&gt; new HashMap&lt;&gt;());\\n            for (Map.Entry&lt;Integer, Integer&gt; entry : counts.entrySet()) {\\n                Integer previous = entry.getKey();\\n                long product = previous.longValue() * num;\\n\\n                // finding a match in the other array\\n                Integer complementaryCount = complementary.get(product);\\n                if (complementaryCount != null) {\\n                    ret += entry.getValue() * complementaryCount;\\n                }\\n            }\\n\\n            // recording current number in the map\\n            counts.put(num, counts.getOrDefault(num, 0) + 1);\\n        }\\n\\n        return ret;\\n    }\\n}\\n</pre>",
                "solutionTags": [],
                "code": "class Solution {\\n    // Cached factors\\n    private final Map&lt;Integer, Map&lt;Integer, Integer&gt;&gt; factorsCache = new HashMap&lt;&gt;();\\n\\n    /*\\n     * Calculates factors for num. Returns a map where\\n     * key is prime factor, value is number of times the factor is used.\\n     *\\n     *  For example, 60 will be represented as\\n     * 2 -&gt; 2\\n     * 3 -&gt; 1\\n     * 5 -&gt; 1\\n     */\\n    private Map&lt;Integer, Integer&gt; factors(int num) {\\n        Map&lt;Integer, Integer&gt; cached = factorsCache.get(num);\\n        if (cached != null) {\\n            // return cached value (if any)\\n            return cached;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 833777,
                "title": "c-o-mn-easiest-solution-with-self-explanatory-code",
                "content": "Please Note that time complexity of find function in unordered_map is O(1)\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();int m=n2.size();\\n        long ans=0;\\n        //type 1\\n        for(int i=0;i<n;i++)\\n        {\\n            double a=n1[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<m;j++)\\n            {\\n                double b=n2[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        //type 2\\n        for(int i=0;i<m;i++)\\n        {\\n            double a=n2[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                double b=n1[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& n1, vector<int>& n2) {\\n        int n=n1.size();int m=n2.size();\\n        long ans=0;\\n        //type 1\\n        for(int i=0;i<n;i++)\\n        {\\n            double a=n1[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<m;j++)\\n            {\\n                double b=n2[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        //type 2\\n        for(int i=0;i<m;i++)\\n        {\\n            double a=n2[i];\\n            unordered_map<double,int> s;\\n            for(int j=0;j<n;j++)\\n            {\\n                double b=n1[j];\\n                double f=a*a/b;\\n                if(s.find(f)!=s.end()) ans+=s[f];\\n                s[b]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 832206,
                "title": "c-solution-using-dictionary",
                "content": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        int w1 = GetWays(nums1, nums2);\\n        int w2 = GetWays(nums2, nums1);\\n        return w1 + w2;\\n    }\\n    \\n    public int GetWays(int[] nums1, int[] nums2) {\\n        int numWays = 0;\\n        long product = 0;\\n        \\n        Dictionary<long, int> d = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++) {\\n            product = (long)nums1[i] * (long)nums1[i];\\n            if(d.ContainsKey(product))\\n                d[product]++;\\n            else {\\n                d.Add(product,1);\\n            }\\n        }\\n    \\n        for(int j = 0; j < nums2.Length-1; j++) {\\n            for(int k = j+1; k < nums2.Length; k++) {\\n                product = (long)nums2[j]*(long)nums2[k];\\n                if(d.ContainsKey(product)) {\\n                    numWays += d[product];\\n                } \\n            }\\n\\n        }\\n            \\n        return numWays;\\n    }\\n    \\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        int w1 = GetWays(nums1, nums2);\\n        int w2 = GetWays(nums2, nums1);\\n        return w1 + w2;\\n    }\\n    \\n    public int GetWays(int[] nums1, int[] nums2) {\\n        int numWays = 0;\\n        long product = 0;\\n        \\n        Dictionary<long, int> d = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++) {\\n            product = (long)nums1[i] * (long)nums1[i];\\n            if(d.ContainsKey(product))\\n                d[product]++;\\n            else {\\n                d.Add(product,1);\\n            }\\n        }\\n    \\n        for(int j = 0; j < nums2.Length-1; j++) {\\n            for(int k = j+1; k < nums2.Length; k++) {\\n                product = (long)nums2[j]*(long)nums2[k];\\n                if(d.ContainsKey(product)) {\\n                    numWays += d[product];\\n                } \\n            }\\n\\n        }\\n            \\n        return numWays;\\n    }\\n    \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 832007,
                "title": "java-bruteforce-o-n-2",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, getMap(nums2)) + getCount(nums2, getMap(nums1));\\n    }\\n    \\n    Map<Long, Integer> getMap(int[] nums){\\n        Map<Long, Integer> map = new HashMap<>();\\n        for(long num: nums)\\n            map.put(num * num, map.getOrDefault(num * num,0)+1);\\n        return map;\\n    }\\n    \\n    int getCount(int[] nums, Map<Long, Integer> map){\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                long prod = (long)nums[i]*(long)nums[j];\\n                if(map.containsKey(prod))\\n                    count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, getMap(nums2)) + getCount(nums2, getMap(nums1));\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 831669,
                "title": "why-91-92-tcs-passed-please-suggest-help",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int ans = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n        Map<Long, Integer> S1 = new HashMap<>();\\n        Map<Long, Integer> S2 = new HashMap<>();\\n        \\n        for (int i = 0; i < n1; i++) {\\n            long s1 = (nums1[i] * nums1[i]);\\n            S1.put(s1, S1.getOrDefault(s1, 0) + 1);\\n        }\\n        // System.out.println(\"S1 = \" + S1);\\n        \\n        for (int i = 0; i < n2; i++) {\\n            long s2 = ((long)nums2[i] * (long)nums2[i]);\\n            S2.put(s2, S2.getOrDefault(s2, 0) + 1);\\n        }\\n        // System.out.println(\"S2 = \" + S2);\\n        \\n        for (int j = 0; j < n2; j++) {\\n            for (int k = j + 1; k < n2; k++) {\\n                long mul = ((long)nums2[j] * (long)nums2[k]);\\n                // System.out.println(nums2[j] + \" \" + nums2[k] + \" = \" + mul);\\n                if (S1.containsKey(mul)) {\\n                    ans += S1.get(mul);\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n1; j++) {\\n            for (int k = j + 1; k < n1; k++) {\\n                long mul = ((long)nums1[j] * (long)nums1[k]);\\n                // System.out.println(nums1[j] + \" * \" + nums1[k] + \" = \" + mul);\\n                if (S2.containsKey(mul)) {\\n                    ans += S2.get(mul);\\n                }\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n}\\n```\\n\\n1 blunder as not converted square elements into long. As mentioned below also corrected answer.\\n\\n**long s1 = ((long)nums1[i] * (long)nums1[i]);**",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        int ans = 0;\\n        int n1 = nums1.length, n2 = nums2.length;\\n        Map<Long, Integer> S1 = new HashMap<>();\\n        Map<Long, Integer> S2 = new HashMap<>();\\n        \\n        for (int i = 0; i < n1; i++) {\\n            long s1 = (nums1[i] * nums1[i]);\\n            S1.put(s1, S1.getOrDefault(s1, 0) + 1);\\n        }\\n        // System.out.println(\"S1 = \" + S1);\\n        \\n        for (int i = 0; i < n2; i++) {\\n            long s2 = ((long)nums2[i] * (long)nums2[i]);\\n            S2.put(s2, S2.getOrDefault(s2, 0) + 1);\\n        }\\n        // System.out.println(\"S2 = \" + S2);\\n        \\n        for (int j = 0; j < n2; j++) {\\n            for (int k = j + 1; k < n2; k++) {\\n                long mul = ((long)nums2[j] * (long)nums2[k]);\\n                // System.out.println(nums2[j] + \" \" + nums2[k] + \" = \" + mul);\\n                if (S1.containsKey(mul)) {\\n                    ans += S1.get(mul);\\n                }\\n            }\\n        }\\n        \\n        for (int j = 0; j < n1; j++) {\\n            for (int k = j + 1; k < n1; k++) {\\n                long mul = ((long)nums1[j] * (long)nums1[k]);\\n                // System.out.println(nums1[j] + \" * \" + nums1[k] + \" = \" + mul);\\n                if (S2.containsKey(mul)) {\\n                    ans += S2.get(mul);\\n                }\\n            }\\n        }\\n         \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831584,
                "title": "python-using-counter-o-n-m",
                "content": "```\\n    def numTriplets(self, A: List[int], B: List[int]) -> int:\\n        def getTriplets(A, B):\\n            m, n = len(A), len(B)\\n            ans = 0\\n            counter = Counter()\\n            for j in range(n):\\n                for k in range(j+1,n):\\n                    prod = B[j]*B[k]\\n                    counter[prod] += 1\\n            for i in range(m):\\n                prod = A[i]**2\\n                ans += counter[prod]\\n            return ans \\n        return getTriplets(A,B) + getTriplets(B,A)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def numTriplets(self, A: List[int], B: List[int]) -> int:\\n        def getTriplets(A, B):\\n            m, n = len(A), len(B)\\n            ans = 0\\n            counter = Counter()\\n            for j in range(n):\\n                for k in range(j+1,n):\\n                    prod = B[j]*B[k]\\n                    counter[prod] += 1\\n            for i in range(m):\\n                prod = A[i]**2\\n                ans += counter[prod]\\n            return ans \\n        return getTriplets(A,B) + getTriplets(B,A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 831575,
                "title": "java-use-hashmap-to-maintain-frequencies-o-n-2-m-2",
                "content": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        HashMap<Long, Integer> s1 = new HashMap();\\n        HashMap<Long, Integer> s2 = new HashMap();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long cur = (long)nums1[i]*nums1[j];\\n                s1.put(cur, s1.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long cur = (long)nums2[i]*nums2[j];\\n                s2.put(cur, s2.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int num : nums1){\\n            res+=s2.getOrDefault((long)num*num, 0);\\n        }\\n        for(int num : nums2){\\n            res+=s1.getOrDefault((long)num*num, 0);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        HashMap<Long, Integer> s1 = new HashMap();\\n        HashMap<Long, Integer> s2 = new HashMap();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long cur = (long)nums1[i]*nums1[j];\\n                s1.put(cur, s1.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long cur = (long)nums2[i]*nums2[j];\\n                s2.put(cur, s2.getOrDefault(cur, 0)+1);\\n            }\\n        }\\n        int res = 0;\\n        for(int num : nums1){\\n            res+=s2.getOrDefault((long)num*num, 0);\\n        }\\n        for(int num : nums2){\\n            res+=s1.getOrDefault((long)num*num, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 831563,
                "title": "c-30s-faster-than-100",
                "content": "Sort first, and then check whether the 3 numbers can exist accoriding to the condition. For this purpose, we can use a HashMap to expedite the search. Thus, in the beginning, we insert the elements into the HashMap (in C++ ```unordered_map```) and then check for the obvious relationship of ```nums1[i]^2 = nums2[j] * nums2[k]``` . We can increment the count by using the HashMap counts to make it even faster for the cases such as ```nums1 = [1,1,1,1]``` and ```nums2 = [1,1]```.\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        long count = 0;\\n        unordered_map<int,int> mp1;\\n        unordered_map<int,int> mp2;\\n        long num;\\n        for (int i = 0;i<nums1.size();i++){\\n            mp1[nums1[i]]++;\\n        }\\n        for (int i = 0;i<nums2.size();i++){\\n            mp2[nums2[i]]++;\\n        }\\n        for (int i = 0;i<nums1.size();i++){\\n            if (i>0 && nums1[i]==nums1[i-1]){\\n                continue;\\n            }\\n            if (nums1[i]>nums2.back()){\\n                break;\\n            }\\n            if (nums1[i]<nums2[0]){\\n                continue;\\n            }\\n            num = (long)nums1[i]*nums1[i];\\n            for (int j = 0;j<nums2.size();j++){\\n                if (j>0 && nums2[j]==nums2[j-1]){\\n                    continue;\\n                }\\n                if (num/nums2[j]<nums2[0])\\n                    break;\\n                if (num%nums2[j]==0 && num/nums2[j]>=nums2[j] && mp2.find(num/nums2[j])!=mp2.end()){\\n                    if (num/nums2[j]==nums2[j]){\\n                        count += mp1[nums1[i]]*(long)(mp2[nums2[j]]*(mp2[nums2[j]]-1))/2;\\n                        break;\\n                    }else{\\n                        count += mp1[nums1[i]]*(long)mp2[nums2[j]]*mp2[num/nums2[j]];\\n                    }\\n                }\\n            }\\n        }\\n        // cout<<\"--------------------\"<<endl;\\n        for (int i = 0;i<nums2.size();i++){\\n            if (i>0 && nums2[i]==nums2[i-1]){\\n                continue;\\n            }\\n            if (nums2[i]>nums1.back()){\\n                break;\\n            }\\n            if (nums2[i]<nums1[0]){\\n                continue;\\n            }\\n            num = (long)nums2[i]*nums2[i];\\n            for (int j = 0;j<nums1.size();j++){\\n                if (j>0 && nums1[j]==nums1[j-1]){\\n                    continue;\\n                }\\n                if (num/nums1[j]<nums1[0])\\n                    break;\\n                if (num%nums1[j]==0 && num/nums1[j]>=nums1[j] && mp1.find(num/nums1[j])!=mp1.end()){\\n                    if (num/nums1[j]==nums1[j]){\\n                        count += mp2[nums2[i]]*(long)(mp1[nums1[j]]*(mp1[nums1[j]]-1))/2;\\n                        break;\\n                    }else{\\n                        count += mp2[nums2[i]]*(long)mp1[nums1[j]]*mp1[num/nums1[j]];\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "```unordered_map```\n```nums1[i]^2 = nums2[j] * nums2[k]```\n```nums1 = [1,1,1,1]```\n```nums2 = [1,1]```",
                "codeTag": "Unknown"
            },
            {
                "id": 831544,
                "title": "python-hashmap",
                "content": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        cnt = 0\\n        a = collections.defaultdict(int)\\n        b = collections.defaultdict(int)\\n        \\n        for num in nums1:\\n            a[num*num] += 1\\n        \\n        for num in nums2:\\n            b[num*num] += 1\\n            \\n        for j in range(len(nums2)):\\n            for k in range(j+ 1, len(nums2)):\\n                c = nums2[j]*nums2[k]\\n                if c in a: cnt += a[c] \\n                        \\n        for j in range(len(nums1)):\\n            for k in range(j+1, len(nums1)):\\n                c = nums1[j]*nums1[k]\\n                if c in b: cnt += b[c] \\n        \\n        return cnt\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        cnt = 0\\n        a = collections.defaultdict(int)\\n        b = collections.defaultdict(int)\\n        \\n        for num in nums1:\\n            a[num*num] += 1\\n        \\n        for num in nums2:\\n            b[num*num] += 1\\n            \\n        for j in range(len(nums2)):\\n            for k in range(j+ 1, len(nums2)):\\n                c = nums2[j]*nums2[k]\\n                if c in a: cnt += a[c] \\n                        \\n        for j in range(len(nums1)):\\n            for k in range(j+1, len(nums1)):\\n                c = nums1[j]*nums1[k]\\n                if c in b: cnt += b[c] \\n        \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831522,
                "title": "python3-frequency-table",
                "content": "\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(nums1), Counter(nums2)\\n        \\n        def fn(x, y, freq): \\n            \"\"\"Return count of triplet of nums[i]**2 = nums[j]*nums[k].\"\"\"\\n            ans = 0\\n            for xx in x: \\n                xx *= xx\\n                ans += sum(freq[xx//yy] - (yy == xx//yy) for yy in y if not xx%yy and xx//yy in freq)\\n            return ans//2\\n\\n        return fn(nums1, nums2, cnt2) + fn(nums2, nums1, cnt1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        cnt1, cnt2 = Counter(nums1), Counter(nums2)\\n        \\n        def fn(x, y, freq): \\n            \"\"\"Return count of triplet of nums[i]**2 = nums[j]*nums[k].\"\"\"\\n            ans = 0\\n            for xx in x: \\n                xx *= xx\\n                ans += sum(freq[xx//yy] - (yy == xx//yy) for yy in y if not xx%yy and xx//yy in freq)\\n            return ans//2\\n\\n        return fn(nums1, nums2, cnt2) + fn(nums2, nums1, cnt1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831511,
                "title": "straightforward-o-n-2-java-solution-with-2-hashmaps",
                "content": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        //hashMap: product -> freq\\n        HashMap<Long, Integer> map1 = new HashMap<>();\\n        HashMap<Long, Integer> map2 = new HashMap<>();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0;i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                Long prod = (long)nums1[i]*nums1[j];\\n                map1.put(prod, map1.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        for(int i=0;i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                Long prod = (long) nums2[i]*nums2[j];\\n                map2.put(prod, map2.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        //get res\\n        int res=0;\\n        for(int num : nums1){\\n            Long sqr = (long)num*num;\\n            res += map2.getOrDefault(sqr, 0);\\n        } \\n        for(int num : nums2){\\n            Long sqr = (long)num*num;\\n            res += map1.getOrDefault(sqr, 0);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        //hashMap: product -> freq\\n        HashMap<Long, Integer> map1 = new HashMap<>();\\n        HashMap<Long, Integer> map2 = new HashMap<>();\\n        int n1 = nums1.length;\\n        int n2 = nums2.length;\\n        for(int i=0;i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                Long prod = (long)nums1[i]*nums1[j];\\n                map1.put(prod, map1.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        for(int i=0;i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                Long prod = (long) nums2[i]*nums2[j];\\n                map2.put(prod, map2.getOrDefault(prod, 0) + 1);\\n            }\\n        }\\n        //get res\\n        int res=0;\\n        for(int num : nums1){\\n            Long sqr = (long)num*num;\\n            res += map2.getOrDefault(sqr, 0);\\n        } \\n        for(int num : nums2){\\n            Long sqr = (long)num*num;\\n            res += map1.getOrDefault(sqr, 0);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047115,
                "title": "reducing-arrays-into-a-sum-of-the-helper-function-results",
                "content": "# Approach\\nCreate a helper function counting possible products of a number in an array. Return the sum of both arrays being mapped to the power of 2 and reduced with the helper function.\\n\\n# Code\\n```\\nclass Solution {\\n\\tfunc countProducts(of: Int, inArray: [Int]) -> Int {\\n\\t\\tguard inArray.count > 1 else { return 0 }\\n\\n\\t\\tvar res = 0\\n\\n\\t\\tfor i in 0...(inArray.count - 2) {\\n\\t\\t\\tfor j in (i + 1)...(inArray.count - 1) {\\n\\t\\t\\t\\tif inArray[i] * inArray[j] == of { res += 1 }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n\\t\\tnums1.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums2)\\n\\t\\t}) + nums2.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums1)\\n\\t\\t})\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc countProducts(of: Int, inArray: [Int]) -> Int {\\n\\t\\tguard inArray.count > 1 else { return 0 }\\n\\n\\t\\tvar res = 0\\n\\n\\t\\tfor i in 0...(inArray.count - 2) {\\n\\t\\t\\tfor j in (i + 1)...(inArray.count - 1) {\\n\\t\\t\\t\\tif inArray[i] * inArray[j] == of { res += 1 }\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res\\n\\t}\\n\\n\\tfunc numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n\\t\\tnums1.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums2)\\n\\t\\t}) + nums2.map { num in num * num }.reduce(0, { acc, num in\\n\\t\\t\\tacc + countProducts(of: num, inArray: nums1)\\n\\t\\t})\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041028,
                "title": "two-pointer-approch-using-hashmap-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private int countways(int[] nums1, int []nums2){\\n        int count = 0;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int n : nums2) {\\n            map.put((long) n * n, map.getOrDefault((long) n * n, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                \\n                if (map.containsKey(prod)) count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        return countways(nums1, nums2)+countways(nums2, nums1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    private int countways(int[] nums1, int []nums2){\\n        int count = 0;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int n : nums2) {\\n            map.put((long) n * n, map.getOrDefault((long) n * n, 0) + 1);\\n        }\\n\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                \\n                if (map.containsKey(prod)) count += map.get(prod);\\n            }\\n        }\\n        return count;\\n    }\\n\\n\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        \\n        return countways(nums1, nums2)+countways(nums2, nums1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965845,
                "title": "easy-to-understand-javascript-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n^2)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nvar numTriplets = function(nums1, nums2) {\\n    const triplets = (numsA, numsB) => {\\n        const squareMap = numsA.reduce((map, num) => {\\n            const square = num ** 2;\\n            const count = map.get(square) ?? 0;\\n\\n            return map.set(square, count + 1);\\n        }, new Map());\\n        let result = 0;\\n\\n        for (let a = 0; a < numsB.length; a++) {\\n            for (let b = a - 1; b >= 0; b--) {\\n                const product = numsB[a] * numsB[b];\\n                if (!squareMap.has(product)) continue;\\n                result += squareMap.get(product);\\n            }\\n        }\\n        return result;\\n    };\\n\\n    return triplets(nums1, nums2) + triplets(nums2, nums1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const triplets = (numsA, numsB) => {\\n        const squareMap = numsA.reduce((map, num) => {\\n            const square = num ** 2;\\n            const count = map.get(square) ?? 0;\\n\\n            return map.set(square, count + 1);\\n        }, new Map());\\n        let result = 0;\\n\\n        for (let a = 0; a < numsB.length; a++) {\\n            for (let b = a - 1; b >= 0; b--) {\\n                const product = numsB[a] * numsB[b];\\n                if (!squareMap.has(product)) continue;\\n                result += squareMap.get(product);\\n            }\\n        }\\n        return result;\\n    };\\n\\n    return triplets(nums1, nums2) + triplets(nums2, nums1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3958898,
                "title": "only-using-map-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n2)$$ \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,int>mp1,mp2;\\n        for(auto it:nums1){\\n           long long k=1LL*it*it;\\n            mp1[k]++;\\n        }\\n            for(auto it:nums2){\\n                  long long k=1LL*it*it;\\n            mp2[k]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<nums2.size()-1;i++){\\n            long long p=nums2[i];\\n            for(int j=i+1;j<nums2.size();j++){\\n                  p=p*nums2[j];\\n                  if(mp1.find(p)!=mp1.end())  cnt+=mp1[p];\\n                  p=nums2[i];\\n            }\\n\\n        }\\n        cout<<endl;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            long long q=nums1[i];\\n            for(int j=i+1;j<nums1.size();j++){\\n                  q=q*nums1[j];\\n           \\n                  if(mp2.find(q)!=mp2.end())  cnt+=mp2[q];\\n              \\n                  q=nums1[i];\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,int>mp1,mp2;\\n        for(auto it:nums1){\\n           long long k=1LL*it*it;\\n            mp1[k]++;\\n        }\\n            for(auto it:nums2){\\n                  long long k=1LL*it*it;\\n            mp2[k]++;\\n        }\\n        \\n        int cnt=0;\\n        for(int i=0;i<nums2.size()-1;i++){\\n            long long p=nums2[i];\\n            for(int j=i+1;j<nums2.size();j++){\\n                  p=p*nums2[j];\\n                  if(mp1.find(p)!=mp1.end())  cnt+=mp1[p];\\n                  p=nums2[i];\\n            }\\n\\n        }\\n        cout<<endl;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            long long q=nums1[i];\\n            for(int j=i+1;j<nums1.size();j++){\\n                  q=q*nums1[j];\\n           \\n                  if(mp2.find(q)!=mp2.end())  cnt+=mp2[q];\\n              \\n                  q=nums1[i];\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3866784,
                "title": "easy-java-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int numTriplets(int[] arr1, int[] arr2) {\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<Long,Integer> hp1 = new HashMap<>();\\n        HashMap<Long,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            long a = (long)arr1[i]*(long)arr1[i];\\n            if(hp1.containsKey(a)) hp1.put(a,hp1.get(a)+1);\\n            else hp1.put(a,1);\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            long a = (long)arr2[i]*(long)arr2[i];\\n            if(hp2.containsKey(a)) hp2.put(a,hp2.get(a)+1);\\n            else hp2.put(a,1);\\n        }\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long a = (long)arr1[i]*(long)arr1[j];\\n                if(hp2.containsKey(a)){\\n                    ans=ans+hp2.get(a);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long a = (long)arr2[i]*(long)arr2[j];\\n                if(hp1.containsKey(a)){\\n                    ans=ans+hp1.get(a);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] arr1, int[] arr2) {\\n        int n1 = arr1.length;\\n        int n2 = arr2.length;\\n\\n        HashMap<Long,Integer> hp1 = new HashMap<>();\\n        HashMap<Long,Integer> hp2 = new HashMap<>();\\n\\n        for(int i=0; i<n1; i++){\\n            long a = (long)arr1[i]*(long)arr1[i];\\n            if(hp1.containsKey(a)) hp1.put(a,hp1.get(a)+1);\\n            else hp1.put(a,1);\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            long a = (long)arr2[i]*(long)arr2[i];\\n            if(hp2.containsKey(a)) hp2.put(a,hp2.get(a)+1);\\n            else hp2.put(a,1);\\n        }\\n\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<n1; i++){\\n            for(int j=i+1; j<n1; j++){\\n                long a = (long)arr1[i]*(long)arr1[j];\\n                if(hp2.containsKey(a)){\\n                    ans=ans+hp2.get(a);\\n                }\\n            }\\n        }\\n\\n        for(int i=0; i<n2; i++){\\n            for(int j=i+1; j<n2; j++){\\n                long a = (long)arr2[i]*(long)arr2[j];\\n                if(hp1.containsKey(a)){\\n                    ans=ans+hp1.get(a);\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3756908,
                "title": "python3-two-pointer-solution-o-1-space-o-n-m-time-with-indepth-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThere are two types of triples we\\'re looking for: \\n\\n    Type 1: Triplet (i, j, k) if nums1[i]^2 == nums2[j] * nums2[k] \\n    Type 2: Triplet (i, j, k) if nums2[i]^2 == nums1[j] * nums1[k]\\n\\nNotice the symmetry. It\\'s saying we must look for triplets across both arrays. The best way to do this is by running the algorithm twice: once with nums1 as the target (the outer-loop) and again with nums2 as the target.\\n\\nTo do this without using any space (this can be done using a hashmap to count the instances where the conditions are true for both types), we can use two pointers like a 3Sum problem. In 3Sum, we investigate 1 number and then iterate our pointers over the remainder of a single array, squeezing the Left and Right pointers together. Then, iterate to the next number, shortening the remaining subarray. \\n\\nThis has a similar approach, except instead of a singular array, we use each number in Array1 `(a1)` and then search for a multiplicative pair in Array2 `(a2)` that would equal to the target of `a1[i]^2`. This works if `a2` is sorted. The time complexity for a sort is `O(nlogn)`, but this pales in comparison to the `O(mn)` runtime of the overall algorithm, so it\\'s beneficial to do this. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe ```helper``` function will be used twice, once searching the `nums1` array against `nums2`, and then vice versa. \\n\\nIn the general case (with `a1 and a2`), sort `a2`, then go through each number in `a1`; our target number will be `a1[i]^2`. To optimally search for the pair in `a2`, we use 2 pointers, starting from the beginning and at the end: `l, r = 0, len(a2) - 1`. Then we iterate over them while `l < r`. \\n\\nThere are three conditions:\\n* `a2[l] * a2[r] > target`: The pair is too large in comparison to our target. To mitigate this, we decrement `r`. This will move our pointer to a smaller number in the leftside (this is why we sorted), lowering our multiplicative result\\n* `a2[l] * a2[r] < target`: Our pair isn\\'t big enough, so we move our left pointer to the right where larger numbers are sorted, thus growing our multiplicative pair\\n* `else: # we found our target`: This has 2 subconditions, when the left and right pointer are equal (i.e, `a2[l] == a2[r]`), and the other when they\\'re not. \\n    * If they\\'re equal, that means we shouldn\\'t iterate over them to avoid recounting. So, we use the formula for counting pairs:`((n * (n - 1)) // 2)`. This is based on a combination formula, but for only 2 items. Get the size of the window, `n`, and use the formula. We `break` afterward because the numbers are equal, so there are no other pairs to consider between the two numbers.\\n    *  Otherwise, they\\'re not equal (but the pair is successful), so we count how many of each number there are and multiply the two together, `res += rightCount * leftCount`. \\n\\n\\nRun this twice on both arrays. This would result in `O(2nm)` runtime, which reduces to `O(nm)`.\\n\\n# Complexity\\n- Time complexity: `O(nm), where n == len(nums1) and m == len(nums2)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int: \\n        def helper(a1, a2): # a1, a2: array1, array2; symmetry\\n            # sort the searchable array, a2, to make conditions possible\\n            a2.sort()\\n            res = 0\\n            for n in a1:\\n                target = n ** 2\\n                l, r = 0, len(a2) - 1\\n                while l < r: \\n                    if a2[l] * a2[r] > target:\\n                        r -= 1\\n                    elif a2[l] * a2[r] < target:\\n                        l += 1\\n                    else:\\n                        # if l, r are the same, use combination form and break\\n                        if a2[l] == a2[r]:\\n                            n = (r - l + 1)\\n                            res += ((n * (n - 1))//2)\\n                            break\\n                        # count all the numbers at l and r\\n                        # that are successful pairs\\n                        left, right = a2[l], a2[r]\\n                        leftCount, rightCount = 0, 0\\n                        while l < len(a2) and a2[l] == left:\\n                            leftCount += 1\\n                            l += 1\\n                        while r >= 0 and a2[r] == right:\\n                            rightCount += 1\\n                            r -= 1\\n                        res += rightCount * leftCount\\n                    \\n            return res\\n        \\n        # run it twice for the symmetry between type1/type2\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```helper```\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int: \\n        def helper(a1, a2): # a1, a2: array1, array2; symmetry\\n            # sort the searchable array, a2, to make conditions possible\\n            a2.sort()\\n            res = 0\\n            for n in a1:\\n                target = n ** 2\\n                l, r = 0, len(a2) - 1\\n                while l < r: \\n                    if a2[l] * a2[r] > target:\\n                        r -= 1\\n                    elif a2[l] * a2[r] < target:\\n                        l += 1\\n                    else:\\n                        # if l, r are the same, use combination form and break\\n                        if a2[l] == a2[r]:\\n                            n = (r - l + 1)\\n                            res += ((n * (n - 1))//2)\\n                            break\\n                        # count all the numbers at l and r\\n                        # that are successful pairs\\n                        left, right = a2[l], a2[r]\\n                        leftCount, rightCount = 0, 0\\n                        while l < len(a2) and a2[l] == left:\\n                            leftCount += 1\\n                            l += 1\\n                        while r >= 0 and a2[r] == right:\\n                            rightCount += 1\\n                            r -= 1\\n                        res += rightCount * leftCount\\n                    \\n            return res\\n        \\n        # run it twice for the symmetry between type1/type2\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3707006,
                "title": "python3-solution-easy-to-understand-beginner-s-friendly",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Map1 = Counter([n * n for n in nums1])\\n        Map2 = Counter([n * n for n in nums2])\\n\\n        res = 0\\n        for i in range(len(nums1) - 1):\\n            for j in range(i + 1, len(nums1)):\\n                res += Map2[nums1[i] * nums1[j]]\\n\\n        for i in range(len(nums2) - 1):\\n            for j in range(i + 1, len(nums2)):\\n                res += Map1[nums2[i] * nums2[j]]\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Map1 = Counter([n * n for n in nums1])\\n        Map2 = Counter([n * n for n in nums2])\\n\\n        res = 0\\n        for i in range(len(nums1) - 1):\\n            for j in range(i + 1, len(nums1)):\\n                res += Map2[nums1[i] * nums1[j]]\\n\\n        for i in range(len(nums2) - 1):\\n            for j in range(i + 1, len(nums2)):\\n                res += Map1[nums2[i] * nums2[j]]\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665094,
                "title": "easy-understand-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Count1 = Counter(nums1)\\n        Count2 = Counter(nums2)\\n        res = 0\\n        for i in Count1:\\n            db = Count2.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count1[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count1[i]\\n                    \\n        for i in Count2:\\n            db = Count1.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count2[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count2[i]\\n\\n        return res\\n                    \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        Count1 = Counter(nums1)\\n        Count2 = Counter(nums2)\\n        res = 0\\n        for i in Count1:\\n            db = Count2.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count1[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count1[i]\\n                    \\n        for i in Count2:\\n            db = Count1.copy()\\n            while db:\\n                item = db.popitem()\\n                Q, r = divmod(i*i, item[0])\\n                if r == 0 and Q in db:\\n                    res += db[Q]*item[1]*Count2[i]\\n                    db.pop(Q)\\n                elif r == 0 and Q == item[0]:\\n                    res += comb(item[1],2)*Count2[i]\\n\\n        return res\\n                    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664545,
                "title": "unique-and-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nlong mod = 1e9+7;\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        map<long long ,long long>mp1;\\n        for(long long i : nums1){\\n            long long n = (i)%mod*(i)%mod;\\n            n=n%mod;\\n\\n\\n            mp1[n]++;\\n        }\\n        map<long long ,long long>mp2;\\n        for(long long i : nums2){\\n            long long n = (i)%mod * (i)%mod;\\n            n=n%mod;\\n\\n            mp2[n]++;\\n        }\\n        int res = 0;\\n\\n        int i = 0;\\n        while(i<nums2.size()){\\n\\n            int j = i+1;\\n            while(j<nums2.size()){\\n\\n                long long n = (nums2[i])%mod*(nums2[j])%mod;\\n                n=n%mod;\\n\\n                if(mp1.find(n)!=mp1.end()){\\n\\n                    res = res + mp1[n];\\n                }\\n\\n\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n       \\n        i = 0;\\n        while(i<nums1.size()){\\n            int j = i+1;\\n            while(j<nums1.size()){\\n\\n                long long int n = (nums1[i])%mod*(nums1[j])%mod;\\n                n=n%mod;\\n\\n                if(mp2.find(n)!=mp2.end()){\\n                    res = res + mp2[n];\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nlong mod = 1e9+7;\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n\\n        map<long long ,long long>mp1;\\n        for(long long i : nums1){\\n            long long n = (i)%mod*(i)%mod;\\n            n=n%mod;\\n\\n\\n            mp1[n]++;\\n        }\\n        map<long long ,long long>mp2;\\n        for(long long i : nums2){\\n            long long n = (i)%mod * (i)%mod;\\n            n=n%mod;\\n\\n            mp2[n]++;\\n        }\\n        int res = 0;\\n\\n        int i = 0;\\n        while(i<nums2.size()){\\n\\n            int j = i+1;\\n            while(j<nums2.size()){\\n\\n                long long n = (nums2[i])%mod*(nums2[j])%mod;\\n                n=n%mod;\\n\\n                if(mp1.find(n)!=mp1.end()){\\n\\n                    res = res + mp1[n];\\n                }\\n\\n\\n                j++;\\n            }\\n            i++;\\n        }\\n        \\n       \\n        i = 0;\\n        while(i<nums1.size()){\\n            int j = i+1;\\n            while(j<nums1.size()){\\n\\n                long long int n = (nums1[i])%mod*(nums1[j])%mod;\\n                n=n%mod;\\n\\n                if(mp2.find(n)!=mp2.end()){\\n                    res = res + mp2[n];\\n                }\\n                j++;\\n            }\\n            i++;\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3607712,
                "title": "python-pass-with-accumulate-frequencys-of-nums-2",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"     \\n        square1 = map(lambda x : x* x, nums1)\\n        square2 = map(lambda x : x* x, nums2)\\n        #frequency of nums1^2 and nums2^2\\n        freq1, freq2 = defaultdict(int),defaultdict(int)\\n        m1, m2 = range(len(nums1)), range(len(nums2))\\n        for i in m1:\\n            freq1[square1[i]] += 1\\n        for i in m2:\\n            freq2[square2[i]] += 1\\n            \\n        Ans = 0\\n        #type1\\n        for item in freq1:\\n            for j in m2:\\n                if item % nums2[j] == 0: \\n                    k = item / nums2[j]\\n                    Ans += nums2[j+1:].count(k) * freq1[item]\\n        #type2\\n        for item in freq2:\\n            for j in m1:\\n                if item % nums1[j] == 0:\\n                    k = item / nums1[j]\\n                    Ans += nums1[j+1:].count(k) * freq2[item]\\n\\n        return Ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n        \"\"\"\\n        :type nums1: List[int]\\n        :type nums2: List[int]\\n        :rtype: int\\n        \"\"\"     \\n        square1 = map(lambda x : x* x, nums1)\\n        square2 = map(lambda x : x* x, nums2)\\n        #frequency of nums1^2 and nums2^2\\n        freq1, freq2 = defaultdict(int),defaultdict(int)\\n        m1, m2 = range(len(nums1)), range(len(nums2))\\n        for i in m1:\\n            freq1[square1[i]] += 1\\n        for i in m2:\\n            freq2[square2[i]] += 1\\n            \\n        Ans = 0\\n        #type1\\n        for item in freq1:\\n            for j in m2:\\n                if item % nums2[j] == 0: \\n                    k = item / nums2[j]\\n                    Ans += nums2[j+1:].count(k) * freq1[item]\\n        #type2\\n        for item in freq2:\\n            for j in m1:\\n                if item % nums1[j] == 0:\\n                    k = item / nums1[j]\\n                    Ans += nums1[j+1:].count(k) * freq2[item]\\n\\n        return Ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562590,
                "title": "c-solution-easy-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    \\n    int count(vector<int> & A,vector<int>& B)\\n    {\\n        map<ll,int> m;\\n        int c=0;\\n        for(auto a :A) m[(ll)a*a]++;\\n\\n        for(int i=0;i<B.size()-1;i++)\\n        {\\n            for(int j{i+1};j<B.size();j++)\\n            {\\n                if(m.count((ll)B[i]*B[j]))\\n                    c+=m[(ll)B[i]*B[j]];\\n            }\\n        }\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        return count(nums1,nums2) + count(nums2,nums1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long int\\n    \\n    int count(vector<int> & A,vector<int>& B)\\n    {\\n        map<ll,int> m;\\n        int c=0;\\n        for(auto a :A) m[(ll)a*a]++;\\n\\n        for(int i=0;i<B.size()-1;i++)\\n        {\\n            for(int j{i+1};j<B.size();j++)\\n            {\\n                if(m.count((ll)B[i]*B[j]))\\n                    c+=m[(ll)B[i]*B[j]];\\n            }\\n        }\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        return count(nums1,nums2) + count(nums2,nums1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540026,
                "title": "brute-force-slowish",
                "content": "# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def count_triplets(nums1: List[int], nums2: List[int]) -> int:\\n            count = 0\\n            product_map = defaultdict(int)\\n\\n            for i in range(len(nums1)):\\n                for j in range(i + 1, len(nums1)):\\n                    product_map[nums1[i] * nums1[j]] += 1\\n\\n            for i in range(len(nums2)):\\n                square = nums2[i] * nums2[i]\\n                count += product_map[square]\\n\\n            return count\\n\\n        return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        def count_triplets(nums1: List[int], nums2: List[int]) -> int:\\n            count = 0\\n            product_map = defaultdict(int)\\n\\n            for i in range(len(nums1)):\\n                for j in range(i + 1, len(nums1)):\\n                    product_map[nums1[i] * nums1[j]] += 1\\n\\n            for i in range(len(nums2)):\\n                square = nums2[i] * nums2[i]\\n                count += product_map[square]\\n\\n            return count\\n\\n        return count_triplets(nums1, nums2) + count_triplets(nums2, nums1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3260804,
                "title": "python3-simplest-solution-beats-96-users-self-explanatory",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1SquareFrequency=defaultdict(int)\\n        nums2SquareFrequency=defaultdict(int)\\n        for num in nums1:\\n            nums1SquareFrequency[num**2]+=1\\n        for num in nums2:\\n            nums2SquareFrequency[num**2]+=1\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                ans+=nums2SquareFrequency[nums1[i]*nums1[j]]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                ans+=nums1SquareFrequency[nums2[i]*nums2[j]]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1SquareFrequency=defaultdict(int)\\n        nums2SquareFrequency=defaultdict(int)\\n        for num in nums1:\\n            nums1SquareFrequency[num**2]+=1\\n        for num in nums2:\\n            nums2SquareFrequency[num**2]+=1\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                ans+=nums2SquareFrequency[nums1[i]*nums1[j]]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                ans+=nums1SquareFrequency[nums2[i]*nums2[j]]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199233,
                "title": "lc-1577-m-python3-a-plain-solution",
                "content": "Use `collections.Counter` and iterations to count.\\n\\n```python3 []\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq_cnter1 = Counter([num**2 for num in nums1])\\n        sq_cnter2 = Counter([num**2 for num in nums2])\\n\\n        def count(nums, sq_cnter):\\n            n = len(nums)\\n            cnt = 0\\n            for i in range(n-1):\\n                for j in range(i+1, n):\\n                    cnt += sq_cnter[nums[i]*nums[j]]\\n            return cnt\\n        \\n        return count(nums1, sq_cnter2) + count(nums2, sq_cnter1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        sq_cnter1 = Counter([num**2 for num in nums1])\\n        sq_cnter2 = Counter([num**2 for num in nums2])\\n\\n        def count(nums, sq_cnter):\\n            n = len(nums)\\n            cnt = 0\\n            for i in range(n-1):\\n                for j in range(i+1, n):\\n                    cnt += sq_cnter[nums[i]*nums[j]]\\n            return cnt\\n        \\n        return count(nums1, sq_cnter2) + count(nums2, sq_cnter1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3199072,
                "title": "everybody-copies-answers-beats-100-this-issue-is-easy-we-sort-and-use-two-pointers-classic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n  var res = 0\\n  nums1.sort((a, b) => a - b < 0 ? -1 : 1)\\n  nums2.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n  function process(nums1, nums2) {\\n    var len1 = nums1.length\\n    var len2 = nums2.length\\n    for (var i = 0; i < len1; i++) {\\n      var leftPointer = 0\\n      var RightPointer = len2 - 1\\n      var cur = nums1[i]\\n      var curSqr = Math.pow(cur, 2)\\n\\n      while (leftPointer < RightPointer) {\\n        var curMul = nums2[leftPointer] * nums2[RightPointer]\\n        if (curMul > curSqr) {\\n          RightPointer--\\n        } else if (curMul < curSqr) {\\n          leftPointer++\\n        } else {\\n          if (nums2[leftPointer] === nums2[RightPointer]) {\\n            let len = RightPointer - leftPointer + 1\\n            res += (len * (len - 1)) / 2\\n            break\\n          } else {\\n            let right = nums2[RightPointer]\\n            let left = nums2[leftPointer]\\n            let leftSameCount = 0\\n            let rightSameCount = 0\\n            while (right === nums2[RightPointer]) {\\n              RightPointer--\\n              rightSameCount++\\n            }\\n            while (left === nums2[leftPointer]) {\\n              leftPointer++\\n              leftSameCount++\\n            }\\n            res += leftSameCount * rightSameCount\\n          }\\n        }\\n      }\\n    }\\n  }  \\n\\n  process(nums1, nums2)\\n  process(nums2, nums1)\\n\\n  return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n  var res = 0\\n  nums1.sort((a, b) => a - b < 0 ? -1 : 1)\\n  nums2.sort((a, b) => a - b < 0 ? -1 : 1)\\n\\n  function process(nums1, nums2) {\\n    var len1 = nums1.length\\n    var len2 = nums2.length\\n    for (var i = 0; i < len1; i++) {\\n      var leftPointer = 0\\n      var RightPointer = len2 - 1\\n      var cur = nums1[i]\\n      var curSqr = Math.pow(cur, 2)\\n\\n      while (leftPointer < RightPointer) {\\n        var curMul = nums2[leftPointer] * nums2[RightPointer]\\n        if (curMul > curSqr) {\\n          RightPointer--\\n        } else if (curMul < curSqr) {\\n          leftPointer++\\n        } else {\\n          if (nums2[leftPointer] === nums2[RightPointer]) {\\n            let len = RightPointer - leftPointer + 1\\n            res += (len * (len - 1)) / 2\\n            break\\n          } else {\\n            let right = nums2[RightPointer]\\n            let left = nums2[leftPointer]\\n            let leftSameCount = 0\\n            let rightSameCount = 0\\n            while (right === nums2[RightPointer]) {\\n              RightPointer--\\n              rightSameCount++\\n            }\\n            while (left === nums2[leftPointer]) {\\n              leftPointer++\\n              leftSameCount++\\n            }\\n            res += leftSameCount * rightSameCount\\n          }\\n        }\\n      }\\n    }\\n  }  \\n\\n  process(nums1, nums2)\\n  process(nums2, nums1)\\n\\n  return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181098,
                "title": "best-solution-with-full-explanation",
                "content": "1.For each array, create a frequency map that counts the occurrences of each element squared. Since we\\'re looking for pairs of elements that multiply to a square, we need to consider the squares of the elements in the arrays.\\n\\n2.For each pair of elements in nums1, check if their product is present in the frequency map of nums2. If so, add the count of that element to the total count.\\n\\n3.For each pair of elements in nums2, check if their product is present in the frequency map of nums1. If so, add the count of that element to the total count.\\n\\n4.Return the total count as the answer.\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        count += countTriplets(nums1, nums2);\\n        count += countTriplets(nums2, nums1);\\n        return count;\\n    }\\n\\n    private int countTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        Map<Long, Integer> freq = new HashMap<>();\\n        for (int n : nums2) {\\n            freq.put((long) n * n, freq.getOrDefault((long) n * n, 0) + 1);\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                if (freq.containsKey(prod)) {\\n                    count += freq.get(prod);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        count += countTriplets(nums1, nums2);\\n        count += countTriplets(nums2, nums1);\\n        return count;\\n    }\\n\\n    private int countTriplets(int[] nums1, int[] nums2) {\\n        int count = 0;\\n        Map<Long, Integer> freq = new HashMap<>();\\n        for (int n : nums2) {\\n            freq.put((long) n * n, freq.getOrDefault((long) n * n, 0) + 1);\\n        }\\n        for (int i = 0; i < nums1.length; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                long prod = (long) nums1[i] * (long) nums1[j];\\n                if (freq.containsKey(prod)) {\\n                    count += freq.get(prod);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3174636,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        let mut ans = 0;\\n        let (mut m1, mut m2) = (HashMap::new(), HashMap::new());\\n        for i in 0..nums1.len() {\\n            for j in i + 1..nums1.len() {\\n                let p = nums1[i] as i64 * nums1[j] as i64;\\n                *m1.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for i in 0..nums2.len() {\\n            for j in i + 1..nums2.len() {\\n                let p = nums2[i] as i64 * nums2[j] as i64;\\n                *m2.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for &num in nums1.iter() {\\n            if let Some(&v) = m2.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        for &num in nums2.iter() {\\n            if let Some(&v) = m1.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        use std::collections::HashMap;\\n        let mut ans = 0;\\n        let (mut m1, mut m2) = (HashMap::new(), HashMap::new());\\n        for i in 0..nums1.len() {\\n            for j in i + 1..nums1.len() {\\n                let p = nums1[i] as i64 * nums1[j] as i64;\\n                *m1.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for i in 0..nums2.len() {\\n            for j in i + 1..nums2.len() {\\n                let p = nums2[i] as i64 * nums2[j] as i64;\\n                *m2.entry(p).or_insert(0) += 1;\\n            }\\n        }\\n        for &num in nums1.iter() {\\n            if let Some(&v) = m2.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        for &num in nums2.iter() {\\n            if let Some(&v) = m1.get(&(num as i64 * num as i64)) {\\n                ans += v;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128576,
                "title": "python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition here is to find all the triplets that satisfy the given condition. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a two-pointer technique to solve this problem. We can iterate through each array, and for each element we can use two pointers to calculate the product of the other two elements. If the product is equal to the current element, we can add the triplet to our answer.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Note\\nNot the most effient solution\\n\\n# Code\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        freq1 = self.get_freq(nums1)\\n        freq2 = self.get_freq(nums2)\\n        ans = 0\\n        ans += self.count(freq1, nums2)\\n        ans += self.count(freq2, nums1)\\n        return ans\\n    \\n    def get_freq(self, nums):\\n        ans = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n):\\n            ans[nums[i] * nums[i]] += 1\\n        return ans\\n    \\n    def count(self, freq, other):\\n        ans = 0\\n        m = len(other)\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                prod = other[i] * other[j]\\n                if prod in freq:\\n                    ans += freq[prod]\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        freq1 = self.get_freq(nums1)\\n        freq2 = self.get_freq(nums2)\\n        ans = 0\\n        ans += self.count(freq1, nums2)\\n        ans += self.count(freq2, nums1)\\n        return ans\\n    \\n    def get_freq(self, nums):\\n        ans = collections.defaultdict(int)\\n        n = len(nums)\\n        for i in range(n):\\n            ans[nums[i] * nums[i]] += 1\\n        return ans\\n    \\n    def count(self, freq, other):\\n        ans = 0\\n        m = len(other)\\n        for i in range(m):\\n            for j in range(i+1, m):\\n                prod = other[i] * other[j]\\n                if prod in freq:\\n                    ans += freq[prod]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3047357,
                "title": "python-hash-map-and-straightforward-solution-explained",
                "content": "the problem data size is just 1000. Thus, we can solve this problem with O(n^2) time complexity.\\n\\nStep 1, build a hash map to track the num^2 value count for each array.\\n\\nStep 2, sweep each arrary, find two numbers from it and check if their product is in the hash map.\\n\\nsee details in code:\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1, nums2):\\n        # build hash table for both nums1 and nums2\\n        num1_sq_dict = collections.defaultdict(int)\\n        num2_sq_dict = collections.defaultdict(int)\\n\\n        for n in nums1:\\n            num1_sq_dict[n * n] += 1\\n        for n in nums2:\\n            num2_sq_dict[n * n] += 1\\n\\n        ans = 0\\n\\n        len_n1 = len(nums1)\\n        len_n2 = len(nums2)\\n        for i in range(len_n1 - 1):\\n            for j in range(i + 1, len_n1):\\n                prod = nums1[i] * nums1[j]\\n                if prod in num2_sq_dict:\\n                    ans += num2_sq_dict[prod]\\n        for i in range(len_n2 - 1):\\n            for j in range(i + 1, len_n2):\\n                prod = nums2[i] * nums2[j]\\n                if prod in num1_sq_dict:\\n                    ans += num1_sq_dict[prod]\\n\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1, nums2):\\n        # build hash table for both nums1 and nums2\\n        num1_sq_dict = collections.defaultdict(int)\\n        num2_sq_dict = collections.defaultdict(int)\\n\\n        for n in nums1:\\n            num1_sq_dict[n * n] += 1\\n        for n in nums2:\\n            num2_sq_dict[n * n] += 1\\n\\n        ans = 0\\n\\n        len_n1 = len(nums1)\\n        len_n2 = len(nums2)\\n        for i in range(len_n1 - 1):\\n            for j in range(i + 1, len_n1):\\n                prod = nums1[i] * nums1[j]\\n                if prod in num2_sq_dict:\\n                    ans += num2_sq_dict[prod]\\n        for i in range(len_n2 - 1):\\n            for j in range(i + 1, len_n2):\\n                prod = nums2[i] * nums2[j]\\n                if prod in num1_sq_dict:\\n                    ans += num1_sq_dict[prod]\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032341,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\nunordered_map<long, long> m1,m2;\\n\\nfor(auto a : nums1)\\nm1[(long)a*(long)a]++;\\n\\nfor(auto a: nums2)\\nm2[(long)a*(long)a]++;\\n\\nint ans=0;\\nfor(int i=0; i<nums1.size();i++){\\nfor(int j=i+1; j<nums1.size(); j++){\\n    ans+=m2[(long)nums1[i]*(long)nums1[j]];\\n}\\n}\\n    for(int i=0; i<nums2.size(); i++){\\nfor(int j=i+1; j<nums2.size(); j++){\\n\\n    ans+=m1[(long)nums2[i]*(long)nums2[j]];\\n}\\n   } \\n  return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\nunordered_map<long, long> m1,m2;\\n\\nfor(auto a : nums1)\\nm1[(long)a*(long)a]++;\\n\\nfor(auto a: nums2)\\nm2[(long)a*(long)a]++;\\n\\nint ans=0;\\nfor(int i=0; i<nums1.size();i++){\\nfor(int j=i+1; j<nums1.size(); j++){\\n    ans+=m2[(long)nums1[i]*(long)nums1[j]];\\n}\\n}\\n    for(int i=0; i<nums2.size(); i++){\\nfor(int j=i+1; j<nums2.size(); j++){\\n\\n    ans+=m1[(long)nums2[i]*(long)nums2[j]];\\n}\\n   } \\n  return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942063,
                "title": "cpp-long-long",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        ll ans = 0;\\n        // type : 1;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            ll val = (ll)nums1[i] * (ll)nums1[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums2.size();j++){\\n                if(val % nums2[j] != 0) continue;\\n                ll x = val / nums2[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        for(int i = 0 ; i < nums2.size(); i++){\\n            ll val = (ll)nums2[i] * (ll)nums2[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums1.size();j++){\\n                if(val % nums1[j] != 0) continue;\\n                ll x = (ll)val / (ll)nums1[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin() , nums1.end());\\n        sort(nums2.begin() , nums2.end());\\n        ll ans = 0;\\n        // type : 1;\\n        for(int i = 0 ; i < nums1.size(); i++){\\n            ll val = (ll)nums1[i] * (ll)nums1[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums2.size();j++){\\n                if(val % nums2[j] != 0) continue;\\n                ll x = val / nums2[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        for(int i = 0 ; i < nums2.size(); i++){\\n            ll val = (ll)nums2[i] * (ll)nums2[i];\\n            unordered_map<int,int>mp;\\n            for(int j = 0 ; j < nums1.size();j++){\\n                if(val % nums1[j] != 0) continue;\\n                ll x = (ll)val / (ll)nums1[j];\\n                if(mp.count(x)){\\n                    ans += mp[x];\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2941753,
                "title": "frequency-table-beat-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPrecalculate frequencies of two arrays.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n$$O(n*m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tif len(nums1) == 1 && len(nums2) == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\tcnt1, cnt2 := freqMap(nums1), freqMap(nums2)\\n\\n\\treturn calculate(nums1, nums2, cnt1, cnt2) + calculate(nums2, nums1, cnt2, cnt1)\\n}\\n\\nfunc freqMap(nums []int) *map[int]int {\\n\\tcounts := map[int]int{}\\n\\tfor i := range nums {\\n\\t\\tcounts[nums[i]] += 1\\n\\t}\\n\\treturn &counts\\n}\\n\\nfunc calculate(nums1, nums2 []int, cnt1, cnt2 *map[int]int) int {\\n\\tvar result int\\n\\tvar xSqr, acc int\\n\\tfor x1, c := range *cnt1 {\\n\\t\\tacc = 0\\n\\t\\txSqr = x1 * x1\\n\\t\\tfor _, x2 := range nums2 {\\n\\t\\t\\tif xSqr%x2 != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n        \\ty := xSqr / x2\\n     \\t\\tif val, ok := (*cnt2)[y]; ok {\\n\\t\\t\\t\\tacc += val\\n\\t\\t\\t\\tif y == x2 {\\n\\t\\t\\t\\t\\tacc -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult += c * acc / 2\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tif len(nums1) == 1 && len(nums2) == 1 {\\n\\t\\treturn 0\\n\\t}\\n\\tcnt1, cnt2 := freqMap(nums1), freqMap(nums2)\\n\\n\\treturn calculate(nums1, nums2, cnt1, cnt2) + calculate(nums2, nums1, cnt2, cnt1)\\n}\\n\\nfunc freqMap(nums []int) *map[int]int {\\n\\tcounts := map[int]int{}\\n\\tfor i := range nums {\\n\\t\\tcounts[nums[i]] += 1\\n\\t}\\n\\treturn &counts\\n}\\n\\nfunc calculate(nums1, nums2 []int, cnt1, cnt2 *map[int]int) int {\\n\\tvar result int\\n\\tvar xSqr, acc int\\n\\tfor x1, c := range *cnt1 {\\n\\t\\tacc = 0\\n\\t\\txSqr = x1 * x1\\n\\t\\tfor _, x2 := range nums2 {\\n\\t\\t\\tif xSqr%x2 != 0 {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t}\\n        \\ty := xSqr / x2\\n     \\t\\tif val, ok := (*cnt2)[y]; ok {\\n\\t\\t\\t\\tacc += val\\n\\t\\t\\t\\tif y == x2 {\\n\\t\\t\\t\\t\\tacc -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult += c * acc / 2\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2891645,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n       return fun(nums1,nums2)+fun(nums2,nums1);\\n    }\\n    int fun(vector<int>&v1,vector<int>&v2)\\n    {\\n        //a*a=x*y\\n        int ans=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            long long int num=(long long)v1[i]*v1[i];\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(num%v2[j]!=0)\\n                {\\n                    continue;\\n                }\\n                int t=num/v2[j];\\n                if(mp.find(t)!=mp.end())\\n                {\\n                    ans=ans+mp[t];\\n                }\\n                mp[v2[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n       return fun(nums1,nums2)+fun(nums2,nums1);\\n    }\\n    int fun(vector<int>&v1,vector<int>&v2)\\n    {\\n        //a*a=x*y\\n        int ans=0;\\n        for(int i=0;i<v1.size();i++)\\n        {\\n            long long int num=(long long)v1[i]*v1[i];\\n            unordered_map<int,int>mp;\\n            for(int j=0;j<v2.size();j++)\\n            {\\n                if(num%v2[j]!=0)\\n                {\\n                    continue;\\n                }\\n                int t=num/v2[j];\\n                if(mp.find(t)!=mp.end())\\n                {\\n                    ans=ans+mp[t];\\n                }\\n                mp[v2[j]]++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2890488,
                "title": "rust-solution",
                "content": "# Code\\n```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n      let nums1 = nums1.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let nums2 = nums2.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let mut m1 = HashMap::new();\\n      let mut m2 = HashMap::new();\\n      let n1 = nums1.len();\\n      let n2 = nums2.len();\\n\\n      for i in 0..n1 {\\n        for j in i+1..n1 {\\n          *m1.entry(nums1[i] * nums1[j]).or_insert(0) += 1;\\n        }\\n      }\\n      for i in 0..n2 {\\n        for j in i+1..n2 {\\n          *m2.entry(nums2[i] * nums2[j]).or_insert(0) += 1;\\n        }\\n      }\\n\\n      let mut result = 0;\\n      for v in nums1 {\\n        if let Some(num) = m2.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      for v in nums2 {\\n        if let Some(num) = m1.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      result as i32\\n  }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::*;\\n\\nimpl Solution {\\n  pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n      let nums1 = nums1.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let nums2 = nums2.into_iter().map(|v| v as usize).collect::<Vec<usize>>();\\n      let mut m1 = HashMap::new();\\n      let mut m2 = HashMap::new();\\n      let n1 = nums1.len();\\n      let n2 = nums2.len();\\n\\n      for i in 0..n1 {\\n        for j in i+1..n1 {\\n          *m1.entry(nums1[i] * nums1[j]).or_insert(0) += 1;\\n        }\\n      }\\n      for i in 0..n2 {\\n        for j in i+1..n2 {\\n          *m2.entry(nums2[i] * nums2[j]).or_insert(0) += 1;\\n        }\\n      }\\n\\n      let mut result = 0;\\n      for v in nums1 {\\n        if let Some(num) = m2.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      for v in nums2 {\\n        if let Some(num) = m1.get(&(v*v)) {\\n          result += num;\\n        }\\n      }\\n      result as i32\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880481,
                "title": "python-counter",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        d1 = Counter(nums1)\\n        d2 = Counter(nums2)\\n        def solve(nums1, d2):\\n            res = 0\\n            for num in nums1:\\n                num *= num\\n                for i in sorted(d2.keys()):\\n                    if not num % i:\\n                        if i < num//i:\\n                            res += d2[i]*d2[num//i]\\n                        elif i == num//i:\\n                            res += d2[i]*(d2[i]-1)//2\\n                            break\\n                        else:\\n                            break\\n            return res\\n        return solve(nums1, d2) + solve(nums2, d1)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums1.sort()\\n        nums2.sort()\\n        d1 = Counter(nums1)\\n        d2 = Counter(nums2)\\n        def solve(nums1, d2):\\n            res = 0\\n            for num in nums1:\\n                num *= num\\n                for i in sorted(d2.keys()):\\n                    if not num % i:\\n                        if i < num//i:\\n                            res += d2[i]*d2[num//i]\\n                        elif i == num//i:\\n                            res += d2[i]*(d2[i]-1)//2\\n                            break\\n                        else:\\n                            break\\n            return res\\n        return solve(nums1, d2) + solve(nums2, d1)",
                "codeTag": "Java"
            },
            {
                "id": 2862975,
                "title": "python-two-sum-algo-faster-than-90-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def twoProduct(self, num: int, nums: List[int]) -> int:\\n        hashMap, count = defaultdict(int), 0\\n        for elem in nums:\\n            if num % elem == 0:\\n                count += hashMap[num // elem]\\n            hashMap[elem] += 1\\n        return count\\n    \\n    def countForArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        res, lastRes, lastNum = 0, 0, 0\\n        nums1.sort()\\n        for idx in range(len(nums1)):\\n            if nums1[idx] == lastNum:\\n                res += lastRes\\n            else:\\n                lastRes = self.twoProduct(nums1[idx] * nums1[idx], nums2)\\n                res += lastRes\\n            lastNum = nums1[idx]\\n        return res\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        return self.countForArray(nums1, nums2) + self.countForArray(nums2, nums1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def twoProduct(self, num: int, nums: List[int]) -> int:\\n        hashMap, count = defaultdict(int), 0\\n        for elem in nums:\\n            if num % elem == 0:\\n                count += hashMap[num // elem]\\n            hashMap[elem] += 1\\n        return count\\n    \\n    def countForArray(self, nums1: List[int], nums2: List[int]) -> int:\\n        res, lastRes, lastNum = 0, 0, 0\\n        nums1.sort()\\n        for idx in range(len(nums1)):\\n            if nums1[idx] == lastNum:\\n                res += lastRes\\n            else:\\n                lastRes = self.twoProduct(nums1[idx] * nums1[idx], nums2)\\n                res += lastRes\\n            lastNum = nums1[idx]\\n        return res\\n    \\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        return self.countForArray(nums1, nums2) + self.countForArray(nums2, nums1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802271,
                "title": "c-two-sum-counting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need two values whose product can be equal to num*num for any num.\\nThink of solving using two sum approach. \\nStore the counts and solve.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTake two maps. Store the count of each element for both arrays in diff maps.\\nNow for any number in map1 we iterate all elements of map2 if map1*map1 can be formed by products of two numbers of map2 which means for the element in map2 map1%map2 == 0 and map2 should also contain map1/map2.\\nNow there will be two cases when `m1*m1 = m2*m2` and `m1*m1 = m2*m3`\\nFor the first case we just take 2 elements out of cnt[m2] using nC2.\\nFor the second case we will have repeated answers as we take `cnt[m2]*cnt[m3]` and then when we reach m3 then we have `cnt[m3]*cnt[m2]` so we store both case in separate variables.\\nDo the same for map2.\\nFinal answer will be case1 + case2/2\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Two maps for nums1 and nums2\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<ll,int> m1, m2;\\n        for(auto i:nums1) m1[i]++;\\n        for(auto i:nums2) m2[i]++;\\n        int ans1 = 0,ans2 = 0;\\n        for(auto i:m1){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m2){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m2.find(x1/x2) != m2.end()) ans2 += y1*y2*m2[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        for(auto i:m2){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m1){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m1.find(x1/x2) != m1.end()) ans2 += y1*y2*m1[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        return ans1 + ans2/2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Counting"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<ll,int> m1, m2;\\n        for(auto i:nums1) m1[i]++;\\n        for(auto i:nums2) m2[i]++;\\n        int ans1 = 0,ans2 = 0;\\n        for(auto i:m1){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m2){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m2.find(x1/x2) != m2.end()) ans2 += y1*y2*m2[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        for(auto i:m2){\\n            ll x1 = i.first*i.first;\\n            int y1 = i.second;\\n            for(auto j:m1){\\n                int x2 = j.first, y2 = j.second;\\n                if(x1%x2 == 0){\\n                    if(x1/x2 == x2) ans1 += y1*(y2*(y2-1))/2;\\n                    else if(m1.find(x1/x2) != m1.end()) ans2 += y1*y2*m1[x1/x2];\\n                }\\n            }\\n            // cout<<i.first<<\" -> \"<<ans1<<\" \";\\n        }\\n        return ans1 + ans2/2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2782416,
                "title": "easy-solution-c-beginner-friendly-best-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst thought was like to write three loops . like one to pick the element from first array( int z = arr[i]) then check if the square (z^2) is present in arr2 ( arr[j] * [k]) and so on\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ni am using a map to store the square and then their frquencies . \\nThen iterating over the second array and check if the multiple of 2 ( in arr2 arr2[j]* arr2[k]) is present in the map or not !\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n\\nclass Solution {\\n\\n    private:\\n\\n    int solve( vector<int>& arr1, vector<int>& arr2 ){\\n\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n\\n        int total = 0;\\n\\n        map<long long , long long > mp;\\n\\n        for(int i = 0 ; i < n1 ; i++){\\n            long long ans = (long long)arr1[i]*arr1[i];\\n            mp[ans]++;\\n        }\\n\\n        for(int i = 0 ; i < n2 ; i++){\\n            for(int j = i+1 ; j < n2 ; j++){\\n                long long ans = (long long)arr2[i]*arr2[j];\\n                total+=mp[ans];\\n            }\\n        }\\n\\n        return total;\\n\\n    }\\n    \\npublic:\\n    int numTriplets(vector<int>& arr1, vector<int>& arr2) {\\n        int total = 0;\\n        total+=solve( arr1 , arr2);\\n        total+=solve( arr2 , arr1);\\n        return total;\\n        \\n\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Ordered Map"
                ],
                "code": "class Solution {\\n\\n    private:\\n\\n    int solve( vector<int>& arr1, vector<int>& arr2 ){\\n\\n        int n1 = arr1.size();\\n        int n2 = arr2.size();\\n\\n        int total = 0;\\n\\n        map<long long , long long > mp;\\n\\n        for(int i = 0 ; i < n1 ; i++){\\n            long long ans = (long long)arr1[i]*arr1[i];\\n            mp[ans]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2723277,
                "title": "python-100-faster-o-n-2-check-by-dictionary",
                "content": "![image](https://assets.leetcode.com/users/images/744c1db8-729c-4a4f-b0ef-7c41fcea3d07_1666206032.2742183.png)\\n\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        dict1, dict2 = {}, {}\\n        \\n        for n in nums1:            \\n            dict1[n] = dict1[n] + 1 if n in dict1 else 1\\n            \\n        for n in nums2:\\n            dict2[n] = dict2[n] + 1 if n in dict2 else 1\\n               \\n        result = 0\\n        \\n        for k in dict1.keys():\\n            k2 = k * k\\n            for m in dict2.keys():\\n                if(k2 % m == 0):\\n                    tmp = k2 / m\\n                    if(tmp in dict2.keys()):\\n                        result += dict1[k] * dict2[m] * dict2[tmp]  if tmp != m else dict2[m] * (dict2[m] - 1) * dict1[k] \\n                        \\n        for k in dict2.keys():\\n            k2 = k * k\\n            for m in dict1.keys():\\n                if(k2 % m == 0):\\n                    tmp = k2 / m\\n                    if(tmp in dict1.keys()):\\n                        result += dict2[k] * dict1[m] * dict1[tmp] if (tmp != m) else dict1[m] * (dict1[m] - 1) * dict2[k]  \\n\\n        return result >> 1",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\n        dict1, dict2 = {}",
                "codeTag": "Java"
            },
            {
                "id": 2693874,
                "title": "c",
                "content": "Runtime: 181 ms, faster than 100.00% of C online submissions for Number of Ways Where Square of Number Is Equal to Product of Two Numbers.\\nMemory Usage: 34.5 MB, less than 100.00% of C online submissions for Number of Ways Where Square of Number Is Equal to Product of Two Numbers.\\n```\\nint process(int* nums1, int n1, int* nums2, int n2){\\n    int** hash1 = malloc(n1 * sizeof(int*));\\n\\n    for(int i = 0; i < n1; i++){\\n        hash1[i] = calloc(2 , sizeof(int));\\n    }\\n\\n    int** hash2 = malloc(n2 * sizeof(int*));\\n        \\n    int ans = 0;\\n    for(int i = 0; i < n1; i++){\\n        int a = nums1[i];\\n        int cn = 0;\\n        while(hash1[a % n1][0] != 0){\\n            if(hash1[a % n1][0] == nums1[i]){\\n                cn = hash1[a % n1][1];\\n                goto next;\\n            }\\n            a++;\\n        } \\n        \\n        for(int j = 0; j < n2; j++){\\n            hash2[j] = calloc(2 , sizeof(int));\\n        }\\n        long long k = (long long)nums1[i] * nums1[i];\\n        for(int j = 0; j < n2; j++){\\n            if(k % nums2[j] == 0){\\n                int remain= k/nums2[j];\\n                int b = k/nums2[j];\\n                //find remain in hash2 table\\n                while( hash2[b % n2][0] != 0){\\n                    if(hash2[b % n2][0] == remain){\\n                        cn += hash2[b % n2][1] ;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n                //inset nums2[j] into hash2 table\\n                b = nums2[j];\\n                while(1){\\n                    if(hash2[b % n2][1] == 0){\\n                        hash2[b % n2][0] = nums2[j];\\n                        hash2[b % n2][1] = 1 ;\\n                        break;\\n                    }                    \\n                    if(hash2[b % n2][0] == nums2[j]){\\n                        hash2[b % n2][1]++;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n            }\\n        }\\n\\n        //insert nums1 into hash1 table\\n        hash1[a % n1][0] = nums1[i];\\n        hash1[a % n1][1] = cn;\\n        \\n        next:\\n        ans += cn;\\n\\n    }\\n    \\n    return ans;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n\\n    return process(nums1, nums1Size, nums2,nums2Size) + process(nums2, nums2Size, nums1, nums1Size); \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint process(int* nums1, int n1, int* nums2, int n2){\\n    int** hash1 = malloc(n1 * sizeof(int*));\\n\\n    for(int i = 0; i < n1; i++){\\n        hash1[i] = calloc(2 , sizeof(int));\\n    }\\n\\n    int** hash2 = malloc(n2 * sizeof(int*));\\n        \\n    int ans = 0;\\n    for(int i = 0; i < n1; i++){\\n        int a = nums1[i];\\n        int cn = 0;\\n        while(hash1[a % n1][0] != 0){\\n            if(hash1[a % n1][0] == nums1[i]){\\n                cn = hash1[a % n1][1];\\n                goto next;\\n            }\\n            a++;\\n        } \\n        \\n        for(int j = 0; j < n2; j++){\\n            hash2[j] = calloc(2 , sizeof(int));\\n        }\\n        long long k = (long long)nums1[i] * nums1[i];\\n        for(int j = 0; j < n2; j++){\\n            if(k % nums2[j] == 0){\\n                int remain= k/nums2[j];\\n                int b = k/nums2[j];\\n                //find remain in hash2 table\\n                while( hash2[b % n2][0] != 0){\\n                    if(hash2[b % n2][0] == remain){\\n                        cn += hash2[b % n2][1] ;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n                //inset nums2[j] into hash2 table\\n                b = nums2[j];\\n                while(1){\\n                    if(hash2[b % n2][1] == 0){\\n                        hash2[b % n2][0] = nums2[j];\\n                        hash2[b % n2][1] = 1 ;\\n                        break;\\n                    }                    \\n                    if(hash2[b % n2][0] == nums2[j]){\\n                        hash2[b % n2][1]++;\\n                        break;\\n                    }\\n                    b++;\\n                }\\n            }\\n        }\\n\\n        //insert nums1 into hash1 table\\n        hash1[a % n1][0] = nums1[i];\\n        hash1[a % n1][1] = cn;\\n        \\n        next:\\n        ans += cn;\\n\\n    }\\n    \\n    return ans;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n\\n\\n    return process(nums1, nums1Size, nums2,nums2Size) + process(nums2, nums2Size, nums1, nums1Size); \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575647,
                "title": "form-hashmaps-of-squares",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        nums1ctr = Counter([el * el for el in nums1])\\n        nums2ctr = Counter([el * el for el in nums2])\\n        res = 0\\n        for i in range(m):\\n            for j in range(i + 1, m):\\n                res += nums2ctr[nums1[i] * nums1[j]]\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                res += nums1ctr[nums2[i] * nums2[j]]\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        m = len(nums1)\\n        n = len(nums2)\\n        nums1ctr = Counter([el * el for el in nums1])\\n        nums2ctr = Counter([el * el for el in nums2])\\n        res = 0\\n        for i in range(m):\\n            for j in range(i + 1, m):\\n                res += nums2ctr[nums1[i] * nums1[j]]\\n        for i in range(n):\\n            for j in range(i + 1, n):\\n                res += nums1ctr[nums2[i] * nums2[j]]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2491708,
                "title": "javascript-solution-passed-all-tests-very-simple",
                "content": "I just found this Github repository with solutions to Leetcode problems https://github.com/AnasImloul/Leetcode-solutions\\nIt is very useful, check it out.\\n```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2468458,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        unordered_map<long,int> l1,l2;\\n        \\n        for(auto n:nums1) l1[(long)n*(long)n]++;\\n        for(auto n:nums2) l2[(long)n*(long)n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            for(int j=i+1; j<nums1.size(); j++)\\n            {\\n                ans += l2[(long)nums1[i]*(long)nums1[j]];\\n            }\\n        }\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            for(int j=i+1; j<nums2.size(); j++)\\n            {\\n                ans += l1[((long)nums2[i]*(long)nums2[j])];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        unordered_map<long,int> l1,l2;\\n        \\n        for(auto n:nums1) l1[(long)n*(long)n]++;\\n        for(auto n:nums2) l2[(long)n*(long)n]++;\\n        \\n        for(int i=0; i<nums1.size(); i++)\\n        {\\n            for(int j=i+1; j<nums1.size(); j++)\\n            {\\n                ans += l2[(long)nums1[i]*(long)nums1[j]];\\n            }\\n        }\\n        for(int i=0; i<nums2.size(); i++)\\n        {\\n            for(int j=i+1; j<nums2.size(); j++)\\n            {\\n                ans += l1[((long)nums2[i]*(long)nums2[j])];\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337336,
                "title": "javascript-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n    // construct two empty dictionaries to store all the multiplication numbers\\n    const nums1Dict = {};\\n    const nums2Dict = {};\\n    \\n    // Go over the first set and multiply each number by the other numbers\\n    for(let i=0;i<nums1.length;i++){\\n        for(let j=i+1; j<nums1.length; j++){\\n            const res = nums1[i] * nums1[j];\\n            if(!nums1Dict[res]) nums1Dict[res] = 1;\\n            else nums1Dict[res] += 1;\\n        }\\n    }\\n    \\n    // Go over the second set and multiply each number by the other numbers\\n    for(let i=0;i<nums2.length;i++){\\n        for(let j=i+1; j<nums2.length; j++){\\n            const res = nums2[i] * nums2[j];\\n            if(!nums2Dict[res]) nums2Dict[res] = 1;\\n            else nums2Dict[res] += 1;\\n        }\\n    }\\n    \\n    let total = 0;\\n    \\n    // Go over the first set again and check if the item sq in nums2 multiplication dictionary\\n    nums1.forEach((item)=>{\\n        nums2Dict[item * item] ? total += nums2Dict[item * item]  : total;\\n    });\\n    \\n    // Go over the second set again and check if the item sq in nums1 multiplication dictionary    \\n    nums2.forEach((item)=>{\\n        nums1Dict[item * item] ? total += nums1Dict[item * item]  : total;\\n    });\\n    \\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(nums1, nums2) {\\n    // construct two empty dictionaries to store all the multiplication numbers\\n    const nums1Dict = {};\\n    const nums2Dict = {};\\n    \\n    // Go over the first set and multiply each number by the other numbers\\n    for(let i=0;i<nums1.length;i++){\\n        for(let j=i+1; j<nums1.length; j++){\\n            const res = nums1[i] * nums1[j];\\n            if(!nums1Dict[res]) nums1Dict[res] = 1;\\n            else nums1Dict[res] += 1;\\n        }\\n    }\\n    \\n    // Go over the second set and multiply each number by the other numbers\\n    for(let i=0;i<nums2.length;i++){\\n        for(let j=i+1; j<nums2.length; j++){\\n            const res = nums2[i] * nums2[j];\\n            if(!nums2Dict[res]) nums2Dict[res] = 1;\\n            else nums2Dict[res] += 1;\\n        }\\n    }\\n    \\n    let total = 0;\\n    \\n    // Go over the first set again and check if the item sq in nums2 multiplication dictionary\\n    nums1.forEach((item)=>{\\n        nums2Dict[item * item] ? total += nums2Dict[item * item]  : total;\\n    });\\n    \\n    // Go over the second set again and check if the item sq in nums1 multiplication dictionary    \\n    nums2.forEach((item)=>{\\n        nums1Dict[item * item] ? total += nums1Dict[item * item]  : total;\\n    });\\n    \\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330645,
                "title": "intuitive-just-counting",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, int> cnt1;\\n        unordered_map<long long, int> cnt2;\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = i + 1; j < nums1.size(); ++j) {\\n                cnt1[1LL * nums1[i] * nums1[j]]++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums2.size(); ++i) {\\n            for (int j = i + 1; j < nums2.size(); ++j) {\\n                cnt2[1LL * nums2[i] * nums2[j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto n : nums1) {\\n            res += cnt2[1LL * n * n];\\n        }\\n        \\n        for (auto n : nums2) {\\n            res += cnt1[1LL * n * n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long, int> cnt1;\\n        unordered_map<long long, int> cnt2;\\n        \\n        for (int i = 0; i < nums1.size(); ++i) {\\n            for (int j = i + 1; j < nums1.size(); ++j) {\\n                cnt1[1LL * nums1[i] * nums1[j]]++;\\n            }\\n        }\\n        \\n        for (int i = 0; i < nums2.size(); ++i) {\\n            for (int j = i + 1; j < nums2.size(); ++j) {\\n                cnt2[1LL * nums2[i] * nums2[j]]++;\\n            }\\n        }\\n        \\n        int res = 0;\\n        for (auto n : nums1) {\\n            res += cnt2[1LL * n * n];\\n        }\\n        \\n        for (auto n : nums2) {\\n            res += cnt1[1LL * n * n];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2325781,
                "title": "simple-python-solution-using-dictionary",
                "content": "The idea is to:\\n1. Create a helper function that takes 2 sets of numbers.\\n2. Within this helper funtion: Go through the first set of numbers and store the squares of each number along with the count of \\'how many times you see the same square\\'. \\n**Note:** This count is important for cases like [1,1] &[1,1,1], where different indexes give you the same sqrs. If you don\\'t keep a count of repeated sqrs, you would get 4 instead of 9 for this example. We are required to find the different combinations of indexes, not the different pairs of products and matching sqrs.\\n2. Go through the second set of numbers and see if the products of two numbers (at diff indexes) have a product that\\'s already in the dictionary keys we created above.\\n3. If there\\'s a key that matches, we have the corresponding number (value) of combinations for that product. Add that to the output.\\n4. Feed the helper function both the lists interchangably. Return the sum of their return values.\\n\\n\\n```\\n\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        def cases(n1, n2):\\n            op = 0\\n            sqs = defaultdict(int)\\n            for i in range(len(n1)):\\n                sqs[n1[i] * n1[i]] += 1\\n            for j in range(len(n2) - 1):\\n                for k in range(j + 1, len(n2)):\\n                    if n2[j] * n2[k] in sqs.keys():\\n                        op += sqs[n2[j] * n2[k]]\\n            return op\\n        \\n        return cases(nums1, nums2) + cases(nums2, nums1)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "The idea is to:\\n1. Create a helper function that takes 2 sets of numbers.\\n2. Within this helper funtion: Go through the first set of numbers and store the squares of each number along with the count of \\'how many times you see the same square\\'. \\n**Note:** This count is important for cases like [1,1] &[1,1,1], where different indexes give you the same sqrs. If you don\\'t keep a count of repeated sqrs, you would get 4 instead of 9 for this example. We are required to find the different combinations of indexes, not the different pairs of products and matching sqrs.\\n2. Go through the second set of numbers and see if the products of two numbers (at diff indexes) have a product that\\'s already in the dictionary keys we created above.\\n3. If there\\'s a key that matches, we have the corresponding number (value) of combinations for that product. Add that to the output.\\n4. Feed the helper function both the lists interchangably. Return the sum of their return values.\\n\\n\\n```\\n\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n        def cases(n1, n2):\\n            op = 0\\n            sqs = defaultdict(int)\\n            for i in range(len(n1)):\\n                sqs[n1[i] * n1[i]] += 1\\n            for j in range(len(n2) - 1):\\n                for k in range(j + 1, len(n2)):\\n                    if n2[j] * n2[k] in sqs.keys():\\n                        op += sqs[n2[j] * n2[k]]\\n            return op\\n        \\n        return cases(nums1, nums2) + cases(nums2, nums1)",
                "codeTag": "Python3"
            },
            {
                "id": 2254504,
                "title": "c-store-count-of-products",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int solve(vector<int>&nums1 , vector<int>&nums2 ){\\n        unordered_map<ll,ll> mpp ;\\n        \\n        for(int i = 0 ; i < nums2.size() ; ++i)\\n            for(int j = i + 1 ; j < nums2.size() ; ++j)\\n                ++mpp[nums2[i] * 1LL *  nums2[j] * 1LL] ; \\n        int ans = 0 ;\\n        for(int i = 0 ; i < nums1.size() ; ++i ) ans += mpp[nums1[i] * 1LL  * nums1[i] * 1LL] ;\\n        return ans ;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solve(nums1,nums2) + solve(nums2,nums1) ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long \\n    int solve(vector<int>&nums1 , vector<int>&nums2 ){\\n        unordered_map<ll,ll> mpp ;\\n        \\n        for(int i = 0 ; i < nums2.size() ; ++i)\\n            for(int j = i + 1 ; j < nums2.size() ; ++j)\\n                ++mpp[nums2[i] * 1LL *  nums2[j] * 1LL] ; \\n        int ans = 0 ;\\n        for(int i = 0 ; i < nums1.size() ; ++i ) ans += mpp[nums1[i] * 1LL  * nums1[i] * 1LL] ;\\n        return ans ;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solve(nums1,nums2) + solve(nums2,nums1) ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248334,
                "title": "js",
                "content": "```\\nvar numTriplets = function (nums1, nums2) {\\n\\tconst squares = [],\\n\\t\\taddSquares = arr => {\\n\\t\\t\\tconst sqFreq = {};\\n\\t\\t\\tlet sq;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tsq = arr[i] ** 2;\\n\\t\\t\\t\\tsqFreq[sq] ? sqFreq[sq]++ : (sqFreq[sq] = 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn sqFreq;\\n\\t\\t},\\n\\t\\tgetMultiplications = type => {\\n\\t\\t\\tconst arr = type ? nums1 : nums2,\\n\\t\\t\\t\\tsqFreq = squares[type];\\n\\t\\t\\tlet count = 0,\\n\\t\\t\\t\\tm;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\t\\t\\tm = arr[i] * arr[j];\\n\\t\\t\\t\\t\\tsqFreq[m] && (count += sqFreq[m]);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t};\\n\\tsquares.push(addSquares(nums1), addSquares(nums2));\\n\\treturn getMultiplications(0) + getMultiplications(1);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function (nums1, nums2) {\\n\\tconst squares = [],\\n\\t\\taddSquares = arr => {\\n\\t\\t\\tconst sqFreq = {};\\n\\t\\t\\tlet sq;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\t\\t\\tsq = arr[i] ** 2;\\n\\t\\t\\t\\tsqFreq[sq] ? sqFreq[sq]++ : (sqFreq[sq] = 1);\\n\\t\\t\\t}\\n\\t\\t\\treturn sqFreq;\\n\\t\\t},\\n\\t\\tgetMultiplications = type => {\\n\\t\\t\\tconst arr = type ? nums1 : nums2,\\n\\t\\t\\t\\tsqFreq = squares[type];\\n\\t\\t\\tlet count = 0,\\n\\t\\t\\t\\tm;\\n\\t\\t\\tfor (let i = 0; i < arr.length; i++)\\n\\t\\t\\t\\tfor (let j = i + 1; j < arr.length; j++) {\\n\\t\\t\\t\\t\\tm = arr[i] * arr[j];\\n\\t\\t\\t\\t\\tsqFreq[m] && (count += sqFreq[m]);\\n\\t\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t};\\n\\tsquares.push(addSquares(nums1), addSquares(nums2));\\n\\treturn getMultiplications(0) + getMultiplications(1);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233322,
                "title": "easy-js-solution",
                "content": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar numTriplets = function(nums1, nums2) {\\n    const nm1 = new Map(), nm2 = new Map();\\n    const n = nums1.length, m = nums2.length;\\n    for(let i = 0; i < n; i++) {\\n        for(let j = i + 1; j < n; j++) {\\n            const product = nums1[i] * nums1[j];\\n            if(!nm1.has(product)) nm1.set(product, 0);\\n            const arr = nm1.get(product);\\n            nm1.set(product, arr + 1);\\n        }\\n    }\\n    for(let i = 0; i < m; i++) {\\n        for(let j = i + 1; j < m; j++) {\\n            const product = nums2[i] * nums2[j];\\n            if(!nm2.has(product)) nm2.set(product, 0);\\n            const arr = nm2.get(product);\\n            nm2.set(product, arr + 1);\\n        }\\n    }\\n    let ans = 0;\\n    \\n    for(let num of nums1) {\\n        const sq = num * num;\\n        if(nm2.has(sq)) {\\n            ans += nm2.get(sq);\\n        }\\n    }\\n    for(let num of nums2) {\\n        const sq = num * num;\\n        if(nm1.has(sq)) {\\n            ans += nm1.get(sq);\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2219792,
                "title": "python-3-using-dictionaries-and-calculating-the-freq",
                "content": "```\\n\\n```class Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n    count = 0\\n    precalnums1sq = []\\n    precalnums2sq = []\\n    precaltype1 = {}\\n    precaltype2 = {}\\n    # precalulate the freqs of type 1\\n    for i in range(len(nums1)):\\n        precalnums1sq.append(nums1[i] ** 2)\\n\\n    # these series of for loops will find the type1\\n    for j in range(len(nums2)):\\n        for k in range(j + 1, len(nums2)):\\n            key = nums2[j] * nums2[k]\\n            if key in precaltype1:\\n                precaltype1[key] = precaltype1.get(key) + 1\\n            else:\\n                precaltype1[key] = 1\\n\\n        # precalculate the freq of type2\\n\\n    for i in range(len(nums2)):\\n        precalnums2sq.append(nums2[i] ** 2)\\n\\n        # these series of for loops will find the type2\\n    for j in range(len(nums1)):\\n        for k in range(j + 1, len(nums1)):\\n            key = nums1[j] * nums1[k]\\n            if key in precaltype2:\\n                precaltype2[key] = precaltype2.get(key) + 1\\n            else:\\n                precaltype2[key] = 1\\n\\n    for source in precalnums1sq:\\n        if source in precaltype1:\\n            count += precaltype1[source]\\n\\n    for source in precalnums2sq:\\n        if source in precaltype2:\\n            count += precaltype2[source]\\n    return count``\\n",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2207357,
                "title": "c-easy-to-understand-unordered-map-solution",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        unordered_map <ll, int> n1_sq, n2_sq, n1_pro, n2_pro;\\n\\n        //building n1_sq\\n        for(int i=0; i<nums1.size(); i++)\\n            n1_sq[((ll)nums1[i]) *((ll)nums1[i])] ++;\\n\\n        //building n2_sq\\n        for(int i=0; i<nums2.size(); i++)\\n            n2_sq[((ll)nums2[i]) *((ll)nums2[i])] ++;\\n\\n        //bulding n1_pro\\n        for(int j=0; j<nums1.size(); j++)\\n            for(int k=j+1; k<nums1.size(); k++) {\\n                n1_pro[((ll)nums1[j])*((ll)nums1[k])]++;\\n            }\\n\\n        //bulding n2_pro\\n        for(int j=0; j<nums2.size(); j++)\\n            for(int k=j+1; k<nums2.size(); k++) {\\n                n2_pro[((ll)nums2[j])*((ll)nums2[k])]++;\\n            }\\n        \\n        for(auto x : n2_pro)\\n            if(n1_sq[x.first])\\n                ans+=(x.second*n1_sq[x.first]);\\n\\n        for(auto x : n1_pro)\\n            if(n2_sq[x.first])\\n                ans+=(x.second*n2_sq[x.first]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        unordered_map <ll, int> n1_sq, n2_sq, n1_pro, n2_pro;\\n\\n        //building n1_sq\\n        for(int i=0; i<nums1.size(); i++)\\n            n1_sq[((ll)nums1[i]) *((ll)nums1[i])] ++;\\n\\n        //building n2_sq\\n        for(int i=0; i<nums2.size(); i++)\\n            n2_sq[((ll)nums2[i]) *((ll)nums2[i])] ++;\\n\\n        //bulding n1_pro\\n        for(int j=0; j<nums1.size(); j++)\\n            for(int k=j+1; k<nums1.size(); k++) {\\n                n1_pro[((ll)nums1[j])*((ll)nums1[k])]++;\\n            }\\n\\n        //bulding n2_pro\\n        for(int j=0; j<nums2.size(); j++)\\n            for(int k=j+1; k<nums2.size(); k++) {\\n                n2_pro[((ll)nums2[j])*((ll)nums2[k])]++;\\n            }\\n        \\n        for(auto x : n2_pro)\\n            if(n1_sq[x.first])\\n                ans+=(x.second*n1_sq[x.first]);\\n\\n        for(auto x : n1_pro)\\n            if(n2_sq[x.first])\\n                ans+=(x.second*n2_sq[x.first]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194431,
                "title": "two-sum-appraoch-map-c",
                "content": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long,int> m1,m2;  //m1 used for tyoe 1 and m2 used for type 2\\n        int ans=0;\\n        \\n        //Filling m1 for checking type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                long l=nums2[i];\\n                m1[l*nums2[j]]++;\\n            }\\n        }\\n        \\n        //Filling m2 for checking type 2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=i+1;j<nums1.size();j++)\\n            {\\n                long l=nums1[i];\\n                m2[l*nums1[j]]++;\\n            }\\n        }\\n        \\n        //Checking no of answers for type 1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long l=nums1[i];\\n            l*=nums1[i];\\n            \\n            ans+=m1[l];\\n        }\\n        \\n         //Checking no of answers for type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long l=nums2[i];\\n            l*=nums2[i];\\n            \\n            ans+=m2[l];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long,int> m1,m2;  //m1 used for tyoe 1 and m2 used for type 2\\n        int ans=0;\\n        \\n        //Filling m1 for checking type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            for(int j=i+1;j<nums2.size();j++)\\n            {\\n                long l=nums2[i];\\n                m1[l*nums2[j]]++;\\n            }\\n        }\\n        \\n        //Filling m2 for checking type 2\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            for(int j=i+1;j<nums1.size();j++)\\n            {\\n                long l=nums1[i];\\n                m2[l*nums1[j]]++;\\n            }\\n        }\\n        \\n        //Checking no of answers for type 1\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long l=nums1[i];\\n            l*=nums1[i];\\n            \\n            ans+=m1[l];\\n        }\\n        \\n         //Checking no of answers for type 1\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long l=nums2[i];\\n            l*=nums2[i];\\n            \\n            ans+=m2[l];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2137513,
                "title": "c-easy-understanding-hashmap",
                "content": "```\\nusing ll=long long int ;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        map<ll,ll> mp;\\n      \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ll ele=(ll)nums1[i]*(ll)nums1[i];\\n            mp.clear();\\n            for(int j=0;j<m;j++){\\n                if((ele%nums2[j])==0){\\n                   if(mp.count(ele/nums2[j])){\\n                       ct+=mp[ele/nums2[j]];\\n                   }\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        mp.clear();\\n       \\n        for(int i=0;i<m;i++){\\n            ll ele=(ll)nums2[i]*(ll)nums2[i];\\n            mp.clear();\\n            for(int j=0;j<n;j++){\\n                if((ele%nums1[j])==0){\\n                    if(mp.count(ele/nums1[j])){\\n                        ct+=mp[ele/nums1[j]];\\n                    }\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long int ;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int n=nums1.size();\\n        int m=nums2.size();\\n        map<ll,ll> mp;\\n      \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            ll ele=(ll)nums1[i]*(ll)nums1[i];\\n            mp.clear();\\n            for(int j=0;j<m;j++){\\n                if((ele%nums2[j])==0){\\n                   if(mp.count(ele/nums2[j])){\\n                       ct+=mp[ele/nums2[j]];\\n                   }\\n                }\\n                mp[nums2[j]]++;\\n            }\\n        }\\n        mp.clear();\\n       \\n        for(int i=0;i<m;i++){\\n            ll ele=(ll)nums2[i]*(ll)nums2[i];\\n            mp.clear();\\n            for(int j=0;j<n;j++){\\n                if((ele%nums1[j])==0){\\n                    if(mp.count(ele/nums1[j])){\\n                        ct+=mp[ele/nums1[j]];\\n                    }\\n                }\\n                mp[nums1[j]]++;\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135421,
                "title": "need-help",
                "content": "```\\ngiving wrong answer for below test case i am unable to figure out where its going wrong ,did dry run thrice \\n\\n[13,4,70,76,11,94,63,86,91,96,2,53,65,14,75,75,13,23,76,96,91,32,55,36,52,32,97,11,48,91,98,36,28,87,24,22,72,89,5,55,35,3,336]\\n[6,96,88,98,78,76,41,81,100,26,89,8,42,28,85,47,74,79,43,69,99,98,86,51,49,60,12,26,21,29,78,84,27,12,31,86,76,69,31,5,40,59]\\n\\nOutput:\\n29\\nExpected:\\n30\\n```\\n```\\nint solution(vector<int>& nums1, vector<int>& nums2){\\n        int count = 0;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            for(int j = 0; j<nums2.size()-1; ++j){\\n                for(int k = j+1; k<nums2.size(); ++k){\\n                    if(nums1[i] == ((double)nums2[j]/nums1[i])*nums2[k]){\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solution(nums1, nums2) + solution(nums2, nums1);\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ngiving wrong answer for below test case i am unable to figure out where its going wrong ,did dry run thrice \\n\\n[13,4,70,76,11,94,63,86,91,96,2,53,65,14,75,75,13,23,76,96,91,32,55,36,52,32,97,11,48,91,98,36,28,87,24,22,72,89,5,55,35,3,336]\\n[6,96,88,98,78,76,41,81,100,26,89,8,42,28,85,47,74,79,43,69,99,98,86,51,49,60,12,26,21,29,78,84,27,12,31,86,76,69,31,5,40,59]\\n\\nOutput:\\n29\\nExpected:\\n30\\n```\n```\\nint solution(vector<int>& nums1, vector<int>& nums2){\\n        int count = 0;\\n        for(int i = 0; i<nums1.size(); ++i){\\n            for(int j = 0; j<nums2.size()-1; ++j){\\n                for(int k = j+1; k<nums2.size(); ++k){\\n                    if(nums1[i] == ((double)nums2[j]/nums1[i])*nums2[k]){\\n                        ++count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return solution(nums1, nums2) + solution(nums2, nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2124011,
                "title": "python2-solution-which-beats-100",
                "content": "Use dictionary, and check keys in ascending order.\\n\\n```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\t\\n\\t\\td1, d2 = Counter(nums1), Counter(nums2)\\n        \\n        ret = 0\\n        key1 = sorted(d1.keys())\\n        key2 = sorted(d2.keys())\\n\\t\\t\\n\\t\\t# Type 1\\n        for k1 in key1:\\n            kk = k1 * k1\\n            for k2 in key2:\\n                if k2 > k1: break\\n                if k2 == k1:\\n                    if d2[k2] < 2: break\\n                    ret += d1[k1] * d2[k2] * (d2[k2] - 1)/2\\n                elif kk % k2 == 0 and d2[kk/k2] > 0:\\n                    ret += d1[k1] * d2[k2] * d2[kk/k2]\\n                    \\n\\t\\t# Type 2\\n        for k2 in key2:\\n            kk = k2 * k2\\n            for k1 in key1:\\n                if k1 > k2: break\\n                if k1 == k2:\\n                    if d1[k1] < 2: break\\n                    ret += d2[k2] * d1[k1] * (d1[k1] - 1)/2\\n                elif kk % k1 == 0 and d1[kk/k1] > 0:\\n                    ret += d2[k2] * d1[k1] * d1[kk/k1]\\n                    \\n        return ret\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def numTriplets(self, nums1, nums2):\\n\\t\\n\\t\\td1, d2 = Counter(nums1), Counter(nums2)\\n        \\n        ret = 0\\n        key1 = sorted(d1.keys())\\n        key2 = sorted(d2.keys())\\n\\t\\t\\n\\t\\t# Type 1\\n        for k1 in key1:\\n            kk = k1 * k1\\n            for k2 in key2:\\n                if k2 > k1: break\\n                if k2 == k1:\\n                    if d2[k2] < 2: break\\n                    ret += d1[k1] * d2[k2] * (d2[k2] - 1)/2\\n                elif kk % k2 == 0 and d2[kk/k2] > 0:\\n                    ret += d1[k1] * d2[k2] * d2[kk/k2]\\n                    \\n\\t\\t# Type 2\\n        for k2 in key2:\\n            kk = k2 * k2\\n            for k1 in key1:\\n                if k1 > k2: break\\n                if k1 == k2:\\n                    if d1[k1] < 2: break\\n                    ret += d2[k2] * d1[k1] * (d1[k1] - 1)/2\\n                elif kk % k1 == 0 and d1[kk/k1] > 0:\\n                    ret += d2[k2] * d1[k1] * d1[kk/k1]\\n                    \\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2102584,
                "title": "c-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    #define li long long int\\n    int findT(vector<int>& n1, vector<int>& n2){\\n        unordered_map<li,int>mp;\\n        int c=0;\\n        for(auto&i:n1)mp[(li)i*i]++;\\n        for(int j=0;j<size(n2);++j)\\n            for(int k=j+1;k<size(n2);++k)c+=mp[(li)n2[j]*n2[k]];\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int c=findT(nums1,nums2);\\n        c+=findT(nums2,nums1);\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define li long long int\\n    int findT(vector<int>& n1, vector<int>& n2){\\n        unordered_map<li,int>mp;\\n        int c=0;\\n        for(auto&i:n1)mp[(li)i*i]++;\\n        for(int j=0;j<size(n2);++j)\\n            for(int k=j+1;k<size(n2);++k)c+=mp[(li)n2[j]*n2[k]];\\n        return c;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int c=findT(nums1,nums2);\\n        c+=findT(nums2,nums1);\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1997087,
                "title": "easy-nothing-is-crazy-here-only-simplicity",
                "content": "\\ttypedef long long int lli;\\n\\n\\n\\tclass Solution {\\n    \\n    int helper(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        \\n        unordered_map<lli,int> hash;\\n        \\n        int n=nums2.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                hash[(lli)(nums2[i])*(lli)(nums2[j])]++;\\n        \\n        int res=0;\\n        \\n        for(lli x:nums1)\\n            res+=hash[x*x];\\n        \\n        return res;\\n    }\\n    \\n\\tpublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) \\n    {\\n        int res=0;\\n        \\n        res+=helper(nums1,nums2);     \\n        res+=helper(nums2,nums1);\\n        \\n        return res;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    int helper(vector<int> &nums1,vector<int> &nums2)\\n    {\\n        \\n        unordered_map<lli,int> hash;\\n        \\n        int n=nums2.size();\\n        \\n        for(int i=0;i<n;i++)\\n            for(int j=i+1;j<n;j++)\\n                hash[(lli)(nums2[i])*(lli)(nums2[j])]++;\\n        \\n        int res=0;\\n        \\n        for(lli x:nums1)\\n            res+=hash[x*x];\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1913072,
                "title": "cpp-best-solution-beats-100-percent-online-submissions-hashing",
                "content": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int ,int>m;\\n         unordered_map<int ,int>m1;\\n        int ans =0;\\n        int ans1 =0;\\n        for(int i =0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }\\n         for(int i =0;i<nums1.size();i++){\\n            m1[nums1[i]]++;\\n        }\\n      \\n        for(int i =0;i<nums1.size();i++){\\n            long long target =nums1[i]*1LL*nums1[i];\\n        \\n            for(auto x:m){\\n              \\n                if(target%x.first==0 && x.first!=nums1[i]){\\n                  \\n                    if(m.find(target/x.first)!=m.end()){\\n                    ans+=(m[target/x.first]*x.second);\\n                    }\\n                }\\n                   if(target%x.first==0 && x.first==nums1[i]){\\n                   \\n                    ans+=x.second*(x.second-1);\\n                }\\n                \\n            }\\n            \\n          \\n        }\\n        \\n        ans=ans/2;\\n  \\n             for(int i =0;i<nums2.size();i++){\\n            long long target =nums2[i]*1LL*nums2[i];\\n          for(auto x:m1){\\n                if(target%x.first==0 && x.first!=nums2[i]){\\n                    if(m1.find(target/x.first)!=m1.end()){\\n                    ans1+=m1[target/x.first]*x.second;\\n                    }\\n                }\\n                  else if(target%x.first==0 && x.first==nums2[i]){\\n                    ans1+=x.second*(x.second-1);\\n                }\\n                \\n            }\\n        }\\n      \\n        ans1=ans1/2;\\n      \\n        return ans+ans1;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int ,int>m;\\n         unordered_map<int ,int>m1;\\n        int ans =0;\\n        int ans1 =0;\\n        for(int i =0;i<nums2.size();i++){\\n            m[nums2[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1882680,
                "title": "java-solution",
                "content": "```\\npublic int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, nums2) + getCount(nums2, nums1);\\n    }\\n\\n    private int getCount(int[] nums1, int[] nums2) {\\n\\n        int res = 0;\\n        for (int j : nums1) {\\n\\n            final long sqr = (long) j * (long) j; // as range is 10^5\\n            final Map<Long, Long> map = new HashMap<>();\\n\\n            for (final int value : nums2) {\\n                if (sqr % (long) value == 0) {\\n                    res += map.getOrDefault(sqr / (long) value, 0L);\\n                    // if divisible store in map so that next time we can pull count\\n                    map.compute((long) value, (k, v) -> v == null ? 1L : 1L + v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numTriplets(int[] nums1, int[] nums2) {\\n        return getCount(nums1, nums2) + getCount(nums2, nums1);\\n    }\\n\\n    private int getCount(int[] nums1, int[] nums2) {\\n\\n        int res = 0;\\n        for (int j : nums1) {\\n\\n            final long sqr = (long) j * (long) j; // as range is 10^5\\n            final Map<Long, Long> map = new HashMap<>();\\n\\n            for (final int value : nums2) {\\n                if (sqr % (long) value == 0) {\\n                    res += map.getOrDefault(sqr / (long) value, 0L);\\n                    // if divisible store in map so that next time we can pull count\\n                    map.compute((long) value, (k, v) -> v == null ? 1L : 1L + v);\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1880784,
                "title": "easy-to-understand-map-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        nums_1_products={}\\n        nums_2_products={}\\n\\n        def prod_dict_generation(input_list,prod_dict):\\n            for i in range(len(input_list)-1):\\n                for j in range(i+1,len(input_list)):\\n                    prod=input_list[i]*input_list[j]\\n                    if prod in prod_dict:\\n                        prod_dict[prod]+=1\\n                    else:\\n                        prod_dict[prod]=1\\n\\n        prod_dict_generation(nums1,nums_1_products)\\n        prod_dict_generation(nums2,nums_2_products)\\n\\n        for num in nums1:\\n            if num*num in nums_2_products:\\n                result+= nums_2_products[num*num]\\n\\n        for num in nums2:\\n            if num*num in nums_1_products:\\n                result+= nums_1_products[num*num]\\n\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        result=0\\n        nums_1_products={}\\n        nums_2_products={}\\n\\n        def prod_dict_generation(input_list,prod_dict):\\n            for i in range(len(input_list)-1):\\n                for j in range(i+1,len(input_list)):\\n                    prod=input_list[i]*input_list[j]\\n                    if prod in prod_dict:\\n                        prod_dict[prod]+=1\\n                    else:\\n                        prod_dict[prod]=1\\n\\n        prod_dict_generation(nums1,nums_1_products)\\n        prod_dict_generation(nums2,nums_2_products)\\n\\n        for num in nums1:\\n            if num*num in nums_2_products:\\n                result+= nums_2_products[num*num]\\n\\n        for num in nums2:\\n            if num*num in nums_1_products:\\n                result+= nums_1_products[num*num]\\n\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1855285,
                "title": "fast-clear-java-solution",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return numTriplets1(nums1, nums2) + numTriplets1(nums2, nums1);\\n    }\\n\\n    int numTriplets1(int[] nums1, int[] nums2) {\\n        int cnt = 0;\\n        for (int n : nums1) {\\n            long nn = (long) n * n;\\n            for (int i = 0, j = nums2.length-1; i < j;) {\\n                long ij = (long) nums2[i] * nums2[j];\\n                if (ij == nn) {\\n                    if (nums2[i] == nums2[j]) {\\n                        cnt += (j - i + 1) * (j - i) / 2;\\n                        break;\\n                    } else {\\n                        int ci = 1;\\n                        while (nums2[i] == nums2[++i]) {\\n                            ++ci;\\n                        }\\n                        int cj = 1;\\n                        while (nums2[j] == nums2[--j]) {\\n                            ++cj;\\n                        }\\n                        cnt += ci * cj;\\n                    }\\n                } else if (ij < nn) {\\n                    ++i;\\n                } else {\\n                    --j;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}```",
                "solutionTags": [
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return numTriplets1(nums1, nums2) + numTriplets1(nums2, nums1);\\n    }\\n\\n    int numTriplets1(int[] nums1, int[] nums2) {\\n        int cnt = 0;\\n        for (int n : nums1) {\\n            long nn = (long) n * n;\\n            for (int i = 0, j = nums2.length-1; i < j;) {\\n                long ij = (long) nums2[i] * nums2[j];\\n                if (ij == nn) {\\n                    if (nums2[i] == nums2[j]) {\\n                        cnt += (j - i + 1) * (j - i) / 2;\\n                        break;\\n                    } else {\\n                        int ci = 1;\\n                        while (nums2[i] == nums2[++i]) {\\n                            ++ci;\\n                        }\\n                        int cj = 1;\\n                        while (nums2[j] == nums2[--j]) {\\n                            ++cj;\\n                        }\\n                        cnt += ci * cj;\\n                    }\\n                } else if (ij < nn) {\\n                    ++i;\\n                } else {\\n                    --j;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 1782580,
                "title": "o-n-m-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>mp,cnt;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                mp[(long long)nums1[i]*nums1[j]]++;\\n            }\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                cnt[(long long)nums2[i]*nums2[j]]++;\\n            }\\n        }\\n        long long res=0;\\n        for(int i=0;i<nums1.size();i++){\\n            res+=cnt[(long long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            res+=mp[(long long)nums2[i]*nums2[i]];\\n        }\\n        return res;  \\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>mp,cnt;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                mp[(long long)nums1[i]*nums1[j]]++;\\n            }\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                cnt[(long long)nums2[i]*nums2[j]]++;\\n            }\\n        }\\n        long long res=0;\\n        for(int i=0;i<nums1.size();i++){\\n            res+=cnt[(long long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            res+=mp[(long long)nums2[i]*nums2[i]];\\n        }\\n        return res;  \\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1745095,
                "title": "typecasting-was-so-crazy-like-omg",
                "content": "```\\n#define lli long long int\\nclass Solution {\\npublic:\\n    int triplets(vector<int>&nums1,vector<int>&nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        unordered_map<lli,lli>mp;\\n        for(int i=0;i<nums2.size();i++)\\n            mp[nums2[i]]++;\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int target=((lli)nums1[i]*(lli)nums1[i]);\\n            int j=0;\\n            int k=nums2.size()-1;\\n            while(j<k){\\n                if((lli)nums2[j]*(lli)nums2[k]==target){\\n                  if(nums2[j]==nums2[k]){\\n                      ans+=((mp[nums2[j]]*(mp[nums2[j]]-1))/2);\\n                  }\\n                else{\\n                    ans+=(mp[nums2[j]]*mp[nums2[k]]);\\n                }\\n                    while(j<k and nums2[j]==nums2[j+1])\\n                        j++;\\n                    while(j<k and nums2[k]==nums2[k-1])\\n                        k--;\\n                    j++;\\n                    k--;\\n                }\\n                else if((lli)nums2[j]*(lli)nums2[k]>target){\\n                    k--;\\n                }\\n                else\\n                    j++;\\n            }\\n        }\\n        return ans;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return triplets(nums1,nums2)+triplets(nums2,nums1);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int triplets(vector<int>&nums1,vector<int>&nums2){\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        unordered_map<lli,lli>mp;\\n        for(int i=0;i<nums2.size();i++)\\n            mp[nums2[i]]++;\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            long long int target=((lli)nums1[i]*(lli)nums1[i]);\\n            int j=0;\\n            int k=nums2.size()-1;\\n            while(j<k){\\n                if((lli)nums2[j]*(lli)nums2[k]==target){\\n                  if(nums2[j]==nums2[k]){\\n                      ans+=((mp[nums2[j]]*(mp[nums2[j]]-1))/2);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 1714050,
                "title": "java-clean-and-easy-code-o-n-n-time-o-1-space",
                "content": "Time : O(M * N)\\nSpace : O(1)\\n\\n**Feel free to ask in comment, if any doubt.**\\n\\n```\\nclass Solution {\\n    public int helper(int[] ar1, int[] ar2){\\n        int res = 0;\\n        int n = ar2.length;\\n        \\n        for(long num : ar1){\\n            int l = 0;\\n            int r = n-1;\\n            \\n            while(l < r){\\n                long val1 = ar2[l];\\n                long val2 = ar2[r];\\n                \\n                if( val1 == val2){\\n\\t\\t\\t\\t    //          l        r\\n                    //          |        |\\n                    // [..., 1, 2, 2, 2, 2, 4,....]\\n                    res += val1*val2 == num*num ? (r-l)*(r-l+1)/2 : 0;\\n                    break;    \\n                }\\n                \\n                if(num*num == val1*val2){\\n                    int count1 = 0;\\n                    while( l < r && ar2[l] == val1){\\n                        count1++;\\n                        l++;\\n                    }\\n                    while( ar2[r] == val2){\\n                        res += count1;\\n                        r--;\\n                    }\\n                }\\n                else if( val1*val2 > num*num){\\n                    while( l < r && ar2[r] == val2)\\n                        r--;\\n                }\\n                else{\\n                    while( l < r && ar2[l] == val1)\\n                        l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return helper(nums1, nums2) + helper(nums2, nums1); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int helper(int[] ar1, int[] ar2){\\n        int res = 0;\\n        int n = ar2.length;\\n        \\n        for(long num : ar1){\\n            int l = 0;\\n            int r = n-1;\\n            \\n            while(l < r){\\n                long val1 = ar2[l];\\n                long val2 = ar2[r];\\n                \\n                if( val1 == val2){\\n\\t\\t\\t\\t    //          l        r\\n                    //          |        |\\n                    // [..., 1, 2, 2, 2, 2, 4,....]\\n                    res += val1*val2 == num*num ? (r-l)*(r-l+1)/2 : 0;\\n                    break;    \\n                }\\n                \\n                if(num*num == val1*val2){\\n                    int count1 = 0;\\n                    while( l < r && ar2[l] == val1){\\n                        count1++;\\n                        l++;\\n                    }\\n                    while( ar2[r] == val2){\\n                        res += count1;\\n                        r--;\\n                    }\\n                }\\n                else if( val1*val2 > num*num){\\n                    while( l < r && ar2[r] == val2)\\n                        r--;\\n                }\\n                else{\\n                    while( l < r && ar2[l] == val1)\\n                        l++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        Arrays.sort(nums1);\\n        Arrays.sort(nums2);\\n        return helper(nums1, nums2) + helper(nums2, nums1); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665174,
                "title": "python-o-nlog-n-m-mlog-m-n-with-bisect-left-200ms",
                "content": "use bisect to find the `i*i == j*k`\\n\\n```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1,s2 = defaultdict(int),defaultdict(int)\\n        for s in nums1:\\n            s1[s] += 1\\n        for s in nums2:\\n            s2[s] += 1\\n        ans = 0\\n        def find(s1,s2):\\n            ans = 0\\n            for i in sorted(s1.keys()):\\n                s2sort = sorted(s2.keys())\\n                if i<s2sort[0]:\\n                    continue\\n                if i>s2sort[-1]:\\n                    break\\n                # print(sorted(s1.keys()),s2sort,i)\\n                for _j,j in enumerate(s2sort):\\n                    # print(sorted(s1.keys()),s2sort,i,j)\\n                    if j*s2sort[-1]<i*i:\\n                        continue\\n                    elif j>i:\\n                        break\\n                    elif (i*i)%j != 0:\\n                        continue\\n                    elif j == i:\\n                        ans += s1[i]*s2[j]*(s2[j]-1)//2\\n                        continue\\n                    else:\\n                        k = bisect_left(s2sort,i*i//j,_j+1)\\n                        while k<len(s2sort):\\n                            # print(s1.keys(),s2sort,i,j,s2sort[k],i*i-j*s2sort[k])\\n                            if j*s2sort[k] == i*i:\\n                                ans += s1[i]*s2[j]*s2[s2sort[k]]\\n                            k = bisect_left(s2sort,i*i//j,k+1)\\n            return ans\\n        t1,t2 = find(s1,s2),find(s2,s1)\\n        # print(t1,t2)\\n        return t1+t2\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        s1,s2 = defaultdict(int),defaultdict(int)\\n        for s in nums1:\\n            s1[s] += 1\\n        for s in nums2:\\n            s2[s] += 1\\n        ans = 0\\n        def find(s1,s2):\\n            ans = 0\\n            for i in sorted(s1.keys()):\\n                s2sort = sorted(s2.keys())\\n                if i<s2sort[0]:\\n                    continue\\n                if i>s2sort[-1]:\\n                    break\\n                # print(sorted(s1.keys()),s2sort,i)\\n                for _j,j in enumerate(s2sort):\\n                    # print(sorted(s1.keys()),s2sort,i,j)\\n                    if j*s2sort[-1]<i*i:\\n                        continue\\n                    elif j>i:\\n                        break\\n                    elif (i*i)%j != 0:\\n                        continue\\n                    elif j == i:\\n                        ans += s1[i]*s2[j]*(s2[j]-1)//2\\n                        continue\\n                    else:\\n                        k = bisect_left(s2sort,i*i//j,_j+1)\\n                        while k<len(s2sort):\\n                            # print(s1.keys(),s2sort,i,j,s2sort[k],i*i-j*s2sort[k])\\n                            if j*s2sort[k] == i*i:\\n                                ans += s1[i]*s2[j]*s2[s2sort[k]]\\n                            k = bisect_left(s2sort,i*i//j,k+1)\\n            return ans\\n        t1,t2 = find(s1,s2),find(s2,s1)\\n        # print(t1,t2)\\n        return t1+t2\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1652793,
                "title": "simple-careful-edge-case-handely-c-code",
                "content": "```\\n    int res = 0;\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<int, int> m1, m2;\\n        for(auto n : nums1) m1[n]++; for(auto n : nums2) m2[n]++;\\n        \\n        for(auto n : nums1) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums2)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m2[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m2[n] * (m2[n] - 1)) / 2;\\n        }\\n            \\n        for(auto n : nums2) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums1)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m1[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m1[n] * (m1[n] - 1)) / 2;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int res = 0;\\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        unordered_map<int, int> m1, m2;\\n        for(auto n : nums1) m1[n]++; for(auto n : nums2) m2[n]++;\\n        \\n        for(auto n : nums1) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums2)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m2[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m2[n] * (m2[n] - 1)) / 2;\\n        }\\n            \\n        for(auto n : nums2) {\\n            \\n            int t = 0;\\n            \\n            for(auto a : nums1)\\n                if(((long long)n * n) % a == 0 && a != n) \\n                    t += m1[((long long)n * n) / a];\\n            \\n            res += t / 2;\\n            res += (m1[n] * (m1[n] - 1)) / 2;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566825,
                "title": "c-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        using lint = long long int;\\n        unordered_map<lint, int> squares1;\\n        unordered_map<lint, int> squares2;\\n        for(lint i : nums1)\\n            ++squares1[i*i];\\n        for(lint i : nums2)\\n            ++squares2[i*i];\\n        auto N1 = nums1.size();\\n        auto N2 = nums2.size();\\n        int ret = 0;\\n        for(size_t i = 0; i < N1; ++i) {\\n            for(size_t j = i + 1; j < N1; ++j) {\\n                lint n = nums1[i];\\n                auto it = squares2.find(n * nums1[j]);\\n                if(it != squares2.end())\\n                    ret += it->second;\\n            }\\n        }\\n        for(size_t i = 0; i < N2; ++i) {\\n            for(size_t j = i + 1; j < N2; ++j) {\\n                lint n = nums2[i];\\n                auto it = squares1.find(n * nums2[j]);\\n                if(it != squares1.end())\\n                    ret += it->second;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        using lint = long long int;\\n        unordered_map<lint, int> squares1;\\n        unordered_map<lint, int> squares2;\\n        for(lint i : nums1)\\n            ++squares1[i*i];\\n        for(lint i : nums2)\\n            ++squares2[i*i];\\n        auto N1 = nums1.size();\\n        auto N2 = nums2.size();\\n        int ret = 0;\\n        for(size_t i = 0; i < N1; ++i) {\\n            for(size_t j = i + 1; j < N1; ++j) {\\n                lint n = nums1[i];\\n                auto it = squares2.find(n * nums1[j]);\\n                if(it != squares2.end())\\n                    ret += it->second;\\n            }\\n        }\\n        for(size_t i = 0; i < N2; ++i) {\\n            for(size_t j = i + 1; j < N2; ++j) {\\n                lint n = nums2[i];\\n                auto it = squares1.find(n * nums2[j]);\\n                if(it != squares1.end())\\n                    ret += it->second;\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532039,
                "title": "python-code-beats-100-in-time-and-90-in-space",
                "content": "\\'\\'\\'\\n    def numTriplets(self, nums1, nums2):\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        \\n        ans, loop = 0, 2\\n        \\n        # set loop to 2, so we can check # of Type 2 after checking # of Type 1\\n        while loop > 0:\\n        \\n            for key in dic1:\\n                squared = key*key\\n                temp = 0\\n                for k in dic2:\\n                    if squared%k == 0 and squared/k in dic2:\\n                        \\n                        # if squared/k in nums2 and k != squared/k, we should add dic2[k]*dic2[squared/k]/2.0\\n                        # Here I am not adding dic2[k]*dic2[squared/k], because we are looping through keys in dic2\\n                        # we will see squared/k in the future and add another half of dic2[k]*dic2[squared/k]\\n                        if squared/k != k:\\n                            temp += dic2[k]*dic2[squared/k]/2.0\\n                            \\n                        # if squared/k in nums2 and k == squared/k, we will add dic2[k]*(dic2[k]-1)/2.0 since k repeats dic2[k] times in nums2\\n                        # we want to pick any two of those ks, there are dic2[k]*(dic2[k]-1)/2.0 ways to do it.\\n                        else:\\n                            temp += dic2[k]*(dic2[k]-1)/2.0\\n                \\n                # key repeats dic1[key] times in nums1. Each key contributes temp to the final result. We multiply them to get the total contribution from key in num1.\\n                ans += temp*dic1[key]\\n            \\n            loop -= 1\\n            dic1, dic2 = dic2, dic1\\n        \\n        return int(ans)\\n\\'\\'\\'\\nI think the time complexity here is O(m*n), m is the length of nums1 and n is the length of nums2\\nPlease correct me if I am wrong. \\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n    def numTriplets(self, nums1, nums2):\\n\\n        dic1 = collections.Counter(nums1)\\n        dic2 = collections.Counter(nums2)\\n        \\n        ans, loop = 0, 2\\n        \\n        # set loop to 2, so we can check # of Type 2 after checking # of Type 1\\n        while loop > 0:\\n        \\n            for key in dic1:\\n                squared = key*key\\n                temp = 0\\n                for k in dic2:\\n                    if squared%k == 0 and squared/k in dic2:\\n                        \\n                        # if squared/k in nums2 and k != squared/k, we should add dic2[k]*dic2[squared/k]/2.0\\n                        # Here I am not adding dic2[k]*dic2[squared/k], because we are looping through keys in dic2\\n                        # we will see squared/k in the future and add another half of dic2[k]*dic2[squared/k]\\n                        if squared/k != k:\\n                            temp += dic2[k]*dic2[squared/k]/2.0\\n                            \\n                        # if squared/k in nums2 and k == squared/k, we will add dic2[k]*(dic2[k]-1)/2.0 since k repeats dic2[k] times in nums2\\n                        # we want to pick any two of those ks, there are dic2[k]*(dic2[k]-1)/2.0 ways to do it.\\n                        else:\\n                            temp += dic2[k]*(dic2[k]-1)/2.0\\n                \\n                # key repeats dic1[key] times in nums1. Each key contributes temp to the final result. We multiply them to get the total contribution from key in num1.\\n                ans += temp*dic1[key]\\n            \\n            loop -= 1\\n            dic1, dic2 = dic2, dic1\\n        \\n        return int(ans)\\n\\'\\'\\'\\nI think the time complexity here is O(m*n), m is the length of nums1 and n is the length of nums2\\nPlease correct me if I am wrong. \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1521021,
                "title": "c-simple-approach-intuitive-approach",
                "content": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>m1;\\n        unordered_map<long long,long long>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n           for(int j=i+1;j<nums1.size();j++)\\n           {\\n               long long  mul=(long long) nums1[i]*nums1[j];\\n               m1[mul]++;\\n           }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n           for(int j=i+1;j<nums2.size();j++)\\n           {\\n               long long mul=(long long)nums2[i]*nums2[j];\\n               m2[mul]++;\\n           }\\n        }\\n        int count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long square=(long long)nums1[i]*nums1[i];\\n            if(m2.find(square)!=m2.end())\\n            {\\n                count+=m2[square];\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long long square=(long long)nums2[i]*nums2[i];\\n            if(m1.find(square)!=m1.end())\\n            {\\n                count+=m1[square];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long long,long long>m1;\\n        unordered_map<long long,long long>m2;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n           for(int j=i+1;j<nums1.size();j++)\\n           {\\n               long long  mul=(long long) nums1[i]*nums1[j];\\n               m1[mul]++;\\n           }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n           for(int j=i+1;j<nums2.size();j++)\\n           {\\n               long long mul=(long long)nums2[i]*nums2[j];\\n               m2[mul]++;\\n           }\\n        }\\n        int count=0;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            long long square=(long long)nums1[i]*nums1[i];\\n            if(m2.find(square)!=m2.end())\\n            {\\n                count+=m2[square];\\n            }\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            long long square=(long long)nums2[i]*nums2[i];\\n            if(m1.find(square)!=m1.end())\\n            {\\n                count+=m1[square];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1511939,
                "title": "python-3-easy-to-understand-solution-with-explanation",
                "content": "it is quite easy to give intuitive idea to brute-force it, the only difficult point is duplicate value removal.\\n\\nhere we use set, to remove duplicate easily, also, it is faster to judge if a value exists in a set than list.\\n\\nfor value i in num1, if i^2/j exists in num2,  we can easily get the value thru textbook combination as below\\n\\n1. count number of i in num1 denoted as i_1, number of j in num2 denoted as j_1, number of i^2/j denoted as k in num2 denoted as k_1\\n\\n2. if j = k, we add i_1 * math.comb(j_1, 2) to ans\\n3. else, we add i_1 * j_1 * k_1\\n\\nfor type 2 it is same\\n```\\nimport math\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums_1, nums_2 = set(nums1), set(nums2)\\n        ans = 0\\n        for i in nums_1:\\n            used = set()\\n            for j in nums_2:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_2:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums1.count(i) * math.comb(nums2.count(j), 2)\\n                else:\\n                    ans += nums1.count(i) * nums2.count(j) * nums2.count(temp)\\n        #print(ans)\\n        for i in nums_2:\\n            used = set()\\n            for j in nums_1:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_1:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums2.count(i) * math.comb(nums1.count(j), 2)\\n                else:\\n                    ans += nums2.count(i) * nums1.count(j) * nums1.count(temp)\\n        return ans\\n",
                "solutionTags": [],
                "code": "it is quite easy to give intuitive idea to brute-force it, the only difficult point is duplicate value removal.\\n\\nhere we use set, to remove duplicate easily, also, it is faster to judge if a value exists in a set than list.\\n\\nfor value i in num1, if i^2/j exists in num2,  we can easily get the value thru textbook combination as below\\n\\n1. count number of i in num1 denoted as i_1, number of j in num2 denoted as j_1, number of i^2/j denoted as k in num2 denoted as k_1\\n\\n2. if j = k, we add i_1 * math.comb(j_1, 2) to ans\\n3. else, we add i_1 * j_1 * k_1\\n\\nfor type 2 it is same\\n```\\nimport math\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        nums_1, nums_2 = set(nums1), set(nums2)\\n        ans = 0\\n        for i in nums_1:\\n            used = set()\\n            for j in nums_2:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_2:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums1.count(i) * math.comb(nums2.count(j), 2)\\n                else:\\n                    ans += nums1.count(i) * nums2.count(j) * nums2.count(temp)\\n        #print(ans)\\n        for i in nums_2:\\n            used = set()\\n            for j in nums_1:\\n                if (i**2)%j:continue\\n                temp = (i**2)//j\\n                if temp not in nums_1:\\n                    continue\\n                if j in used:continue\\n                used.add(j)\\n                used.add(temp)\\n                if temp == j:\\n                    ans += nums2.count(i) * math.comb(nums1.count(j), 2)\\n                else:\\n                    ans += nums2.count(i) * nums1.count(j) * nums1.count(temp)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1507756,
                "title": "c-solution",
                "content": "```\\n  int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long long,long long> mp,mp1;\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        for(auto x: nums1){\\n            mp[(long long)x*x]++;\\n        }\\n        \\n        for(auto x : nums2){\\n            mp1[(long long)x*x]++;\\n        }\\n        \\n        int ans=0;\\n        \\n      \\n        \\n        \\n        \\n        for(int i=0;i<nums2.size();i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                \\n                if(mp.find(((long long)nums2[i]*(long long)nums2[j]))!=mp.end()){\\n                    ans+=mp[(long long)nums2[i]*(long long)nums2[j]];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                \\n                if(mp1.find((long long)nums1[i]*(long long)nums1[j])!=mp1.end()){\\n                    \\n                    ans+=mp1[(long long)nums1[i]*(long long)nums1[j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n  int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        map<long long,long long> mp,mp1;\\n        \\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        \\n        for(auto x: nums1){\\n            mp[(long long)x*x]++;\\n        }\\n        \\n        for(auto x : nums2){\\n            mp1[(long long)x*x]++;\\n        }\\n        \\n        int ans=0;\\n        \\n      \\n        \\n        \\n        \\n        for(int i=0;i<nums2.size();i++){\\n            for(int j=i+1;j<nums2.size();j++){\\n                \\n                if(mp.find(((long long)nums2[i]*(long long)nums2[j]))!=mp.end()){\\n                    ans+=mp[(long long)nums2[i]*(long long)nums2[j]];\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<nums1.size();i++){\\n            for(int j=i+1;j<nums1.size();j++){\\n                \\n                if(mp1.find((long long)nums1[i]*(long long)nums1[j])!=mp1.end()){\\n                    \\n                    ans+=mp1[(long long)nums1[i]*(long long)nums1[j]];\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1447289,
                "title": "python-solution-using-dictionary",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        count = 0\\n        d = {}\\n        for i in range(len(nums2)):\\n            for j in range(i+1,len(nums2)):\\n                prod = nums2[i]*nums2[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums1)):\\n            num = pow(nums1[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n                        \\n        d = {}\\n        for i in range(0,len(nums1)):\\n            for j in range(i+1,len(nums1)):\\n                prod = nums1[i]*nums1[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums2)):\\n            num = pow(nums2[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        \\n        count = 0\\n        d = {}\\n        for i in range(len(nums2)):\\n            for j in range(i+1,len(nums2)):\\n                prod = nums2[i]*nums2[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums1)):\\n            num = pow(nums1[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n                        \\n        d = {}\\n        for i in range(0,len(nums1)):\\n            for j in range(i+1,len(nums1)):\\n                prod = nums1[i]*nums1[j]\\n                if prod not in d:\\n                    d[prod] = 1\\n                    \\n                else:\\n                    d[prod]+=1\\n                    \\n        for i in range(0,len(nums2)):\\n            num = pow(nums2[i],2)\\n            if num in d.keys():\\n                count+=d[num]\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437693,
                "title": "c-easy-solution-91-beat-math",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        unordered_map<int,int>mp3;\\n        unordered_map<int,int>mp4;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;\\n        }\\n        int ans=0;\\n        unordered_map<int,int>::iterator itr1;\\n        for(itr1=mp1.begin();itr1!=mp1.end();itr1++)\\n        {\\n            unordered_map<int,int>::iterator itr2;\\n            for(itr2=mp2.begin();itr2!=mp2.end();itr2++)\\n            {\\n                long long t = ((long long)itr1->first*(long long)itr1->first)/(long long)itr2->first;\\n                if((long long)t*(long long)itr2->first==((long long)itr1->first*(long long)itr1->first) && mp2.find(t)!=mp2.end() && mp4.find(itr2->first)==mp4.end())\\n                {\\n                    if(t==itr2->first)\\n                    {\\n                        if(itr2->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr2->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr1->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr2->second*mp2[t]);\\n                        ans+= (p*itr1->second);\\n                        mp4[itr2->first]++;\\n                        mp4[t]++;\\n                    }\\n                }\\n            }\\n            mp4.clear();\\n        }\\n        unordered_map<int,int>::iterator itr3;\\n        for(itr3=mp2.begin();itr3!=mp2.end();itr3++)\\n        {\\n            unordered_map<int,int>::iterator itr4;\\n            for(itr4=mp1.begin();itr4!=mp1.end();itr4++)\\n            {\\n                long long t = ((long long)itr3->first*(long long)itr3->first)/(long long)itr4->first;\\n                if((long long)t*(long long)itr4->first==((long long)itr3->first*(long long)itr3->first) && mp1.find(t)!=mp1.end() && mp3.find(itr4->first)==mp3.end())\\n                {\\n                    if(t==itr4->first)\\n                    {\\n                        if(itr4->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr4->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr3->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr4->second*mp1[t]);\\n                        ans+= (p*itr3->second);\\n                        mp3[itr4->first]++;\\n                        mp3[t]++;\\n                    }\\n                }\\n            }\\n            mp3.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<int,int>mp1;\\n        unordered_map<int,int>mp2;\\n        unordered_map<int,int>mp3;\\n        unordered_map<int,int>mp4;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            mp1[nums1[i]]++;\\n        }\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            mp2[nums2[i]]++;\\n        }\\n        int ans=0;\\n        unordered_map<int,int>::iterator itr1;\\n        for(itr1=mp1.begin();itr1!=mp1.end();itr1++)\\n        {\\n            unordered_map<int,int>::iterator itr2;\\n            for(itr2=mp2.begin();itr2!=mp2.end();itr2++)\\n            {\\n                long long t = ((long long)itr1->first*(long long)itr1->first)/(long long)itr2->first;\\n                if((long long)t*(long long)itr2->first==((long long)itr1->first*(long long)itr1->first) && mp2.find(t)!=mp2.end() && mp4.find(itr2->first)==mp4.end())\\n                {\\n                    if(t==itr2->first)\\n                    {\\n                        if(itr2->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr2->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr1->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr2->second*mp2[t]);\\n                        ans+= (p*itr1->second);\\n                        mp4[itr2->first]++;\\n                        mp4[t]++;\\n                    }\\n                }\\n            }\\n            mp4.clear();\\n        }\\n        unordered_map<int,int>::iterator itr3;\\n        for(itr3=mp2.begin();itr3!=mp2.end();itr3++)\\n        {\\n            unordered_map<int,int>::iterator itr4;\\n            for(itr4=mp1.begin();itr4!=mp1.end();itr4++)\\n            {\\n                long long t = ((long long)itr3->first*(long long)itr3->first)/(long long)itr4->first;\\n                if((long long)t*(long long)itr4->first==((long long)itr3->first*(long long)itr3->first) && mp1.find(t)!=mp1.end() && mp3.find(itr4->first)==mp3.end())\\n                {\\n                    if(t==itr4->first)\\n                    {\\n                        if(itr4->second==1)\\n                        {\\n                            continue;\\n                        }\\n                        long long n = itr4->second -1;\\n                        long long p = (n*(n+1))/2;\\n                        ans+=(itr3->second*p);\\n                    }\\n                    else\\n                    {\\n                        long long p = (itr4->second*mp1[t]);\\n                        ans+= (p*itr3->second);\\n                        mp3[itr4->first]++;\\n                        mp3[t]++;\\n                    }\\n                }\\n            }\\n            mp3.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421656,
                "title": "c-solution-using-map",
                "content": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        \\nmap<long long ,int>mp1;\\nmap<long long ,int>mp2;\\n        \\n        for(int i=0;i<n1;i++){\\n            long long  val=(long long)nums1[i]*(long long)nums1[i];\\n            mp1[val]++;\\n            \\n        }\\n        \\n        int count1=0,count2=0;\\n        \\n    for(int i=0;i<n2;i++){\\n        for(int j=i+1;j<n2;j++){\\n            long long val=(long long)nums2[j]*(long long)nums2[i];\\n            if(mp1.find(val)!=mp1.end()){\\n                count1+=mp1[val];\\n            }\\n        }\\n    }\\n        \\n        for(int i=0;i<n2;i++){\\n           long long  val=(long long)nums2[i]*(long long)nums2[i];\\n            mp2[val]++;\\n            \\n        }\\n        \\n            \\n    for(int i=0;i<n1;i++){\\n        for(int j=i+1;j<n1;j++){\\n            long long val=(long long)nums1[i]*(long long)nums1[j];\\n            if(mp2.find(val)!=mp2.end()){\\n                count2+=mp2[val];\\n            }\\n        }\\n    }\\n        \\n        \\n       return count1+count2; \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        \\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        \\nmap<long long ,int>mp1;\\nmap<long long ,int>mp2;\\n        \\n        for(int i=0;i<n1;i++){\\n            long long  val=(long long)nums1[i]*(long long)nums1[i];\\n            mp1[val]++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1412612,
                "title": "c-2-pointers-and-map",
                "content": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\nll help1(ll t,vector<int> &ar,unordered_map<ll,ll> &mp){\\n    ll n=ar.size(),ans=0;\\n    for(ll i=0;i<n;i++){\\n        if(t%ar[i]) continue;\\n        ll n1=ar[i],n2=t/ar[i];\\n        if(n2>n1) ans+=mp[n2];              //  choose all possible n2 for a given n1\\n        else if(n2==n1){\\n            ans+=(mp[n2]*(mp[n2]-1))/2;     //  choose any 2 numbers from mp[n2] numbers  \\n            break;\\n        }else break;                        //  break to prevent counting repeated pairs\\n    }\\n    return ans;\\n}\\n\\nll help2(vector<int>& ar1, vector<int>& ar2){\\n    ll n=ar1.size(),ans=0;\\n    unordered_map<ll,ll> mp;\\n    for(auto it:ar2) mp[it]++;\\n    for(ll i=0;i<n;i++) ans+=help1(1LL*ar1[i]*ar1[i],ar2,mp);\\n    return ans;\\n}\\n\\nint numTriplets(vector<int>& ar1, vector<int>& ar2) {\\n    sort(ar1.begin(),ar1.end());\\n    sort(ar2.begin(),ar2.end());\\n    return help2(ar1,ar2)+help2(ar2,ar1);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\npublic:\\nll help1(ll t,vector<int> &ar,unordered_map<ll,ll> &mp){\\n    ll n=ar.size(),ans=0;\\n    for(ll i=0;i<n;i++){\\n        if(t%ar[i]) continue;\\n        ll n1=ar[i],n2=t/ar[i];\\n        if(n2>n1) ans+=mp[n2];              //  choose all possible n2 for a given n1\\n        else if(n2==n1){\\n            ans+=(mp[n2]*(mp[n2]-1))/2;     //  choose any 2 numbers from mp[n2] numbers  \\n            break;\\n        }else break;                        //  break to prevent counting repeated pairs\\n    }\\n    return ans;\\n}\\n\\nll help2(vector<int>& ar1, vector<int>& ar2){\\n    ll n=ar1.size(),ans=0;\\n    unordered_map<ll,ll> mp;\\n    for(auto it:ar2) mp[it]++;\\n    for(ll i=0;i<n;i++) ans+=help1(1LL*ar1[i]*ar1[i],ar2,mp);\\n    return ans;\\n}\\n\\nint numTriplets(vector<int>& ar1, vector<int>& ar2) {\\n    sort(ar1.begin(),ar1.end());\\n    sort(ar2.begin(),ar2.end());\\n    return help2(ar1,ar2)+help2(ar2,ar1);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1409995,
                "title": "python3-use-counter-to-handle-duplicates",
                "content": "a comment in the code\\n\\n```\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\tdictN1,dictN2 = Counter(nums1),Counter(nums2)\\n\\tlistN1,listN2 = sorted(dictN1.keys()),sorted(dictN2.keys())\\n\\tN1,N2 = len(listN1),len(listN2)\\n\\n\\tretV = 0\\n\\tfor _ in range(2):\\n\\t\\tfor n in listN1:\\n\\t\\t\\tl,r = 0,N2-1\\n\\t\\t\\tif n>listN2[r]:          break\\n\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\tn2,p = n**2,listN2[l]*listN2[r]\\n\\t\\t\\t\\tif n2<p:\\t\\t\\tr -= 1\\n\\t\\t\\t\\telif n2==p:\\n\\t\\t\\t\\t\\tretV += dictN1[n]*(dictN2[listN2[l]]*dictN2[listN2[r]] if l<r else dictN2[listN2[l]]*(dictN2[listN2[l]]-1)//2)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\telse:\\t\\t\\t\\tl += 1\\n\\n\\t\\tdictN1,dictN2,listN1,listN2,N1,N2 = dictN2,dictN1,listN2,listN1,N2,N1                # switch nums1 and nums2 and repeat to reuse the code\\n\\n\\treturn retV\\n```",
                "solutionTags": [],
                "code": "```\\ndef numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n\\n\\tdictN1,dictN2 = Counter(nums1),Counter(nums2)\\n\\tlistN1,listN2 = sorted(dictN1.keys()),sorted(dictN2.keys())\\n\\tN1,N2 = len(listN1),len(listN2)\\n\\n\\tretV = 0\\n\\tfor _ in range(2):\\n\\t\\tfor n in listN1:\\n\\t\\t\\tl,r = 0,N2-1\\n\\t\\t\\tif n>listN2[r]:          break\\n\\t\\t\\twhile l<=r:\\n\\t\\t\\t\\tn2,p = n**2,listN2[l]*listN2[r]\\n\\t\\t\\t\\tif n2<p:\\t\\t\\tr -= 1\\n\\t\\t\\t\\telif n2==p:\\n\\t\\t\\t\\t\\tretV += dictN1[n]*(dictN2[listN2[l]]*dictN2[listN2[r]] if l<r else dictN2[listN2[l]]*(dictN2[listN2[l]]-1)//2)\\n\\t\\t\\t\\t\\tl += 1\\n\\t\\t\\t\\t\\tr -= 1\\n\\t\\t\\t\\telse:\\t\\t\\t\\tl += 1\\n\\n\\t\\tdictN1,dictN2,listN1,listN2,N1,N2 = dictN2,dictN1,listN2,listN1,N2,N1                # switch nums1 and nums2 and repeat to reuse the code\\n\\n\\treturn retV\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1401312,
                "title": "python-solution-n-2-time-and-linear-space",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c=0\\n        #take 1 number from nums2 and two numbers from nums1\\n        nums1Products=defaultdict(int)\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                nums1Products[nums1[i]*nums1[j]]+=1\\n        for i in nums2:\\n            target=i**2\\n            c+=nums1Products[target]\\n                \\n        #take 1 number from nums1 and two numbers from nums2\\n        nums2Products=defaultdict(int)\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                nums2Products[nums2[i]*nums2[j]]+=1\\n        for i in nums1:\\n            target=i**2\\n            c+=nums2Products[target]\\n        \\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c=0\\n        #take 1 number from nums2 and two numbers from nums1\\n        nums1Products=defaultdict(int)\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                nums1Products[nums1[i]*nums1[j]]+=1\\n        for i in nums2:\\n            target=i**2\\n            c+=nums1Products[target]\\n                \\n        #take 1 number from nums1 and two numbers from nums2\\n        nums2Products=defaultdict(int)\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                nums2Products[nums2[i]*nums2[j]]+=1\\n        for i in nums1:\\n            target=i**2\\n            c+=nums2Products[target]\\n        \\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1392942,
                "title": "python3-counter-o-n-2",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c1=Counter([i**2 for i in nums1])\\n        c2=Counter([i**2 for i in nums2])\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                p=nums1[i]*nums1[j]\\n                ans+=c2[p]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                p=nums2[i]*nums2[j]\\n                ans+=c1[p]\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        c1=Counter([i**2 for i in nums1])\\n        c2=Counter([i**2 for i in nums2])\\n        ans=0\\n        for i in range(len(nums1)-1):\\n            for j in range(i+1,len(nums1)):\\n                p=nums1[i]*nums1[j]\\n                ans+=c2[p]\\n        for i in range(len(nums2)-1):\\n            for j in range(i+1,len(nums2)):\\n                p=nums2[i]*nums2[j]\\n                ans+=c1[p]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367641,
                "title": "rust-0ms-100-idea-caveats-and-source",
                "content": "| Theoretical | Test | Beats |\\n| --- | --- | --- |\\n| O(nm) time | 0ms | 100% |\\n| O(n+m) mem | 2.2MB | 100% |\\n\\n*New record?*\\n\\n***\\\\## Idea***\\n\\n**Big picture**: Write code for doing it forward, then call the function reversing its args.\\n\\n**Brute force**: enumerate all i\\'s then j\\'s then k\\'s; compare `n1[i] ** 2` and `n2[j] * n2[k]`.\\n\\n**Optimization**: if for a `n1[i]`, the current `n2[j] * n2[k]` is too small, then next time we don\\'t try a smaller `n2[j]` or `n2[k]`, and vice versa for greater.\\n\\n> You can also do it the other way around, enumerating `j` and `k` while binary-searching for a suitable `i`. Will be O(m<sup>2</sup>log(n)) tho.\\n\\n*How to implement?* Use sorted `n2`; initialize `j` and `k` to 0 and `len - 1`, respectively; decrease `k` if the product is too large, and increase `j` otherwise.\\n\\n*How to count?* If there are repeated elements in `n2`, then there isn\\'t an elegant way of processing them as they lie individually, tho continuously, in `n2`. So we preprocess `n2`, keeping the unique elements and their respective count, `c2`. For `j == k`, add `c2[j] * c2[k]`; otherwise, add `c2[j] * (c2[j] - 1) / 2` (combinations, which is permutations / orderings).\\n\\n**Winding it up**: do the same to `n1` and multiply gains by `c1`.\\n\\n***\\\\## Caveats***\\n\\n**Algorithm level**\\n\\n- loop until `j > k`, not `j >= k`. There can be repeated values, remember?\\n- it\\'s `c2[j] * (c2[j] - 1) / 2`, with the `/ 2`. I fell for it, personally.\\n\\n**Language level**\\n\\n- don\\'t copy the vectors; use references.\\n- data range limit 1e5\\u2014remember to use `i64` for squares and products.\\n- use `i32` or `i64` for indices and cast them to `usize` when indexing. There\\'s a `k -= 1` that is guaranteed not to be used as an index when it\\'s negative (cuz the loop breaks).\\n- and probably some more. I don\\'t remember.\\n\\n***\\\\## Source code***\\n\\nFull source with debug `println`s and tests:\\n\\n```rust\\nstruct Solution;\\n\\nimpl Solution {\\n    fn _ntri(n1: &[i32], c1: &[i32], n2: &[i32], c2: &[i32]) -> i32 {\\n        // Assumes that n1, n2 are sorted and unique, and that c1, c2 hold the\\n        // counts of each unique element in n1, n2\\n        // println!(\"{:?}\", n1);\\n        // println!(\"{:?}\", c1);\\n        // println!(\"{:?}\", n2);\\n        // println!(\"{:?}\", c2);\\n\\n        let mut cnt = 0;\\n        for i in 0..(n1.len()) {\\n            let sq = n1[i] as i64 * n1[i] as i64;\\n            let mut j = 0i32;\\n            let mut k = n2.len() as i32 - 1;\\n            while j <= k {\\n                let pd = n2[j as usize] as i64 * n2[k as usize] as i64;\\n                // println!(\\n                //     \"{} {} {} => {:?}\", i, j, k, sq.partial_cmp(&pd).unwrap());\\n                if sq == pd {\\n                    cnt += c1[i] * if j == k {\\n                        c2[j as usize] * (c2[j as usize] - 1) / 2\\n                    } else {\\n                        c2[j as usize] * c2[k as usize]\\n                    };\\n                    j += 1;\\n                } else if sq < pd {\\n                    k -= 1;\\n                } else {\\n                    j += 1;\\n                }\\n            }\\n        }\\n\\n        cnt\\n    }\\n\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        const INF: i32 = 0x3f3f3f3f;\\n        let mut nums1 = nums1;\\n        nums1.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut nums2 = nums2;\\n        nums2.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n\\n        let mut uniq1: Vec<i32> = vec![];\\n        let mut cnts1: Vec<i32> = vec![];\\n        let mut uniq2: Vec<i32> = vec![];\\n        let mut cnts2: Vec<i32> = vec![];\\n\\n        let mut tot = 0;\\n        let mut prev = INF;\\n        for a in nums1.iter() {\\n            if *a != prev {\\n                uniq1.push(*a);\\n                cnts1.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts1[tot - 1] += 1;\\n            }\\n        }\\n\\n        tot = 0;\\n        prev = INF;\\n        for a in nums2.iter() {\\n            if *a != prev {\\n                uniq2.push(*a);\\n                cnts2.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts2[tot - 1] += 1;\\n            }\\n        }\\n\\n        let fw = Self::_ntri(&uniq1[..], &cnts1[..], &uniq2[..], &cnts2[..]);\\n        let bw = Self::_ntri(&uniq2[..], &cnts2[..], &uniq1[..], &cnts1[..]);\\n        // println!(\"{} {}\", fw, bw);\\n        fw + bw\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_sample_1() {\\n        let n1 = vec![7, 4];\\n        let n2 = vec![5, 2, 8, 9];\\n        assert_eq!(Solution::num_triplets(n1, n2), 1);\\n    }\\n\\n    #[test]\\n    fn test_sample_2() {\\n        let n1 = vec![1, 1];\\n        let n2 = vec![1, 1, 1];\\n        assert_eq!(Solution::num_triplets(n1, n2), 9);\\n    }\\n\\n    #[test]\\n    fn test_sample_3() {\\n        let n1 = vec![7, 7, 8, 3];\\n        let n2 = vec![1, 2, 9, 7];\\n        assert_eq!(Solution::num_triplets(n1, n2), 2);\\n    }\\n\\n    #[test]\\n    fn test_sample_4() {\\n        let n1 = vec![4, 7, 9, 11, 23];\\n        let n2 = vec![3, 5, 1024, 12, 18];\\n        assert_eq!(Solution::num_triplets(n1, n2), 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nstruct Solution;\\n\\nimpl Solution {\\n    fn _ntri(n1: &[i32], c1: &[i32], n2: &[i32], c2: &[i32]) -> i32 {\\n        // Assumes that n1, n2 are sorted and unique, and that c1, c2 hold the\\n        // counts of each unique element in n1, n2\\n        // println!(\"{:?}\", n1);\\n        // println!(\"{:?}\", c1);\\n        // println!(\"{:?}\", n2);\\n        // println!(\"{:?}\", c2);\\n\\n        let mut cnt = 0;\\n        for i in 0..(n1.len()) {\\n            let sq = n1[i] as i64 * n1[i] as i64;\\n            let mut j = 0i32;\\n            let mut k = n2.len() as i32 - 1;\\n            while j <= k {\\n                let pd = n2[j as usize] as i64 * n2[k as usize] as i64;\\n                // println!(\\n                //     \"{} {} {} => {:?}\", i, j, k, sq.partial_cmp(&pd).unwrap());\\n                if sq == pd {\\n                    cnt += c1[i] * if j == k {\\n                        c2[j as usize] * (c2[j as usize] - 1) / 2\\n                    } else {\\n                        c2[j as usize] * c2[k as usize]\\n                    };\\n                    j += 1;\\n                } else if sq < pd {\\n                    k -= 1;\\n                } else {\\n                    j += 1;\\n                }\\n            }\\n        }\\n\\n        cnt\\n    }\\n\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n        const INF: i32 = 0x3f3f3f3f;\\n        let mut nums1 = nums1;\\n        nums1.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n        let mut nums2 = nums2;\\n        nums2.sort_by(|a, b| a.partial_cmp(b).unwrap());\\n\\n        let mut uniq1: Vec<i32> = vec![];\\n        let mut cnts1: Vec<i32> = vec![];\\n        let mut uniq2: Vec<i32> = vec![];\\n        let mut cnts2: Vec<i32> = vec![];\\n\\n        let mut tot = 0;\\n        let mut prev = INF;\\n        for a in nums1.iter() {\\n            if *a != prev {\\n                uniq1.push(*a);\\n                cnts1.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts1[tot - 1] += 1;\\n            }\\n        }\\n\\n        tot = 0;\\n        prev = INF;\\n        for a in nums2.iter() {\\n            if *a != prev {\\n                uniq2.push(*a);\\n                cnts2.push(1);\\n                tot += 1;\\n                prev = *a;\\n            } else {\\n                cnts2[tot - 1] += 1;\\n            }\\n        }\\n\\n        let fw = Self::_ntri(&uniq1[..], &cnts1[..], &uniq2[..], &cnts2[..]);\\n        let bw = Self::_ntri(&uniq2[..], &cnts2[..], &uniq1[..], &cnts1[..]);\\n        // println!(\"{} {}\", fw, bw);\\n        fw + bw\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_sample_1() {\\n        let n1 = vec![7, 4];\\n        let n2 = vec![5, 2, 8, 9];\\n        assert_eq!(Solution::num_triplets(n1, n2), 1);\\n    }\\n\\n    #[test]\\n    fn test_sample_2() {\\n        let n1 = vec![1, 1];\\n        let n2 = vec![1, 1, 1];\\n        assert_eq!(Solution::num_triplets(n1, n2), 9);\\n    }\\n\\n    #[test]\\n    fn test_sample_3() {\\n        let n1 = vec![7, 7, 8, 3];\\n        let n2 = vec![1, 2, 9, 7];\\n        assert_eq!(Solution::num_triplets(n1, n2), 2);\\n    }\\n\\n    #[test]\\n    fn test_sample_4() {\\n        let n1 = vec![4, 7, 9, 11, 23];\\n        let n2 = vec![3, 5, 1024, 12, 18];\\n        assert_eq!(Solution::num_triplets(n1, n2), 0);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1342968,
                "title": "c-o-n-2-time-and-o-3n-memory",
                "content": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        \\n        var hash1 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            var square = (long)nums1[i] * nums1[i];\\n            if (!hash1.ContainsKey(square)) hash1.Add(square, 0);\\n            hash1[square]++;\\n        }\\n        \\n        var hash2 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            var square = (long)nums2[i] * nums2[i];\\n            if (!hash2.ContainsKey(square)) hash2.Add(square, 0);\\n            hash2[square]++;\\n        }\\n        \\n        \\n        var count = 0;\\n        \\n        //Type 1\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums2.Length; j++)\\n            {\\n                var product = (long)nums2[i] * nums2[j];\\n                if (hash1.ContainsKey(product)) count = count + hash1[product];\\n            }\\n        }\\n        \\n        //Type 2\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums1.Length; j++)\\n            {\\n                var product = (long)nums1[i] * nums1[j];\\n                if (hash2.ContainsKey(product)) count = count + hash2[product];\\n            }\\n        }\\n        \\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int NumTriplets(int[] nums1, int[] nums2) {\\n        \\n        var hash1 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            var square = (long)nums1[i] * nums1[i];\\n            if (!hash1.ContainsKey(square)) hash1.Add(square, 0);\\n            hash1[square]++;\\n        }\\n        \\n        var hash2 = new Dictionary<long, int>();\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            var square = (long)nums2[i] * nums2[i];\\n            if (!hash2.ContainsKey(square)) hash2.Add(square, 0);\\n            hash2[square]++;\\n        }\\n        \\n        \\n        var count = 0;\\n        \\n        //Type 1\\n        for(int i = 0; i < nums2.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums2.Length; j++)\\n            {\\n                var product = (long)nums2[i] * nums2[j];\\n                if (hash1.ContainsKey(product)) count = count + hash1[product];\\n            }\\n        }\\n        \\n        //Type 2\\n        for(int i = 0; i < nums1.Length; i++)\\n        {\\n            for(int j = i + 1; j < nums1.Length; j++)\\n            {\\n                var product = (long)nums1[i] * nums1[j];\\n                if (hash2.ContainsKey(product)) count = count + hash2[product];\\n            }\\n        }\\n        \\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338173,
                "title": "c-o-n-m-time-and-o-1-memory-100-faster-with-100-less-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        return fun(a,b)+fun(b,a);\\n    }\\n    int fun(vector<int>& a, vector<int>& b){ //simple O(1) two sum (kinda) for every x in a.\\n        ll n=a.size(),m=b.size(),ans=0;\\n        for(auto &x:a){\\n            ll tar=x; tar=tar*((ll)x);\\n            int i=0,j=m-1;\\n            while(i<j){\\n                ll t=b[i]; t=t*((ll)b[j]);\\n                if(t<tar)\\n                    i++;\\n                else if(t>tar)\\n                    j--;\\n                else{\\n                    if(b[i]==b[j]){\\n                        ll len=j-i+1;\\n                        ans+=((len)*(len-1))/2;\\n                        break;\\n                    }\\n                    ll cnt1=0,cnt2=0,x=b[i],y=b[j];\\n                    while(b[i]==x)\\n                    {i++;cnt1++;}\\n                    while(b[j]==y)\\n                    {j--;cnt2++;}\\n                    ans+=cnt1*cnt2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int numTriplets(vector<int>& a, vector<int>& b) {\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        return fun(a,b)+fun(b,a);\\n    }\\n    int fun(vector<int>& a, vector<int>& b){ //simple O(1) two sum (kinda) for every x in a.\\n        ll n=a.size(),m=b.size(),ans=0;\\n        for(auto &x:a){\\n            ll tar=x; tar=tar*((ll)x);\\n            int i=0,j=m-1;\\n            while(i<j){\\n                ll t=b[i]; t=t*((ll)b[j]);\\n                if(t<tar)\\n                    i++;\\n                else if(t>tar)\\n                    j--;\\n                else{\\n                    if(b[i]==b[j]){\\n                        ll len=j-i+1;\\n                        ans+=((len)*(len-1))/2;\\n                        break;\\n                    }\\n                    ll cnt1=0,cnt2=0,x=b[i],y=b[j];\\n                    while(b[i]==x)\\n                    {i++;cnt1++;}\\n                    while(b[j]==y)\\n                    {j--;cnt2++;}\\n                    ans+=cnt1*cnt2;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331579,
                "title": "just-two-passes-on-two-cases",
                "content": "```scala\\n  def numTriplets(num1: Array[Int], num2: Array[Int]): Int = {\\n\\n    def f(dou: Array[Double], opp: Array[Double]): Int = {\\n      var count = 0\\n      dou.foreach(tar => {\\n        var s = 0\\n        var e = opp.length - 1\\n        while (s < e) {\\n          if (opp(s) * opp(e) < tar) {\\n            s += 1\\n          } else if (opp(s) * opp(e) > tar) {\\n            e -= 1\\n          } else {\\n            if (opp(s) == opp(e)) {\\n              var tot = e - s\\n              count += (1 + tot) * tot / 2\\n              s = e + 1\\n            } else {\\n              var a = s\\n              var b = e\\n              while (a < opp.length && opp(a) == opp(s)) a += 1\\n              while (b >= a && opp(e) == opp(b)) b -= 1\\n              count += (a - s) * (e - b)\\n              s = a\\n              e = b\\n            }\\n          }\\n        }\\n      })\\n      count\\n    }\\n\\n    f(num1.map(Math.pow(_, 2)), num2.map(_.toDouble).sortWith(_ < _)) + f(\\n      num2.map(Math.pow(_, 2)),\\n      num1.map(_.toDouble).sortWith(_ < _)\\n    )\\n\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def numTriplets(num1: Array[Int], num2: Array[Int]): Int = {\\n\\n    def f(dou: Array[Double], opp: Array[Double]): Int = {\\n      var count = 0\\n      dou.foreach(tar => {\\n        var s = 0\\n        var e = opp.length - 1\\n        while (s < e) {\\n          if (opp(s) * opp(e) < tar) {\\n            s += 1\\n          } else if (opp(s) * opp(e) > tar) {\\n            e -= 1\\n          } else {\\n            if (opp(s) == opp(e)) {\\n              var tot = e - s\\n              count += (1 + tot) * tot / 2\\n              s = e + 1\\n            } else {\\n              var a = s\\n              var b = e\\n              while (a < opp.length && opp(a) == opp(s)) a += 1\\n              while (b >= a && opp(e) == opp(b)) b -= 1\\n              count += (a - s) * (e - b)\\n              s = a\\n              e = b\\n            }\\n          }\\n        }\\n      })\\n      count\\n    }\\n\\n    f(num1.map(Math.pow(_, 2)), num2.map(_.toDouble).sortWith(_ < _)) + f(\\n      num2.map(Math.pow(_, 2)),\\n      num1.map(_.toDouble).sortWith(_ < _)\\n    )\\n\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1293341,
                "title": "golang-solution",
                "content": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n    m1, m2 := make(map[int]int), make(map[int]int)\\n    for _, v := range nums1 {\\n        m1[v*v]++\\n    }\\n    for _, v := range nums2 {\\n        m2[v*v]++\\n    }\\n    count:=0\\n    fmt.Println(\"m1, m2:\" ,m1,m2)\\n    for k, v := range m1 {\\n        for i:=0 ; i<len(nums2); i++ {\\n            for j:=i+1; j< len(nums2); j++ {\\n                if nums2[i]*nums2[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    for k, v := range m2 {\\n        for i:=0 ; i<len(nums1); i++ {\\n            for j:=i+1; j< len(nums1); j++ {\\n                if nums1[i]*nums1[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n    m1, m2 := make(map[int]int), make(map[int]int)\\n    for _, v := range nums1 {\\n        m1[v*v]++\\n    }\\n    for _, v := range nums2 {\\n        m2[v*v]++\\n    }\\n    count:=0\\n    fmt.Println(\"m1, m2:\" ,m1,m2)\\n    for k, v := range m1 {\\n        for i:=0 ; i<len(nums2); i++ {\\n            for j:=i+1; j< len(nums2); j++ {\\n                if nums2[i]*nums2[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    for k, v := range m2 {\\n        for i:=0 ; i<len(nums1); i++ {\\n            for j:=i+1; j< len(nums1); j++ {\\n                if nums1[i]*nums1[j] == k {\\n                    count+=v\\n                }\\n            }\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1280561,
                "title": "c-using-2-hashmap-type-casting-to-long-long-everywhere-o-nums1-size-2-nums2-size-2",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n      unordered_map<ll, int> m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll x = (ll) nums1[i] * (ll)nums1[i];\\n            m[x]++;\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums2.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums2.size(); j++)\\n            {\\n                ll val = (ll) nums2[i] * (ll)nums2[j];\\n                if(m.find(val) != m.end())\\n                {\\n                    cnt=cnt+m[val];\\n                }\\n            }\\n        }\\n         unordered_map<ll, int> m1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ll x = (ll) nums2[i] * (ll)nums2[i];\\n            m1[x]++;\\n        }\\n        int cnt1 = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums1.size(); j++)\\n            {\\n                ll val = (ll) nums1[i] * (ll)nums1[j];\\n                if(m1.find(val) != m1.end()){\\n                    cnt1 = cnt1 + m1[val];\\n                }\\n            }\\n        }\\n        return cnt+cnt1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2)\\n    {\\n      unordered_map<ll, int> m;\\n        for(int i=0;i<nums1.size();i++)\\n        {\\n            ll x = (ll) nums1[i] * (ll)nums1[i];\\n            m[x]++;\\n        }\\n        int cnt = 0;\\n        for(int i = 0; i < nums2.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums2.size(); j++)\\n            {\\n                ll val = (ll) nums2[i] * (ll)nums2[j];\\n                if(m.find(val) != m.end())\\n                {\\n                    cnt=cnt+m[val];\\n                }\\n            }\\n        }\\n         unordered_map<ll, int> m1;\\n        for(int i=0;i<nums2.size();i++)\\n        {\\n            ll x = (ll) nums2[i] * (ll)nums2[i];\\n            m1[x]++;\\n        }\\n        int cnt1 = 0;\\n        for(int i = 0; i < nums1.size(); i++)\\n        {\\n            for(int j = i + 1; j < nums1.size(); j++)\\n            {\\n                ll val = (ll) nums1[i] * (ll)nums1[j];\\n                if(m1.find(val) != m1.end()){\\n                    cnt1 = cnt1 + m1[val];\\n                }\\n            }\\n        }\\n        return cnt+cnt1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1276018,
                "title": "ruby-100-100",
                "content": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef num_triplets(nums1, nums2)\\n  (f(nums1, nums2) + f(nums2, nums1)) / 2\\nend\\n\\ndef f(a, b)\\n  h = b.tally\\n  a.sum do |x|\\n    s = x * x\\n    h.sum do |y, c|\\n      s % y == 0 ? c * (x == y ? c - 1 : h.fetch(s / y, 0)) : 0\\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums1\\n# @param {Integer[]} nums2\\n# @return {Integer}\\ndef num_triplets(nums1, nums2)\\n  (f(nums1, nums2) + f(nums2, nums1)) / 2\\nend\\n\\ndef f(a, b)\\n  h = b.tally\\n  a.sum do |x|\\n    s = x * x\\n    h.sum do |y, c|\\n      s % y == 0 ? c * (x == y ? c - 1 : h.fetch(s / y, 0)) : 0\\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238485,
                "title": "typescript-map-o-n-m",
                "content": "```\\nfunction fromSecond(num:number[],target:number){\\n    let mp=new Map(),\\n        len:number=num.length,\\n        ans:number=0;\\n    mp.set(num[len-1],1);\\n    for (let i=len-2;i>=0;i--){\\n        if (target%num[i]==0){\\n            let want:number=Math.floor(target/num[i]);\\n            if (mp.has(want)){\\n                if (want*num[i]==target){\\n                    ans+=mp.get(want);\\n                }\\n            }\\n        }\\n        if (mp.has(num[i])){\\n            mp.set(num[i],mp.get(num[i])+1);\\n        }else{\\n            mp.set(num[i],1);\\n        }\\n    }\\n    return ans;\\n}\\nfunction numTriplets(num1: number[], num2: number[]): number {\\n    let ans:number=0;\\n    for (let value of num1){\\n        ans+=fromSecond(num2,value*value);\\n    }\\n    for (let value of num2){\\n        ans+=fromSecond(num1,value*value);\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction fromSecond(num:number[],target:number){\\n    let mp=new Map(),\\n        len:number=num.length,\\n        ans:number=0;\\n    mp.set(num[len-1],1);\\n    for (let i=len-2;i>=0;i--){\\n        if (target%num[i]==0){\\n            let want:number=Math.floor(target/num[i]);\\n            if (mp.has(want)){\\n                if (want*num[i]==target){\\n                    ans+=mp.get(want);\\n                }\\n            }\\n        }\\n        if (mp.has(num[i])){\\n            mp.set(num[i],mp.get(num[i])+1);\\n        }else{\\n            mp.set(num[i],1);\\n        }\\n    }\\n    return ans;\\n}\\nfunction numTriplets(num1: number[], num2: number[]): number {\\n    let ans:number=0;\\n    for (let value of num1){\\n        ans+=fromSecond(num2,value*value);\\n    }\\n    for (let value of num2){\\n        ans+=fromSecond(num1,value*value);\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1234891,
                "title": "javascript",
                "content": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map} duplets\\n */\\nconst getAllPossibleMultipliedPais = nums => {\\n    const duplets = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            const dupletRes = nums[i] * nums[j];\\n            duplets.set(dupletRes, (duplets.get(dupletRes) || 0) + 1);\\n        }\\n    }\\n    \\n    return duplets;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map}\\n */\\nconst getAllSquares = nums => {\\n    const squares = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        const squareRes = nums[i] * nums[i];\\n        squares.set(squareRes, (squares.get(squareRes) || 0) + 1);\\n    }\\n    \\n    return squares;\\n}\\n\\nconst getMatchesCount = (dupletsMap, squaresMap) => {\\n    let matches = 0;\\n    for (let [duplet, freq] of dupletsMap) {\\n        const matchedSquareFreq = squaresMap.get(duplet);\\n        if (matchedSquareFreq === undefined) {\\n            continue;\\n        }\\n        \\n        matches += freq * matchedSquareFreq;\\n    }\\n    \\n    return matches;\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst numTriplets = (nums1, nums2) => \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums1),\\n    getAllSquares(nums2)\\n) \\n+ \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums2),\\n    getAllSquares(nums1)\\n)\\n```",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map} duplets\\n */\\nconst getAllPossibleMultipliedPais = nums => {\\n    const duplets = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i + 1; j < nums.length; j++) {\\n            const dupletRes = nums[i] * nums[j];\\n            duplets.set(dupletRes, (duplets.get(dupletRes) || 0) + 1);\\n        }\\n    }\\n    \\n    return duplets;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @return {Map}\\n */\\nconst getAllSquares = nums => {\\n    const squares = new Map();\\n    for (let i = 0; i < nums.length; i++) {\\n        const squareRes = nums[i] * nums[i];\\n        squares.set(squareRes, (squares.get(squareRes) || 0) + 1);\\n    }\\n    \\n    return squares;\\n}\\n\\nconst getMatchesCount = (dupletsMap, squaresMap) => {\\n    let matches = 0;\\n    for (let [duplet, freq] of dupletsMap) {\\n        const matchedSquareFreq = squaresMap.get(duplet);\\n        if (matchedSquareFreq === undefined) {\\n            continue;\\n        }\\n        \\n        matches += freq * matchedSquareFreq;\\n    }\\n    \\n    return matches;\\n}\\n\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nconst numTriplets = (nums1, nums2) => \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums1),\\n    getAllSquares(nums2)\\n) \\n+ \\ngetMatchesCount(\\n    getAllPossibleMultipliedPais(nums2),\\n    getAllSquares(nums1)\\n)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222895,
                "title": "swift-solution",
                "content": "Swift solution\\n```\\nclass Solution {\\n    func helper(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let c2 = nums2.count\\n        var products = [Int: Int]()\\n        for i in 0..<(c2 - 1) {\\n            for j in (i + 1)..<c2 {\\n                products[nums2[i] * nums2[j], default: Int(0)] += 1\\n            }\\n        }\\n        return nums1.reduce(into: Int(0), { if let productCount = products[$1 * $1] { $0 += productCount } })\\n    }\\n    func numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func helper(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        let c2 = nums2.count\\n        var products = [Int: Int]()\\n        for i in 0..<(c2 - 1) {\\n            for j in (i + 1)..<c2 {\\n                products[nums2[i] * nums2[j], default: Int(0)] += 1\\n            }\\n        }\\n        return nums1.reduce(into: Int(0), { if let productCount = products[$1 * $1] { $0 += productCount } })\\n    }\\n    func numTriplets(_ nums1: [Int], _ nums2: [Int]) -> Int {\\n        return helper(nums1, nums2) + helper(nums2, nums1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195046,
                "title": "concise-python-solution-similar-to-2-sum",
                "content": "```\\n    def triplets(self, counter, arr):\\n        result = 0\\n        for num in arr:\\n            for k, v in counter.items():\\n                if num == k:\\n                    result += v*(v-1)/2\\n                elif k < num and (num*num)%k == 0:\\n                    result += counter[int((num*num)/k)] * v\\n        return int(result)\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        counter1, counter2, result = Counter(nums1), Counter(nums2), 0\\n        return self.triplets(counter2, nums1) + self.triplets(counter1, nums2)\\n```",
                "solutionTags": [],
                "code": "```\\n    def triplets(self, counter, arr):\\n        result = 0\\n        for num in arr:\\n            for k, v in counter.items():\\n                if num == k:\\n                    result += v*(v-1)/2\\n                elif k < num and (num*num)%k == 0:\\n                    result += counter[int((num*num)/k)] * v\\n        return int(result)\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        counter1, counter2, result = Counter(nums1), Counter(nums2), 0\\n        return self.triplets(counter2, nums1) + self.triplets(counter1, nums2)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1162603,
                "title": "i-can-t-understand-what-s-wrong-with-my-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int checkproduct(int a, vector<int>& arr){\\n        int count=0;\\n        int n=arr.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]*arr[j]==a)count++;\\n            }\\n        }\\n        return count;   \\n    }   \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        for(int i=0;i<n1;i++){\\n            //if(checkproduct(nums1[i]*nums1[i],nums2))\\n                ans+=checkproduct(nums1[i]*nums1[i],nums2);\\n        }\\n        for(int i=0;i<n2;i++){\\n            //if(checkproduct(nums2[i]*nums2[i],nums1))\\n                ans+=checkproduct(nums2[i]*nums2[i],nums2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int checkproduct(int a, vector<int>& arr){\\n        int count=0;\\n        int n=arr.size();\\n        for(int i=0;i<n-1;i++){\\n            for(int j=i+1;j<n;j++){\\n                if(arr[i]*arr[j]==a)count++;\\n            }\\n        }\\n        return count;   \\n    }   \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans=0;\\n        int n1=nums1.size();\\n        int n2=nums2.size();\\n        for(int i=0;i<n1;i++){\\n            //if(checkproduct(nums1[i]*nums1[i],nums2))\\n                ans+=checkproduct(nums1[i]*nums1[i],nums2);\\n        }\\n        for(int i=0;i<n2;i++){\\n            //if(checkproduct(nums2[i]*nums2[i],nums1))\\n                ans+=checkproduct(nums2[i]*nums2[i],nums2);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1150908,
                "title": "java-time-o-m-n-short-98-native-data-structure",
                "content": "```\\n    private int singleNumTriplets(int[] nums1, int[] nums2) {\\n        int[] b = new int[100001];\\n        for (int i = 0; i < nums2.length; i++) {\\n            b[nums2[i]]++;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums1.length - 1; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                int st = (int)Math.sqrt((long)nums1[i]*nums1[j]);\\n                if (st*st == nums1[i]*nums1[j]) {\\n                    ans +=b[st];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return singleNumTriplets(nums1,nums2) + singleNumTriplets(nums2,nums1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    private int singleNumTriplets(int[] nums1, int[] nums2) {\\n        int[] b = new int[100001];\\n        for (int i = 0; i < nums2.length; i++) {\\n            b[nums2[i]]++;\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < nums1.length - 1; i++) {\\n            for (int j = i + 1; j < nums1.length; j++) {\\n                int st = (int)Math.sqrt((long)nums1[i]*nums1[j]);\\n                if (st*st == nums1[i]*nums1[j]) {\\n                    ans +=b[st];\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return singleNumTriplets(nums1,nums2) + singleNumTriplets(nums2,nums1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1150155,
                "title": "javascript-faster-than-50",
                "content": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(numsA, numsB) {\\n    function addToMap(val, map) {\\n        map.set(val, 1 + (map.get(val) || 0))\\n    }\\n    \\n    const mapProductsA = new Map()\\n    const mapSquaresA = new Map()\\n    const mapProductsB = new Map()\\n    const mapSquaresB = new Map()\\n    \\n    \\n    for (const val of numsA.values())\\n        addToMap(val ** 2, mapSquaresA)\\n    for (const val of numsB.values())\\n        addToMap(val ** 2, mapSquaresB)\\n    \\n    for (let i = 0, len = numsA.length; i < len; i++) {\\n        const valI = numsA[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsA[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsA)\\n        }\\n    }\\n    \\n    for (let i = 0, len = numsB.length; i < len; i++) {\\n        const valI = numsB[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsB[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsB)\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [squareA, countA] of mapSquaresA.entries()) {\\n        const countB = mapProductsB.get(squareA) || 0\\n        let outcome = countA * countB\\n        result += outcome\\n    }\\n    for (const [squareB, countB] of mapSquaresB.entries()) {\\n        const countA = mapProductsA.get(squareB) || 0\\n        let outcome = countB * countA\\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums1\\n * @param {number[]} nums2\\n * @return {number}\\n */\\nvar numTriplets = function(numsA, numsB) {\\n    function addToMap(val, map) {\\n        map.set(val, 1 + (map.get(val) || 0))\\n    }\\n    \\n    const mapProductsA = new Map()\\n    const mapSquaresA = new Map()\\n    const mapProductsB = new Map()\\n    const mapSquaresB = new Map()\\n    \\n    \\n    for (const val of numsA.values())\\n        addToMap(val ** 2, mapSquaresA)\\n    for (const val of numsB.values())\\n        addToMap(val ** 2, mapSquaresB)\\n    \\n    for (let i = 0, len = numsA.length; i < len; i++) {\\n        const valI = numsA[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsA[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsA)\\n        }\\n    }\\n    \\n    for (let i = 0, len = numsB.length; i < len; i++) {\\n        const valI = numsB[i]\\n        for (let j = 1 + i; j < len; j++) {\\n            const valJ = numsB[j]\\n            const product = valI * valJ\\n            addToMap(product, mapProductsB)\\n        }\\n    }\\n    \\n    \\n    let result = 0\\n    for (const [squareA, countA] of mapSquaresA.entries()) {\\n        const countB = mapProductsB.get(squareA) || 0\\n        let outcome = countA * countB\\n        result += outcome\\n    }\\n    for (const [squareB, countB] of mapSquaresB.entries()) {\\n        const countA = mapProductsA.get(squareB) || 0\\n        let outcome = countB * countA\\n        result += outcome\\n    }\\n    \\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1127152,
                "title": "python-super-brute-force-solution",
                "content": "\\tn1, n2 = len(nums1), len(nums2)\\n\\th1, h2 = {}, {}\\n\\tresult = 0\\n\\tfor i in range(n1):\\n\\t\\tfor j in range(i + 1, n1):\\n\\t\\t\\tp = nums1[i] * nums1[j]\\n\\t\\t\\th1[p] = h1.get(p, 0) + 1\\n\\tfor num in nums2:\\n\\t\\tp = num * num\\n\\t\\tif h1.get(p):\\n\\t\\t\\tresult += h1[p]\\n\\tfor i in range(n2):\\n\\t\\tfor j in range(i + 1, n2):\\n\\t\\t\\tp = nums2[i] * nums2[j]\\n\\t\\t\\th2[p] = h2.get(p, 0) + 1\\n\\tfor num in nums1:\\n\\t\\tp = num * num\\n\\t\\tif h2.get(p):\\n\\t\\t\\tresult += h2[p]\\n\\treturn result",
                "solutionTags": [],
                "code": "\\tn1, n2 = len(nums1), len(nums2)\\n\\th1, h2 = {}, {}\\n\\tresult = 0\\n\\tfor i in range(n1):\\n\\t\\tfor j in range(i + 1, n1):\\n\\t\\t\\tp = nums1[i] * nums1[j]\\n\\t\\t\\th1[p] = h1.get(p, 0) + 1\\n\\tfor num in nums2:\\n\\t\\tp = num * num\\n\\t\\tif h1.get(p):\\n\\t\\t\\tresult += h1[p]\\n\\tfor i in range(n2):\\n\\t\\tfor j in range(i + 1, n2):\\n\\t\\t\\tp = nums2[i] * nums2[j]\\n\\t\\t\\th2[p] = h2.get(p, 0) + 1\\n\\tfor num in nums1:\\n\\t\\tp = num * num\\n\\t\\tif h2.get(p):\\n\\t\\t\\tresult += h2[p]\\n\\treturn result",
                "codeTag": "Unknown"
            },
            {
                "id": 1026856,
                "title": "python3-3-lines-easy-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        C1, C2 = Counter(x*x for x in nums1), Counter(x*x for x in nums2)\\n        f = lambda A, C: sum(C[A[i]*A[j]] for i in range(len(A)) for j in range(i+1, len(A)))\\n        return f(nums1, C2) + f(nums2, C1)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        C1, C2 = Counter(x*x for x in nums1), Counter(x*x for x in nums2)\\n        f = lambda A, C: sum(C[A[i]*A[j]] for i in range(len(A)) for j in range(i+1, len(A)))\\n        return f(nums1, C2) + f(nums2, C1)",
                "codeTag": "Java"
            },
            {
                "id": 1025055,
                "title": "c-13-line",
                "content": "```\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return help(nums1, nums2) + help(nums2, nums1);\\n    }\\n    \\n    int help(vector<int>& v, vector<int>& u){\\n        unordered_map<long,int> mp1, mp2;\\n        for(auto x:v) mp1[long(x)*x]++;\\n        for(auto x:u) mp2[x]++;\\n        int res = 0;\\n        for(auto x:u){\\n            for(auto [y, cnt] : mp1){\\n                if(y % x !=0) continue;\\n                res += cnt * (mp2[y/x] - (x == y/x));\\n            }\\n        }\\n        return res/2;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return help(nums1, nums2) + help(nums2, nums1);\\n    }\\n    \\n    int help(vector<int>& v, vector<int>& u){\\n        unordered_map<long,int> mp1, mp2;\\n        for(auto x:v) mp1[long(x)*x]++;\\n        for(auto x:u) mp2[x]++;\\n        int res = 0;\\n        for(auto x:u){\\n            for(auto [y, cnt] : mp1){\\n                if(y % x !=0) continue;\\n                res += cnt * (mp2[y/x] - (x == y/x));\\n            }\\n        }\\n        return res/2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1020379,
                "title": "c-c-o-mn-with-explanation-translated-to-c",
                "content": "This is my translation of [C++ O(MN) with explanation](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation) into C.\\n\\nWhat a difference a language makes!  In C, you have to do _a lot_ of things by hand.  (FWIW, this is the fastest C implementation so far.)\\n\\n```c\\n/* Approach copied from\\n *   https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation\\n *\\n */\\n\\n#include <search.h>\\n\\n/* We need a NUL-terminated key to use with the hash table.  This integer\\n * representation is faster to calculate than calling sprintf().\\n */\\nstatic void\\nint2key (int v, char key[8])\\n{\\n    /* Assumption key is non-negative */\\n    key[0] = 0x80 | (v >> 28);\\n    key[1] = 0x80 | (v >> 21);\\n    key[2] = 0x80 | (v >> 14);\\n    key[3] = 0x80 | (v >> 7);\\n    key[4] = 0x80 | (v >> 0);\\n    key[5] = 0; /* NUL byte needed for termination */\\n}\\n\\nstruct elem\\n{\\n    int         num;        /* Original number */\\n    unsigned    count;      /* Number of occurrences */\\n    char        key[8];     /* NUL-terminated representation of `num\\' */\\n};\\n\\n/* Constraints: */\\n#define MAX_ELEMS 1000\\n#define MAX_NUM 100000\\n\\n#define DEBUG 0\\n\\n\\nstatic int\\nlookup_freq (int v)\\n{\\n    char key[8];\\n    ENTRY *entry;\\n    \\n    int2key(v, key);\\n    entry = hsearch((ENTRY) { .key = key, }, FIND);\\n    if (entry)\\n        return ((struct elem *) entry->data)->count;\\n    else\\n        return 0;\\n}\\n\\n\\nstatic int\\ncount (const int *a, int a_count, const int *b, int b_count)\\n{\\n    /* XXX assume all allocations are successul */\\n    struct elem *elems, *el;\\n    ENTRY *entry;\\n    unsigned n_elems, j;\\n    long target, square;\\n    char key[8];\\n    int i, count;\\n    \\n    if (DEBUG)\\n        printf(\"called %s\\\\n\", __func__);\\n    \\n    /* Calculate frequency table */\\n    elems = malloc(sizeof(elems[0]) * MAX_ELEMS);\\n    n_elems = 0;\\n    hcreate(MAX_ELEMS);\\n    for (i = 0; i < b_count; ++i)\\n    {\\n        el = &elems[n_elems];\\n        int2key(b[i], el->key);\\n        entry = hsearch((ENTRY) { .key = el->key, .data = el}, ENTER);\\n        /* again, assume success */\\n        if (entry->data == el)\\n        {\\n            if (DEBUG)\\n                printf(\"new element for %d\\\\n\", b[i]);\\n            el->count = 1;\\n            el->num = b[i];\\n            ++n_elems;\\n        }\\n        else\\n            ++((struct elem *) entry->data)->count;\\n    }\\n    \\n    count = 0;\\n    for (i = 0; i < a_count; ++i)\\n    {\\n        square = (long) a[i] * (long) a[i];\\n        if (DEBUG)\\n            printf(\"square: %ld\\\\n\", square);\\n        for (j = 0; j < n_elems; ++j)\\n        {\\n            if (DEBUG)\\n                printf(\"elems[%u] = { num: %d, count: %u }\\\\n\", j, elems[j].num, elems[j].count);\\n            if (square % elems[j].num)\\n                continue;\\n            target = square / elems[j].num;\\n            if (target > MAX_NUM)\\n                continue;\\n            int2key((int) target, key);\\n            entry = hsearch((ENTRY) { .key = key, }, FIND);\\n            if (entry)\\n            {\\n                el = entry->data;\\n                if (target == elems[j].num)\\n                    count += el->count * (el->count - 1);\\n                else\\n                    count += el->count * lookup_freq(square / target);\\n                if (DEBUG)\\n                    printf(\"found target %ld, new count: %d\\\\n\", target, count);\\n            }\\n            else if (DEBUG)\\n                printf(\"did not find target %ld\\\\n\", target);\\n        }\\n    }\\n    \\n    hdestroy();\\n    free(elems);\\n    \\n    return count / 2;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    return count(nums1, nums1Size, nums2, nums2Size)\\n         + count(nums2, nums2Size, nums1, nums1Size);\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\n/* Approach copied from\\n *   https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/831519/C%2B%2B-O(MN)-with-explanation\\n *\\n */\\n\\n#include <search.h>\\n\\n/* We need a NUL-terminated key to use with the hash table.  This integer\\n * representation is faster to calculate than calling sprintf().\\n */\\nstatic void\\nint2key (int v, char key[8])\\n{\\n    /* Assumption key is non-negative */\\n    key[0] = 0x80 | (v >> 28);\\n    key[1] = 0x80 | (v >> 21);\\n    key[2] = 0x80 | (v >> 14);\\n    key[3] = 0x80 | (v >> 7);\\n    key[4] = 0x80 | (v >> 0);\\n    key[5] = 0; /* NUL byte needed for termination */\\n}\\n\\nstruct elem\\n{\\n    int         num;        /* Original number */\\n    unsigned    count;      /* Number of occurrences */\\n    char        key[8];     /* NUL-terminated representation of `num\\' */\\n};\\n\\n/* Constraints: */\\n#define MAX_ELEMS 1000\\n#define MAX_NUM 100000\\n\\n#define DEBUG 0\\n\\n\\nstatic int\\nlookup_freq (int v)\\n{\\n    char key[8];\\n    ENTRY *entry;\\n    \\n    int2key(v, key);\\n    entry = hsearch((ENTRY) { .key = key, }, FIND);\\n    if (entry)\\n        return ((struct elem *) entry->data)->count;\\n    else\\n        return 0;\\n}\\n\\n\\nstatic int\\ncount (const int *a, int a_count, const int *b, int b_count)\\n{\\n    /* XXX assume all allocations are successul */\\n    struct elem *elems, *el;\\n    ENTRY *entry;\\n    unsigned n_elems, j;\\n    long target, square;\\n    char key[8];\\n    int i, count;\\n    \\n    if (DEBUG)\\n        printf(\"called %s\\\\n\", __func__);\\n    \\n    /* Calculate frequency table */\\n    elems = malloc(sizeof(elems[0]) * MAX_ELEMS);\\n    n_elems = 0;\\n    hcreate(MAX_ELEMS);\\n    for (i = 0; i < b_count; ++i)\\n    {\\n        el = &elems[n_elems];\\n        int2key(b[i], el->key);\\n        entry = hsearch((ENTRY) { .key = el->key, .data = el}, ENTER);\\n        /* again, assume success */\\n        if (entry->data == el)\\n        {\\n            if (DEBUG)\\n                printf(\"new element for %d\\\\n\", b[i]);\\n            el->count = 1;\\n            el->num = b[i];\\n            ++n_elems;\\n        }\\n        else\\n            ++((struct elem *) entry->data)->count;\\n    }\\n    \\n    count = 0;\\n    for (i = 0; i < a_count; ++i)\\n    {\\n        square = (long) a[i] * (long) a[i];\\n        if (DEBUG)\\n            printf(\"square: %ld\\\\n\", square);\\n        for (j = 0; j < n_elems; ++j)\\n        {\\n            if (DEBUG)\\n                printf(\"elems[%u] = { num: %d, count: %u }\\\\n\", j, elems[j].num, elems[j].count);\\n            if (square % elems[j].num)\\n                continue;\\n            target = square / elems[j].num;\\n            if (target > MAX_NUM)\\n                continue;\\n            int2key((int) target, key);\\n            entry = hsearch((ENTRY) { .key = key, }, FIND);\\n            if (entry)\\n            {\\n                el = entry->data;\\n                if (target == elems[j].num)\\n                    count += el->count * (el->count - 1);\\n                else\\n                    count += el->count * lookup_freq(square / target);\\n                if (DEBUG)\\n                    printf(\"found target %ld, new count: %d\\\\n\", target, count);\\n            }\\n            else if (DEBUG)\\n                printf(\"did not find target %ld\\\\n\", target);\\n        }\\n    }\\n    \\n    hdestroy();\\n    free(elems);\\n    \\n    return count / 2;\\n}\\n\\nint numTriplets(int* nums1, int nums1Size, int* nums2, int nums2Size){\\n    return count(nums1, nums1Size, nums2, nums2Size)\\n         + count(nums2, nums2Size, nums1, nums1Size);\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1019760,
                "title": "go-68ms-easy-solution",
                "content": "```\\nfunc gen(nums []int) map[int]int {\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tfor y := i + 1; y < len(nums); y++ {\\n\\t\\t\\tm[nums[i]*nums[y]]++\\n\\t\\t}\\n\\t}\\n\\treturn m\\n}\\n\\nfunc find(m map[int]int, nums int) int {\\n\\treturn m[nums]\\n}\\n\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tm1, m2 := gen(nums1), gen(nums2)\\n\\n\\tvar c int\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tc += find(m2, nums1[i]*nums1[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(nums2); i++ {\\n\\t\\tc += find(m1, nums2[i]*nums2[i])\\n\\t}\\n\\treturn c\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc gen(nums []int) map[int]int {\\n\\tm := make(map[int]int)\\n\\tfor i := 0; i < len(nums)-1; i++ {\\n\\t\\tfor y := i + 1; y < len(nums); y++ {\\n\\t\\t\\tm[nums[i]*nums[y]]++\\n\\t\\t}\\n\\t}\\n\\treturn m\\n}\\n\\nfunc find(m map[int]int, nums int) int {\\n\\treturn m[nums]\\n}\\n\\nfunc numTriplets(nums1 []int, nums2 []int) int {\\n\\tm1, m2 := gen(nums1), gen(nums2)\\n\\n\\tvar c int\\n\\tfor i := 0; i < len(nums1); i++ {\\n\\t\\tc += find(m2, nums1[i]*nums1[i])\\n\\t}\\n\\n\\tfor i := 0; i < len(nums2); i++ {\\n\\t\\tc += find(m1, nums2[i]*nums2[i])\\n\\t}\\n\\treturn c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1019725,
                "title": "c-260ms-55-100ms-63-two-solution-very-easy-to-anderstand-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;                   //for all products for arr1\\n      unordered_map<long,int> st2;                   //for all products for arr2\\n      \\n      for(int i = 0; i < nums1.size(); i++)              //contain all products from arr1 to hash\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums2.size(); i++)                  //contain all products from arr2 to hash\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums1.size(); i++){             //and check\\n        long t = long(nums1[i])*nums1[i];\\n        if(st2.count(t)) ans += st2[t];\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st1.count(t)) ans += st1[t];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\\nif we put in hash squared numbers\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;\\n      unordered_map<long,int> st2;\\n      \\n      for(int i = 0; i < nums1.size(); i++){\\n        long t = long(nums1[i])*nums1[i];\\n        if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums1.size(); i++)\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st2.count(t)) ans += st2[t];\\n        }\\n      \\n      \\n      for(int i = 0; i < nums2.size(); i++)\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st1.count(t)) ans += st1[t];\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;                   //for all products for arr1\\n      unordered_map<long,int> st2;                   //for all products for arr2\\n      \\n      for(int i = 0; i < nums1.size(); i++)              //contain all products from arr1 to hash\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums2.size(); i++)                  //contain all products from arr2 to hash\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n        }\\n      \\n      for(int i = 0; i < nums1.size(); i++){             //and check\\n        long t = long(nums1[i])*nums1[i];\\n        if(st2.count(t)) ans += st2[t];\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st1.count(t)) ans += st1[t];\\n      }\\n      \\n      return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n      int ans = 0;\\n      unordered_map<long,int> st1;\\n      unordered_map<long,int> st2;\\n      \\n      for(int i = 0; i < nums1.size(); i++){\\n        long t = long(nums1[i])*nums1[i];\\n        if(st1.count(t)) st1[t]++;\\n          else st1[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums2.size(); i++){\\n        long t = long(nums2[i])*nums2[i];\\n        if(st2.count(t)) st2[t]++;\\n          else st2[t] = 1;\\n      }\\n      \\n      for(int i = 0; i < nums1.size(); i++)\\n        for(int j = i + 1; j < nums1.size(); j++){\\n          long t = long(nums1[i])*nums1[j];\\n          if(st2.count(t)) ans += st2[t];\\n        }\\n      \\n      \\n      for(int i = 0; i < nums2.size(); i++)\\n        for(int j = i + 1; j < nums2.size(); j++){\\n          long t = long(nums2[i])*nums2[j];\\n          if(st1.count(t)) ans += st1[t];\\n        }\\n      \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011388,
                "title": "c-99-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int a[100001]={0};\\n        int b[100001]={0};\\n        for(int i=0;i<nums1.size();i++)\\n            a[nums1[i]]++;\\n        for(int j=0;j<nums2.size();j++)\\n            b[nums2[j]]++;\\n             \\n        vector<int>::iterator ip;     \\n        ip=unique(nums1.begin(),nums1.end());\\n        nums1.resize(distance(nums1.begin(),ip));\\n        ip=unique(nums2.begin(),nums2.end());\\n        nums2.resize(distance(nums2.begin(),ip));\\n        \\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n             {\\n                 int start=0,end=nums2.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums2[start]==nums1[i] )\\n                         ans+=a[nums1[i]]*((b[nums2[start]]*(b[nums2[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]==nums2[start]* 1ll *nums2[end])\\n                     {\\n                         ans+=a[nums1[i]]*b[nums2[start]]*b[nums2[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]<nums2[start]* 1ll *nums2[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }\\n        // cout<<ans<<\" \";\\n          for(int i=0;i<nums2.size();i++)\\n             {\\n                 int start=0,end=nums1.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums1[start]==nums2[i])\\n                         ans+=b[nums2[i]]*((a[nums1[start]]*(a[nums1[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]==nums1[start]* 1ll *nums1[end])\\n                     {\\n                         ans+=b[nums2[i]]*a[nums1[start]]*a[nums1[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]<nums1[start]* 1ll *nums1[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }   \\n             return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(),nums1.end());\\n        sort(nums2.begin(),nums2.end());\\n        int a[100001]={0};\\n        int b[100001]={0};\\n        for(int i=0;i<nums1.size();i++)\\n            a[nums1[i]]++;\\n        for(int j=0;j<nums2.size();j++)\\n            b[nums2[j]]++;\\n             \\n        vector<int>::iterator ip;     \\n        ip=unique(nums1.begin(),nums1.end());\\n        nums1.resize(distance(nums1.begin(),ip));\\n        ip=unique(nums2.begin(),nums2.end());\\n        nums2.resize(distance(nums2.begin(),ip));\\n        \\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++)\\n             {\\n                 int start=0,end=nums2.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums2[start]==nums1[i] )\\n                         ans+=a[nums1[i]]*((b[nums2[start]]*(b[nums2[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]==nums2[start]* 1ll *nums2[end])\\n                     {\\n                         ans+=a[nums1[i]]*b[nums2[start]]*b[nums2[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums1[i]* 1ll *nums1[i]<nums2[start]* 1ll *nums2[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }\\n        // cout<<ans<<\" \";\\n          for(int i=0;i<nums2.size();i++)\\n             {\\n                 int start=0,end=nums1.size()-1;\\n                 while(start<=end)\\n                 {\\n                     if(start==end)\\n                     {\\n                         if(nums1[start]==nums2[i])\\n                         ans+=b[nums2[i]]*((a[nums1[start]]*(a[nums1[start]]-1))/2);\\n                         start++;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]==nums1[start]* 1ll *nums1[end])\\n                     {\\n                         ans+=b[nums2[i]]*a[nums1[start]]*a[nums1[end]];\\n                         start++;\\n                         end--;\\n                     }\\n                     else if(nums2[i]* 1ll *nums2[i]<nums1[start]* 1ll *nums1[end])\\n                         end--;\\n                     else start++;\\n                 }\\n             }   \\n             return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1010182,
                "title": "c-2sum-like-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums1, vector<int>& nums2){\\n        int ret = 0;\\n        for(int i=0; i<nums1.size(); i++){\\n            int left = 0;\\n            int right = nums2.size()-1;\\n            long cur1 = (long)nums1[i] * (long)nums1[i];\\n            while(left <= right){\\n                long cur2 = (long)nums2[left] * (long)nums2[right];\\n                if(cur2 < cur1){\\n                    left++;\\n                }\\n                else if(cur2 > cur1){\\n                    right--;\\n                }\\n                else{\\n                    int lcnt = 1;\\n                    int rcnt = 1;\\n                    while(left+1 < nums2.size() && nums2[left] == nums2[left+1]){\\n                        lcnt++;\\n                        left++;\\n                    }\\n                    while(right-1 >= 0 && nums2[right] == nums2[right-1]){\\n                        rcnt++;\\n                        right--;\\n                    }\\n                    \\n                    if(nums2[left] != nums2[right]) ret += lcnt*rcnt;\\n                    else ret += lcnt*(rcnt-1)/2;\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return func(nums1,nums2)+func(nums2,nums1);\\n\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(vector<int>& nums1, vector<int>& nums2){\\n        int ret = 0;\\n        for(int i=0; i<nums1.size(); i++){\\n            int left = 0;\\n            int right = nums2.size()-1;\\n            long cur1 = (long)nums1[i] * (long)nums1[i];\\n            while(left <= right){\\n                long cur2 = (long)nums2[left] * (long)nums2[right];\\n                if(cur2 < cur1){\\n                    left++;\\n                }\\n                else if(cur2 > cur1){\\n                    right--;\\n                }\\n                else{\\n                    int lcnt = 1;\\n                    int rcnt = 1;\\n                    while(left+1 < nums2.size() && nums2[left] == nums2[left+1]){\\n                        lcnt++;\\n                        left++;\\n                    }\\n                    while(right-1 >= 0 && nums2[right] == nums2[right-1]){\\n                        rcnt++;\\n                        right--;\\n                    }\\n                    \\n                    if(nums2[left] != nums2[right]) ret += lcnt*rcnt;\\n                    else ret += lcnt*(rcnt-1)/2;\\n                    left++;\\n                    right--;\\n                }\\n            }\\n        }\\n        return ret;\\n    }\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        sort(nums1.begin(), nums1.end());\\n        sort(nums2.begin(), nums2.end());\\n        return func(nums1,nums2)+func(nums2,nums1);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997380,
                "title": "c-short-solution",
                "content": "Run-time is `O(N^2)`, space is `O(N)`.\\n\\n```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return count(nums1, nums2) + count(nums2, nums1);\\n    }\\n    \\n    int count(std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int64_t,int> m;\\n        for(const auto &n: a) ++m[(int64_t)n*n];\\n        int count{0};\\n        for(int i{0}, size{(int)b.size()}; i < size; ++i)\\n            for(int j{i+1}; j < size; ++j)\\n                if(m.count((int64_t)b[i]*b[j])) count += m[(int64_t)b[i]*b[j]];\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        return count(nums1, nums2) + count(nums2, nums1);\\n    }\\n    \\n    int count(std::vector<int>& a, std::vector<int>& b) {\\n        std::unordered_map<int64_t,int> m;\\n        for(const auto &n: a) ++m[(int64_t)n*n];\\n        int count{0};\\n        for(int i{0}, size{(int)b.size()}; i < size; ++i)\\n            for(int j{i+1}; j < size; ++j)\\n                if(m.count((int64_t)b[i]*b[j])) count += m[(int64_t)b[i]*b[j]];\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992805,
                "title": "p23-5",
                "content": "Like two su\\nLike two sum",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 990567,
                "title": "rust-68-ms-beats-100-of-solutions",
                "content": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         let mut ans = 0;\\n    let n1 = nums1.len();\\n    let n2 = nums2.len();\\n    let mut nums1_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    let mut nums2_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    for i in 0..n1 {\\n        for j in i + 1..n1 {\\n            let count = nums1_product.entry(nums1[i] as i64 * nums1[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for i in 0..n2 {\\n        for j in i + 1..n2 {\\n            let count = nums2_product.entry(nums2[i] as i64 * nums2[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for num in nums1 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums2_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    for num in nums2 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums1_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn num_triplets(nums1: Vec<i32>, nums2: Vec<i32>) -> i32 {\\n         let mut ans = 0;\\n    let n1 = nums1.len();\\n    let n2 = nums2.len();\\n    let mut nums1_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    let mut nums2_product: std::collections::HashMap<i64, i32> = std::collections::HashMap::new();\\n    for i in 0..n1 {\\n        for j in i + 1..n1 {\\n            let count = nums1_product.entry(nums1[i] as i64 * nums1[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for i in 0..n2 {\\n        for j in i + 1..n2 {\\n            let count = nums2_product.entry(nums2[i] as i64 * nums2[j] as i64).or_insert(0);\\n            *count += 1;\\n        }\\n    }\\n    for num in nums1 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums2_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    for num in nums2 {\\n        let num = num as i64;\\n        let target = num.pow(2);\\n        if let Some(value) = nums1_product.get(&target) {\\n            ans += value;\\n        }\\n    }\\n    ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 976084,
                "title": "my-c-solution-using-two-pointers",
                "content": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        sort(ALL(nums1)); sort(ALL(nums2));\\n        ans += helper(nums1, nums2);\\n        ans += helper(nums2, nums1);\\n        return ans;       \\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2){\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int res = 0;\\n        REP(i, n1){\\n            long target = (long)nums1[i] * (long)nums1[i];\\n            int l = 0, r = n2 - 1;\\n            while(l <= r){\\n                long now = (long)nums2[l] * (long)nums2[r];\\n                if(now < target){\\n                    l++;\\n                    continue;\\n                }else if(now > target){\\n                    r--;\\n                    continue;\\n                }\\n                int lcnt = 0, rcnt = 0;\\n                int lv = nums2[l], rv = nums2[r];\\n                while(l < n2 && nums2[l] == lv){\\n                    l++;\\n                    lcnt++;\\n                }\\n                while(r >= 0 && nums2[r] == rv){\\n                    r--;\\n                    rcnt++;\\n                }\\n                if(lv != rv) res += lcnt * rcnt;\\n                else res += (lcnt * (rcnt - 1)) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\n#define REP(i, n) for(int i = 0; i < n; i++)\\n#define REPP(i, n) for(int i = 1; i <= n; i++)\\n#define ALL(obj) (obj).begin(), (obj).end()\\n\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 0;\\n        sort(ALL(nums1)); sort(ALL(nums2));\\n        ans += helper(nums1, nums2);\\n        ans += helper(nums2, nums1);\\n        return ans;       \\n    }\\n    \\n    int helper(vector<int>& nums1, vector<int>& nums2){\\n        int n1 = nums1.size(), n2 = nums2.size();\\n        int res = 0;\\n        REP(i, n1){\\n            long target = (long)nums1[i] * (long)nums1[i];\\n            int l = 0, r = n2 - 1;\\n            while(l <= r){\\n                long now = (long)nums2[l] * (long)nums2[r];\\n                if(now < target){\\n                    l++;\\n                    continue;\\n                }else if(now > target){\\n                    r--;\\n                    continue;\\n                }\\n                int lcnt = 0, rcnt = 0;\\n                int lv = nums2[l], rv = nums2[r];\\n                while(l < n2 && nums2[l] == lv){\\n                    l++;\\n                    lcnt++;\\n                }\\n                while(r >= 0 && nums2[r] == rv){\\n                    r--;\\n                    rcnt++;\\n                }\\n                if(lv != rv) res += lcnt * rcnt;\\n                else res += (lcnt * (rcnt - 1)) / 2;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 960288,
                "title": "java-solution-not-a-good-problem",
                "content": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n         int res = 0;   \\n        \\n         res += findTriplesHelper(nums1, nums2);\\n         res += findTriplesHelper(nums2, nums1);\\n         return res;\\n    }\\n    \\n    \\n    public int findTriplesHelper(int[] nums1, int[] nums2){\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele: nums2){\\n            map.put(ele, map.getOrDefault(ele,0)+1);\\n        }\\n        \\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            long temp = (long)nums1[i]*(long)nums1[i];\\n            Set<Integer> set = new HashSet<>();\\n            for(Integer key: map.keySet()){\\n                if(set.contains(key)){\\n                    continue;\\n                }\\n                set.add(key);\\n                if(temp%key==0 && map.containsKey((int)(temp/key))){\\n  \\n                    if((int)(temp/key)!=key){\\n                       res += map.get(key) * map.get((int)(temp/key));\\n                       set.add((int)(temp/key));\\n                    }else{\\n                        res += map.get(key)*(map.get(key)-1)/2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n         int res = 0;   \\n        \\n         res += findTriplesHelper(nums1, nums2);\\n         res += findTriplesHelper(nums2, nums1);\\n         return res;\\n    }\\n    \\n    \\n    public int findTriplesHelper(int[] nums1, int[] nums2){\\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int ele: nums2){\\n            map.put(ele, map.getOrDefault(ele,0)+1);\\n        }\\n        \\n        \\n        int res = 0;\\n        \\n        for(int i=0;i<nums1.length;i++){\\n            long temp = (long)nums1[i]*(long)nums1[i];\\n            Set<Integer> set = new HashSet<>();\\n            for(Integer key: map.keySet()){\\n                if(set.contains(key)){\\n                    continue;\\n                }\\n                set.add(key);\\n                if(temp%key==0 && map.containsKey((int)(temp/key))){\\n  \\n                    if((int)(temp/key)!=key){\\n                       res += map.get(key) * map.get((int)(temp/key));\\n                       set.add((int)(temp/key));\\n                    }else{\\n                        res += map.get(key)*(map.get(key)-1)/2;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 937040,
                "title": "python-o-n-2",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        product1 = collections.defaultdict(int)\\n        for i in range(len(nums1)):\\n            for j in range(i+1, len(nums1)):\\n                product1[nums1[i] * nums1[j]] += 1\\n        product2 = collections.defaultdict(int)\\n        for i in range(len(nums2)):\\n            for j in range(i+1, len(nums2)):\\n                product2[nums2[i] * nums2[j]] += 1\\n        count = 0\\n        for num in nums1:\\n            count += product2[num ** 2]\\n        for num in nums2:\\n            count += product1[num ** 2]\\n        return count",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        product1 = collections.defaultdict(int)\\n        for i in range(len(nums1)):\\n            for j in range(i+1, len(nums1)):\\n                product1[nums1[i] * nums1[j]] += 1\\n        product2 = collections.defaultdict(int)\\n        for i in range(len(nums2)):\\n            for j in range(i+1, len(nums2)):\\n                product2[nums2[i] * nums2[j]] += 1\\n        count = 0\\n        for num in nums1:\\n            count += product2[num ** 2]\\n        for num in nums2:\\n            count += product1[num ** 2]\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 889221,
                "title": "simple-solution",
                "content": "\\tfrom collections import Counter\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\t\\t\\tans,b,c,n1,n2 = 0, Counter([x**2 for x in nums1]) , Counter([x**2 for x in nums2]), len(nums1), len(nums2)\\n\\n\\t\\t\\tfor i in range(n1-1):\\n\\t\\t\\t\\tfor j in range(i+1,n1):\\n\\t\\t\\t\\t\\tans += c[nums1[i]*nums1[j]]\\n\\n\\t\\t\\tfor i in range(n2-1):\\n\\t\\t\\t\\tfor j in range(i+1,n2):\\n\\t\\t\\t\\t\\tans += b[nums2[i]*nums2[j]]\\n\\n\\t\\t\\treturn ans",
                "solutionTags": [],
                "code": "\\tfrom collections import Counter\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\t\\t\\tans,b,c,n1,n2 = 0, Counter([x**2 for x in nums1]) , Counter([x**2 for x in nums2]), len(nums1), len(nums2)\\n\\n\\t\\t\\tfor i in range(n1-1):\\n\\t\\t\\t\\tfor j in range(i+1,n1):\\n\\t\\t\\t\\t\\tans += c[nums1[i]*nums1[j]]\\n\\n\\t\\t\\tfor i in range(n2-1):\\n\\t\\t\\t\\tfor j in range(i+1,n2):\\n\\t\\t\\t\\t\\tans += b[nums2[i]*nums2[j]]\\n\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 889197,
                "title": "simple-o-n-2",
                "content": "\\tfrom collections import Counter\\n\\timport math\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\n\\t\\t\\tcount =0\\n\\n\\t\\t\\ta =Counter([float(item) for item in nums1])\\n\\t\\t\\tb = Counter([float(item) for item in nums2])\\n\\t\\t\\t#print(a,b)\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums1)):\\n\\t\\t\\t\\t\\tk  = nums1[i]*nums1[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k) \\n\\n\\t\\t\\t\\t\\tif x in b:\\n\\t\\t\\t\\t\\t\\tcount += b[x]\\n\\n\\t\\t\\tfor i in range(len(nums2)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums2)):\\n\\t\\t\\t\\t\\tk  = nums2[i]*nums2[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k)\\n\\n\\t\\t\\t\\t\\tif x in a:\\n\\t\\t\\t\\t\\t\\tcount += a[x]\\n\\t\\t\\treturn count",
                "solutionTags": [],
                "code": "\\tfrom collections import Counter\\n\\timport math\\n\\tclass Solution(object):\\n\\t\\tdef numTriplets(self, nums1, nums2):\\n\\n\\t\\t\\tcount =0\\n\\n\\t\\t\\ta =Counter([float(item) for item in nums1])\\n\\t\\t\\tb = Counter([float(item) for item in nums2])\\n\\t\\t\\t#print(a,b)\\n\\n\\t\\t\\tfor i in range(len(nums1)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums1)):\\n\\t\\t\\t\\t\\tk  = nums1[i]*nums1[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k) \\n\\n\\t\\t\\t\\t\\tif x in b:\\n\\t\\t\\t\\t\\t\\tcount += b[x]\\n\\n\\t\\t\\tfor i in range(len(nums2)):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums2)):\\n\\t\\t\\t\\t\\tk  = nums2[i]*nums2[j]\\n\\t\\t\\t\\t\\tx = math.sqrt(k)\\n\\n\\t\\t\\t\\t\\tif x in a:\\n\\t\\t\\t\\t\\t\\tcount += a[x]\\n\\t\\t\\treturn count",
                "codeTag": "Java"
            },
            {
                "id": 882201,
                "title": "simple-c-o-n-2-brute-force-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long int,int> mp1,mp2;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++)\\n                mp1[(long)nums1[i]*nums1[j]]++;\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++)\\n                mp2[(long)nums2[i]*nums2[j]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find((long)nums1[i]*nums1[i])!=mp2.end())\\n                ans+=mp2[(long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find((long)nums2[i]*nums2[i])!=mp1.end())\\n                ans+=mp1[(long)nums2[i]*nums2[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numTriplets(vector<int>& nums1, vector<int>& nums2) {\\n        unordered_map<long int,int> mp1,mp2;\\n        for(int i=0;i<nums1.size()-1;i++){\\n            for(int j=i+1;j<nums1.size();j++)\\n                mp1[(long)nums1[i]*nums1[j]]++;\\n        }\\n        for(int i=0;i<nums2.size()-1;i++){\\n            for(int j=i+1;j<nums2.size();j++)\\n                mp2[(long)nums2[i]*nums2[j]]++;\\n        }\\n        int ans=0;\\n        for(int i=0;i<nums1.size();i++){\\n            if(mp2.find((long)nums1[i]*nums1[i])!=mp2.end())\\n                ans+=mp2[(long)nums1[i]*nums1[i]];\\n        }\\n        for(int i=0;i<nums2.size();i++){\\n            if(mp1.find((long)nums2[i]*nums2[i])!=mp1.end())\\n                ans+=mp1[(long)nums2[i]*nums2[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871108,
                "title": "concise-python-solution",
                "content": "```\\ndef numTriplets(self, a1: List[int], a2: List[int]) -> int:        \\n\\tans, m1, m2, n1, n2 = 0, Counter([x**2 for x in a1]), Counter([x**2 for x in a2]), len(a1), len(a2)\\n\\tfor i in range(n1-1):\\n\\t\\tfor j in range(i+1, n1):\\n\\t\\t\\tans += m2[a1[i]*a1[j]]\\n\\tfor i in range(n2-1):\\n\\t\\tfor j in range(i+1, n2):\\n\\t\\t\\tans += m1[a2[i]*a2[j]]\\n\\treturn ans",
                "solutionTags": [],
                "code": "```\\ndef numTriplets(self, a1: List[int], a2: List[int]) -> int:        \\n\\tans, m1, m2, n1, n2 = 0, Counter([x**2 for x in a1]), Counter([x**2 for x in a2]), len(a1), len(a2)\\n\\tfor i in range(n1-1):\\n\\t\\tfor j in range(i+1, n1):\\n\\t\\t\\tans += m2[a1[i]*a1[j]]\\n\\tfor i in range(n2-1):\\n\\t\\tfor j in range(i+1, n2):\\n\\t\\t\\tans += m1[a2[i]*a2[j]]\\n\\treturn ans",
                "codeTag": "Python3"
            },
            {
                "id": 852763,
                "title": "kotlin-easy-clean-solution-100-100",
                "content": "```\\nfun numTriplets(nums1: IntArray, nums2: IntArray): Int {\\n    return numTripletsAux(nums1, nums2) + numTripletsAux(nums2, nums1)\\n}\\n\\nprivate fun numTripletsAux(nums1: IntArray, nums2: IntArray): Int {\\n    val squareCounts = mutableMapOf<Long, Int>()\\n\\n    for (n in nums1) {\\n        val square = n.toLong() * n.toLong()\\n        squareCounts[square] = squareCounts.getOrDefault(square, 0) + 1\\n    }\\n\\n    var count = 0\\n    for (i in nums2.indices) {\\n        for (j in i + 1 until nums2.size) {\\n            count += squareCounts.getOrDefault(nums2[i].toLong() * nums2[j].toLong(), 0)\\n        }\\n    }\\n    return count\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun numTriplets(nums1: IntArray, nums2: IntArray): Int {\\n    return numTripletsAux(nums1, nums2) + numTripletsAux(nums2, nums1)\\n}\\n\\nprivate fun numTripletsAux(nums1: IntArray, nums2: IntArray): Int {\\n    val squareCounts = mutableMapOf<Long, Int>()\\n\\n    for (n in nums1) {\\n        val square = n.toLong() * n.toLong()\\n        squareCounts[square] = squareCounts.getOrDefault(square, 0) + 1\\n    }\\n\\n    var count = 0\\n    for (i in nums2.indices) {\\n        for (j in i + 1 until nums2.size) {\\n            count += squareCounts.getOrDefault(nums2[i].toLong() * nums2[j].toLong(), 0)\\n        }\\n    }\\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 846653,
                "title": "c-from-o-m-n-2-n-m-2-to-o-n-2-m-2",
                "content": "```\\npublic class Solution {\\n\\n\\t// TLE Time: O(M*N^2 + N*M^2)\\n    public int NumTripletsBF(int[] nums1, int[] nums2) {\\n\\n        if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        \\n        var numTriplets = 0;\\n        \\n        // Type 1\\n        for (var i = 0; i < nums1.Length; i++) {\\n            for (var j = 0; j < nums2.Length - 1; j++) {\\n                for (var k = j + 1; k < nums2.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums1[i], 2);\\n                    var exp2 = (long) nums2[j] * nums2[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var i = 0; i < nums2.Length; i++) {\\n            for (var j = 0; j < nums1.Length - 1; j++) {\\n                for (var k = j + 1; k < nums1.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums2[i], 2);\\n                    var exp2 = (long) nums1[j] * nums1[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }    \\n    \\n\\t // Time: O(N^2 + M^2)\\n     public int NumTriplets(int[] nums1, int[] nums2) {\\n\\n         if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        var numTriplets = 0;\\n        \\n\\t\\t// Outer loop can be replaced by compromising on some space complexity\\n\\t\\t// 2 dictionary will keep the result of the left expression in the equations Type 1/2\\n\\t\\t\\n        var n1iDict = new Dictionary<long, int>(); \\n        var n2iDict = new Dictionary<long, int>(); \\n        for (var i = 0; i < nums1.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums1[i], 2);;\\n            if (!n1iDict.ContainsKey(exp1))\\n                n1iDict.Add(exp1, 0);\\n            n1iDict[exp1]++;\\n        }\\n        for (var i = 0; i < nums2.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums2[i], 2);;\\n            if (!n2iDict.ContainsKey(exp1))\\n                n2iDict.Add(exp1, 0);\\n            n2iDict[exp1]++;\\n        }\\n        \\n        // Type 1\\n        for (var j = 0; j < nums2.Length - 1; j++) {\\n            for (var k = j + 1; k < nums2.Length; k++) {\\n                var exp2 = (long) nums2[j] * nums2[k];\\n                if (n1iDict.ContainsKey(exp2)) {\\n                    numTriplets += n1iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var j = 0; j < nums1.Length - 1; j++) {\\n            for (var k = j + 1; k < nums1.Length; k++) {\\n                var exp2 = (long) nums1[j] * nums1[k];\\n                if (n2iDict.ContainsKey(exp2)) {\\n                    numTriplets += n2iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n\\n\\t// TLE Time: O(M*N^2 + N*M^2)\\n    public int NumTripletsBF(int[] nums1, int[] nums2) {\\n\\n        if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        \\n        var numTriplets = 0;\\n        \\n        // Type 1\\n        for (var i = 0; i < nums1.Length; i++) {\\n            for (var j = 0; j < nums2.Length - 1; j++) {\\n                for (var k = j + 1; k < nums2.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums1[i], 2);\\n                    var exp2 = (long) nums2[j] * nums2[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var i = 0; i < nums2.Length; i++) {\\n            for (var j = 0; j < nums1.Length - 1; j++) {\\n                for (var k = j + 1; k < nums1.Length; k++) {\\n                    var exp1 = (long) Math.Pow(nums2[i], 2);\\n                    var exp2 = (long) nums1[j] * nums1[k];\\n                    if (exp1 == exp2) {\\n                        numTriplets++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }    \\n    \\n\\t // Time: O(N^2 + M^2)\\n     public int NumTriplets(int[] nums1, int[] nums2) {\\n\\n         if (nums1 == null || nums2 == null) {\\n            return 0;\\n        }\\n        var numTriplets = 0;\\n        \\n\\t\\t// Outer loop can be replaced by compromising on some space complexity\\n\\t\\t// 2 dictionary will keep the result of the left expression in the equations Type 1/2\\n\\t\\t\\n        var n1iDict = new Dictionary<long, int>(); \\n        var n2iDict = new Dictionary<long, int>(); \\n        for (var i = 0; i < nums1.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums1[i], 2);;\\n            if (!n1iDict.ContainsKey(exp1))\\n                n1iDict.Add(exp1, 0);\\n            n1iDict[exp1]++;\\n        }\\n        for (var i = 0; i < nums2.Length; i++) {\\n            var exp1 = (long) Math.Pow(nums2[i], 2);;\\n            if (!n2iDict.ContainsKey(exp1))\\n                n2iDict.Add(exp1, 0);\\n            n2iDict[exp1]++;\\n        }\\n        \\n        // Type 1\\n        for (var j = 0; j < nums2.Length - 1; j++) {\\n            for (var k = j + 1; k < nums2.Length; k++) {\\n                var exp2 = (long) nums2[j] * nums2[k];\\n                if (n1iDict.ContainsKey(exp2)) {\\n                    numTriplets += n1iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        // Type 2\\n        for (var j = 0; j < nums1.Length - 1; j++) {\\n            for (var k = j + 1; k < nums1.Length; k++) {\\n                var exp2 = (long) nums1[j] * nums1[k];\\n                if (n2iDict.ContainsKey(exp2)) {\\n                    numTriplets += n2iDict[exp2];\\n                }\\n            }\\n        }\\n        \\n        return numTriplets;\\n    }   \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843709,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        count = 0 \\n        \\n        dic1 = dict()\\n        for num in nums1:\\n            if num in dic1:\\n                dic1[num] += 1\\n            else:\\n                dic1[num] = 1\\n                \\n        dic2 = dict()\\n        for num in nums2:\\n            if num in dic2:\\n                dic2[num] += 1\\n            else:\\n                dic2[num] = 1\\n                     \\n        for num1 in nums1:\\n            square = num1 ** 2\\n            for num2 in nums2:\\n                if square / num2 in dic2:\\n                    if square / num2 == num2:\\n                        count += dic2[square / num2] - 1\\n                    else:\\n                        count += dic2[square / num2]\\n                        \\n        for num2 in nums2:\\n            square = num2 ** 2\\n            for num1 in nums1:\\n                if square / num1 in dic1:\\n                    if square / num1 == num1:\\n                        count += dic1[square / num1] - 1\\n                    else:\\n                        count += dic1[square / num1]\\n                        \\n        return int(count / 2)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numTriplets(self, nums1: List[int], nums2: List[int]) -> int:\\n        count = 0 \\n        \\n        dic1 = dict()\\n        for num in nums1:\\n            if num in dic1:\\n                dic1[num] += 1\\n            else:\\n                dic1[num] = 1\\n                \\n        dic2 = dict()\\n        for num in nums2:\\n            if num in dic2:\\n                dic2[num] += 1\\n            else:\\n                dic2[num] = 1\\n                     \\n        for num1 in nums1:\\n            square = num1 ** 2\\n            for num2 in nums2:\\n                if square / num2 in dic2:\\n                    if square / num2 == num2:\\n                        count += dic2[square / num2] - 1\\n                    else:\\n                        count += dic2[square / num2]\\n                        \\n        for num2 in nums2:\\n            square = num2 ** 2\\n            for num1 in nums1:\\n                if square / num1 in dic1:\\n                    if square / num1 == num1:\\n                        count += dic1[square / num1] - 1\\n                    else:\\n                        count += dic1[square / num1]\\n                        \\n        return int(count / 2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 843537,
                "title": "c-using-dictionary-build-on-someone-else-s-response-in-discussion",
                "content": "I hope it\\'s allowed if I gave credit? \\nUsed this code for baseline - [User: kanchanapy](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/832206/C-solution-using-Dictionary)\\nNow, if anyone could tell me the complexity of time / space on this, that would be great...\\n```\\n\\npublic int NumTriplets(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t//not sure needs sorting\\n\\t\\t\\tArray.Sort(nums1);\\n\\t\\t\\tArray.Sort(nums2);\\n\\t\\t\\t//run the method to identify  how many triplets formed for each array as the product\\n\\t\\t\\tint c1 = getCount(nums1, nums2);\\n\\t\\t\\tint c2 = getCount(nums2, nums1);\\n\\t\\t\\treturn c1 + c2;\\n\\t\\t}\\n\\n\\t\\tpublic int getCount(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t\\t//store the product for the first array provided to the method\\n\\t\\t\\tlong product = 0;\\n\\t\\t\\t//how many times the triplet appears in the dictionary\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tDictionary<long, int> d = new Dictionary<long, int>();\\n\\n\\t\\t\\t//calc the product of array1\\n\\t\\t\\tfor (int i = 0, l = nums1.Length; i < l; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tproduct = (long)nums1[i] * (long)nums1[i];\\n\\t\\t\\t\\t//check if already appears in dictionary, if it does, increment valu, if not, create key in dictionary\\n\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[product] +=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td.Add(product, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//product of 2 values in second array provided\\n\\t\\t\\tfor (int j = 0, l = nums2.Length; j < l; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int k = 0; k < l; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t/// there\\'s a constraint that J must be smaller than k!!!\\n\\t\\t\\t\\t\\tif (j == k || j > k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tproduct = (long)nums2[j] * (long)nums2[k];\\n\\t\\t\\t\\t\\t//find all the products of array1 that correspond to products of array2\\n\\t\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount += d[product];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "solutionTags": [],
                "code": "I hope it\\'s allowed if I gave credit? \\nUsed this code for baseline - [User: kanchanapy](https://leetcode.com/problems/number-of-ways-where-square-of-number-is-equal-to-product-of-two-numbers/discuss/832206/C-solution-using-Dictionary)\\nNow, if anyone could tell me the complexity of time / space on this, that would be great...\\n```\\n\\npublic int NumTriplets(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t//not sure needs sorting\\n\\t\\t\\tArray.Sort(nums1);\\n\\t\\t\\tArray.Sort(nums2);\\n\\t\\t\\t//run the method to identify  how many triplets formed for each array as the product\\n\\t\\t\\tint c1 = getCount(nums1, nums2);\\n\\t\\t\\tint c2 = getCount(nums2, nums1);\\n\\t\\t\\treturn c1 + c2;\\n\\t\\t}\\n\\n\\t\\tpublic int getCount(int[] nums1, int[] nums2)\\n\\t\\t{\\n\\t\\t\\t//store the product for the first array provided to the method\\n\\t\\t\\tlong product = 0;\\n\\t\\t\\t//how many times the triplet appears in the dictionary\\n\\t\\t\\tint count = 0;\\n\\n\\t\\t\\tDictionary<long, int> d = new Dictionary<long, int>();\\n\\n\\t\\t\\t//calc the product of array1\\n\\t\\t\\tfor (int i = 0, l = nums1.Length; i < l; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tproduct = (long)nums1[i] * (long)nums1[i];\\n\\t\\t\\t\\t//check if already appears in dictionary, if it does, increment valu, if not, create key in dictionary\\n\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td[product] +=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\td.Add(product, 1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t//product of 2 values in second array provided\\n\\t\\t\\tfor (int j = 0, l = nums2.Length; j < l; j++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tfor (int k = 0; k < l; k++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t/// there\\'s a constraint that J must be smaller than k!!!\\n\\t\\t\\t\\t\\tif (j == k || j > k)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tproduct = (long)nums2[j] * (long)nums2[k];\\n\\t\\t\\t\\t\\t//find all the products of array1 that correspond to products of array2\\n\\t\\t\\t\\t\\tif (d.ContainsKey(product))\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tcount += d[product];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 842402,
                "title": "my-java-solution-using-hashmap",
                "content": "1. Here we make use of hashmap to solve this problem.\\n2. We initialise a map to store the square of nums1 elements and its frequency.\\n3. So we iterate through the first array, store the square of these numbers as the key and its frequency as value.\\n4. Then now we go through each and every element from the nums2 array and check if there is any key that matches with the product of any 2 number from num2. If yes, we update the result.\\n5. Finally return the answer.\\n\\n```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return preProcessProblem(nums1, nums2) + preProcessProblem(nums2, nums1);\\n    }\\n    public int preProcessProblem(int [] nums1, int [] nums2) {\\n        int result = 0;\\n        int n1 = nums1.length; \\n        int n2 = nums2.length;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int i=0; i<n1; i++) {\\n            map.put((long)nums1[i]*nums1[i], map.getOrDefault((long)nums1[i]*nums1[i], 0) + 1);\\n        }\\n        for (int j=0; j<n2; j++) {\\n            for (int k=j+1; k<n2; k++) {\\n                result += (long)map.getOrDefault((long)nums2[j]*nums2[k], 0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numTriplets(int[] nums1, int[] nums2) {\\n        return preProcessProblem(nums1, nums2) + preProcessProblem(nums2, nums1);\\n    }\\n    public int preProcessProblem(int [] nums1, int [] nums2) {\\n        int result = 0;\\n        int n1 = nums1.length; \\n        int n2 = nums2.length;\\n        Map<Long, Integer> map = new HashMap<>();\\n        for (int i=0; i<n1; i++) {\\n            map.put((long)nums1[i]*nums1[i], map.getOrDefault((long)nums1[i]*nums1[i], 0) + 1);\\n        }\\n        for (int j=0; j<n2; j++) {\\n            for (int k=j+1; k<n2; k++) {\\n                result += (long)map.getOrDefault((long)nums2[j]*nums2[k], 0);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2003902,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "bruteforce accepted"
                    },
                    {
                        "username": "topswe",
                        "content": " HINT: Two-Sum. Search for nums1[i]^2 / nums2[k]\n\nAlso notice that Type1 and Type2 definitions are symmetric!\n\nOptimal: O(mn) time : O(m + n) space\n"
                    }
                ]
            },
            {
                "id": 1683126,
                "content": [
                    {
                        "username": "c4tdog",
                        "content": "bruteforce accepted"
                    },
                    {
                        "username": "topswe",
                        "content": " HINT: Two-Sum. Search for nums1[i]^2 / nums2[k]\n\nAlso notice that Type1 and Type2 definitions are symmetric!\n\nOptimal: O(mn) time : O(m + n) space\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Count Sub Islands",
        "question_content": "<p>You are given two <code>m x n</code> binary matrices <code>grid1</code> and <code>grid2</code> containing only <code>0</code>&#39;s (representing water) and <code>1</code>&#39;s (representing land). An <strong>island</strong> is a group of <code>1</code>&#39;s connected <strong>4-directionally</strong> (horizontal or vertical). Any cells outside of the grid are considered water cells.</p>\n\n<p>An island in <code>grid2</code> is considered a <strong>sub-island </strong>if there is an island in <code>grid1</code> that contains <strong>all</strong> the cells that make up <strong>this</strong> island in <code>grid2</code>.</p>\n\n<p>Return the <em><strong>number</strong> of islands in </em><code>grid2</code> <em>that are considered <strong>sub-islands</strong></em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/10/test1.png\" style=\"width: 493px; height: 205px;\" />\n<pre>\n<strong>Input:</strong> grid1 = [[1,1,1,0,0],[0,1,1,1,1],[0,0,0,0,0],[1,0,0,0,0],[1,1,0,1,1]], grid2 = [[1,1,1,0,0],[0,0,1,1,1],[0,1,0,0,0],[1,0,1,1,0],[0,1,0,1,0]]\n<strong>Output:</strong> 3\n<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are three sub-islands.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/06/03/testcasex2.png\" style=\"width: 491px; height: 201px;\" />\n<pre>\n<strong>Input:</strong> grid1 = [[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]], grid2 = [[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\n<strong>Output:</strong> 2 \n<strong>Explanation: </strong>In the picture above, the grid on the left is grid1 and the grid on the right is grid2.\nThe 1s colored red in grid2 are those considered to be part of a sub-island. There are two sub-islands.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == grid1.length == grid2.length</code></li>\n\t<li><code>n == grid1[i].length == grid2[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 500</code></li>\n\t<li><code>grid1[i][j]</code> and <code>grid2[i][j]</code> are either <code>0</code> or <code>1</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 1284306,
                "title": "98-faster-simple-approach-well-explained",
                "content": "##  IDEA:\\n\\uD83D\\uDC49 firstly remove all the non-common island\\n\\uD83D\\uDC49 Now count the sub-islands\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return\\n            \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            dfs(i-1,j)\\n            \\n        # removing all the non-common sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        \\n        c=0\\n\\t\\t# counting sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    dfs(i,j)\\n                    c+=1\\n        return c\\n\\t\\t\\nIf you have any doubt ......... please feel free to ask !!!\\nThank You \\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "##  IDEA:\\n\\uD83D\\uDC49 firstly remove all the non-common island\\n\\uD83D\\uDC49 Now count the sub-islands\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return\\n            \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n            dfs(i-1,j)\\n            \\n        # removing all the non-common sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        \\n        c=0\\n\\t\\t# counting sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    dfs(i,j)\\n                    c+=1\\n        return c\\n\\t\\t\\nIf you have any doubt ......... please feel free to ask !!!\\nThank You \\uD83E\\uDD1E",
                "codeTag": "Java"
            },
            {
                "id": 1284319,
                "title": "java-c-python-dfs-solution",
                "content": "# **Intuition**\\nYou need to know how to count the the number of islands\\nRefer to [200. Number of Islands](https://leetcode.com/problems/number-of-islands/discuss/1284203/C%2B%2BPython-DFS-Solution)\\n<br>\\n\\n# **Explanation**\\nBased on solution above,\\nreturn 0 if and only if we find it\\'s not a sub island.\\n<br>\\n\\n# **Complexity**\\nTime `O(mn)`\\nSpace `O(mn)`\\n<br>\\n\\n**Java**\\n```java\\n    public int countSubIslands(int[][] B, int[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    private int dfs(int[][] B, int[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length, res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int countSubIslands(vector<vector<int>>& B, vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    int dfs(vector<vector<int>>& B, vector<vector<int>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size(), res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n```\\n\\n**Python**\\n```py\\n    def countSubIslands(self, B, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == 1): return 1\\n            A[i][j] = 0\\n            res = B[i][j]\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                res &= dfs(i + di, j + dj)\\n            return res\\n            \\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j])\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int countSubIslands(int[][] B, int[][] A) {\\n        int m = A.length, n = A[0].length, res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    private int dfs(int[][] B, int[][] A, int i, int j) {\\n        int m = A.length, n = A[0].length, res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n```\n```cpp\\n    int countSubIslands(vector<vector<int>>& B, vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    int dfs(vector<vector<int>>& B, vector<vector<int>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size(), res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n```\n```py\\n    def countSubIslands(self, B, A):\\n        n, m = len(A), len(A[0])\\n\\n        def dfs(i, j):\\n            if not (0 <= i < n and 0 <= j < m and A[i][j] == 1): return 1\\n            A[i][j] = 0\\n            res = B[i][j]\\n            for di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n                res &= dfs(i + di, j + dj)\\n            return res\\n            \\n        return sum(dfs(i, j) for i in xrange(n) for j in xrange(m) if A[i][j])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1284224,
                "title": "c-dfs",
                "content": "\\napply DFS for grid2, and if we can find 1 cell in grid1 is 0 and grid2 is 1 then this island is not a sub-island.\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, int &res) {\\n        int m = grid1.size(), n = grid1[0].size();\\n        if(x < 0 || y < 0 || x >= m || y >= n) return;\\n        if(grid1[x][y] == 0 && grid2[x][y] == 1) {\\n            res = false;\\n        }\\n        if(grid2[x][y] == 0) return;\\n        grid2[x][y] = 0;\\n        dfs(grid1, grid2, x + 1, y, res);\\n        dfs(grid1, grid2, x, y + 1, res);\\n        dfs(grid1, grid2, x - 1, y, res);\\n        dfs(grid1, grid2, x, y - 1, res);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid1[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < m ; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid2[i][j] == 1) {\\n                    int res = true;\\n                    dfs(grid1, grid2, i, j, res);\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, int &res) {\\n        int m = grid1.size(), n = grid1[0].size();\\n        if(x < 0 || y < 0 || x >= m || y >= n) return;\\n        if(grid1[x][y] == 0 && grid2[x][y] == 1) {\\n            res = false;\\n        }\\n        if(grid2[x][y] == 0) return;\\n        grid2[x][y] = 0;\\n        dfs(grid1, grid2, x + 1, y, res);\\n        dfs(grid1, grid2, x, y + 1, res);\\n        dfs(grid1, grid2, x - 1, y, res);\\n        dfs(grid1, grid2, x, y - 1, res);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid1[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < m ; i++) {\\n            for(int j = 0; j < n; j++) {\\n                if(grid2[i][j] == 1) {\\n                    int res = true;\\n                    dfs(grid1, grid2, i, j, res);\\n                    ans += res;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284261,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int result = 0;\\n        for(int i=0;i<grid2.length;i++)\\n            for(int j=0;j<grid2[0].length;j++)\\n                if(grid2[i][j] == 1 && isSubIsland(grid1, grid2, i , j)) result++;\\n        return result;\\n    }\\n    private boolean isSubIsland(int[][] grid1, int[][] grid2, int i, int j) {\\n        boolean result = true;\\n        if(i>=0 && i<grid2.length && j>=0 && j<grid2[0].length && grid2[i][j] == 1) {\\n            if(grid2[i][j] != grid1[i][j]) result =false;\\n            grid2[i][j] = -1; // Mark Visited\\n            boolean left = isSubIsland(grid1, grid2, i, j -1);\\n            boolean right = isSubIsland(grid1, grid2, i, j +1);\\n            boolean top = isSubIsland(grid1, grid2, i-1, j);\\n            boolean bottom = isSubIsland(grid1, grid2, i+1, j);\\n            if(!left || !right || !top || !bottom) return false;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int result = 0;\\n        for(int i=0;i<grid2.length;i++)\\n            for(int j=0;j<grid2[0].length;j++)\\n                if(grid2[i][j] == 1 && isSubIsland(grid1, grid2, i , j)) result++;\\n        return result;\\n    }\\n    private boolean isSubIsland(int[][] grid1, int[][] grid2, int i, int j) {\\n        boolean result = true;\\n        if(i>=0 && i<grid2.length && j>=0 && j<grid2[0].length && grid2[i][j] == 1) {\\n            if(grid2[i][j] != grid1[i][j]) result =false;\\n            grid2[i][j] = -1; // Mark Visited\\n            boolean left = isSubIsland(grid1, grid2, i, j -1);\\n            boolean right = isSubIsland(grid1, grid2, i, j +1);\\n            boolean top = isSubIsland(grid1, grid2, i-1, j);\\n            boolean bottom = isSubIsland(grid1, grid2, i+1, j);\\n            if(!left || !right || !top || !bottom) return false;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284232,
                "title": "fill-second-and-count-first",
                "content": "We flood-fill islands as usual in the second grid, and our `dfs` function returns the count of land cells.\\n    \\nHowever, this time we also count land in matching cells in the first grid. \\n    \\nIn the end, if number of land cells matches - then the island in the second grid is a sub-island.\\n    \\n**C++**\\n```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\npair<int, int> dfs(vector<vector<int>>& g1, vector<vector<int>>& g2, int i, int j) {\\n    if (i < 0 || j < 0 || i >= g1.size() || j >= g1[0].size() || g2[i][j] == 0)\\n        return {0, 0};\\n    g2[i][j] = 0;\\n    pair<int, int> res{g1[i][j], 1};\\n    for (int d = 0; d < 4; ++d) {\\n        auto [cnt1, cnt2] = dfs(g1, g2, i + dir[d], j + dir[d + 1]);\\n        res.first += cnt1;\\n        res.second += cnt2;\\n    }\\n    return res;\\n}\\nint countSubIslands(vector<vector<int>>& g1, vector<vector<int>>& g2) {\\n    int m = g1.size(), n = g1[0].size(), res = 0;\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto [cnt1, cnt2] = dfs(g1, g2, i, j);\\n            res += cnt1 > 0 && cnt1 == cnt2;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint dir[5] = {0, 1, 0, -1, 0};\\npair<int, int> dfs(vector<vector<int>>& g1, vector<vector<int>>& g2, int i, int j) {\\n    if (i < 0 || j < 0 || i >= g1.size() || j >= g1[0].size() || g2[i][j] == 0)\\n        return {0, 0};\\n    g2[i][j] = 0;\\n    pair<int, int> res{g1[i][j], 1};\\n    for (int d = 0; d < 4; ++d) {\\n        auto [cnt1, cnt2] = dfs(g1, g2, i + dir[d], j + dir[d + 1]);\\n        res.first += cnt1;\\n        res.second += cnt2;\\n    }\\n    return res;\\n}\\nint countSubIslands(vector<vector<int>>& g1, vector<vector<int>>& g2) {\\n    int m = g1.size(), n = g1[0].size(), res = 0;\\n    for (int i = 0; i < m; ++i)\\n        for (int j = 0; j < n; ++j) {\\n            auto [cnt1, cnt2] = dfs(g1, g2, i, j);\\n            res += cnt1 > 0 && cnt1 == cnt2;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1325964,
                "title": "java-easy-solution-dfs-on-second-and-checking-on-1st-grid",
                "content": "This question can be follow up for No of islands. In this we make a dfs call on 2nd grid and we take a flag i.e in my case I have taken ans . I initialize my ans to 1 means it is island then I traverse whole 2nd grid connected component which contains only 1 and at any time when the grid 2 contains 1 and at same time on that place grid 1 contains 0 means this can\\'t be island so make flag variable back to zero but I do not stop the dfs . traverse whole component irrespective of the result . Atlast take a variable for storing the count and return that variable.\\n\\n\\n\\'\\'\\'\\nclass Solution {\\n   \\n    int ans =0;\\n    public void dfs(int[][] grid1, int[][] grid2, int i , int j){\\n        if(i<0|| i>=grid1.length ||j<0|| j>=grid1[0].length || grid2[i][j]==0 ) return;\\n        if(grid1[i][j]== 0)ans =0;\\n        grid2[i][j] =0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }\\n    \\n    \\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        // problem can be solved using dfs\\n        int res=0;\\n        for(int i=0 ;i <grid1.length ;i++){\\n            for(int j=0 ;j<grid2[0].length ;j++){\\n                \\n                if(grid2[i][j]==1)\\n                {\\n                    ans=1;\\n                    dfs(grid1, grid2, i, j);\\n                    res+=ans;\\n                }\\n            }\\n        }\\n        return res;\\n        \\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n   \\n    int ans =0;\\n    public void dfs(int[][] grid1, int[][] grid2, int i , int j){\\n        if(i<0|| i>=grid1.length ||j<0|| j>=grid1[0].length || grid2[i][j]==0 ) return;\\n        if(grid1[i][j]== 0)ans =0;\\n        grid2[i][j] =0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1284588,
                "title": "c-dfs-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    bool res;\\n    void mark_current_island(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int x,int y,int r,int c){\\n        if(x<0 || x>=r || y<0 || y>=c || grid2[x][y]!=1)  //Boundary case for matrix\\n            return ;\\n        \\n        //if there is water on  grid1 for the location on B then our current island can\\'t be counted and so we mark res as false \\n        if(grid1[x][y]==0){\\n            res=false;\\n            return;\\n        }\\n        //Mark current cell as visited\\n        grid2[x][y] = 0;\\n        \\n        //Make recursive call in all 4 adjacent directions\\n        mark_current_island(grid1,grid2,x+1,y,r,c);  //DOWN\\n        mark_current_island(grid1,grid2,x,y+1,r,c);  //RIGHT\\n        mark_current_island(grid1,grid2,x-1,y,r,c);  //TOP\\n        mark_current_island(grid1,grid2,x,y-1,r,c);  //LEFT\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        //For FAST I/O\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int rows = grid1.size();\\n        if(rows==0)     //Empty grid boundary case\\n            return 0;\\n        int cols = grid1[0].size();\\n\\t\\t\\n        //Iterate for all cells of the array\\n        int no_of_islands = 0;\\n\\t\\t\\n        //dfs on grid2 \\n        for(int i=0;i<rows;++i){\\n            for(int j=0;j<cols;++j){\\n                if(grid2[i][j]==1){\\n                    res=true;\\n                    mark_current_island(grid1,grid2,i,j,rows,cols);\\n                    //if current island of grid2 meets the requirement update the no of islands\\n                    if(res)\\n                        no_of_islands += 1;\\n                }\\n            }\\n        }\\n\\t\\t\\n        return no_of_islands;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool res;\\n    void mark_current_island(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int x,int y,int r,int c){\\n        if(x<0 || x>=r || y<0 || y>=c || grid2[x][y]!=1)  //Boundary case for matrix\\n            return ;\\n        \\n        //if there is water on  grid1 for the location on B then our current island can\\'t be counted and so we mark res as false \\n        if(grid1[x][y]==0){\\n            res=false;\\n            return;\\n        }\\n        //Mark current cell as visited\\n        grid2[x][y] = 0;\\n        \\n        //Make recursive call in all 4 adjacent directions\\n        mark_current_island(grid1,grid2,x+1,y,r,c);  //DOWN\\n        mark_current_island(grid1,grid2,x,y+1,r,c);  //RIGHT\\n        mark_current_island(grid1,grid2,x-1,y,r,c);  //TOP\\n        mark_current_island(grid1,grid2,x,y-1,r,c);  //LEFT\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        //For FAST I/O\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        \\n        int rows = grid1.size();\\n        if(rows==0)     //Empty grid boundary case\\n            return 0;\\n        int cols = grid1[0].size();\\n\\t\\t\\n        //Iterate for all cells of the array\\n        int no_of_islands = 0;\\n\\t\\t\\n        //dfs on grid2 \\n        for(int i=0;i<rows;++i){\\n            for(int j=0;j<cols;++j){\\n                if(grid2[i][j]==1){\\n                    res=true;\\n                    mark_current_island(grid1,grid2,i,j,rows,cols);\\n                    //if current island of grid2 meets the requirement update the no of islands\\n                    if(res)\\n                        no_of_islands += 1;\\n                }\\n            }\\n        }\\n\\t\\t\\n        return no_of_islands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284211,
                "title": "c-dfs",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. DFS\\n\\n**Intuition**: If an island in `B` overlaps with a water cell in `A`, then this island shouldn\\'t be considered.\\n\\n**Algorithm**\\n\\n1. For each water cell `A[i][j]`, sink the island in `B` containing `B[i][j]` into water.\\n2. Count the number of islands in `B`.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-246/problems/count-sub-islands/\\n// Author: github.com/lzl124631x\\n// Time: O(MN)\\n// Space: O(1)\\nclass Solution {\\n    int dirs[4][2] = {{0,1},{0,-1},{-1,0},{1,0}}, M, N;\\n    void dfs(vector<vector<int>> &B, int x, int y, int color) {\\n        if (B[x][y] == color) return;\\n        B[x][y] = color;\\n        for (auto &[dx, dy] : dirs) {\\n            int a = x + dx, b = y + dy;\\n            if (a < 0 || a >= M || b < 0 || b >= N) continue;\\n            dfs(B, a, b, color);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& A, vector<vector<int>>& B) {\\n        M = A.size(), N = A[0].size();\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (A[i][j] == 0) dfs(B, i, j, 0); // sink this island at B[i][j]\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (B[i][j] == 1) {\\n                    dfs(B, i, j, 0);\\n                    ++cnt; // count islands in `B`\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-246/problems/count-sub-islands/\\n// Author: github.com/lzl124631x\\n// Time: O(MN)\\n// Space: O(1)\\nclass Solution {\\n    int dirs[4][2] = {{0,1},{0,-1},{-1,0},{1,0}}, M, N;\\n    void dfs(vector<vector<int>> &B, int x, int y, int color) {\\n        if (B[x][y] == color) return;\\n        B[x][y] = color;\\n        for (auto &[dx, dy] : dirs) {\\n            int a = x + dx, b = y + dy;\\n            if (a < 0 || a >= M || b < 0 || b >= N) continue;\\n            dfs(B, a, b, color);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& A, vector<vector<int>>& B) {\\n        M = A.size(), N = A[0].size();\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (A[i][j] == 0) dfs(B, i, j, 0); // sink this island at B[i][j]\\n            }\\n        }\\n        int cnt = 0;\\n        for (int i = 0; i < M; ++i) {\\n            for (int j = 0; j < N; ++j) {\\n                if (B[i][j] == 1) {\\n                    dfs(B, i, j, 0);\\n                    ++cnt; // count islands in `B`\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284266,
                "title": "short-easy-solution-using-dfs-w-explanation",
                "content": "\\u2714\\uFE0F ***Solution (DFS on grid2)***    \\n\\n**If all land cells of an island in grid2 are also land cells in grid1, then it is sub-island of some island in grid1.**\\n\\nSo, we just need to start a DFS on every land cell of `grid2`. This DFS call will iterate over a single complete island of grid2 and check if all the cells found in the current island are also preset in `grid1`. . We do this iteratively for all islands of grid2.\\n\\t\\n\\tvector<vector<bool>> vis;\\n    int moves[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}, m, n, cnt = 0;\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        m = size(grid1), n = size(grid1[0]);\\n        vis.resize(m, vector<bool>(n));\\n\\t\\t// iterate over all the cells and start a dfs from unvisited land cell\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                if(!vis[i][j] && grid2[i][j]) {   // start a dfs search for island consisting of cell (i,j) in grid2\\n                    bool ans = true;\\n                    if(dfs(grid2, grid1, i, j, ans)) cnt++;\\n                }\\n        return cnt;\\n    }\\n    bool dfs(vector<vector<int> >& grid2,vector<vector<int> >& grid1, int i, int j, bool& ans) {\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || grid2[i][j] == 0) return true;        \\n        if(grid1[i][j] == 0) ans = false;  // if any of island cell for current island of grid2 is not present in grid1\\n        vis[i][j] = true;                  // mark visited for each land cell so that we don\\'t repeat it again\\n        for(int k = 0; k < 4; k++) \\n            dfs(grid2, grid1,i + moves[k][0], j + moves[k][1], ans);\\n        return ans;\\n    }\\n\\t\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [
                    "C"
                ],
                "code": "\\u2714\\uFE0F ***Solution (DFS on grid2)***    \\n\\n**If all land cells of an island in grid2 are also land cells in grid1, then it is sub-island of some island in grid1.**\\n\\nSo, we just need to start a DFS on every land cell of `grid2`. This DFS call will iterate over a single complete island of grid2 and check if all the cells found in the current island are also preset in `grid1`. . We do this iteratively for all islands of grid2.\\n\\t\\n\\tvector<vector<bool>> vis;\\n    int moves[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}}, m, n, cnt = 0;\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        m = size(grid1), n = size(grid1[0]);\\n        vis.resize(m, vector<bool>(n));\\n\\t\\t// iterate over all the cells and start a dfs from unvisited land cell\\n        for(int i = 0; i < m; i++) \\n            for(int j = 0; j < n; j++) \\n                if(!vis[i][j] && grid2[i][j]) {   // start a dfs search for island consisting of cell (i,j) in grid2\\n                    bool ans = true;\\n                    if(dfs(grid2, grid1, i, j, ans)) cnt++;\\n                }\\n        return cnt;\\n    }\\n    bool dfs(vector<vector<int> >& grid2,vector<vector<int> >& grid1, int i, int j, bool& ans) {\\n        if(i < 0 || i >= m || j < 0 || j >= n || vis[i][j] || grid2[i][j] == 0) return true;        \\n        if(grid1[i][j] == 0) ans = false;  // if any of island cell for current island of grid2 is not present in grid1\\n        vis[i][j] = true;                  // mark visited for each land cell so that we don\\'t repeat it again\\n        for(int k = 0; k < 4; k++) \\n            dfs(grid2, grid1,i + moves[k][0], j + moves[k][1], ans);\\n        return ans;\\n    }\\n\\t\\n***Time Complexity :*** **`O(M*N)`**\\n***Space Complexity :*** **`O(M*N)`**\\n\\n---\\n---\\n\\n\\uD83D\\uDCBB\\uD83D\\uDC31\\u200D\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, please do comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "codeTag": "Unknown"
            },
            {
                "id": 1284370,
                "title": "java-bfs-dfs-similar-to-number-of-islands",
                "content": "**Here I am discussing my approach to this problem**\\n**Approach:**\\n1. Do a **bfs/dfs** on `grid2 matrix` **similar** to what you did in [Number of Islands](https://leetcode.com/problems/number-of-islands/).\\n2. For a current island in` grid2`, check for every cell in that island **if they are present in** `grid1`. This will **ensure if this is a sub-island** of `grid1`.\\n3. Maintain a `flag` and mark it false if you **encounter any cell which is part of island in grid2 and not a part of island in grid1**. \\n4. **Increase** the `count` for each island of `grid2`, when `flag` is **true**.\\n5. **Return** `count`, as this will be the **number of islands** in `grid2` that are considered **sub-islands**.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int count = 0;\\n        int[] dir = {1, 0, -1, 0, 1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid2[i][j] == 0 || vis[i][j])\\n                    continue;\\n                \\n                Queue<int[]> queue = new LinkedList<>();\\n                boolean flag = true;\\n                vis[i][j] = true;\\n                \\n                queue.add(new int[] {i, j});\\n                \\n                while(!queue.isEmpty()) {\\n                    int[] vtx = queue.remove();\\n                    \\n                    if(grid1[vtx[0]][vtx[1]] == 0)\\n                        flag = false;\\n                    \\n                    for(int k = 0; k < 4; ++k) {\\n                        int x = vtx[0] + dir[k];\\n                        int y = vtx[1] + dir[k + 1];\\n                        \\n                        if(x >= 0 && x < m && y >= 0 && y < n && grid2[x][y] == 1 && !vis[x][y]) {\\n                            vis[x][y] = true;\\n                            \\n                            queue.add(new int[] {x, y});\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(m * n) // m = grid2.length, n = grid2[0].length\\nSpace Complexity: O(m * n) // m = grid2.length, n = grid[0].length\\n```\\n\\n**Another optimized approach, thanks to [@coderskater114](https://leetcode.com/coderskater114/)**\\nWe can mark `grid2[x][y] = 0` when visited instead of using extra boolean `vis` array and mark it `true`. \\nBelow is the solution.\\n\\n**Source Code:**\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        int count = 0;\\n        int[] dir = {1, 0, -1, 0, 1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid2[i][j] == 0 )\\n                    continue;\\n                \\n                Queue<int[]> queue = new LinkedList<>();\\n                boolean flag = true;\\n                grid2[i][j] = 0;\\n                \\n                queue.add(new int[] {i, j});\\n                \\n                while(!queue.isEmpty()) {\\n                    int[] vtx = queue.remove();\\n                    \\n                    if(grid1[vtx[0]][vtx[1]] == 0)\\n                        flag = false;\\n                    \\n                    for(int k = 0; k < 4; ++k) {\\n                        int x = vtx[0] + dir[k];\\n                        int y = vtx[1] + dir[k + 1];\\n                        \\n                        if(x >= 0 && x < m && y >= 0 && y < n && grid2[x][y] == 1) {\\n                            grid2[x][y] = 0;\\n                            \\n                            queue.add(new int[] {x, y});\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n**Complexity Analysis:**\\n```\\nTime Complexity: O(m * n) // m = grid2.length, n = grid2[0].length\\nSpace Complexity: O(m * n) // m = grid2.length, n = grid[0].length\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        boolean[][] vis = new boolean[m][n];\\n        int count = 0;\\n        int[] dir = {1, 0, -1, 0, 1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid2[i][j] == 0 || vis[i][j])\\n                    continue;\\n                \\n                Queue<int[]> queue = new LinkedList<>();\\n                boolean flag = true;\\n                vis[i][j] = true;\\n                \\n                queue.add(new int[] {i, j});\\n                \\n                while(!queue.isEmpty()) {\\n                    int[] vtx = queue.remove();\\n                    \\n                    if(grid1[vtx[0]][vtx[1]] == 0)\\n                        flag = false;\\n                    \\n                    for(int k = 0; k < 4; ++k) {\\n                        int x = vtx[0] + dir[k];\\n                        int y = vtx[1] + dir[k + 1];\\n                        \\n                        if(x >= 0 && x < m && y >= 0 && y < n && grid2[x][y] == 1 && !vis[x][y]) {\\n                            vis[x][y] = true;\\n                            \\n                            queue.add(new int[] {x, y});\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nTime Complexity: O(m * n) // m = grid2.length, n = grid2[0].length\\nSpace Complexity: O(m * n) // m = grid2.length, n = grid[0].length\\n```\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        int count = 0;\\n        int[] dir = {1, 0, -1, 0, 1};\\n        \\n        for(int i = 0; i < m; ++i) {\\n            for(int j = 0; j < n; ++j) {\\n                if(grid2[i][j] == 0 )\\n                    continue;\\n                \\n                Queue<int[]> queue = new LinkedList<>();\\n                boolean flag = true;\\n                grid2[i][j] = 0;\\n                \\n                queue.add(new int[] {i, j});\\n                \\n                while(!queue.isEmpty()) {\\n                    int[] vtx = queue.remove();\\n                    \\n                    if(grid1[vtx[0]][vtx[1]] == 0)\\n                        flag = false;\\n                    \\n                    for(int k = 0; k < 4; ++k) {\\n                        int x = vtx[0] + dir[k];\\n                        int y = vtx[1] + dir[k + 1];\\n                        \\n                        if(x >= 0 && x < m && y >= 0 && y < n && grid2[x][y] == 1) {\\n                            grid2[x][y] = 0;\\n                            \\n                            queue.add(new int[] {x, y});\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    ++count;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nTime Complexity: O(m * n) // m = grid2.length, n = grid2[0].length\\nSpace Complexity: O(m * n) // m = grid2.length, n = grid[0].length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426989,
                "title": "python-3-recursive-dfs-with-comments",
                "content": "**Note:**   *I am open to sugguestions on ways to improve the solution, or style. What is right? What is wrong?* \\n\\nIf you find the solution useful, feel free to upvote. or not ;P\\n \\n** **\\n\\n```\\nclass Solution:\\n    def check_islands(self, grid1, grid2, row, col):\\n        \\n        if row < 0 or row >= len(grid2) or col < 0 or col >= len(grid2[0]) or grid2[row][col] == 0: \\n            return True\\n        # If one of the cells in either grid is land and the other is water, then the current cell can **not** be a sub-island.\\n        elif (grid1[row][col] == 0 and grid2[row][col] == 1) or (grid1[row][col] == 1 and grid2[row][col] == 0):\\n            return False\\n        # If the cell in both grids is land, we want to change the value so we don\\'t check this same cell later.\\n        elif grid1[row][col] == 1 and grid2[row][col] == 1:\\n            grid2[row][col] = 0            \\n        \\n            left = self.check_islands(grid1, grid2, row, col - 1)\\n            right = self.check_islands(grid1, grid2, row, col + 1)\\n            top = self.check_islands(grid1, grid2, row - 1, col)\\n            bottom = self.check_islands(grid1, grid2, row + 1, col)\\n    \\n            \\n            # If all directions of a land cell in grid2 match with corresponding land cells in grid1, then a sub-island was found.\\n            return left and right and top and bottom\\n    \\n    \\n    \\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        num_sub_islands = 0 \\n        \\n        for row in range(len(grid2)):\\n            for col in range(len(grid2[row])):\\n                # If grid2 is land, and grid2 is a sub-island of grid 1\\n                if grid2[row][col] == 1 and self.check_islands(grid1, grid2, row, col): \\n                    num_sub_islands += 1\\n                        \\n        return num_sub_islands",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "**Note:**   *I am open to sugguestions on ways to improve the solution, or style. What is right? What is wrong?* \\n\\nIf you find the solution useful, feel free to upvote. or not ;P\\n \\n** **\\n\\n```\\nclass Solution:\\n    def check_islands(self, grid1, grid2, row, col):\\n        \\n        if row < 0 or row >= len(grid2) or col < 0 or col >= len(grid2[0]) or grid2[row][col] == 0: \\n            return True\\n        # If one of the cells in either grid is land and the other is water, then the current cell can **not** be a sub-island.\\n        elif (grid1[row][col] == 0 and grid2[row][col] == 1) or (grid1[row][col] == 1 and grid2[row][col] == 0):\\n            return False\\n        # If the cell in both grids is land, we want to change the value so we don\\'t check this same cell later.\\n        elif grid1[row][col] == 1 and grid2[row][col] == 1:\\n            grid2[row][col] = 0            \\n        \\n            left = self.check_islands(grid1, grid2, row, col - 1)\\n            right = self.check_islands(grid1, grid2, row, col + 1)\\n            top = self.check_islands(grid1, grid2, row - 1, col)\\n            bottom = self.check_islands(grid1, grid2, row + 1, col)\\n    \\n            \\n            # If all directions of a land cell in grid2 match with corresponding land cells in grid1, then a sub-island was found.\\n            return left and right and top and bottom\\n    \\n    \\n    \\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        num_sub_islands = 0 \\n        \\n        for row in range(len(grid2)):\\n            for col in range(len(grid2[row])):\\n                # If grid2 is land, and grid2 is a sub-island of grid 1\\n                if grid2[row][col] == 1 and self.check_islands(grid1, grid2, row, col): \\n                    num_sub_islands += 1\\n                        \\n        return num_sub_islands",
                "codeTag": "Java"
            },
            {
                "id": 1284407,
                "title": "python-easy-explained-dfs",
                "content": "Idea: \\n\\nTraverse through all the indices in grid2 and if grid2[i][j] == 1, then, check for the max-area island attached to that grid[i][j] in all the four direction. Once a cell in grid2 is visited, mark it as visited (I marked it as 2, you can even make it back zero). \\n\\nDo not change anything in grid1. \\n\\nJust while checking the max-possible-area of island in grid2, parallely check if that cell in grid1 is 1. If yes then continue exploring connected lands in up, left,right,down direction further, but if no, then, mark the flag as no, **but still keep exploring the connected lands** (Reason: The island we have touched once, must not be toughed again, else our algo may never converge or may give wrong answer.)\\n\\n![image](https://assets.leetcode.com/users/images/c243d51c-9532-4238-b75e-c0508e92dd83_1624164211.6386034.png)\\n\\n\\nThe full Code:\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        def isIsland(i, j):\\n            flag = True\\n            if grid1[i][j]!=1:\\n                flag = False\\n            \\n            if i-1>=0 and grid2[i-1][j]==1:\\n                grid2[i-1][j] = 2\\n                flag = isIsland(i-1,j) and flag and grid1[i-1][j]\\n                    \\n            if i+1<n and grid2[i+1][j]==1:\\n                grid2[i+1][j] = 2\\n                flag = isIsland(i+1,j) and flag and grid1[i+1][j]\\n            \\n            if j-1>=0 and grid2[i][j-1]==1:\\n                grid2[i][j-1] = 2\\n                flag = isIsland(i,j-1) and flag and grid1[i][j-1]\\n            \\n            if j+1<m and grid2[i][j+1]==1:\\n                grid2[i][j+1]=2\\n                flag = isIsland(i,j+1) and flag and grid1[i][j+1]\\n            return flag\\n            \\n        \\n        count = 0\\n        n = len(grid2)\\n        m = len(grid2[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid2[i][j]==1:\\n                    grid2[i][j] = 2\\n                    if isIsland(i, j):\\n                        count += 1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        def isIsland(i, j):\\n            flag = True\\n            if grid1[i][j]!=1:\\n                flag = False\\n            \\n            if i-1>=0 and grid2[i-1][j]==1:\\n                grid2[i-1][j] = 2\\n                flag = isIsland(i-1,j) and flag and grid1[i-1][j]\\n                    \\n            if i+1<n and grid2[i+1][j]==1:\\n                grid2[i+1][j] = 2\\n                flag = isIsland(i+1,j) and flag and grid1[i+1][j]\\n            \\n            if j-1>=0 and grid2[i][j-1]==1:\\n                grid2[i][j-1] = 2\\n                flag = isIsland(i,j-1) and flag and grid1[i][j-1]\\n            \\n            if j+1<m and grid2[i][j+1]==1:\\n                grid2[i][j+1]=2\\n                flag = isIsland(i,j+1) and flag and grid1[i][j+1]\\n            return flag\\n            \\n        \\n        count = 0\\n        n = len(grid2)\\n        m = len(grid2[0])\\n        for i in range(n):\\n            for j in range(m):\\n                if grid2[i][j]==1:\\n                    grid2[i][j] = 2\\n                    if isIsland(i, j):\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1297304,
                "title": "weeb-does-python-bfs-beats-93-93",
                "content": "![image](https://assets.leetcode.com/users/images/5de9a20f-77e4-4816-9ca6-4e4f67f31269_1624675171.5262058.png)\\n\\n\\tclass Solution:\\n\\t\\tdef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n\\t\\t\\tqueue, row, col, visited = deque([]),len(grid1), len(grid1[0]), set([])\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor x in range(row):\\n\\t\\t\\t\\tfor y in range(col):\\n\\t\\t\\t\\t\\tif grid1[x][y] == 1 and grid2[x][y] == 1:\\n\\t\\t\\t\\t\\t\\tgrid2[x][y] = \"X\"\\n\\t\\t\\t\\t\\t\\tqueue.append((x,y))\\n\\t\\t\\t\\t\\t\\tcount += self.subCheck(queue,row,col,visited,grid1,grid2)   \\n\\t\\t\\treturn count\\n\\n\\t\\tdef subCheck(self,queue, row, col, visited, grid1, grid2):\\n\\t\\t\\tkey = True\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tx,y = queue.popleft()\\n\\t\\t\\t\\tfor nx,ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid2[nx][ny] == 1:\\n\\t\\t\\t\\t\\t\\tif grid1[nx][ny] != 1:\\n\\t\\t\\t\\t\\t\\t\\tkey = False\\n\\t\\t\\t\\t\\t\\tgrid2[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\t\\tqueue.append((nx,ny))\\n\\n\\t\\t\\tif key:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\treturn 0\\n\\nEnough coding, its time to chill and watch some anime\\nCheck out DOMESTIC NA KANOJO (Domestic girlfriend)\\n\\nEpisodes: 12\\nGenre: Drama, Romance, School\\n\\nI love this anime, the drama is good",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/5de9a20f-77e4-4816-9ca6-4e4f67f31269_1624675171.5262058.png)\\n\\n\\tclass Solution:\\n\\t\\tdef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n\\t\\t\\tqueue, row, col, visited = deque([]),len(grid1), len(grid1[0]), set([])\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor x in range(row):\\n\\t\\t\\t\\tfor y in range(col):\\n\\t\\t\\t\\t\\tif grid1[x][y] == 1 and grid2[x][y] == 1:\\n\\t\\t\\t\\t\\t\\tgrid2[x][y] = \"X\"\\n\\t\\t\\t\\t\\t\\tqueue.append((x,y))\\n\\t\\t\\t\\t\\t\\tcount += self.subCheck(queue,row,col,visited,grid1,grid2)   \\n\\t\\t\\treturn count\\n\\n\\t\\tdef subCheck(self,queue, row, col, visited, grid1, grid2):\\n\\t\\t\\tkey = True\\n\\t\\t\\twhile queue:\\n\\t\\t\\t\\tx,y = queue.popleft()\\n\\t\\t\\t\\tfor nx,ny in [[x+1,y], [x-1,y], [x,y+1], [x,y-1]]:\\n\\t\\t\\t\\t\\tif 0<=nx<row and 0<=ny<col and grid2[nx][ny] == 1:\\n\\t\\t\\t\\t\\t\\tif grid1[nx][ny] != 1:\\n\\t\\t\\t\\t\\t\\t\\tkey = False\\n\\t\\t\\t\\t\\t\\tgrid2[nx][ny] = \"X\"\\n\\t\\t\\t\\t\\t\\tqueue.append((nx,ny))\\n\\n\\t\\t\\tif key:\\n\\t\\t\\t\\treturn 1\\n\\n\\t\\t\\treturn 0\\n\\nEnough coding, its time to chill and watch some anime\\nCheck out DOMESTIC NA KANOJO (Domestic girlfriend)\\n\\nEpisodes: 12\\nGenre: Drama, Romance, School\\n\\nI love this anime, the drama is good",
                "codeTag": "Java"
            },
            {
                "id": 1284325,
                "title": "python-union-find",
                "content": "**Idea**\\n1. Use Union Find to connect all lands that belongs to the same island, for both girds. Let `(-1, -1)` be the root for all water cells.\\n2. For each island in `grid2`, get all its land cells.\\n3. For each land cell, say `grid2[r][c]`, check which island `grid1[r][c]` belongs to, add the island \"root\" into a set named `islands1`.\\n4. Remove `(-1, -1)`, which is the root of all water cells, from `islands1`. Now, if `len(islands1) == 1`, it means we found a island in `grid2`.\\n\\n**Complexity**\\nTime: `O(mn)`\\nSpace: `O(mn)`\\n\\n**Python**\\n```\\n    def countSubIslands(self, grid1, grid2):\\n\\t\\n        m, n = len(grid1), len(grid1[0])\\n\\n        def union(uf, x, y):\\n            uf[find(uf, x)] = find(uf, y)\\n            \\n        def find(uf, x):\\n\\t\\t\\t# the root of all 0s is (-1, -1)\\n            if x == (-1, -1):\\n                return x\\n            if uf[x] != x:\\n                uf[x] = find(uf, uf[x])\\n            return uf[x]\\n        \\n\\t\\t# connect all adjacent 1s for a given grid\\n        def process_grid(g):\\n            uf = {\\n                (r, c): (r, c) if g[r][c] else (-1, -1)\\n                for r in range(m)\\n                for c in range(n)\\n            }\\n            \\n            for r in range(m):\\n                for c in range(n):\\n                    if g[r][c]:\\n                        for nr, nc in [(r+1, c), (r, c+1)]:\\n                            if 0 <= nr < m and 0 <= nc < n and g[nr][nc]:\\n                                union(uf, (r, c), (nr, nc))\\n                                \\n            return uf\\n        \\n\\t\\t# group all land that belongs to the same island\\n        uf1, uf2 = process_grid(grid1), process_grid(grid2)\\n        islands2 = defaultdict(set)\\n        for r in range(m):\\n            for c in range(n):\\n                if grid2[r][c]:\\n                    root = find(uf2, (r, c))\\n                    islands2[root].add((r, c))\\n\\t\\t\\t\\t\\t\\n\\t\\t# find sub island\\n        res = 0\\n        for cells in islands2.values():\\n\\t\\t\\t# for all cell of a island in grid2, \\n\\t\\t\\t# if the corresponding cells in grid1 are also a land and belong to the same island, \\n\\t\\t\\t# we found an island\\n            islands1 = set(find(uf1, (r, c)) for r, c in cells)\\n\\t\\t\\t\\n\\t\\t\\t# a water cell is found in grid1\\n            if (-1, -1) in islands1:\\n                continue\\n            # all cells belong to the same island\\n            if len(islands1) == 1:\\n                res += 1\\n        return res\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\n    def countSubIslands(self, grid1, grid2):\\n\\t\\n        m, n = len(grid1), len(grid1[0])\\n\\n        def union(uf, x, y):\\n            uf[find(uf, x)] = find(uf, y)\\n            \\n        def find(uf, x):\\n\\t\\t\\t# the root of all 0s is (-1, -1)\\n            if x == (-1, -1):\\n                return x\\n            if uf[x] != x:\\n                uf[x] = find(uf, uf[x])\\n            return uf[x]\\n        \\n\\t\\t# connect all adjacent 1s for a given grid\\n        def process_grid(g):\\n            uf = {\\n                (r, c): (r, c) if g[r][c] else (-1, -1)\\n                for r in range(m)\\n                for c in range(n)\\n            }\\n            \\n            for r in range(m):\\n                for c in range(n):\\n                    if g[r][c]:\\n                        for nr, nc in [(r+1, c), (r, c+1)]:\\n                            if 0 <= nr < m and 0 <= nc < n and g[nr][nc]:\\n                                union(uf, (r, c), (nr, nc))\\n                                \\n            return uf\\n        \\n\\t\\t# group all land that belongs to the same island\\n        uf1, uf2 = process_grid(grid1), process_grid(grid2)\\n        islands2 = defaultdict(set)\\n        for r in range(m):\\n            for c in range(n):\\n                if grid2[r][c]:\\n                    root = find(uf2, (r, c))\\n                    islands2[root].add((r, c))\\n\\t\\t\\t\\t\\t\\n\\t\\t# find sub island\\n        res = 0\\n        for cells in islands2.values():\\n\\t\\t\\t# for all cell of a island in grid2, \\n\\t\\t\\t# if the corresponding cells in grid1 are also a land and belong to the same island, \\n\\t\\t\\t# we found an island\\n            islands1 = set(find(uf1, (r, c)) for r, c in cells)\\n\\t\\t\\t\\n\\t\\t\\t# a water cell is found in grid1\\n            if (-1, -1) in islands1:\\n                continue\\n            # all cells belong to the same island\\n            if len(islands1) == 1:\\n                res += 1\\n        return res\\n                \\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1285045,
                "title": "javascript-dfs-solution-o-nm-time-and-o-1-space",
                "content": "This is a typical DFS problem with a bit of a twist. In general we do a regular dfs on the grid2 to count no of islands. But additionally we check if all the cells of the grid2 island are also 1 in grid1 (at the same position).\\n\\nImplementation note: I\\'m using grid2 to mark visited cells (this is why I\\'m setting those to 2). If I can play this trick (that is, modify input) and don\\'t count stack frames in space complexity, than I can assume it is O(1). Otherwise we need to assume O(nm).\\n\\nHere is my implementation:\\n\\n```javascript\\nvar countSubIslands = function(grid1, grid2) {\\n    const R = grid2.length, C = grid2[0].length;\\n    \\n    // returns no of cells in grid 2 not covered in grid1\\n    function noOfNotCoveredDfs(i, j) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= R || j >= C) return 0;\\n        if (grid2[i][j] !== 1) return 0;\\n        \\n        // mark visited\\n        grid2[i][j] = 2;\\n        \\n        return (grid1[i][j] === 1 ? 0 : 1) + \\n            noOfNotCoveredDfs(i - 1, j) + \\n            noOfNotCoveredDfs(i + 1, j) + \\n            noOfNotCoveredDfs(i, j - 1) + \\n            noOfNotCoveredDfs(i, j + 1);\\n    }\\n    \\n    let ans = 0;\\n    for (let i = 0; i < R; i++) {\\n        for (let j = 0; j < C; j++) {\\n            if (grid2[i][j] === 1) {\\n                if (noOfNotCoveredDfs(i, j) === 0) {\\n                    ans++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar countSubIslands = function(grid1, grid2) {\\n    const R = grid2.length, C = grid2[0].length;\\n    \\n    // returns no of cells in grid 2 not covered in grid1\\n    function noOfNotCoveredDfs(i, j) {\\n        if (i < 0 || j < 0) return 0;\\n        if (i >= R || j >= C) return 0;\\n        if (grid2[i][j] !== 1) return 0;\\n        \\n        // mark visited\\n        grid2[i][j] = 2;\\n        \\n        return (grid1[i][j] === 1 ? 0 : 1) + \\n            noOfNotCoveredDfs(i - 1, j) + \\n            noOfNotCoveredDfs(i + 1, j) + \\n            noOfNotCoveredDfs(i, j - 1) + \\n            noOfNotCoveredDfs(i, j + 1);\\n    }\\n    \\n    let ans = 0;\\n    for (let i = 0; i < R; i++) {\\n        for (let j = 0; j < C; j++) {\\n            if (grid2[i][j] === 1) {\\n                if (noOfNotCoveredDfs(i, j) === 0) {\\n                    ans++;\\n                }\\n            }\\n        }\\n    }\\n    \\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2053936,
                "title": "c-intuitive-and-simple-approach-using-dfs",
                "content": "This question is easy but one might make it complex by thinking too much. I made this mistake at first. \\nWe just need to count the number of connected components which are also present in grid1. Now, it can be made as complex as you want. But, a simple way to solve this is using the visited and a boolean variable to decide whether or not we need to count the current component or not.\\n***How do we use them?***\\nWell, we know that if a component of grid2 is in grid1 too, then for all of the cells of grid2 component having 1, the same cell in grid1 should also have a 1 in it. If there is not 1 in grid1 cell, then we change the boolean variable from `true` to `false`, But make sure to mark all the cells in that component as visited because we are skipping the cells which have 1 but are visited. So, we start dfs from the cells which have 1 but which are unvisited so far. \\n\\n***NOTE*** Even if we have changed the state of boolean variable, we have to keep going with the dfs calls in each direction because we have to mark all the cells of that component as visited so that we do not start another dfs call from them. \\n\\n```\\nclass Solution {\\npublic:\\n    bool flag = true;\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid2[0].size(), count = 0;\\n        vector <vector <int>> visited(m,vector<int>(n,0));\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(grid2[i][j]==1){\\n                    if(!visited[i][j]){\\n                        flag = true;\\n                        dfs(i,j,m,n,grid1,grid2,visited);\\n                        if(flag) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\nprotected:\\n    void dfs(int x, int y, int m, int n, vector <vector <int>>&grid1, vector <vector <int>>&grid2, vector <vector <int>>&visited){\\n        if(x<0 or x>=m or y<0 or y>=n) return;\\n        if(visited[x][y] or grid2[x][y]==0) return;\\n        \\n        if(grid1[x][y] == 0) flag = false;\\n        \\n        visited[x][y] = 1;\\n        dfs(x-1,y,m,n,grid1,grid2,visited);\\n        dfs(x+1,y,m,n,grid1,grid2,visited);\\n        dfs(x,y-1,m,n,grid1,grid2,visited);\\n        dfs(x,y+1,m,n,grid1,grid2,visited);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag = true;\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid2[0].size(), count = 0;\\n        vector <vector <int>> visited(m,vector<int>(n,0));\\n        for(int i = 0; i<m; i++){\\n            for(int j = 0; j<n; j++){\\n                if(grid2[i][j]==1){\\n                    if(!visited[i][j]){\\n                        flag = true;\\n                        dfs(i,j,m,n,grid1,grid2,visited);\\n                        if(flag) count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\nprotected:\\n    void dfs(int x, int y, int m, int n, vector <vector <int>>&grid1, vector <vector <int>>&grid2, vector <vector <int>>&visited){\\n        if(x<0 or x>=m or y<0 or y>=n) return;\\n        if(visited[x][y] or grid2[x][y]==0) return;\\n        \\n        if(grid1[x][y] == 0) flag = false;\\n        \\n        visited[x][y] = 1;\\n        dfs(x-1,y,m,n,grid1,grid2,visited);\\n        dfs(x+1,y,m,n,grid1,grid2,visited);\\n        dfs(x,y-1,m,n,grid1,grid2,visited);\\n        dfs(x,y+1,m,n,grid1,grid2,visited);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416127,
                "title": "easy-clear-solution-python3-dp",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubIslands(self, back: List[List[int]], grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=0\\n        test=True\\n        def dfs(i,j):\\n            nonlocal test\\n            if grid[i][j]==1:\\n                if back[i][j] != 1:\\n                    test=False\\n                grid[i][j]=0\\n                if j<n-1:\\n                    dfs(i,j+1)\\n                if j>0:\\n                    dfs(i,j-1)\\n                if i>0:\\n                    dfs(i-1,j)\\n                if i<m-1:\\n                    dfs(i+1,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    \\n                    test=True\\n                    dfs(i,j)\\n                    if test :\\n                        res+=1\\n                    \\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, back: List[List[int]], grid: List[List[int]]) -> int:\\n        m=len(grid)\\n        n=len(grid[0])\\n        res=0\\n        test=True\\n        def dfs(i,j):\\n            nonlocal test\\n            if grid[i][j]==1:\\n                if back[i][j] != 1:\\n                    test=False\\n                grid[i][j]=0\\n                if j<n-1:\\n                    dfs(i,j+1)\\n                if j>0:\\n                    dfs(i,j-1)\\n                if i>0:\\n                    dfs(i-1,j)\\n                if i<m-1:\\n                    dfs(i+1,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid[i][j]==1:\\n                    \\n                    test=True\\n                    dfs(i,j)\\n                    if test :\\n                        res+=1\\n                    \\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2675238,
                "title": "simple-intuition-to-solve-996-ms-faster-than-70-12-of-c-online-submissions",
                "content": "We have to basically check **if the islands present in the grid2 is a subset or not of the islands of grid1.**\\nWhat we can do is to ***store the coordinates of the islands of the grid2 in a data structure*** and after that `we see if for any coordinate of the island of grid2, if the cell of grid 1 contains 0 then that island of the grid 2 is not a sub set of the island of grid 1.`\\nBelow is the implementation of the above logic.\\n```\\nclass Solution {\\npublic:\\n  void dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col, vector<pair<int, int>>& coOrdinatesOfOneIsland) {\\n    if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || !grid[row][col] || visited[row][col])\\n      return;\\n    visited[row][col] = 1;\\n    coOrdinatesOfOneIsland.push_back({ row, col });\\n    dfs(grid, visited, row, col + 1, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row, col - 1, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row + 1, col, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row - 1, col, coOrdinatesOfOneIsland);\\n  }\\n  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n    vector<vector<pair<int, int>>> coordinates;\\n    int n = grid2.size();\\n    int m = grid2[0].size();\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (grid2[i][j] == 1 && visited[i][j] == 0) {\\n          vector<pair<int, int>> coOrdinatesOfOneIsland;\\n          dfs(grid2, visited, i, j, coOrdinatesOfOneIsland);\\n          coordinates.push_back(coOrdinatesOfOneIsland);\\n        }\\n      }\\n    }\\n    int count = 0;\\n    for (auto it : coordinates) {\\n      bool flag = true;\\n      for (auto itr : it) {\\n        if (!grid1[itr.first][itr.second]) {\\n          flag = false;\\n          break;\\n        }\\n      }\\n      if (flag) count++;\\n    }\\n    return count;\\n  }\\n};\\n```\\nIf you like the approach Please upvote it so that it can reach it more people.\\nIn case of any query/doubt feel free to comment.",
                "solutionTags": [
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  void dfs(vector<vector<int>>& grid, vector<vector<int>>& visited, int row, int col, vector<pair<int, int>>& coOrdinatesOfOneIsland) {\\n    if (row < 0 || row >= grid.size() || col < 0 || col >= grid[0].size() || !grid[row][col] || visited[row][col])\\n      return;\\n    visited[row][col] = 1;\\n    coOrdinatesOfOneIsland.push_back({ row, col });\\n    dfs(grid, visited, row, col + 1, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row, col - 1, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row + 1, col, coOrdinatesOfOneIsland);\\n    dfs(grid, visited, row - 1, col, coOrdinatesOfOneIsland);\\n  }\\n  int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n    vector<vector<pair<int, int>>> coordinates;\\n    int n = grid2.size();\\n    int m = grid2[0].size();\\n    vector<vector<int>> visited(n, vector<int>(m, 0));\\n    for (int i = 0; i < n; i++) {\\n      for (int j = 0; j < m; j++) {\\n        if (grid2[i][j] == 1 && visited[i][j] == 0) {\\n          vector<pair<int, int>> coOrdinatesOfOneIsland;\\n          dfs(grid2, visited, i, j, coOrdinatesOfOneIsland);\\n          coordinates.push_back(coOrdinatesOfOneIsland);\\n        }\\n      }\\n    }\\n    int count = 0;\\n    for (auto it : coordinates) {\\n      bool flag = true;\\n      for (auto itr : it) {\\n        if (!grid1[itr.first][itr.second]) {\\n          flag = false;\\n          break;\\n        }\\n      }\\n      if (flag) count++;\\n    }\\n    return count;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2519379,
                "title": "python-elegant-short-in-place-dfs",
                "content": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n^2)\\n\\t\\tMemory: O(n^2)\\n\\t\\t\"\"\"\\n\\n\\t\\tLAND = 1\\n\\t\\tWATER = 0\\n\\n\\t\\tdef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n\\t\\t\\tm, n = len(grid1), len(grid1[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid2[i][j] == self.LAND and grid1[i][j] == self.WATER:\\n\\t\\t\\t\\t\\t\\tself.sink_island(i, j, grid2)\\n\\n\\t\\t\\tislands = 0\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid2[i][j] == self.LAND:\\n\\t\\t\\t\\t\\t\\tself.sink_island(i, j, grid2)\\n\\t\\t\\t\\t\\t\\tislands += 1\\n\\n\\t\\t\\treturn islands\\n\\n\\t\\t@classmethod\\n\\t\\tdef sink_island(cls, row: int, col: int, grid: List[List[int]]):\\n\\t\\t\\tif grid[row][col] == cls.LAND:\\n\\t\\t\\t\\tgrid[row][col] = cls.WATER\\n\\t\\t\\t\\tif row > 0:\\n\\t\\t\\t\\t\\tcls.sink_island(row - 1, col, grid)\\n\\t\\t\\t\\tif row < len(grid) - 1:\\n\\t\\t\\t\\t\\tcls.sink_island(row + 1, col, grid)\\n\\t\\t\\t\\tif col < len(grid[0]) - 1:\\n\\t\\t\\t\\t\\tcls.sink_island(row, col + 1, grid)\\n\\t\\t\\t\\tif col > 0:\\n\\t\\t\\t\\t\\tcls.sink_island(row, col - 1, grid)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\t\"\"\"\\n\\t\\tTime:   O(n^2)\\n\\t\\tMemory: O(n^2)\\n\\t\\t\"\"\"\\n\\n\\t\\tLAND = 1\\n\\t\\tWATER = 0\\n\\n\\t\\tdef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n\\t\\t\\tm, n = len(grid1), len(grid1[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid2[i][j] == self.LAND and grid1[i][j] == self.WATER:\\n\\t\\t\\t\\t\\t\\tself.sink_island(i, j, grid2)\\n\\n\\t\\t\\tislands = 0\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif grid2[i][j] == self.LAND:\\n\\t\\t\\t\\t\\t\\tself.sink_island(i, j, grid2)\\n\\t\\t\\t\\t\\t\\tislands += 1\\n\\n\\t\\t\\treturn islands\\n\\n\\t\\t@classmethod\\n\\t\\tdef sink_island(cls, row: int, col: int, grid: List[List[int]]):\\n\\t\\t\\tif grid[row][col] == cls.LAND:\\n\\t\\t\\t\\tgrid[row][col] = cls.WATER\\n\\t\\t\\t\\tif row > 0:\\n\\t\\t\\t\\t\\tcls.sink_island(row - 1, col, grid)\\n\\t\\t\\t\\tif row < len(grid) - 1:\\n\\t\\t\\t\\t\\tcls.sink_island(row + 1, col, grid)\\n\\t\\t\\t\\tif col < len(grid[0]) - 1:\\n\\t\\t\\t\\t\\tcls.sink_island(row, col + 1, grid)\\n\\t\\t\\t\\tif col > 0:\\n\\t\\t\\t\\t\\tcls.sink_island(row, col - 1, grid)\\n",
                "codeTag": "Java"
            },
            {
                "id": 1819208,
                "title": "java-dfs-solution-o-nm-time-and-o-1-space",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0 ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length ; j++){\\n\\t\\t\\t// applying dfs on grid2 and checking for corresponding cells in grid1 \\n                if(grid2[i][j] == 1){\\n                    ans = 1;\\n                    dfs(grid1, grid2, i, j);\\n                    count += ans;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid1.length || j >= grid1[0].length || grid2[i][j] == 0) return ;\\n\\t\\t// if the corresponding cell in grid1 is water, then we just make ans = 0.\\n        if(grid1[i][j] == 0) ans = 0;\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0 ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length ; j++){\\n\\t\\t\\t// applying dfs on grid2 and checking for corresponding cells in grid1 \\n                if(grid2[i][j] == 1){\\n                    ans = 1;\\n                    dfs(grid1, grid2, i, j);\\n                    count += ans;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid1.length || j >= grid1[0].length || grid2[i][j] == 0) return ;\\n\\t\\t// if the corresponding cell in grid1 is water, then we just make ans = 0.\\n        if(grid1[i][j] == 0) ans = 0;\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284907,
                "title": "during-contest-thought-vs-after-contest-thought-fun-to-optimize-it-well-commented",
                "content": "# During contest\\nAfter looking at constraints, I was insured that brute force will work. For example :\\n1. Go each (i,j) in grid2 and if it\\'s one than check there is common path for both grid1 and grid2 which is possible from (i,j).\\n2. If at any point (i,j), we get island for grid2 but not for grid1 then we return false because no common path.\\n3. So, If we get false then we reset all the possible path which is reachable from (i,j) in grid2.\\n4. At the end of step2 and step3, we\\'ll have modified grid2 such that for all path from (i,j) in grid2 there must be island in grid1.\\n5. Now that\\'s simple just find connected component for grid2.\\n\\n```\\n\\nvector<vector<bool>> visited(500, vector<bool>(500, false));\\n\\nclass Solution {\\n   public:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n\\n    bool isValid(int i, int j, vector<vector<int>>& grid2) {\\n        return (min(i, j) >= 0 && i < grid2.size() && j < grid2[0].size() && grid2[i][j]);\\n    }\\n\\n    bool isCommonPath(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        if (grid1[i][j] == 0) {\\n            // This is not a valid island. We need to reset.\\n            return false;\\n        }\\n        // Mark as visited\\n        visited[i][j] = true;\\n\\n        bool flag = true;\\n        for (int k = 0; k < 4 && flag; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2) && !visited[i][j] && !isCommonPath(grid1, grid2, r, c)) {\\n                flag = false;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    void reset(vector<vector<int>>& grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n\\n        //  Explore all the possible way and reset them also\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2)) {\\n                reset(grid2, r, c);\\n            }\\n        }\\n    }\\n\\n    void doDfs(vector<vector<int>>& grid, int i, int j) {\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid)) {\\n                doDfs(grid, r, c);\\n            }\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    //  Check all possible path grid1 contains or not\\n                    if (!isCommonPath(grid1, grid2, i, j)) {\\n                        // If not the reset it.\\n                        reset(grid2, i, j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Count number of connected components\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    count++;\\n                    doDfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\n\\n# After Contest\\nI realise that we don\\'t need to do such recursive call. Instead of that we can do very simple way. \\n1. If there is an island in grid2, then start exploring all the path and let\\'s assume this is going to make a valid island.\\n2. In case we get such (i,j) where grid2 has island but not in grid1, In that case our assumption was invalid. Revert that and just return.\\n3. Later, I realise that we don\\'t need visited in this scenario. We can mark grid2 as visited. Because if (i,j)->(l,m) was failed than also (l,m)->(x,y)[For rest of path, because we are rerturnig directly] will be failed(because l and m is common failure point).\\n\\n```\\nclass Solution {\\n   public:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n\\n    bool isValid(int i, int j, vector<vector<int>>& grid2) {\\n        return (min(i, j) >= 0 && i < grid2.size() && j < grid2[0].size() && grid2[i][j]);\\n    }\\n\\n    void doDfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int& flag) {\\n        if (!grid1[i][j]) {\\n            // Not a valid island, need to revert our assumption\\n            flag = 0;\\n            return;\\n        }\\n\\n        //  Mark visited\\n        grid2[i][j] = 0;\\n\\n        //  Explore all possible path\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2)) {\\n                doDfs(grid1, grid2, r, c, flag);\\n            }\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    //  Let\\'s assume we are getting a valid island\\n                    int isAllConnect = 1;\\n                    doDfs(grid1, grid2, i, j, isAllConnect);\\n                    count += isAllConnect;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nvector<vector<bool>> visited(500, vector<bool>(500, false));\\n\\nclass Solution {\\n   public:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n\\n    bool isValid(int i, int j, vector<vector<int>>& grid2) {\\n        return (min(i, j) >= 0 && i < grid2.size() && j < grid2[0].size() && grid2[i][j]);\\n    }\\n\\n    bool isCommonPath(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        if (grid1[i][j] == 0) {\\n            // This is not a valid island. We need to reset.\\n            return false;\\n        }\\n        // Mark as visited\\n        visited[i][j] = true;\\n\\n        bool flag = true;\\n        for (int k = 0; k < 4 && flag; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2) && !visited[i][j] && !isCommonPath(grid1, grid2, r, c)) {\\n                flag = false;\\n            }\\n        }\\n        return flag;\\n    }\\n\\n    void reset(vector<vector<int>>& grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n\\n        //  Explore all the possible way and reset them also\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2)) {\\n                reset(grid2, r, c);\\n            }\\n        }\\n    }\\n\\n    void doDfs(vector<vector<int>>& grid, int i, int j) {\\n        grid[i][j] = 0;\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid)) {\\n                doDfs(grid, r, c);\\n            }\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    //  Check all possible path grid1 contains or not\\n                    if (!isCommonPath(grid1, grid2, i, j)) {\\n                        // If not the reset it.\\n                        reset(grid2, i, j);\\n                    }\\n                }\\n            }\\n        }\\n\\n        // Count number of connected components\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    count++;\\n                    doDfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\n   public:\\n    vector<int> dx = {1, -1, 0, 0};\\n    vector<int> dy = {0, 0, 1, -1};\\n\\n    bool isValid(int i, int j, vector<vector<int>>& grid2) {\\n        return (min(i, j) >= 0 && i < grid2.size() && j < grid2[0].size() && grid2[i][j]);\\n    }\\n\\n    void doDfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int& flag) {\\n        if (!grid1[i][j]) {\\n            // Not a valid island, need to revert our assumption\\n            flag = 0;\\n            return;\\n        }\\n\\n        //  Mark visited\\n        grid2[i][j] = 0;\\n\\n        //  Explore all possible path\\n        for (int k = 0; k < 4; k++) {\\n            int r = i + dx[k], c = j + dy[k];\\n            if (isValid(r, c, grid2)) {\\n                doDfs(grid1, grid2, r, c, flag);\\n            }\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), count = 0;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (grid2[i][j]) {\\n                    //  Let\\'s assume we are getting a valid island\\n                    int isAllConnect = 1;\\n                    doDfs(grid1, grid2, i, j, isAllConnect);\\n                    count += isAllConnect;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3639925,
                "title": "fully-efficient-solution-in-java",
                "content": "# Algorithm : \\n- Perform DFS on grid2 and store the coordinates of the island.\\n- Check if every coordinate stored is \\'1\\' in grid1.\\n- If all the coordinates are 1\\'s in grid1 then increment the count.\\n- Finally return the count.\\n>### *Check the implementation for clear understanding !!*\\n---\\n# Java Code\\n```\\nclass Pair\\n{\\n    int x = 0;\\n    int y = 0;\\n    Pair(int x,int y)\\n    {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public void DFS(int[][] grid2,boolean[][] visited,int i,int j,ArrayList<Pair> arr)\\n    {\\n        if(i<0 || i>=grid2.length || j<0 || j>=grid2[0].length || visited[i][j] == true ||grid2[i][j]!=1)\\n            return;\\n        visited[i][j] = true;\\n        Pair p = new Pair(i,j);\\n        arr.add(p);\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            DFS(grid2,visited,newRow,newCol,arr);\\n        }\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int rows = grid1.length;\\n        int cols = grid1[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid2[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    ArrayList<Pair> arr = new ArrayList<>();\\n                    DFS(grid2,visited,i,j,arr);\\n                    boolean flag = false;\\n                    for(Pair p : arr)\\n                    {\\n                        int x = p.x;\\n                        int y = p.y;\\n                        if(grid1[x][y] != 1)\\n                        {\\n                            flag = true;\\n                            break;\\n                        }\\n                    }\\n                    if(!flag)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n---\\n#### *Please don\\'t forget to upvote if you\\'ve liked my explanation.*\\n---",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Pair\\n{\\n    int x = 0;\\n    int y = 0;\\n    Pair(int x,int y)\\n    {\\n        this.x = x;\\n        this.y = y;\\n    }\\n}\\nclass Solution {\\n    int[] xDir = {0,0,-1,1};\\n    int[] yDir = {-1,1,0,0};\\n    public void DFS(int[][] grid2,boolean[][] visited,int i,int j,ArrayList<Pair> arr)\\n    {\\n        if(i<0 || i>=grid2.length || j<0 || j>=grid2[0].length || visited[i][j] == true ||grid2[i][j]!=1)\\n            return;\\n        visited[i][j] = true;\\n        Pair p = new Pair(i,j);\\n        arr.add(p);\\n        for(int k = 0;k<4;k++)\\n        {\\n            int newRow = i+xDir[k];\\n            int newCol = j+yDir[k];\\n            DFS(grid2,visited,newRow,newCol,arr);\\n        }\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int rows = grid1.length;\\n        int cols = grid1[0].length;\\n        boolean[][] visited = new boolean[rows][cols];\\n        int count = 0;\\n        for(int i = 0;i<rows;i++)\\n        {\\n            for(int j = 0;j<cols;j++)\\n            {\\n                if(grid2[i][j] == 1 && visited[i][j] == false)\\n                {\\n                    ArrayList<Pair> arr = new ArrayList<>();\\n                    DFS(grid2,visited,i,j,arr);\\n                    boolean flag = false;\\n                    for(Pair p : arr)\\n                    {\\n                        int x = p.x;\\n                        int y = p.y;\\n                        if(grid1[x][y] != 1)\\n                        {\\n                            flag = true;\\n                            break;\\n                        }\\n                    }\\n                    if(!flag)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2839333,
                "title": "c-count-sub-islands-with-recursion",
                "content": "**Description**\\n\\nFind the number of islands in `grid2`, for which there is an island in `grid1` that contains all the cells that make up this island in `grid2`.\\n\\n**Program**\\n\\n```cpp []\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& check) {\\n        int m = grid2.size(), n = grid2[0].size();\\n        if (r < 0 || r >= m || c < 0 || c >= n || grid2[r][c] == 0) {\\n            return;\\n        }\\n        if (grid1[r][c] == 0 && grid2[r][c] == 1) {\\n            check = false;\\n        }\\n        grid2[r][c] = 0;\\n        dfs(r - 1, c, grid1, grid2, check);\\n        dfs(r + 1, c, grid1, grid2, check);\\n        dfs(r, c - 1, grid1, grid2, check);\\n        dfs(r, c + 1, grid1, grid2, check);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid2.size(), n = grid2[0].size();\\n        int result = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid2[r][c] == 1) {\\n                    bool check = true;\\n                    dfs(r, c, grid1, grid2, check);\\n                    result += check;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```cpp []\\nclass Solution {\\nprivate:\\n    void dfs(int r, int c, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& check) {\\n        int m = grid2.size(), n = grid2[0].size();\\n        if (r < 0 || r >= m || c < 0 || c >= n || grid2[r][c] == 0) {\\n            return;\\n        }\\n        if (grid1[r][c] == 0 && grid2[r][c] == 1) {\\n            check = false;\\n        }\\n        grid2[r][c] = 0;\\n        dfs(r - 1, c, grid1, grid2, check);\\n        dfs(r + 1, c, grid1, grid2, check);\\n        dfs(r, c - 1, grid1, grid2, check);\\n        dfs(r, c + 1, grid1, grid2, check);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid2.size(), n = grid2[0].size();\\n        int result = 0;\\n        for (int r = 0; r < m; r++) {\\n            for (int c = 0; c < n; c++) {\\n                if (grid2[r][c] == 1) {\\n                    bool check = true;\\n                    dfs(r, c, grid1, grid2, check);\\n                    result += check;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284347,
                "title": "java-simple-dfs-with-explanation-and-comments-t-o-n-m-and-s-o-n-m",
                "content": "```\\n/*\\n    Simply use DFS to find all the complete islands in grid2 and for a cell of a island of grid2,\\n    check if the corresponding cell in grid1 is also a part of a island in grid1.\\n    If the current island is not a sub-island, then for at least one of the cell of the island in grid2, \\n    the corresponding cell in grid1 is water. We check the presence of such a cell.\\n*/\\nclass Solution {\\n    boolean isSub; // stores if an island in grid2 is a sub-island or not.\\n    int [][]dir={{1,0},{0,1},{-1,0},{0,-1}}; // direction that we can go.\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n=grid1.length,m=grid1[0].length;\\n        boolean [][]vis=new boolean[n][m];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid2[i][j]==1){\\n                    isSub=true;\\n                    dfs(i,j,grid1,grid2,n,m,vis); // we start exploring in grid2.\\n                    \\n                    // if this island is a sub-island, we count it.\\n                    if(isSub)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public void dfs(int i, int j, int [][]grid1, int [][]grid2, int n, int m, boolean [][]vis){\\n        vis[i][j]=true;\\n        \\n        // if the corresponding cell in grid1 is water, then we just make \\'isSub\\' false.\\n        if(grid1[i][j]!=1)\\n            isSub=false;\\n        \\n        int x,y;\\n        for(int []d:dir){\\n            x=d[0]+i;\\n            y=d[1]+j;\\n            if(x<0||x>=n||y<0||y>=m||vis[x][y]||grid2[x][y]!=1)\\n                continue;            \\n            dfs(x,y,grid1,grid2,n,m,vis);\\n        }        \\n    }\\n}\\n\\n// T=O(n*m), S=O(n*m)\\n// Please share and upvote if this helps.\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Simply use DFS to find all the complete islands in grid2 and for a cell of a island of grid2,\\n    check if the corresponding cell in grid1 is also a part of a island in grid1.\\n    If the current island is not a sub-island, then for at least one of the cell of the island in grid2, \\n    the corresponding cell in grid1 is water. We check the presence of such a cell.\\n*/\\nclass Solution {\\n    boolean isSub; // stores if an island in grid2 is a sub-island or not.\\n    int [][]dir={{1,0},{0,1},{-1,0},{0,-1}}; // direction that we can go.\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n=grid1.length,m=grid1[0].length;\\n        boolean [][]vis=new boolean[n][m];\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(!vis[i][j]&&grid2[i][j]==1){\\n                    isSub=true;\\n                    dfs(i,j,grid1,grid2,n,m,vis); // we start exploring in grid2.\\n                    \\n                    // if this island is a sub-island, we count it.\\n                    if(isSub)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public void dfs(int i, int j, int [][]grid1, int [][]grid2, int n, int m, boolean [][]vis){\\n        vis[i][j]=true;\\n        \\n        // if the corresponding cell in grid1 is water, then we just make \\'isSub\\' false.\\n        if(grid1[i][j]!=1)\\n            isSub=false;\\n        \\n        int x,y;\\n        for(int []d:dir){\\n            x=d[0]+i;\\n            y=d[1]+j;\\n            if(x<0||x>=n||y<0||y>=m||vis[x][y]||grid2[x][y]!=1)\\n                continue;            \\n            dfs(x,y,grid1,grid2,n,m,vis);\\n        }        \\n    }\\n}\\n\\n// T=O(n*m), S=O(n*m)\\n// Please share and upvote if this helps.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3331864,
                "title": "c-faster-than-90-easy-dfs-explained-clean-code",
                "content": "\\n# PLEASE DO UPVOTE!!!!\\n\\n**To count the number of subislands is the only thing we have to keep in mind apart from counting the islands in the grid2 is , the respective island in the grid1 should be the bigger island, ie all the coordinates containing 1 in grid2 should be there in grid1 and if at any point while counting the islands we encounter grid2[i][j] = 1 and grid1[i][j] = 0, that wont contribute as a subisland and we will not increment our ans**\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\nint vis[500][500];\\n\\nvoid DFS(int i,int j,vector<vector<int>>&grid1,vector<vector<int>>&grid2,bool &f)\\n{\\n   if(i>=grid2.size()||j>=grid2[0].size()||i<0||j<0||grid2[i][j]==0||vis[i][j]==1) return;\\n   if(grid1[i][j]==0)\\n   {\\n        f = true;\\n        return;\\n   }\\n   vis[i][j] = 1;\\n   DFS(i+1,j,grid1,grid2,f);\\n   DFS(i-1,j,grid1,grid2,f);\\n   DFS(i,j+1,grid1,grid2,f);\\n   DFS(i,j-1,grid1,grid2,f);\\n}\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n       \\n       int n = grid1.size();\\n       int m = grid1[0].size();\\n       int ans = 0;\\n\\n       for(int i = 0;i<n;++i)\\n       {\\n           for(int j = 0;j<m;++j)\\n           {\\n               if(grid2[i][j]==1&&vis[i][j]==0)\\n               { \\n                  bool f = 0;\\n                  DFS(i,j,grid1,grid2,f);\\n                  if(!f) ans++; \\n               }\\n           }\\n       }\\n\\n       return ans;\\n      \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\nint vis[500][500];\\n\\nvoid DFS(int i,int j,vector<vector<int>>&grid1,vector<vector<int>>&grid2,bool &f)\\n{\\n   if(i>=grid2.size()||j>=grid2[0].size()||i<0||j<0||grid2[i][j]==0||vis[i][j]==1) return;\\n   if(grid1[i][j]==0)\\n   {\\n        f = true;\\n        return;\\n   }\\n   vis[i][j] = 1;\\n   DFS(i+1,j,grid1,grid2,f);\\n   DFS(i-1,j,grid1,grid2,f);\\n   DFS(i,j+1,grid1,grid2,f);\\n   DFS(i,j-1,grid1,grid2,f);\\n}\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n       \\n       int n = grid1.size();\\n       int m = grid1[0].size();\\n       int ans = 0;\\n\\n       for(int i = 0;i<n;++i)\\n       {\\n           for(int j = 0;j<m;++j)\\n           {\\n               if(grid2[i][j]==1&&vis[i][j]==0)\\n               { \\n                  bool f = 0;\\n                  DFS(i,j,grid1,grid2,f);\\n                  if(!f) ans++; \\n               }\\n           }\\n       }\\n\\n       return ans;\\n      \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829961,
                "title": "c-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\nDFS:-\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int x, int y, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& chk){\\n\\t\\t\\tif(x<0 || x>=grid1.size() || y<0 || y>=grid1[0].size()){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tif(grid1[x][y]==0 && grid2[x][y]==1){chk=false;}\\n\\t\\t\\tif(grid2[x][y]==0){return;}\\n\\t\\t\\tgrid2[x][y]=0;\\n\\t\\t\\tdfs(x-1, y, grid1, grid2, chk);\\n\\t\\t\\tdfs(x, y-1, grid1, grid2, chk);\\n\\t\\t\\tdfs(x+1, y, grid1, grid2, chk);\\n\\t\\t\\tdfs(x, y+1, grid1, grid2, chk);\\n\\t\\t}\\n\\t\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n\\t\\t\\tvector<vector<int>>v(grid1.size(), vector<int>(grid1[0].size(), 0));\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tfor(int i=0; i<grid2.size(); i++){\\n\\t\\t\\t\\tfor(int j=0; j<grid2[0].size(); j++){\\n\\t\\t\\t\\t\\tif(grid2[i][j]==1){\\n\\t\\t\\t\\t\\t\\tbool chk=true;\\n\\t\\t\\t\\t\\t\\tdfs(i, j, grid1, grid2, chk);\\n\\t\\t\\t\\t\\t\\tans+=chk;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int x, int y, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& chk){\\n\\t\\t\\tif(x<0 || x>=grid1.size() || y<0 || y>=grid1[0].size()){\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2772355,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int countSubIslands(vector<vector<int>>& B, vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    int dfs(vector<vector<int>>& B, vector<vector<int>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size(), res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int countSubIslands(vector<vector<int>>& B, vector<vector<int>>& A) {\\n        int m = A.size(), n = A[0].size(), res = 0;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (A[i][j] == 1)\\n                    res += dfs(B, A, i, j);\\n        return res;\\n    }\\n\\n\\n    int dfs(vector<vector<int>>& B, vector<vector<int>>& A, int i, int j) {\\n        int m = A.size(), n = A[0].size(), res = 1;\\n        if (i < 0 || i == m || j < 0 || j == n || A[i][j] == 0) return 1;\\n        A[i][j] = 0;\\n        res &= dfs(B, A, i - 1, j);\\n        res &= dfs(B, A, i + 1, j);\\n        res &= dfs(B, A, i, j - 1);\\n        res &= dfs(B, A, i, j + 1);\\n        return res & B[i][j];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354688,
                "title": "c-easy-to-understand-linear-1-pass-bfs-better-than-90-c-submissions",
                "content": "The Idea is very simple\\nTraverse grid2 and whenever you find 1 in grid2 check that whether it has been visited or not, if it is not visited then cover the whole area(bfs on all 4 directions) having 1 (land) and mark them as visited and simuntaneosly check the position in grid1, whether it is 1 or not, if position in grid1 in not 1 them mark answer for that spread as false and spread the island in grid2.\\n\\nStep-\\n1. visited[][] = false, count = 0\\n2. traverse grid2, if position at grid2 is not visited and grid2[i][j] == 1, then spread the island\\n3. Spread Function(BFS)- mark position as visited\\n\\t1. Create a queue, ans = true \\n\\t2. \\tStore the current indexws i,j in queue\\n\\t3. \\twhile q is not empty, pop elements from queue\\n\\t4. \\tcheck the popped position in grid1 is 1 or not, if not then update answer for that spread as 0(don\\'t return, we need to finish the island/spread for grid2)\\n\\t5. \\tthen travel all 4 directions from the popped position and check if it is not visited and position in grid2 is 1 then push it in queue and mark it as visited\\n\\t6. return ans\\n\\t\\n4. \\tif returned ans is true increase count by 1\\n5. \\treturn the count\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\n    bool** visited;\\n    queue<pair<int,int>> q;\\n    vector<vector<int>> arr1;\\n    vector<vector<int>> arr2;\\n    \\npublic:\\n    \\n    bool spread(int i,int j){\\n        \\n        visited[i][j] = true;\\n        q.push({i,j});\\n        bool ans = true;\\n        \\n        while(q.empty() == false){                       // bfs\\n            pair<int,int> element = q.front();\\n            q.pop();\\n            int r = element.first;\\n            int c = element.second;\\n            if(arr1[r][c] != 1){\\n                ans =  false;                   // if the island position in grid1 is water then updating answer as false\\n            }\\n            \\n            // moving to all four directions\\n            int hor[] = {-1,1,0,0};\\n            int ver[] = {0,0,-1,1};\\n            for(int a = 0 ; a < 4 ; a++){\\n                int row = r + hor[a];\\n                int col = c + ver[a];\\n                if(row >= 0 && row < arr1.size() && col >= 0 && col < arr1[0].size()){\\n                    if(visited[row][col] == false && arr2[row][col] == 1 ){\\n                        visited[row][col] = true;\\n                        q.push({row,col});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        arr1 = grid1;\\n        arr2 = grid2;\\n        int count = 0;\\n        visited = new bool*[rows];\\n        for(int i = 0 ; i < rows ; i++ ){\\n            visited[i] = new bool[cols];\\n            for(int j = 0 ; j < cols ; j++){\\n                visited[i][j] = false;\\n            }\\n        }\\n\\n        \\n        \\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(visited[i][j] == false && grid2[i][j] == 1){\\n                    bool ans = spread(i,j);\\n                    if(ans == true){\\n                        count += 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    \\n        \\n    }\\n};\\n```\\n\\n\\nTime Complexity - O(N^2) linear\\nSpace Complexity - O(N^2)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Queue",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    bool** visited;\\n    queue<pair<int,int>> q;\\n    vector<vector<int>> arr1;\\n    vector<vector<int>> arr2;\\n    \\npublic:\\n    \\n    bool spread(int i,int j){\\n        \\n        visited[i][j] = true;\\n        q.push({i,j});\\n        bool ans = true;\\n        \\n        while(q.empty() == false){                       // bfs\\n            pair<int,int> element = q.front();\\n            q.pop();\\n            int r = element.first;\\n            int c = element.second;\\n            if(arr1[r][c] != 1){\\n                ans =  false;                   // if the island position in grid1 is water then updating answer as false\\n            }\\n            \\n            // moving to all four directions\\n            int hor[] = {-1,1,0,0};\\n            int ver[] = {0,0,-1,1};\\n            for(int a = 0 ; a < 4 ; a++){\\n                int row = r + hor[a];\\n                int col = c + ver[a];\\n                if(row >= 0 && row < arr1.size() && col >= 0 && col < arr1[0].size()){\\n                    if(visited[row][col] == false && arr2[row][col] == 1 ){\\n                        visited[row][col] = true;\\n                        q.push({row,col});\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        arr1 = grid1;\\n        arr2 = grid2;\\n        int count = 0;\\n        visited = new bool*[rows];\\n        for(int i = 0 ; i < rows ; i++ ){\\n            visited[i] = new bool[cols];\\n            for(int j = 0 ; j < cols ; j++){\\n                visited[i][j] = false;\\n            }\\n        }\\n\\n        \\n        \\n        for(int i = 0 ; i < rows ; i++){\\n            for(int j = 0 ; j < cols ; j++){\\n                if(visited[i][j] == false && grid2[i][j] == 1){\\n                    bool ans = spread(i,j);\\n                    if(ans == true){\\n                        count += 1;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2233338,
                "title": "c-dfs-solution",
                "content": "Apply DFS for grid2, and if we can find a cell that is 0 in grid1 and in grid2, it is 1 then this island is not a sub-island, hence ans++.\\n\\n```\\n\\nvoid dfs(vector<vector<int>> &grid1, vector<vector<int>> &grid2, int i, int j, int& ans){\\n        int n = grid1.size(), m = grid1[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or grid2[i][j]==0) return;\\n        if(grid1[i][j]==0 and grid2[i][j]==1){\\n            ans = false; \\n            return;\\n        }\\n        grid2[i][j] = 0;\\n        int x[] = {0,0,-1,1}, y[] = {1,-1,0,0};\\n        for(int at=0;at<4;at++){\\n            dfs(grid1,grid2,i+x[at],j+y[at],ans);\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), res = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ans = 1;\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,ans);\\n                    res += ans;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "Apply DFS for grid2, and if we can find a cell that is 0 in grid1 and in grid2, it is 1 then this island is not a sub-island, hence ans++.\\n\\n```\\n\\nvoid dfs(vector<vector<int>> &grid1, vector<vector<int>> &grid2, int i, int j, int& ans){\\n        int n = grid1.size(), m = grid1[0].size();\\n        if(i<0 or i>=n or j<0 or j>=m or grid2[i][j]==0) return;\\n        if(grid1[i][j]==0 and grid2[i][j]==1){\\n            ans = false; \\n            return;\\n        }\\n        grid2[i][j] = 0;\\n        int x[] = {0,0,-1,1}, y[] = {1,-1,0,0};\\n        for(int at=0;at<4;at++){\\n            dfs(grid1,grid2,i+x[at],j+y[at],ans);\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size(), res = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int ans = 1;\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,ans);\\n                    res += ans;\\n                }\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2038853,
                "title": "c-easy-intuitive-dfs-bfs-approach-solutions-with-time-complexity",
                "content": "**1. DFS Approach**\\n```\\nclass Solution {\\npublic:\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid2.size(),m=grid2[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    if(dfs(grid1,grid2,i,j,n,m))\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nbool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int n,int m){\\n    \\n        // Base Case\\n        if(i<0||i>=n||j<0||j>=m||grid2[i][j]!=1)\\n            return true;\\n        \\n        // checking in grid 1\\n        if(grid1[i][j]==0)\\n            return false;\\n    \\n        // mark this cell visited \\n        grid2[i][j]=2;\\n    \\n        // calling dfs for valid directions\\n        bool a=dfs(grid1,grid2,i-1,j,n,m);\\n        bool b=dfs(grid1,grid2,i,j-1,n,m);\\n        bool c=dfs(grid1,grid2,i+1,j,n,m);\\n        bool d=dfs(grid1,grid2,i,j+1,n,m);\\n    \\n        // if either of the function returns false i.e. it is not a sub-island \\n        return a&&b&&c&&d;\\n\\n    }\\n};\\nTime Complexity: O(mn)\\n```\\n\\n**2. BFS Approach**\\n\\n```\\nclass Solution {\\npublic:\\n\\nint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n\\tint n = grid1.size(),m=grid1[0].size();\\n\\tvector<vector<int>> vis(n, vector<int>(m));\\n\\tint res = 0;\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(grid2[i][j] == 1 && vis[i][j]==0){\\n\\t\\t\\t\\tif(bfs(grid1,grid2,vis,i,j,n,m)) {\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n    bool bfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, vector<vector<int>>& vis, int i,int j,int n, int m) {\\n\\tqueue<pair<int, int>> q;\\n\\tq.push({i,j});\\n\\tvis[i][j] = 1;\\n\\tbool res = true;\\n\\twhile(!q.empty()) {\\n\\t\\tint r = q.front().first, c = q.front().second;\\n\\t\\tif(grid1[r][c] == 0) res=false;\\n\\t\\tq.pop();\\n\\t\\tint dx[] = {0, 1, 0, -1};\\n\\t\\tint dy[] = {1, 0, -1, 0};\\n\\n\\t\\tfor(int i = 0; i < 4; i++) {\\n\\t\\t\\tint newX = dx[i] + r;\\n\\t\\t\\tint newY = dy[i] + c;\\n\\n\\t\\t\\tif(newX >= 0 && newX < n && newY >= 0 && newY < m && grid2[newX][newY] == 1 && vis[newX][newY] == 0) {\\n\\t\\t\\t\\tq.push({newX, newY});\\n\\t\\t\\t\\tvis[newX][newY] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}   \\n\\treturn res;\\n}\\n};\\nTime Complexity: O(mn)\\n```\\n####  DO UPVOTE IF U FIND IT HELPFUL :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid2.size(),m=grid2[0].size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    if(dfs(grid1,grid2,i,j,n,m))\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\nbool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int n,int m){\\n    \\n        // Base Case\\n        if(i<0||i>=n||j<0||j>=m||grid2[i][j]!=1)\\n            return true;\\n        \\n        // checking in grid 1\\n        if(grid1[i][j]==0)\\n            return false;\\n    \\n        // mark this cell visited \\n        grid2[i][j]=2;\\n    \\n        // calling dfs for valid directions\\n        bool a=dfs(grid1,grid2,i-1,j,n,m);\\n        bool b=dfs(grid1,grid2,i,j-1,n,m);\\n        bool c=dfs(grid1,grid2,i+1,j,n,m);\\n        bool d=dfs(grid1,grid2,i,j+1,n,m);\\n    \\n        // if either of the function returns false i.e. it is not a sub-island \\n        return a&&b&&c&&d;\\n\\n    }\\n};\\nTime Complexity: O(mn)\\n```\n```\\nclass Solution {\\npublic:\\n\\nint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n\\tint n = grid1.size(),m=grid1[0].size();\\n\\tvector<vector<int>> vis(n, vector<int>(m));\\n\\tint res = 0;\\n\\tfor(int i=0;i<n;i++) {\\n\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\tif(grid2[i][j] == 1 && vis[i][j]==0){\\n\\t\\t\\t\\tif(bfs(grid1,grid2,vis,i,j,n,m)) {\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n    bool bfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, vector<vector<int>>& vis, int i,int j,int n, int m) {\\n\\tqueue<pair<int, int>> q;\\n\\tq.push({i,j});\\n\\tvis[i][j] = 1;\\n\\tbool res = true;\\n\\twhile(!q.empty()) {\\n\\t\\tint r = q.front().first, c = q.front().second;\\n\\t\\tif(grid1[r][c] == 0) res=false;\\n\\t\\tq.pop();\\n\\t\\tint dx[] = {0, 1, 0, -1};\\n\\t\\tint dy[] = {1, 0, -1, 0};\\n\\n\\t\\tfor(int i = 0; i < 4; i++) {\\n\\t\\t\\tint newX = dx[i] + r;\\n\\t\\t\\tint newY = dy[i] + c;\\n\\n\\t\\t\\tif(newX >= 0 && newX < n && newY >= 0 && newY < m && grid2[newX][newY] == 1 && vis[newX][newY] == 0) {\\n\\t\\t\\t\\tq.push({newX, newY});\\n\\t\\t\\t\\tvis[newX][newY] = 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}   \\n\\treturn res;\\n}\\n};\\nTime Complexity: O(mn)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1931652,
                "title": "c-union-find-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        p = vector<int>(m * n + 1);\\n        cnt = m * n;\\n        rank = vector<int>(m * n + 1, 1);\\n        iota(p.begin(), p.end(), 0);\\n        vector<pair<int,int>> dir = {{0, 1}, {1, 0}};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j] == 0) {\\n                    cnt--;\\n                    continue;\\n                } \\n                int a = i * n + j;\\n                for (int k = 0; k < dir.size(); k++) {\\n                    int x = i + dir[k].first, y = j + dir[k].second;\\n                    if (x >= m || y >= n) continue;\\n                    if (grid2[x][y] == 0) continue;\\n                    int b = x * n + y;\\n                    comb(a, b);\\n                }\\n            }\\n        }\\n        unordered_set<int> invalide;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j] == 0) continue;\\n                int root = find(i * n + j);\\n                if (grid1[i][j] == 0) {\\n                    invalide.insert(root);\\n                }\\n            }\\n        }\\n        return cnt - invalide.size();\\n    }\\nprivate:\\n    vector<int> p;\\n    vector<int> rank;\\n    int cnt = 0;;\\n    void comb(int a, int b) {\\n        int roota = find(a);\\n        int rootb = find(b);\\n        if (roota == rootb) return;\\n        cnt--;\\n        if (rank[roota] > rank[rootb]) {\\n            p[rootb] = roota;\\n            rank[roota] += rank[rootb];\\n        } else {\\n            p[roota] = rootb;\\n            rank[rootb] += rank[roota];\\n        }\\n        return;\\n    }\\n    int find(int a) {\\n        if (p[a] != a) {\\n            p[a] = find(p[a]);\\n        }\\n        return p[a];\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        p = vector<int>(m * n + 1);\\n        cnt = m * n;\\n        rank = vector<int>(m * n + 1, 1);\\n        iota(p.begin(), p.end(), 0);\\n        vector<pair<int,int>> dir = {{0, 1}, {1, 0}};\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j] == 0) {\\n                    cnt--;\\n                    continue;\\n                } \\n                int a = i * n + j;\\n                for (int k = 0; k < dir.size(); k++) {\\n                    int x = i + dir[k].first, y = j + dir[k].second;\\n                    if (x >= m || y >= n) continue;\\n                    if (grid2[x][y] == 0) continue;\\n                    int b = x * n + y;\\n                    comb(a, b);\\n                }\\n            }\\n        }\\n        unordered_set<int> invalide;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j] == 0) continue;\\n                int root = find(i * n + j);\\n                if (grid1[i][j] == 0) {\\n                    invalide.insert(root);\\n                }\\n            }\\n        }\\n        return cnt - invalide.size();\\n    }\\nprivate:\\n    vector<int> p;\\n    vector<int> rank;\\n    int cnt = 0;;\\n    void comb(int a, int b) {\\n        int roota = find(a);\\n        int rootb = find(b);\\n        if (roota == rootb) return;\\n        cnt--;\\n        if (rank[roota] > rank[rootb]) {\\n            p[rootb] = roota;\\n            rank[roota] += rank[rootb];\\n        } else {\\n            p[roota] = rootb;\\n            rank[rootb] += rank[roota];\\n        }\\n        return;\\n    }\\n    int find(int a) {\\n        if (p[a] != a) {\\n            p[a] = find(p[a]);\\n        }\\n        return p[a];\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849456,
                "title": "begineer-level-approach-c-simple-solution",
                "content": "**In first DFS , we just make all the similar 1\\'s child of 1st matrix as 2  in 2nd matrix**\\n**In second DFS we Just count for all the 2s that are also present as 1 in 1st matrix**\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2 ,int i, int j){\\n        if(i<0  or j<0 or i==grid2.size() or j==grid2[0].size() or grid2[i][j] != 1){\\n            return;\\n        }\\n        if(grid2[i][j] == 1 and grid1[i][j] == 1){\\n            grid2[i][j]=2;\\n        }else{\\n            return;\\n        }\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j-1);\\n    }\\n    void dfs1(vector<vector<int>>& grid2 ,int i,int j,bool& flag){\\n        if(i<0 or j<0 or i==grid2.size() or j==grid2[0].size() or grid2[i][j]==0 or grid2[i][j] == 3){\\n            return;\\n        }\\n        if(grid2[i][j] == 1)\\n        {\\n            flag = false;\\n            return;\\n        }\\n        grid2[i][j] = 3;\\n        dfs1(grid2,i+1,j,flag);\\n        dfs1(grid2,i,j+1,flag);\\n        dfs1(grid2,i-1,j,flag);\\n        dfs1(grid2,i,j-1,flag);\\n    }    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        for(int i=0;i<grid1.size();i++){\\n            for(int j=0;j<grid1[i].size();j++){\\n                if(grid2[i][j])dfs(grid1,grid2,i,j);\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<grid2.size();i++){\\n            for(int j=0;j<grid2[i].size();j++){\\n                // cout<<grid2[i][j]<<\" \";\\n                if(grid2[i][j]==2){\\n                    bool flag=true;\\n                    dfs1(grid2,i,j,flag);\\n                    if(flag)\\n                    count++;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2 ,int i, int j){\\n        if(i<0  or j<0 or i==grid2.size() or j==grid2[0].size() or grid2[i][j] != 1){\\n            return;\\n        }\\n        if(grid2[i][j] == 1 and grid1[i][j] == 1){\\n            grid2[i][j]=2;\\n        }else{\\n            return;\\n        }\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j-1);\\n    }\\n    void dfs1(vector<vector<int>>& grid2 ,int i,int j,bool& flag){\\n        if(i<0 or j<0 or i==grid2.size() or j==grid2[0].size() or grid2[i][j]==0 or grid2[i][j] == 3){\\n            return;\\n        }\\n        if(grid2[i][j] == 1)\\n        {\\n            flag = false;\\n            return;\\n        }\\n        grid2[i][j] = 3;\\n        dfs1(grid2,i+1,j,flag);\\n        dfs1(grid2,i,j+1,flag);\\n        dfs1(grid2,i-1,j,flag);\\n        dfs1(grid2,i,j-1,flag);\\n    }    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        for(int i=0;i<grid1.size();i++){\\n            for(int j=0;j<grid1[i].size();j++){\\n                if(grid2[i][j])dfs(grid1,grid2,i,j);\\n            }\\n        }\\n        int count=0;\\n        for(int i=0;i<grid2.size();i++){\\n            for(int j=0;j<grid2[i].size();j++){\\n                // cout<<grid2[i][j]<<\" \";\\n                if(grid2[i][j]==2){\\n                    bool flag=true;\\n                    dfs1(grid2,i,j,flag);\\n                    if(flag)\\n                    count++;\\n                }\\n            }\\n            // cout<<endl;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1834762,
                "title": "javascript-dfs-solution",
                "content": "```\\n/**\\n * @param {number[][]} grid1\\n * @param {number[][]} grid2\\n * @return {number}\\n */\\nvar countSubIslands = function(grid1, grid2) {\\n    let count = 0\\n    let isSubIsland = true\\n    for (let i = 0; i < grid2.length; i++) {\\n        for (let j = 0; j < grid2[i].length; j++) {\\n            if (grid2[i][j] === 1) {\\n                dfs(i, j)\\n                if (isSubIsland) count++\\n                isSubIsland = true\\n            }\\n        }\\n    }\\n    function dfs(raw, col) {\\n        if (raw >= grid2.length || raw < 0 || col >= grid2[0].length || col < 0 || grid2[raw][col] == 0) return;\\n        if (grid2[raw][col] === 1 && grid1[raw][col] === 0) {\\n            isSubIsland = false\\n            return\\n        }\\n        grid2[raw][col] = 0\\n        dfs(raw - 1, col)\\n        dfs(raw + 1, col)\\n        dfs(raw, col - 1)\\n        dfs(raw, col + 1)\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid1\\n * @param {number[][]} grid2\\n * @return {number}\\n */\\nvar countSubIslands = function(grid1, grid2) {\\n    let count = 0\\n    let isSubIsland = true\\n    for (let i = 0; i < grid2.length; i++) {\\n        for (let j = 0; j < grid2[i].length; j++) {\\n            if (grid2[i][j] === 1) {\\n                dfs(i, j)\\n                if (isSubIsland) count++\\n                isSubIsland = true\\n            }\\n        }\\n    }\\n    function dfs(raw, col) {\\n        if (raw >= grid2.length || raw < 0 || col >= grid2[0].length || col < 0 || grid2[raw][col] == 0) return;\\n        if (grid2[raw][col] === 1 && grid1[raw][col] === 0) {\\n            isSubIsland = false\\n            return\\n        }\\n        grid2[raw][col] = 0\\n        dfs(raw - 1, col)\\n        dfs(raw + 1, col)\\n        dfs(raw, col - 1)\\n        dfs(raw, col + 1)\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1834141,
                "title": "java-simple-dfs-grid-difference-2-grid1-grid2",
                "content": "A valid island contains land cells in both grids, and it is not connected to any new land cell in grid2. Based on this, we can do a preprocessing: `gird1 = gird1 * 2 - grid2` to get the difference of two grids. We would get `-1`, `0`, `1` and `2` in the difference grid:\\n- `grid[i][j] == -1`: `(i, j)` is water in grid1 and land in grid2\\n- `grid[i][j] == 0`: `(i, j)` is water in grid1 and water in grid2\\n- `grid[i][j] == 1`: `(i, j)` is land in grid1 and land in grid2\\n- `grid[i][j] == 2`: `(i, j)` is land in grid1 and water in grid2\\n\\nBy doing this, we can simply search for cells with value `1` in the difference grid (i.g. `grid1`), and check if it is connected to any cells with value `-1`, if yes then this island is invalid and should not be counted as subisland; otherwise it\\'s valid and we should increment `count`.\\n\\n```java\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        // preprocess two grids:\\n        // gird1 = gird1 * 2 - grid2\\n        for (int i = 0; i < grid1.length; ++i) {\\n            for (int j = 0; j < grid1[0].length; ++j) {\\n                grid1[i][j] = grid1[i][j] * 2 - grid2[i][j];\\n            }\\n        }\\n\\t\\t\\n        // count valid islands\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; ++i) {\\n            for (int j = 0; j < grid1[0].length; ++j) {\\n                if (grid1[i][j] == 1 && isValid(grid1, i, j)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int r, int c) {\\n        // if the index is invalid, simply return true and end this recursion\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length) {\\n            return true;\\n        }\\n        \\n        // grid[r][c] == 2: this cell is land in grid1 but is water in grid2\\n        // grid[r][c] == 0: this cell is land in both grid1 and grid2\\n        if (grid[r][c] == 2 || grid[r][c] == 0) return true;\\n        \\n        // grid[r][c] == -1: this cell is water in grid1 but is land in grid2\\n        if (grid[r][c] == -1) return false;\\n        \\n        // mark this cell as visited\\n        grid[r][c] = 0;\\n        \\n        return isValid(grid, r-1, c) & isValid(grid, r+1, c) & isValid(grid, r, c+1) & isValid(grid, r, c-1);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        // preprocess two grids:\\n        // gird1 = gird1 * 2 - grid2\\n        for (int i = 0; i < grid1.length; ++i) {\\n            for (int j = 0; j < grid1[0].length; ++j) {\\n                grid1[i][j] = grid1[i][j] * 2 - grid2[i][j];\\n            }\\n        }\\n\\t\\t\\n        // count valid islands\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; ++i) {\\n            for (int j = 0; j < grid1[0].length; ++j) {\\n                if (grid1[i][j] == 1 && isValid(grid1, i, j)) {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean isValid(int[][] grid, int r, int c) {\\n        // if the index is invalid, simply return true and end this recursion\\n        if (r < 0 || c < 0 || r >= grid.length || c >= grid[0].length) {\\n            return true;\\n        }\\n        \\n        // grid[r][c] == 2: this cell is land in grid1 but is water in grid2\\n        // grid[r][c] == 0: this cell is land in both grid1 and grid2\\n        if (grid[r][c] == 2 || grid[r][c] == 0) return true;\\n        \\n        // grid[r][c] == -1: this cell is water in grid1 but is land in grid2\\n        if (grid[r][c] == -1) return false;\\n        \\n        // mark this cell as visited\\n        grid[r][c] = 0;\\n        \\n        return isValid(grid, r-1, c) & isValid(grid, r+1, c) & isValid(grid, r, c+1) & isValid(grid, r, c-1);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643200,
                "title": "python3-dfs-easy-understanding",
                "content": "```\\ndef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int: \\n        m, n = len(grid1), len(grid1[0])\\n        sub_islands = 0\\n        \\n        def dfs(row: int, col: int):\\n            if row < 0 or row >= m or col < 0 or col >= n:\\n                return True\\n            \\n            if grid2[row][col] != 1:\\n                return True\\n            \\n            grid2[row][col] = 0\\n            \\n            top = dfs(row - 1, col)\\n            bot = dfs(row + 1, col)\\n            left = dfs(row, col - 1)\\n            right = dfs(row, col + 1)\\n            \\n            if grid1[row][col] != 1:\\n                return False\\n            \\n            return top and bot and left and right\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    sub_islands += dfs(i, j)\\n        \\n        return sub_islands\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int: \\n        m, n = len(grid1), len(grid1[0])\\n        sub_islands = 0\\n        \\n        def dfs(row: int, col: int):\\n            if row < 0 or row >= m or col < 0 or col >= n:\\n                return True\\n            \\n            if grid2[row][col] != 1:\\n                return True\\n            \\n            grid2[row][col] = 0\\n            \\n            top = dfs(row - 1, col)\\n            bot = dfs(row + 1, col)\\n            left = dfs(row, col - 1)\\n            right = dfs(row, col + 1)\\n            \\n            if grid1[row][col] != 1:\\n                return False\\n            \\n            return top and bot and left and right\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    sub_islands += dfs(i, j)\\n        \\n        return sub_islands\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1286892,
                "title": "count-sub-islands-c-dfs",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> x;\\n    bool b=true;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(grid[i][j]==0) return;\\n        if(x[i][j]==0) b=false;\\n        grid[i][j]=0;\\n        if(j<m-1)\\n        dfs(grid,i,j+1);\\n        if(i<n-1)\\n        dfs(grid,i+1,j);\\n        if(j>0)\\n        dfs(grid,i,j-1);\\n        if(i>0)\\n        dfs(grid,i-1,j);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        x=grid1;\\n        n=grid1.size();\\n        m=grid1[0].size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(grid2,i,j);\\n                    if(b)\\n                        cnt++;\\n                    b=true;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n };\\n\\n\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<vector<int>> x;\\n    bool b=true;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(grid[i][j]==0) return;\\n        if(x[i][j]==0) b=false;\\n        grid[i][j]=0;\\n        if(j<m-1)\\n        dfs(grid,i,j+1);\\n        if(i<n-1)\\n        dfs(grid,i+1,j);\\n        if(j>0)\\n        dfs(grid,i,j-1);\\n        if(i>0)\\n        dfs(grid,i-1,j);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        x=grid1;\\n        n=grid1.size();\\n        m=grid1[0].size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(grid2,i,j);\\n                    if(b)\\n                        cnt++;\\n                    b=true;\\n                }\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n };\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284850,
                "title": "o-m-n-time-complexity-95-faster-with-comments",
                "content": "Kindly go through it. Incase of any doubts, feel free to comment.\\n\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        # Time complexity: O(m*n+m*n)=>O(m*n) (we are iteraing twice through every cell)\\n        # Space complexity: O(1)\\n        \\n        m=len(grid2)\\n        n=len(grid2[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:return \\n\\t\\t\\t# update the value as we don\\'t want to navigate the same cell again\\n            grid2[i][j]=0\\n            #visit all directions\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                #removing potenial islands which are not present in grid1\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                #simply calculating different islands\\n                if grid2[i][j]==1:\\n                    count+=1\\n                    dfs(i,j)\\n        return count\\n            \\n```\\nIf you are happy with the solution, do not shy to upvote\\nif you don\\'t like or have any suggestion please comment\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        # Time complexity: O(m*n+m*n)=>O(m*n) (we are iteraing twice through every cell)\\n        # Space complexity: O(1)\\n        \\n        m=len(grid2)\\n        n=len(grid2[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:return \\n\\t\\t\\t# update the value as we don\\'t want to navigate the same cell again\\n            grid2[i][j]=0\\n            #visit all directions\\n            dfs(i,j-1)\\n            dfs(i,j+1)\\n            dfs(i-1,j)\\n            dfs(i+1,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                #removing potenial islands which are not present in grid1\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                #simply calculating different islands\\n                if grid2[i][j]==1:\\n                    count+=1\\n                    dfs(i,j)\\n        return count\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284448,
                "title": "easy-python-solution-on-dfs",
                "content": "* lets see the basic idea is if for example thier is a piece of land in grid2 at that point their is water in grid1 then by no chance it can become a subisland and hence this land and island made by the land cannot be a subisland\\n* now we remove all this type of islands from our grid2 using basic dfs\\n* now we are left with those land which are subarray because any part that was not covered was removed earlier \\n* so now we count the islands using basic dfs ..,..\\n** if u like the answer do upvote it motivates a lot ..thanks for reading the answer**\\n\\n\\n```\\nclass Solution(object):\\n    def countSubIslands(self, grid1, grid2):\\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n        # here we remove the unnecesaary islands by seeing the point that if for a land in grid2 and water in grid1 it cannot be a subisland and hence island in which this land resides should be removed \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n\\t\\t#now we just need to count the islands left over \\t\\t\\t\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    \\n                    dfs(i,j)\\n                    count+=1\\n        return count \\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSubIslands(self, grid1, grid2):\\n        m=len(grid1)\\n        n=len(grid1[0])\\n        \\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or grid2[i][j]==0:\\n                return \\n            grid2[i][j]=0\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n        # here we remove the unnecesaary islands by seeing the point that if for a land in grid2 and water in grid1 it cannot be a subisland and hence island in which this land resides should be removed \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n\\t\\t#now we just need to count the islands left over \\t\\t\\t\\n        count=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    \\n                    dfs(i,j)\\n                    count+=1\\n        return count \\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1284287,
                "title": "python3-dfs",
                "content": "\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid1), len(grid1[0]) # dimensions \\n        \\n        def fn(i, j): \\n            \"\"\"Return True if i, j is in a sub-island.\"\"\"\\n            grid2[i][j] = 0 # mark as visited \\n            ans = grid1[i][j]\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid2[ii][jj]: \\n                    ans &= fn(ii, jj)\\n            return ans \\n            \\n        ans = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid2[i][j] and fn(i, j): ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid1), len(grid1[0]) # dimensions \\n        \\n        def fn(i, j): \\n            \"\"\"Return True if i, j is in a sub-island.\"\"\"\\n            grid2[i][j] = 0 # mark as visited \\n            ans = grid1[i][j]\\n            for ii, jj in (i-1, j), (i, j-1), (i, j+1), (i+1, j): \\n                if 0 <= ii < m and 0 <= jj < n and grid2[ii][jj]: \\n                    ans &= fn(ii, jj)\\n            return ans \\n            \\n        ans = 0 \\n        for i in range(m):\\n            for j in range(n): \\n                if grid2[i][j] and fn(i, j): ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284265,
                "title": "python-no-extra-space-dfs",
                "content": "The Main idea behind this solution is to visit all the islands in grid2 and check if the corresponding place(i,j) in grid1 is a land(1) or not.If the value is not 1 then I have assigned False to a gloval boolean varible(bval) and checking whether i have encountered a False or not and incrementing the count\\n\\n\\n\\n~~~\\nbval=True #global variable\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        def dfs1(i,j):\\n            global bval\\n            grid2[i][j]=0\\n            if(grid1[i][j]==0):bval=False; #conflict arised that is grid2 have land and grid1 have water\\n            if(i+1<len(grid1) and grid2[i+1][j]==1):dfs1(i+1,j) #downw\\n            if(j+1<len(grid1[0]) and grid2[i][j+1]==1):dfs1(i,j+1) #right\\n            if(i-1>=0 and grid2[i-1][j]==1):dfs1(i-1,j) #up\\n            if(j-1>=0 and grid2[i][j-1]==1):dfs1(i,j-1) #left\\n        count=0 \\n        for i in range(len(grid1)):\\n            for j in range(len(grid1[0])):\\n                if(grid2[i][j]==1):\\n                    global bval\\n                    bval=True #intially assuming true\\n                    dfs1(i,j)\\n                    if(bval):count+=1 #if no conflict occured,incrementing count\\n        return count\\n~~~",
                "solutionTags": [],
                "code": "The Main idea behind this solution is to visit all the islands in grid2 and check if the corresponding place(i,j) in grid1 is a land(1) or not.If the value is not 1 then I have assigned False to a gloval boolean varible(bval) and checking whether i have encountered a False or not and incrementing the count\\n\\n\\n\\n~~~\\nbval=True #global variable\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        def dfs1(i,j):\\n            global bval\\n            grid2[i][j]=0\\n            if(grid1[i][j]==0):bval=False; #conflict arised that is grid2 have land and grid1 have water\\n            if(i+1<len(grid1) and grid2[i+1][j]==1):dfs1(i+1,j) #downw\\n            if(j+1<len(grid1[0]) and grid2[i][j+1]==1):dfs1(i,j+1) #right\\n            if(i-1>=0 and grid2[i-1][j]==1):dfs1(i-1,j) #up\\n            if(j-1>=0 and grid2[i][j-1]==1):dfs1(i,j-1) #left\\n        count=0 \\n        for i in range(len(grid1)):\\n            for j in range(len(grid1[0])):\\n                if(grid2[i][j]==1):\\n                    global bval\\n                    bval=True #intially assuming true\\n                    dfs1(i,j)\\n                    if(bval):count+=1 #if no conflict occured,incrementing count\\n        return count\\n~~~",
                "codeTag": "Java"
            },
            {
                "id": 1284256,
                "title": "easiest-java-dfs",
                "content": "```\\n// Simple DFS: Idea is to traverse the grid2 == 1 and if we find at any time where \\n// grid2 == 1 && grid1 == 0 we would not consider it in our solution\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0; i < grid2.length; i++){\\n            for(int j = 0; j < grid2[i].length; j++){\\n                if(grid2[i][j] == 1){\\n                    if(solve(grid1, grid2, i, j))\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    public boolean solve(int[][] grid1, int[][] grid2, int r, int c){\\n        if(r < 0 || r >= grid2.length ||c < 0 || c >= grid2[r].length || grid2[r][c] == 0) return true;\\n        boolean flag = grid1[r][c] == 1;\\n        grid2[r][c] = 0;\\n        boolean right = solve(grid1, grid2, r+1, c);\\n        boolean left = solve(grid1, grid2, r-1, c);\\n        boolean up = solve(grid1, grid2, r, c+1);\\n        boolean down = solve(grid1, grid2, r, c-1);\\n        return flag && up && left && right && down;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n// Simple DFS: Idea is to traverse the grid2 == 1 and if we find at any time where \\n// grid2 == 1 && grid1 == 0 we would not consider it in our solution\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0; i < grid2.length; i++){\\n            for(int j = 0; j < grid2[i].length; j++){\\n                if(grid2[i][j] == 1){\\n                    if(solve(grid1, grid2, i, j))\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    public boolean solve(int[][] grid1, int[][] grid2, int r, int c){\\n        if(r < 0 || r >= grid2.length ||c < 0 || c >= grid2[r].length || grid2[r][c] == 0) return true;\\n        boolean flag = grid1[r][c] == 1;\\n        grid2[r][c] = 0;\\n        boolean right = solve(grid1, grid2, r+1, c);\\n        boolean left = solve(grid1, grid2, r-1, c);\\n        boolean up = solve(grid1, grid2, r, c+1);\\n        boolean down = solve(grid1, grid2, r, c-1);\\n        return flag && up && left && right && down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3239168,
                "title": "c-solution-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust cover all the islands in grid2 and check there should be 1 for all corressponding row and col in grid1. If the condition is false, then the island is not sub-island of grid1.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS traversal in four direction.\\n\\n# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check = 1;\\n    void solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int n, int m)\\n    {\\n        if(grid1[i][j] == 0) check = 0;\\n        grid2[i][j] = 0;\\n        int d[] = {1,0,-1,0,1};\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int x = i + d[k];\\n            int y = j + d[k+1];\\n            if(x >= 0 and y >= 0 and x < n and y < m and grid2[x][y] == 1)\\n            {\\n                solve(grid1,grid2,x,y,n,m);\\n            }\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    solve(grid1,grid2,i,j,n,m);\\n                    if(check) ans++;\\n                    check = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check = 1;\\n    void solve(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int n, int m)\\n    {\\n        if(grid1[i][j] == 0) check = 0;\\n        grid2[i][j] = 0;\\n        int d[] = {1,0,-1,0,1};\\n        for(int k = 0; k < 4; k++)\\n        {\\n            int x = i + d[k];\\n            int y = j + d[k+1];\\n            if(x >= 0 and y >= 0 and x < n and y < m and grid2[x][y] == 1)\\n            {\\n                solve(grid1,grid2,x,y,n,m);\\n            }\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size(), m = grid1[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    solve(grid1,grid2,i,j,n,m);\\n                    if(check) ans++;\\n                    check = 1;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2868941,
                "title": "huh-100-faster-simple-java-solution-i-bet-for-the-best-easy-to-understand",
                "content": "**Upvote if you liked the solution**\\n```\\n//My point is:-\\n// at what circustances will we consider an island B in grid2 is a sub-island of island A in grid1?\\n// it is when all cells of island B are also island cells in island A\\n// ** in other words:\\n// if there is some cell in islandB that is water in corresponded cell of island A, \\n// then island B is not a sub-island of island A\\n\\n// os the idea is we have to traverse all islands in grid2,\\n// and exclude those island that are not sub-island in grid1\\n// then what\\'s left are all sub-island\\n\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        //so whats going on my mind is to traverse all the 1\\'s of grid2 we get and sink them as edges are also covered with water\\n        int n=grid1.length;\\n        int m=grid1[0].length;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //we need to check the lands which were island in grid2 but water in grid 1 which makes\\n                //them - non Sub island as grid1 has water and grid2 land is vice versa so we have to water fill all of those lands\\n                if(grid1[i][j]==0 && grid2[i][j]==1)\\n                {\\n                    \\n                dfs(grid2,i,j);}//mark all the connected island as sink in water\\n            }\\n        }\\n        \\n        //now the left over body is completly a part of subIsland of grid 1 now we have to count islands\\n        //so for doing that previous ques no 200 will work as pass the dfs increase count and sink all the visited or joined islands.\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid2[i][j]==1)\\n                {\\n                    ans++;\\n                dfs(grid2,i,j);}//mark all the connected island as sink in water\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    private void dfs(int[][] grid2,int i,int j)\\n    {\\n        //boundary se bahar ya paani me aajae to return\\n        if(i<0 || j<0 || i>=grid2.length|| j>=grid2[0].length || grid2[i][j]==0)\\n            return;\\n        \\n        grid2[i][j]=0;//sab ko duba do paani me jo visit ho jae\\n        \\n        dfs(grid2,i-1,j);\\n        dfs(grid2,i+1,j);\\n        dfs(grid2,i,j-1);\\n        dfs(grid2,i,j+1);\\n    }\\n}",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        //so whats going on my mind is to traverse all the 1\\'s of grid2 we get and sink them as edges are also covered with water\\n        int n=grid1.length;\\n        int m=grid1[0].length;\\n        \\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //we need to check the lands which were island in grid2 but water in grid 1 which makes\\n                //them - non Sub island as grid1 has water and grid2 land is vice versa so we have to water fill all of those lands\\n                if(grid1[i][j]==0 && grid2[i][j]==1)\\n                {\\n                    \\n                dfs(grid2,i,j);}",
                "codeTag": "Java"
            },
            {
                "id": 2701612,
                "title": "dfs-solution-2d-grid-c",
                "content": "```\\nint dx[] = {0,  0, -1, 1};\\nint dy[] = {-1, 1,  0, 0};\\nint M , N;\\n\\nvoid DFS(int r , int c , vector<vector<int>>& grid) {\\n    if (r < 0 || r == M || c < 0 || c == N || grid[r][c] == 0) return;\\n    grid[r][c] = 0;\\n    for(int i = 0; i < 4; i++) {\\n        int x = dx[i] + r;\\n        int y = dy[i] + c;\\n        if (x >= 0 && x < M && y >= 0 && y < N && grid[x][y] == 1) DFS(x , y , grid);\\n    }\\n}\\nclass Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1 , vector<vector<int>>& grid2) {\\n        M = grid1.size();\\n        N = grid1[0].size();\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(grid1[i][j] == 0) {\\n                    DFS(i , j , grid2);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(grid2[i][j] == 1) {\\n                    DFS(i , j , grid2);\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1 , vector<vector<int>>& grid2) {\\n        M = grid1.size();\\n        N = grid1[0].size();\\n        for(int i = 0; i < M; i++) {\\n            for(int j = 0; j < N; j++) {\\n                if(grid1[i][j] == 0) {\\n                    DFS(i , j , grid2);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2284204,
                "title": "c-dfs-solution",
                "content": "**Apply DFS for grid2, and if we can find 1 cell in grid1 is 0 and grid2 is 1 then this island is not a sub-island.**\\n\\n```\\nclass Solution {\\n    int dx[4]={0,0,-1,1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    void DFS(vector<vector<int>>& grid1,vector<vector<int>>& grid2,int i,int j,int n,int m,int& res){\\n        if(min(i,j)<0 or i>=n or j>=m or !grid2[i][j]) return;\\n        if(grid1[i][j]==0 and grid2[i][j]==1){\\n            res=false;\\n        }\\n        grid2[i][j]=0;\\n        for(int k=0;k<4;++k){\\n            DFS(grid1,grid2,i+dx[k],j+dy[k],n,m,res);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int ans=0) {\\n        int n=grid1.size(), m=grid1[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid2[i][j]){\\n                    int res=true;\\n                    DFS(grid1,grid2,i,j,n,m,res);\\n                    ans += res;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dx[4]={0,0,-1,1};\\n    int dy[4]={1,-1,0,0};\\n    \\n    void DFS(vector<vector<int>>& grid1,vector<vector<int>>& grid2,int i,int j,int n,int m,int& res){\\n        if(min(i,j)<0 or i>=n or j>=m or !grid2[i][j]) return;\\n        if(grid1[i][j]==0 and grid2[i][j]==1){\\n            res=false;\\n        }\\n        grid2[i][j]=0;\\n        for(int k=0;k<4;++k){\\n            DFS(grid1,grid2,i+dx[k],j+dy[k],n,m,res);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int ans=0) {\\n        int n=grid1.size(), m=grid1[0].size();\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid2[i][j]){\\n                    int res=true;\\n                    DFS(grid1,grid2,i,j,n,m,res);\\n                    ans += res;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201489,
                "title": "super-easy-to-understand-guaranteed-time-o-m-n-space-o-1-ignoring-recursive-calls",
                "content": "upvote if you like what you see....\\n```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0)return;\\n        grid[i][j]=0;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j-1);\\n\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n=grid1.size();\\n        m=grid1[0].size();\\n        //removing all those islands which are in grid2 but not in grid1... becoz those islands can never be part of sub-islands \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid1[i][j]==0 && grid2[i][j]==1) \\n                    dfs(grid2,i,j);\\n        //fianllly countiing number of remaining islands \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j]==1)\\n                    ans++,dfs(grid2,i,j);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    void dfs(vector<vector<int>>& grid,int i,int j){\\n        if(i<0 || j<0 || i>=n || j>=m || grid[i][j]==0)return;\\n        grid[i][j]=0;\\n        dfs(grid,i+1,j);\\n        dfs(grid,i,j+1);\\n        dfs(grid,i-1,j);\\n        dfs(grid,i,j-1);\\n\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n=grid1.size();\\n        m=grid1[0].size();\\n        //removing all those islands which are in grid2 but not in grid1... becoz those islands can never be part of sub-islands \\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid1[i][j]==0 && grid2[i][j]==1) \\n                    dfs(grid2,i,j);\\n        //fianllly countiing number of remaining islands \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j]==1)\\n                    ans++,dfs(grid2,i,j);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2188766,
                "title": "java-dfs-in-depth-explanation-w-graph",
                "content": "This problem is pretty similar to **LC. 200 Number of Islands**. The only difference is we need to add a boolean variable **flag** in to the solution to check if it\\'s a island on grid1[ ][ ]. The definition of sub-islands is that an island in `grid2` is considered as a sub-island if there is an island in `grid1` that contains all the cells which make up the island in `grid2`. That\\'s why we need the `flag` boolean variable.\\n  \\n  Let\\'s look the example below to make sure you really understand the concept. Let\\'s say the left one is grid1[ ][ ] and the right one is gird2[ ][ ]. Then we can easily to tell that there are **2** sub-islands on grid2 because the island on grid1 contains those two cells == 1 on grid2. \\n  \\n![image](https://assets.leetcode.com/users/images/8e51dc2e-d31e-491c-bc0d-b0cb672eb4ab_1656011251.9436862.png) ![image](https://assets.leetcode.com/users/images/7cd51a69-73a8-456b-9a50-e345bbfa6adc_1656011264.2254725.png)\\n\\n  Let\\'s look another example here. Let\\'s say we have grid1[ ][ ] on the left and grid2[ ][ ] on the right. Then how many sub-islands are there? The answer is **0**. Why it is 0 but not 2, like the example above? That\\'s because the cells on grid1 are not connected so it is not considered as an island. \\n\\n![image](https://assets.leetcode.com/users/images/1389b4b0-128c-469e-8cd8-28f5b54a7d97_1656011391.7221453.png) ![image](https://assets.leetcode.com/users/images/eaf69aeb-9f9a-44a0-aee4-527009c20523_1656011398.9343407.png)\\n\\n  Let\\'s look one more example. Let\\'s say we have grid1[ ][ ] on the left and grid2[ ][ ] on the right. How many sub-islands in grid2 now? The answer is **0** again. According to the sub-islands definition above, the islands in grid1 doesn\\'t contains all the cells of the island in grid2. Hence, none of the cells in grid2 is considered as sub-islands.\\n  \\n  ![image](https://assets.leetcode.com/users/images/643dfb0a-ca1d-4525-b1e8-4cd4be0dc364_1656011656.9506977.png) ![image](https://assets.leetcode.com/users/images/7f4690ec-ff3b-48c0-b39c-69338104ff61_1656011672.0947614.png)\\n\\n\\n```\\nclass Solution \\n{\\n    public int countSubIslands(int[][] grid1, int[][] grid2)\\n    {\\n        // O(n*m) time where n is grid1.length and m is grid2.length\\n        // O(n*m) space \\n        int count = 0;\\n        \\n        for(int i = 0; i < grid2.length; i++)\\n        {\\n            for(int j = 0; j < grid2[0].length; j++)\\n            {\\n                if(grid2[i][j] == 1 && DFS(grid1, grid2, i, j))\\n                    count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean DFS(int[][] grid1, int[][] grid2, int i, int j)\\n    {\\n        if(i < 0 || i >= grid2.length || j < 0 || j >= grid2[0].length || grid2[i][j] == 0)\\n            return true;\\n        \\n        boolean flag = grid1[i][j] == 1;\\n        \\n        // mark as visited by flood fill\\n        grid2[i][j] = 0;\\n        \\n        boolean up = DFS(grid1, grid2, i-1, j);\\n        boolean down = DFS(grid1, grid2, i+1, j);\\n        boolean left = DFS(grid1, grid2, i, j-1);\\n        boolean right = DFS(grid1, grid2, i, j+1);\\n        \\n        return (flag && up && down && left && right);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int countSubIslands(int[][] grid1, int[][] grid2)\\n    {\\n        // O(n*m) time where n is grid1.length and m is grid2.length\\n        // O(n*m) space \\n        int count = 0;\\n        \\n        for(int i = 0; i < grid2.length; i++)\\n        {\\n            for(int j = 0; j < grid2[0].length; j++)\\n            {\\n                if(grid2[i][j] == 1 && DFS(grid1, grid2, i, j))\\n                    count += 1;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private boolean DFS(int[][] grid1, int[][] grid2, int i, int j)\\n    {\\n        if(i < 0 || i >= grid2.length || j < 0 || j >= grid2[0].length || grid2[i][j] == 0)\\n            return true;\\n        \\n        boolean flag = grid1[i][j] == 1;\\n        \\n        // mark as visited by flood fill\\n        grid2[i][j] = 0;\\n        \\n        boolean up = DFS(grid1, grid2, i-1, j);\\n        boolean down = DFS(grid1, grid2, i+1, j);\\n        boolean left = DFS(grid1, grid2, i, j-1);\\n        boolean right = DFS(grid1, grid2, i, j+1);\\n        \\n        return (flag && up && down && left && right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895587,
                "title": "java-dfs-clean-solution-faster-than-99",
                "content": "```\\nclass Solution {\\n    private final int water = 0;\\n    private final int land = 1;\\n    private int rows;\\n    private int cols;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        rows = grid1.length;\\n        cols = grid1[0].length;\\n        int count = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid2[i][j] == land && grid1[i][j] == land) {\\n                    count += countSubIslands(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2, int i, int j) {\\n        if (i < 0 || j < 0 || i >= rows || j >= cols || grid2[i][j] == water) {\\n            return 1;\\n        }\\n        int current = 1;\\n        if (grid1[i][j] == water) {\\n            current = 0;\\n        }\\n        grid2[i][j] = water;\\n        return current \\n            * countSubIslands(grid1, grid2, i - 1, j)\\n            * countSubIslands(grid1, grid2, i + 1, j)\\n            * countSubIslands(grid1, grid2, i, j - 1)\\n            * countSubIslands(grid1, grid2, i, j + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    private final int water = 0;\\n    private final int land = 1;\\n    private int rows;\\n    private int cols;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        rows = grid1.length;\\n        cols = grid1[0].length;\\n        int count = 0;\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (grid2[i][j] == land && grid1[i][j] == land) {\\n                    count += countSubIslands(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2, int i, int j) {\\n        if (i < 0 || j < 0 || i >= rows || j >= cols || grid2[i][j] == water) {\\n            return 1;\\n        }\\n        int current = 1;\\n        if (grid1[i][j] == water) {\\n            current = 0;\\n        }\\n        grid2[i][j] = water;\\n        return current \\n            * countSubIslands(grid1, grid2, i - 1, j)\\n            * countSubIslands(grid1, grid2, i + 1, j)\\n            * countSubIslands(grid1, grid2, i, j - 1)\\n            * countSubIslands(grid1, grid2, i, j + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393245,
                "title": "c-solution-dfs",
                "content": "```\\nvoid dfs(int i,int j,vector<vector<int>>& grid1,vector<vector<int>>& grid2,int &flag){\\n        \\n        if(i<0 || j<0 || i>=grid2.size() || j>=grid2[0].size() || grid2[i][j]==0){\\n            return;\\n        }\\n        \\n        if(grid1[i][j]!=grid2[i][j]){\\n            flag = 0;\\n        } \\n        \\n        grid2[i][j] = 0;\\n        \\n        dfs(i-1,j,grid1,grid2,flag);\\n        dfs(i,j-1,grid1,grid2,flag);\\n        dfs(i+1,j,grid1,grid2,flag);\\n        dfs(i,j+1,grid1,grid2,flag);\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int ans=0;\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid2[i][j]==1){\\n                    \\n                    int flag=1;\\n                    dfs(i,j,grid1,grid2,flag);\\n                    if(flag){\\n                       ans+=1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(int i,int j,vector<vector<int>>& grid1,vector<vector<int>>& grid2,int &flag){\\n        \\n        if(i<0 || j<0 || i>=grid2.size() || j>=grid2[0].size() || grid2[i][j]==0){\\n            return;\\n        }\\n        \\n        if(grid1[i][j]!=grid2[i][j]){\\n            flag = 0;\\n        } \\n        \\n        grid2[i][j] = 0;\\n        \\n        dfs(i-1,j,grid1,grid2,flag);\\n        dfs(i,j-1,grid1,grid2,flag);\\n        dfs(i+1,j,grid1,grid2,flag);\\n        dfs(i,j+1,grid1,grid2,flag);\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int ans=0;\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid2[i][j]==1){\\n                    \\n                    int flag=1;\\n                    dfs(i,j,grid1,grid2,flag);\\n                    if(flag){\\n                       ans+=1;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307458,
                "title": "c-solution-99-6-faster",
                "content": "**If you like it then please upvote**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i, int j, int r, int c,bool &x){\\n        if(i>=r||i<0||j<0||j>=c){\\n            return;\\n        }\\n        if(grid2[i][j]==1&&grid1[i][j]==1){\\n            grid1[i][j] = 2;\\n            grid2[i][j] = 2;\\n        }\\n        \\n        else if(grid1[i][j]!=1&&grid2[i][j]==1){\\n            x = false;\\n            return;\\n        }\\n        else if(grid1[i][j]!=1||grid2[i][j]!=1){\\n            return;\\n        }\\n        helper(grid1,grid2,i-1,j,r,c,x);\\n        helper(grid1,grid2,i+1,j,r,c,x);\\n        helper(grid1,grid2,i,j-1,r,c,x);\\n        helper(grid1,grid2,i,j+1,r,c,x);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        int r = grid1.size();\\n        int c = grid1[0].size();\\n        int count=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                bool x = true;\\n                if(grid2[i][j]==1&&grid1[i][j]==1){\\n                    helper(grid1,grid2,i,j,r,c,x);\\n                    if(x){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void helper(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i, int j, int r, int c,bool &x){\\n        if(i>=r||i<0||j<0||j>=c){\\n            return;\\n        }\\n        if(grid2[i][j]==1&&grid1[i][j]==1){\\n            grid1[i][j] = 2;\\n            grid2[i][j] = 2;\\n        }\\n        \\n        else if(grid1[i][j]!=1&&grid2[i][j]==1){\\n            x = false;\\n            return;\\n        }\\n        else if(grid1[i][j]!=1||grid2[i][j]!=1){\\n            return;\\n        }\\n        helper(grid1,grid2,i-1,j,r,c,x);\\n        helper(grid1,grid2,i+1,j,r,c,x);\\n        helper(grid1,grid2,i,j-1,r,c,x);\\n        helper(grid1,grid2,i,j+1,r,c,x);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        ios::sync_with_stdio(false);\\n        cin.tie(nullptr);\\n        cout.tie(nullptr);\\n        \\n        int r = grid1.size();\\n        int c = grid1[0].size();\\n        int count=0;\\n        for(int i=0; i<r; i++){\\n            for(int j=0; j<c; j++){\\n                bool x = true;\\n                if(grid2[i][j]==1&&grid1[i][j]==1){\\n                    helper(grid1,grid2,i,j,r,c,x);\\n                    if(x){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1303575,
                "title": "java-easy-solution-and-explanation-for-beginners-99-90",
                "content": "This problem is exactly similar to number of islands. In order to know if island is subIsland of grid1 you need to maintain a boolean as true. when you find that there is no possibility of subIsland mark it to false. \\n```\\nclass Solution {\\n    private boolean isSubPart;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if (grid2 == null || grid1 == null || grid2.length == 0 || grid1.length == 0)\\n            return 0;\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid2.length; i++) {\\n            for (int j = 0; j < grid2[i].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    isSubPart = true;\\n                    dfs(grid1, grid2, i, j);\\n                    if (isSubPart) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid2.length || j >= grid2[i].length || grid2[i][j] == 0)\\n            return;\\n        \\n        if (grid1[i][j] != 1) {\\n            isSubPart = false;\\n        }\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i + 1, j);\\n        dfs(grid1, grid2, i - 1, j);\\n        dfs(grid1, grid2, i, j + 1);\\n        dfs(grid1, grid2, i, j - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean isSubPart;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if (grid2 == null || grid1 == null || grid2.length == 0 || grid1.length == 0)\\n            return 0;\\n        \\n        int count = 0;\\n        for (int i = 0; i < grid2.length; i++) {\\n            for (int j = 0; j < grid2[i].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    isSubPart = true;\\n                    dfs(grid1, grid2, i, j);\\n                    if (isSubPart) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j) {\\n        if (i < 0 || j < 0 || i >= grid2.length || j >= grid2[i].length || grid2[i][j] == 0)\\n            return;\\n        \\n        if (grid1[i][j] != 1) {\\n            isSubPart = false;\\n        }\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i + 1, j);\\n        dfs(grid1, grid2, i - 1, j);\\n        dfs(grid1, grid2, i, j + 1);\\n        dfs(grid1, grid2, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1293062,
                "title": "easy-dfs-approach-c",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool isSub ;\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>= grid2.size() || j>= grid2[0].size() || grid2[i][j]==0)\\n            return ;\\n        \\n        grid2[i][j] = 0;\\n        if(grid1[i][j] == false)\\n            isSub = false;\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i,j-1);\\n        \\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int count =0;\\n        for(int i=0;i<grid2.size();i++)\\n        {\\n            for(int j=0;j<grid2[0].size();j++)\\n            {\\n                if(grid2[i][j] == 1 and grid1[i][j] == 1)\\n                {\\n                    isSub = true;\\n                    dfs(grid1,grid2,i,j);\\n                    if(isSub)\\n                        count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isSub ;\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>= grid2.size() || j>= grid2[0].size() || grid2[i][j]==0)\\n            return ;\\n        \\n        grid2[i][j] = 0;\\n        if(grid1[i][j] == false)\\n            isSub = false;\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i,j-1);\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1286135,
                "title": "my-java-solution-using-dfs",
                "content": "```\\n/*\\nCOunt the number of islands in grid2\\n\\nIf grid2\\'s island is a subisland of grid1\\'s island, then all the 1s in grid2 must be in the grid1 too to make it a subisland\\n*/\\n\\n\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if (grid1 == null && grid2 == null)\\n            return 0;\\n        int row = grid2.length;\\n        int col = grid2[0].length;\\n        int subIslands = 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (grid2[i][j] == 1) {\\n                    subIslands += findSubIslands(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return subIslands;\\n    }\\n    \\n    public int findSubIslands(int [][] grid1, int [][] grid2, int i, int j) {\\n        /*\\n        Because this is the condition where we are outside the border of our island and this is where our search ends.\\nIf we return 0 from here, then the dfs for all the tiles in the path to the border will always evaluate to zero.\\nIf we return 1 from here, then the dfs for a tile will equal to the && of the all the tiles in the path to the border, which is what we want.\\n*/\\n        if (i < 0 || j < 0 || i >= grid2.length || j >= grid2[0].length || grid2[i][j] == 0)\\n            return 1;\\n        int result = 1;\\n        grid2[i][j] = 0;\\n        result &= findSubIslands(grid1, grid2, i+1, j);\\n        result &= findSubIslands(grid1, grid2, i-1, j);\\n        result &= findSubIslands(grid1, grid2, i, j-1);\\n        result &= findSubIslands(grid1, grid2, i, j+1);\\n        // 1 in grid2 must be a 1 in grid1\\n        return result & grid1[i][j];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n/*\\nCOunt the number of islands in grid2\\n\\nIf grid2\\'s island is a subisland of grid1\\'s island, then all the 1s in grid2 must be in the grid1 too to make it a subisland\\n*/\\n\\n\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if (grid1 == null && grid2 == null)\\n            return 0;\\n        int row = grid2.length;\\n        int col = grid2[0].length;\\n        int subIslands = 0;\\n        for (int i=0; i<row; i++) {\\n            for (int j=0; j<col; j++) {\\n                if (grid2[i][j] == 1) {\\n                    subIslands += findSubIslands(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return subIslands;\\n    }\\n    \\n    public int findSubIslands(int [][] grid1, int [][] grid2, int i, int j) {\\n        /*\\n        Because this is the condition where we are outside the border of our island and this is where our search ends.\\nIf we return 0 from here, then the dfs for all the tiles in the path to the border will always evaluate to zero.\\nIf we return 1 from here, then the dfs for a tile will equal to the && of the all the tiles in the path to the border, which is what we want.\\n*/\\n        if (i < 0 || j < 0 || i >= grid2.length || j >= grid2[0].length || grid2[i][j] == 0)\\n            return 1;\\n        int result = 1;\\n        grid2[i][j] = 0;\\n        result &= findSubIslands(grid1, grid2, i+1, j);\\n        result &= findSubIslands(grid1, grid2, i-1, j);\\n        result &= findSubIslands(grid1, grid2, i, j-1);\\n        result &= findSubIslands(grid1, grid2, i, j+1);\\n        // 1 in grid2 must be a 1 in grid1\\n        return result & grid1[i][j];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998233,
                "title": "python3-solution-using-bfs-beats-99-time-100-space-o-m-n-o-m-n",
                "content": "![sumukha 2023-08-30 at 4.40.11 PM.png](https://assets.leetcode.com/users/images/d7c86a2c-e5e0-4ec5-ab4d-2fe9b6b4c952_1693763034.4553797.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nthe logic here is any island that exists in grid2 being check by `grid2[i][j]` which when 1 enters if condition \\nfrom here we use bfs by checking all 4 directions but before this we need to check if this is also an island in grid1 if not then we can set the flag which takes if if it is a subisland or no.\\nthrought bfs is done and in all he islands visted of grid2 if none of them set the flag then flag remains 1 and we can add 1 to answer indicating the curent island formation we got in bfs is a subisland of grid1 also.\\nreturning ans does it\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**_______O(M*N)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**_______O(M*N) only in case all are islands else it is O(max(m,n))**\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n=len(grid2),len(grid2[0])\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]:\\n                    f=1\\n                    q=[(i,j)]\\n                    while q:\\n                        ni,nj=q.pop(0)\\n                        if grid2[ni][nj]==0:continue\\n                        grid2[ni][nj]=0\\n                        if grid1[ni][nj]==0:f=0\\n                        if ni>0 and grid2[ni-1][nj]:q.append((ni-1,nj))\\n                        if ni<m-1 and grid2[ni+1][nj]:q.append((ni+1,nj))\\n                        if nj>0 and grid2[ni][nj-1]:q.append((ni,nj-1))\\n                        if nj<n-1 and grid2[ni][nj+1]:q.append((ni,nj+1))\\n                    if f:ans+=1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n=len(grid2),len(grid2[0])\\n        ans=0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]:\\n                    f=1\\n                    q=[(i,j)]\\n                    while q:\\n                        ni,nj=q.pop(0)\\n                        if grid2[ni][nj]==0:continue\\n                        grid2[ni][nj]=0\\n                        if grid1[ni][nj]==0:f=0\\n                        if ni>0 and grid2[ni-1][nj]:q.append((ni-1,nj))\\n                        if ni<m-1 and grid2[ni+1][nj]:q.append((ni+1,nj))\\n                        if nj>0 and grid2[ni][nj-1]:q.append((ni,nj-1))\\n                        if nj<n-1 and grid2[ni][nj+1]:q.append((ni,nj+1))\\n                    if f:ans+=1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301218,
                "title": "dsu-map",
                "content": "# Intuition\\nCheck that each island of grid2 is exits on grid1 or its parent should also exits in grid1 otherwise whole island or parent of that will be not considered\\n\\n# Approach\\n It is similar to find number of island in a single grid ,here just we make two disjoint sets of both grid, and for checking whether subisland is exits or not , for that check each island of grid2 and its parent in dsu both should be exists and if either one of them not exits then whole subisland will not consider ( store -1 in it). \\n\\n# Code\\n```\\nclass Solution {\\n\\n   class DSU{\\n\\n       HashMap<String,Node> map=new HashMap<>();\\n       class Node{\\n           String node;\\n           Node parent;\\n           int h;\\n           int child;\\n\\n           Node(String s){\\n               this.node=s;\\n               this.parent=null;\\n               this.h=0;\\n               this.child=1;\\n           }\\n       }\\n\\n       public void create(String el){\\n           Node n=new Node(el);\\n           n.parent=n;\\n\\n           map.put(el,n);\\n       }\\n\\n       public Node find(String el){\\n            Node n=map.get(el);\\n\\n            if(n==n.parent) return n;\\n\\n            Node rr=find(n.parent.node);\\n\\n            n.parent=rr;\\n            return rr;           \\n       }\\n\\n       public void union(String s1,String s2){\\n\\n           Node d1=find(s1);\\n           Node d2=find(s2);\\n\\n           if(d1.h<d2.h){\\n               d1.parent=d2;\\n               d2.child+=d1.child;\\n           }else if(d1.h>d2.h){\\n               d2.parent=d1;\\n               d2.child+=d1.child;\\n           }else{\\n               d1.parent=d2;\\n               d2.child+=d1.child;\\n               d2.h++;\\n           }\\n       }\\n   }\\n\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        int r=grid1.length;\\n        int c=grid1[0].length;\\n\\n        DSU d1=new DSU();\\n        DSU d2=new DSU();\\n\\n        for(int i=0;i<r;i++){\\n\\n            for(int j=0;j<c;j++){\\n\\n                if(grid1[i][j]==1){\\n                    String n1=\"\"+i+\"-\"+j;\\n                    d1.create(n1);\\n                    int[][] x={{-1,0},{0,-1}};\\n\\n                     for(int[] y:x){\\n                         int newi=i+y[0];\\n                         int newj=j+y[1];\\n\\n                         if(safe(newi,newj,r,c,grid1)){\\n                             String n2=\"\"+newi+\"-\"+newj;\\n\\n                              d1.union(n1,n2);\\n\\n                         }\\n                     }\\n                }\\n\\n                if(grid2[i][j]==1){\\n                    String n1=\"\"+i+\"-\"+j;\\n                    d2.create(n1);\\n                    int[][] x={{-1,0},{0,-1}};\\n\\n                     for(int[] y:x){\\n                         int newi=i+y[0];\\n                         int newj=j+y[1];\\n\\n                         if(safe(newi,newj,r,c,grid2)){\\n                             String n2=\"\"+newi+\"-\"+newj;\\n                              d2.union(n1,n2);\\n                         }\\n                     }\\n                }\\n            }\\n        }\\n\\n        int subisland=0;\\n\\n        HashMap<String,Integer> map=new HashMap<>();\\n\\n        for(String node :d2.map.keySet()){\\n            String par=d2.find(node).node;\\n            if(d1.map.containsKey(par) && d1.map.containsKey(node)){ \\n                if(map.containsKey(par) && map.get(par)==-1) continue;\\n                    map.put(par, 1);\\n            }  \\n            else map.put(par,-1);\\n\\n        }\\n\\n        for(String s:map.keySet()){\\n            if(map.get(s)==1) subisland++;\\n        }\\n\\n        return subisland;\\n\\n    }\\n\\n    public boolean safe(int cr,int cc, int r,int c,int[][] grid){\\n\\n        if(cr<0 || cc <0 || cr>=r || cc>=c ) return false;\\n\\n        if(grid[cr][cc]==1) return true;\\n\\n        return false;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n   class DSU{\\n\\n       HashMap<String,Node> map=new HashMap<>();\\n       class Node{\\n           String node;\\n           Node parent;\\n           int h;\\n           int child;\\n\\n           Node(String s){\\n               this.node=s;\\n               this.parent=null;\\n               this.h=0;\\n               this.child=1;\\n           }\\n       }\\n\\n       public void create(String el){\\n           Node n=new Node(el);\\n           n.parent=n;\\n\\n           map.put(el,n);\\n       }\\n\\n       public Node find(String el){\\n            Node n=map.get(el);\\n\\n            if(n==n.parent) return n;\\n\\n            Node rr=find(n.parent.node);\\n\\n            n.parent=rr;\\n            return rr;           \\n       }\\n\\n       public void union(String s1,String s2){\\n\\n           Node d1=find(s1);\\n           Node d2=find(s2);\\n\\n           if(d1.h<d2.h){\\n               d1.parent=d2;\\n               d2.child+=d1.child;\\n           }else if(d1.h>d2.h){\\n               d2.parent=d1;\\n               d2.child+=d1.child;\\n           }else{\\n               d1.parent=d2;\\n               d2.child+=d1.child;\\n               d2.h++;\\n           }\\n       }\\n   }\\n\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        int r=grid1.length;\\n        int c=grid1[0].length;\\n\\n        DSU d1=new DSU();\\n        DSU d2=new DSU();\\n\\n        for(int i=0;i<r;i++){\\n\\n            for(int j=0;j<c;j++){\\n\\n                if(grid1[i][j]==1){\\n                    String n1=\"\"+i+\"-\"+j;\\n                    d1.create(n1);\\n                    int[][] x={{-1,0},{0,-1}};\\n\\n                     for(int[] y:x){\\n                         int newi=i+y[0];\\n                         int newj=j+y[1];\\n\\n                         if(safe(newi,newj,r,c,grid1)){\\n                             String n2=\"\"+newi+\"-\"+newj;\\n\\n                              d1.union(n1,n2);\\n\\n                         }\\n                     }\\n                }\\n\\n                if(grid2[i][j]==1){\\n                    String n1=\"\"+i+\"-\"+j;\\n                    d2.create(n1);\\n                    int[][] x={{-1,0},{0,-1}};\\n\\n                     for(int[] y:x){\\n                         int newi=i+y[0];\\n                         int newj=j+y[1];\\n\\n                         if(safe(newi,newj,r,c,grid2)){\\n                             String n2=\"\"+newi+\"-\"+newj;\\n                              d2.union(n1,n2);\\n                         }\\n                     }\\n                }\\n            }\\n        }\\n\\n        int subisland=0;\\n\\n        HashMap<String,Integer> map=new HashMap<>();\\n\\n        for(String node :d2.map.keySet()){\\n            String par=d2.find(node).node;\\n            if(d1.map.containsKey(par) && d1.map.containsKey(node)){ \\n                if(map.containsKey(par) && map.get(par)==-1) continue;\\n                    map.put(par, 1);\\n            }  \\n            else map.put(par,-1);\\n\\n        }\\n\\n        for(String s:map.keySet()){\\n            if(map.get(s)==1) subisland++;\\n        }\\n\\n        return subisland;\\n\\n    }\\n\\n    public boolean safe(int cr,int cc, int r,int c,int[][] grid){\\n\\n        if(cr<0 || cc <0 || cr>=r || cc>=c ) return false;\\n\\n        if(grid[cr][cc]==1) return true;\\n\\n        return false;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916073,
                "title": "javascript-bfs-with-explanation",
                "content": "# Approach\\nThis is similar to the number of islands problem except we need to explore the entire island first to determine if its a sub island.  See comments below for explanation.\\n\\nThe BFS code provided below is standard boilerplate for related graph problems.  The only change here is the addition of the res variable and the validation to see if the land cells in grid1 and grid2 match up.\\n\\n# Complexity\\n- Time complexity: O(mn).  You may need to explore every single cell in the grid.  Imagine both grid1 and grid2 were all land.\\n\\n- Space complexity: O(mn).  In the worst case, all cells in the grid will be visited and added to the visited set.\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} grid1\\n * @param {number[][]} grid2\\n * @return {number}\\n */\\nvar countSubIslands = function(grid1, grid2) {\\n    const visited = new Set()\\n    let sub = 0;\\n    for (let r = 0; r < grid1.length; r++) {\\n        for (let c = 0; c < grid1[0].length; c++) {\\n            if (grid2[r][c] === 1 && !visited.has(getPosKey(r, c)) && bfs(grid1, grid2, r, c, visited)) {\\n                sub++;\\n            }\\n        }\\n    }\\n    return sub;\\n};\\n\\nconst deltas = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n];\\n\\nconst bfs = (grid1, grid2, r, c, visited) => {\\n    let res = true;\\n    const queue = [getPosKey(r, c)];\\n    visited.add(getPosKey(r, c));\\n    while (queue.length > 0) {\\n        const posKey = queue.shift();\\n        const [row, col] = getPosFromKey(posKey);\\n        // Don\\'t return false right away!  We need to explore the\\n        // entire island first so that we can determine if its a\\n        // sub-island or not.  If we return early, we\\'ll be left in\\n        // a weird state where an unexplored portion of the island\\n        // will be left behind in grid2.  When you do BFS on these \\n        // portions, it may lead to bugs where that unexplored\\n        // portion gets counted as a sub island even though the\\n        // island it belongs to is not a sub island at all.\\n        if (!hasMatchingLand(grid1, grid2, row, col)) {\\n            res = false;\\n        }\\n        // Add neighbors to queue.\\n        for (const [deltaRow, deltaCol] of deltas) {\\n            const neighborRow = row + deltaRow;\\n            const neighborCol = col + deltaCol;\\n            const neighborPosKey = getPosKey(neighborRow, neighborCol);\\n            if (\\n                isOutOfBounds(grid2, neighborRow, neighborCol) ||\\n                isWater(grid2, neighborRow, neighborCol) ||\\n                visited.has(neighborPosKey)\\n            ) {\\n                continue;\\n            }\\n            queue.push(neighborPosKey);\\n            visited.add(neighborPosKey);\\n        }\\n    }\\n    return res;\\n}\\n\\nconst getPosKey = (r, c) => `${r},${c}`;\\n\\nconst getPosFromKey = (key) => key.split(\\',\\').map(Number);\\n\\nconst isOutOfBounds = (grid, r, c) => r < 0 || r > grid.length - 1 || c < 0 || c > grid[0].length - 1;\\n\\nconst isWater = (grid, r, c) => grid[r][c] === 0;\\n\\nconst hasMatchingLand = (grid1, grid2, r, c) => grid1[r][c] === 1 && grid2[r][c] === 1;\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\n/**\\n * @param {number[][]} grid1\\n * @param {number[][]} grid2\\n * @return {number}\\n */\\nvar countSubIslands = function(grid1, grid2) {\\n    const visited = new Set()\\n    let sub = 0;\\n    for (let r = 0; r < grid1.length; r++) {\\n        for (let c = 0; c < grid1[0].length; c++) {\\n            if (grid2[r][c] === 1 && !visited.has(getPosKey(r, c)) && bfs(grid1, grid2, r, c, visited)) {\\n                sub++;\\n            }\\n        }\\n    }\\n    return sub;\\n};\\n\\nconst deltas = [\\n    [-1, 0],\\n    [1, 0],\\n    [0, -1],\\n    [0, 1],\\n];\\n\\nconst bfs = (grid1, grid2, r, c, visited) => {\\n    let res = true;\\n    const queue = [getPosKey(r, c)];\\n    visited.add(getPosKey(r, c));\\n    while (queue.length > 0) {\\n        const posKey = queue.shift();\\n        const [row, col] = getPosFromKey(posKey);\\n        // Don\\'t return false right away!  We need to explore the\\n        // entire island first so that we can determine if its a\\n        // sub-island or not.  If we return early, we\\'ll be left in\\n        // a weird state where an unexplored portion of the island\\n        // will be left behind in grid2.  When you do BFS on these \\n        // portions, it may lead to bugs where that unexplored\\n        // portion gets counted as a sub island even though the\\n        // island it belongs to is not a sub island at all.\\n        if (!hasMatchingLand(grid1, grid2, row, col)) {\\n            res = false;\\n        }\\n        // Add neighbors to queue.\\n        for (const [deltaRow, deltaCol] of deltas) {\\n            const neighborRow = row + deltaRow;\\n            const neighborCol = col + deltaCol;\\n            const neighborPosKey = getPosKey(neighborRow, neighborCol);\\n            if (\\n                isOutOfBounds(grid2, neighborRow, neighborCol) ||\\n                isWater(grid2, neighborRow, neighborCol) ||\\n                visited.has(neighborPosKey)\\n            ) {\\n                continue;\\n            }\\n            queue.push(neighborPosKey);\\n            visited.add(neighborPosKey);\\n        }\\n    }\\n    return res;\\n}\\n\\nconst getPosKey = (r, c) => `${r},${c}`;\\n\\nconst getPosFromKey = (key) => key.split(\\',\\').map(Number);\\n\\nconst isOutOfBounds = (grid, r, c) => r < 0 || r > grid.length - 1 || c < 0 || c > grid[0].length - 1;\\n\\nconst isWater = (grid, r, c) => grid[r][c] === 0;\\n\\nconst hasMatchingLand = (grid1, grid2, r, c) => grid1[r][c] === 1 && grid2[r][c] === 1;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2867228,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    DFS 2D\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint n, m, fl, vis[505][505];\\n    vector<vector<int>> grids1, grids2;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x <n and y >= 0 and y < m and !vis[x][y] and grids2[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            if(!grids1[x][y]) {\\n                fl = 0;\\n            }\\n            vis[x][y] = 1;\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        memset(vis, 0, sizeof(vis));\\n        grids1 = grid1, grids2 = grid2;\\n        n = grid1.size(), m = grid1[0].size();\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(valid(i, j)) {\\n                    fl = 1;\\n                    dfs(i, j);\\n                    if(fl) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint n, m, fl, vis[505][505];\\n    vector<vector<int>> grids1, grids2;\\n\\n    bool valid(int x, int y) {\\n        if(x >= 0 and x <n and y >= 0 and y < m and !vis[x][y] and grids2[x][y]) return true;\\n        else return false;\\n    }\\n\\n    void dfs(int x, int y) {\\n        if(valid(x, y)) {\\n            if(!grids1[x][y]) {\\n                fl = 0;\\n            }\\n            vis[x][y] = 1;\\n            dfs(x+1, y);\\n            dfs(x-1, y);\\n            dfs(x, y+1);\\n            dfs(x, y-1);\\n        }\\n    }\\n\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        memset(vis, 0, sizeof(vis));\\n        grids1 = grid1, grids2 = grid2;\\n        n = grid1.size(), m = grid1[0].size();\\n\\n        int ans = 0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(valid(i, j)) {\\n                    fl = 1;\\n                    dfs(i, j);\\n                    if(fl) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2848424,
                "title": "c-simple-dfs-like-number-of-islands-clean",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &grid1, vector<vector<int>>&grid2, int i, int j, int m, int n,int &check)\\n    {\\n        if(i < 0 || i >=m or j < 0 or j >= n or grid2[i][j] != 1 or grid2[i][j] != 1)\\n            return;\\n        if(grid1[i][j] == 0 and grid2[i][j] == 1)\\n            check = 0;\\n        grid2[i][j] = 2;\\n        dfs(grid1, grid2, i + 1, j, m, n, check);\\n        dfs(grid1, grid2, i , j + 1, m, n, check);\\n        dfs(grid1, grid2, i, j - 1, m, n, check);\\n        dfs(grid1, grid2, i - 1, j, m, n, check);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int m = grid1.size(), n = grid2[0].size();\\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid1[i][j] == 1 and grid2[i][j] == 1)\\n                {\\n                    int check = 1;\\n                    dfs(grid1, grid2, i, j, m, n, check);\\n                    count += check;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>> &grid1, vector<vector<int>>&grid2, int i, int j, int m, int n,int &check)\\n    {\\n        if(i < 0 || i >=m or j < 0 or j >= n or grid2[i][j] != 1 or grid2[i][j] != 1)\\n            return;\\n        if(grid1[i][j] == 0 and grid2[i][j] == 1)\\n            check = 0;\\n        grid2[i][j] = 2;\\n        dfs(grid1, grid2, i + 1, j, m, n, check);\\n        dfs(grid1, grid2, i , j + 1, m, n, check);\\n        dfs(grid1, grid2, i, j - 1, m, n, check);\\n        dfs(grid1, grid2, i - 1, j, m, n, check);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int m = grid1.size(), n = grid2[0].size();\\n        int count = 0;\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(grid1[i][j] == 1 and grid2[i][j] == 1)\\n                {\\n                    int check = 1;\\n                    dfs(grid1, grid2, i, j, m, n, check);\\n                    count += check;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834581,
                "title": "1905-my-java-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\n// at what circustances will we consider an island B in grid2 is a sub-island of island A in grid1?\\n// it is when all cells of island B are also island cells in island A\\n// ** in other words:\\n// if there is some cell in islandB that is water in corresponded cell of island A, \\n// then island B is not a sub-island of island A\\n\\n// os the idea is we have to traverse all islands in grid2,\\n// and exclude those island that are not sub-island in grid1\\n// then what\\'s left are all sub-island\\n\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length, n = grid1[0].length;\\n\\n        for(int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // if we find an island in grid2, we check if this cell is also an island in grid1\\n                if (grid1[i][j]==0 && grid2[i][j]==1) {\\n                    // this island of grid2 is not an sub-island of grid1 \\n                    // so we flood fill this island in grid2, make this island all 0\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n\\n        // now that we have flood-filled all non-sub-island, what\\'s left are all sub island\\n        // we just traverse again in grid2 and count\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j]==1) {\\n                    res++;\\n                    dfs(grid2, i, j); // flood fill this island as marked visited\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\n    // this dfs method is the same as leetcode 200, there is no change here\\n    private void dfs(int[][] grid, int i, int j) {\\n        int m = grid.length, n = grid[0].length;\\n        if (i<0 || j<0 || i >= m || j>=n) return;\\n        if (grid[i][j] == 0) return;\\n\\n        grid[i][j] = 0;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// at what circustances will we consider an island B in grid2 is a sub-island of island A in grid1?\\n// it is when all cells of island B are also island cells in island A\\n// ** in other words:\\n// if there is some cell in islandB that is water in corresponded cell of island A, \\n// then island B is not a sub-island of island A\\n\\n// os the idea is we have to traverse all islands in grid2,\\n// and exclude those island that are not sub-island in grid1\\n// then what\\'s left are all sub-island\\n\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length, n = grid1[0].length;\\n\\n        for(int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                // if we find an island in grid2, we check if this cell is also an island in grid1\\n                if (grid1[i][j]==0 && grid2[i][j]==1) {\\n                    // this island of grid2 is not an sub-island of grid1 \\n                    // so we flood fill this island in grid2, make this island all 0\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n\\n        // now that we have flood-filled all non-sub-island, what\\'s left are all sub island\\n        // we just traverse again in grid2 and count\\n        int res = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (grid2[i][j]==1) {\\n                    res++;\\n                    dfs(grid2, i, j); // flood fill this island as marked visited\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n\\n    // this dfs method is the same as leetcode 200, there is no change here\\n    private void dfs(int[][] grid, int i, int j) {\\n        int m = grid.length, n = grid[0].length;\\n        if (i<0 || j<0 || i >= m || j>=n) return;\\n        if (grid[i][j] == 0) return;\\n\\n        grid[i][j] = 0;\\n        dfs(grid, i+1, j);\\n        dfs(grid, i-1, j);\\n        dfs(grid, i, j+1);\\n        dfs(grid, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2619147,
                "title": "java-99-01-faster-dfs-easy",
                "content": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int row = grid1.length;\\n        int col = grid1[0].length;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid1[i][j] == 0) {\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid2[i][j] == 1) {\\n                    ans++;\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static void dfs(int[][] g2, int r, int c) {\\n        if (r < 0 || c < 0 || r >= g2.length || c >= g2[0].length || g2[r][c] == 0) {\\n            return;\\n        }\\n        g2[r][c] = 0;\\n        dfs(g2, r + 1, c);\\n        dfs(g2, r - 1, c);\\n        dfs(g2, r, c + 1);\\n        dfs(g2, r, c - 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int row = grid1.length;\\n        int col = grid1[0].length;\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid1[i][j] == 0) {\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid2[i][j] == 1) {\\n                    ans++;\\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    private static void dfs(int[][] g2, int r, int c) {\\n        if (r < 0 || c < 0 || r >= g2.length || c >= g2[0].length || g2[r][c] == 0) {\\n            return;\\n        }\\n        g2[r][c] = 0;\\n        dfs(g2, r + 1, c);\\n        dfs(g2, r - 1, c);\\n        dfs(g2, r, c + 1);\\n        dfs(g2, r, c - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2407967,
                "title": "c-easy-dfs-solution-using-flag-variable-tc-76-89",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& g1, vector<vector<int>>& g2, int i,int j,int &flag){\\n       if(i<0 or j<0 or i>=g2.size() or j>=g2[0].size() or g2[i][j]==0) return;\\n        if(g1[i][j]==0) flag=0;\\n            g2[i][j]=0;\\n        dfs(g1,g2,i+1,j,flag);\\n        dfs(g1,g2,i-1,j,flag);\\n        dfs(g1,g2,i,j+1,flag);\\n        dfs(g1,g2,i,j-1,flag);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid2.size();\\n        int m=grid2[0].size();\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    int flag=1;\\n                    dfs(grid1,grid2,i,j,flag);\\n                    ct+=flag;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<m;j++){\\n        //         cout<<grid2[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        return ct;\\n    }\\n};\\n**If U Like It Please Upvote.**\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& g1, vector<vector<int>>& g2, int i,int j,int &flag){\\n       if(i<0 or j<0 or i>=g2.size() or j>=g2[0].size() or g2[i][j]==0) return;\\n        if(g1[i][j]==0) flag=0;\\n            g2[i][j]=0;\\n        dfs(g1,g2,i+1,j,flag);\\n        dfs(g1,g2,i-1,j,flag);\\n        dfs(g1,g2,i,j+1,flag);\\n        dfs(g1,g2,i,j-1,flag);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid2.size();\\n        int m=grid2[0].size();\\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    int flag=1;\\n                    dfs(grid1,grid2,i,j,flag);\\n                    ct+=flag;\\n                }\\n            }\\n        }\\n        // for(int i=0;i<n;i++){\\n        //     for(int j=0;j<m;j++){\\n        //         cout<<grid2[i][j]<<\" \";\\n        //     }\\n        //     cout<<endl;\\n        // }\\n        return ct;\\n    }\\n};\\n**If U Like It Please Upvote.**\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2307885,
                "title": "c-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, bool& flag){\\n        if(x<0 || y<0 || x>=n || y>=m || grid2[x][y]!=1)\\n            return;\\n        \\n        if(grid1[x][y]!=1)\\n            flag=false;\\n        \\n        grid2[x][y]=2;\\n        dfs(grid1,grid2,x+1,y,flag);\\n        dfs(grid1,grid2,x,y+1,flag);\\n        dfs(grid1,grid2,x,y-1,flag);\\n        dfs(grid1,grid2,x-1,y,flag);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n=grid2.size(), m=grid2[0].size();\\n        int ans=0;\\n        bool flag=true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag) ans++;\\n                    flag=true;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n,m;\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, bool& flag){\\n        if(x<0 || y<0 || x>=n || y>=m || grid2[x][y]!=1)\\n            return;\\n        \\n        if(grid1[x][y]!=1)\\n            flag=false;\\n        \\n        grid2[x][y]=2;\\n        dfs(grid1,grid2,x+1,y,flag);\\n        dfs(grid1,grid2,x,y+1,flag);\\n        dfs(grid1,grid2,x,y-1,flag);\\n        dfs(grid1,grid2,x-1,y,flag);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n=grid2.size(), m=grid2[0].size();\\n        int ans=0;\\n        bool flag=true;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag) ans++;\\n                    flag=true;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2262792,
                "title": "c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<int>>&grid1,vector<vector<int>>& grid2,int N,int M){\\n        if(i<0 or j<0 or i>=N or j>=M or grid2[i][j]==0){return true;}\\n            \\n        if(grid1[i][j]==0){return false;}\\n        grid2[i][j]=0;\\n        \\n        bool a=dfs(i-1,j,grid1,grid2,N,M);\\n        bool b=dfs(i+1,j,grid1,grid2,N,M);\\n        bool c=dfs(i,j+1,grid1,grid2,N,M);\\n        bool d=dfs(i,j-1,grid1,grid2,N,M);\\n        return a and b and c and d ;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int N=grid1.size();\\n        int M=grid1[0].size();\\n        \\n        int c=0;\\n        for(int i=0;i<N;i++){\\n            for(int j=0;j<M;j++){\\n                if(grid2[i][j]==0)continue;\\n                if(dfs(i,j,grid1,grid2,N,M))c++;\\n        }\\n    }\\n    return c; \\n    }      \\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    bool dfs(int i,int j,vector<vector<int>>&grid1,vector<vector<int>>& grid2,int N,int M){\\n        if(i<0 or j<0 or i>=N or j>=M or grid2[i][j]==0){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2107753,
                "title": "java-dfs",
                "content": "```\\nclass Solution {\\n    int m = 0, n = 0;\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        m = grid1.length;\\n        n = grid1[0].length;\\n        int subIslands = 0;\\n        \\n        // get rid of useless(non-overlapping) islands from grid1\\n        for(int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid2[i][j] == 0)\\n                    grid1[i][j] = 0;\\n            }\\n        }\\n        \\n        // fill grid1 and grid2\\n        for(int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid2[i][j] == 1)\\n                    if (dfs(grid1, grid2, i, j))\\n                        subIslands++;\\n            }\\n        }\\n        \\n        return subIslands;\\n    }\\n    \\n    int[] dirs = new int[]{0,1,0,-1,0};\\n    \\n    public boolean dfs(int[][] grid1, int[][] grid2, int x, int y){\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid2[x][y] == 0)\\n            return true;\\n        \\n        // return false if grid2 has an island, but grid1 doesn\\'t\\n        if (grid1[x][y] == 0)\\n            return false;\\n        \\n        grid1[x][y] = 0;\\n        grid2[x][y] = 0;\\n        boolean isSubisland = true;\\n\\n        for(int i = 0; i < 4; i++){\\n            isSubisland = dfs(grid1, grid2, x + dirs[i], y + dirs[i + 1]) && isSubisland;\\n        }\\n        \\n        return isSubisland;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int m = 0, n = 0;\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        m = grid1.length;\\n        n = grid1[0].length;\\n        int subIslands = 0;\\n        \\n        // get rid of useless(non-overlapping) islands from grid1\\n        for(int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid2[i][j] == 0)\\n                    grid1[i][j] = 0;\\n            }\\n        }\\n        \\n        // fill grid1 and grid2\\n        for(int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (grid2[i][j] == 1)\\n                    if (dfs(grid1, grid2, i, j))\\n                        subIslands++;\\n            }\\n        }\\n        \\n        return subIslands;\\n    }\\n    \\n    int[] dirs = new int[]{0,1,0,-1,0};\\n    \\n    public boolean dfs(int[][] grid1, int[][] grid2, int x, int y){\\n        if (x < 0 || x >= m || y < 0 || y >= n || grid2[x][y] == 0)\\n            return true;\\n        \\n        // return false if grid2 has an island, but grid1 doesn\\'t\\n        if (grid1[x][y] == 0)\\n            return false;\\n        \\n        grid1[x][y] = 0;\\n        grid2[x][y] = 0;\\n        boolean isSubisland = true;\\n\\n        for(int i = 0; i < 4; i++){\\n            isSubisland = dfs(grid1, grid2, x + dirs[i], y + dirs[i + 1]) && isSubisland;\\n        }\\n        \\n        return isSubisland;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2106247,
                "title": "c-simple-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void check(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int m,int n,bool &result){\\n        if(i<0 || j<0 || i>=m || j>=n)\\n            return;\\n        if(grid2[i][j]!=1)\\n            return;\\n        if(grid1[i][j]!=1)\\n            result=false;\\n        grid2[i][j]=0;\\n        check(grid1,grid2,i+1,j,m,n,result);\\n        check(grid1,grid2,i-1,j,m,n,result);\\n        check(grid1,grid2,i,j+1,m,n,result);\\n        check(grid1,grid2,i,j-1,m,n,result);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans=0;\\n        int m=grid1.size();\\n        int n=grid1[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j]==1){\\n                    bool result=true;\\n                    check(grid1,grid2,i,j,m,n,result);\\n                    if(result)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void check(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int m,int n,bool &result){\\n        if(i<0 || j<0 || i>=m || j>=n)\\n            return;\\n        if(grid2[i][j]!=1)\\n            return;\\n        if(grid1[i][j]!=1)\\n            result=false;\\n        grid2[i][j]=0;\\n        check(grid1,grid2,i+1,j,m,n,result);\\n        check(grid1,grid2,i-1,j,m,n,result);\\n        check(grid1,grid2,i,j+1,m,n,result);\\n        check(grid1,grid2,i,j-1,m,n,result);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans=0;\\n        int m=grid1.size();\\n        int n=grid1[0].size();\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j]==1){\\n                    bool result=true;\\n                    check(grid1,grid2,i,j,m,n,result);\\n                    if(result)\\n                        ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974798,
                "title": "java-beats-100-00-memory-speed-0ms-april-2022",
                "content": "```\\nclass Solution {\\n    int ans = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0 ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length ; j++){\\n\\t\\t\\t// applying dfs on grid2 and checking for corresponding cells in grid1 \\n                if(grid2[i][j] == 1){\\n                    ans = 1;\\n                    dfs(grid1, grid2, i, j);\\n                    count += ans;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid1.length || j >= grid1[0].length || grid2[i][j] == 0) return ;\\n\\t\\t// if the corresponding cell in grid1 is water, then we just make ans = 0.\\n        if(grid1[i][j] == 0) ans = 0;\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    int ans = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for(int i = 0 ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length ; j++){\\n\\t\\t\\t// applying dfs on grid2 and checking for corresponding cells in grid1 \\n                if(grid2[i][j] == 1){\\n                    ans = 1;\\n                    dfs(grid1, grid2, i, j);\\n                    count += ans;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j){\\n        if(i < 0 || j < 0 || i >= grid1.length || j >= grid1[0].length || grid2[i][j] == 0) return ;\\n\\t\\t// if the corresponding cell in grid1 is water, then we just make ans = 0.\\n        if(grid1[i][j] == 0) ans = 0;\\n        grid2[i][j] = 0;\\n        dfs(grid1, grid2, i-1, j);\\n        dfs(grid1, grid2, i+1, j);\\n        dfs(grid1, grid2, i, j+1);\\n        dfs(grid1, grid2, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1921102,
                "title": "java-easy-solution-dfs-super-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int num = 0;\\n        for (int i = 0; i < grid1.length; i++){\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1 && grid1[i][j] == 0) { //when [][]=1 in grid2 and [][]=0 in grid 1; change the 1s and it\\'s udlr(up,down,left,right) in grid2 to 0 \\n                    dfs(grid2, i, j);\\n                }\\n            }\\n        }\\n        for (int i = 0; i < grid2.length; i++){\\n            for (int j = 0; j < grid2[0].length; j++) {\\n                if (grid2[i][j] == 1) { //get the sub islands\\n                    dfs(grid2, i, j);\\n                    num++;\\n                }\\n            }\\n        }\\n        return num;\\n    }\\n    private void dfs(int[][] grid2, int i, int j){ //turn udlr to 0\\n        if (i < 0 || j < 0 || i >= grid2.length || j >= grid2[0].length || grid2[i][j] == 0){\\n            return;\\n        }\\n        grid2[i][j] = 0;\\n        dfs(grid2, i + 1, j);\\n        dfs(grid2, i - 1, j);\\n        dfs(grid2, i, j + 1);\\n        dfs(grid2, i, j - 1);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int num = 0;\\n        for (int i = 0; i < grid1.length; i++){\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1 && grid1[i][j] == 0) { //when [][]=1 in grid2 and [][]=0 in grid 1; change the 1s and it\\'s udlr(up,down,left,right) in grid2 to 0 \\n                    dfs(grid2, i, j);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1877054,
                "title": "c-simple-code-easy-to-understand-tc-o-n-2-sc-o-1",
                "content": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint Island(vector<vector<int>> &grid1, vector<vector<int>> &grid2, int i, int j){\\n        if(i<0 || j<0 || i>=grid1.size() || j>=grid1[0].size() || (grid1[i][j]==0 && grid2[i][j]==0) ) return 1;\\n        if(grid1[i][j]==grid2[i][j]){\\n            grid1[i][j]=0;\\n            grid2[i][j]=0;\\n            return Island(grid1, grid2, i+1, j) & Island(grid1, grid2, i-1, j) & Island(grid1, grid2, i, j-1) & Island(grid1, grid2, i, j+1);\\n        }\\n        if(grid1[i][j]==0) return 0;\\n        return 1;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size(), m=grid1[0].size(),ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid1[i][j]==1 && grid2[i][j]==1){\\n                    ans+=Island(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "#### *Please Upvote if it helps\\u2B06\\uFE0F*\\n```\\nint Island(vector<vector<int>> &grid1, vector<vector<int>> &grid2, int i, int j){\\n        if(i<0 || j<0 || i>=grid1.size() || j>=grid1[0].size() || (grid1[i][j]==0 && grid2[i][j]==0) ) return 1;\\n        if(grid1[i][j]==grid2[i][j]){\\n            grid1[i][j]=0;\\n            grid2[i][j]=0;\\n            return Island(grid1, grid2, i+1, j) & Island(grid1, grid2, i-1, j) & Island(grid1, grid2, i, j-1) & Island(grid1, grid2, i, j+1);\\n        }\\n        if(grid1[i][j]==0) return 0;\\n        return 1;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size(), m=grid1[0].size(),ans=0;\\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(grid1[i][j]==1 && grid2[i][j]==1){\\n                    ans+=Island(grid1, grid2, i, j);\\n                }\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1829086,
                "title": "java-dfs-floodfill-25-ms",
                "content": "```\\nclass Solution {\\n    \\n    boolean isSubIsland;\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n || grid2[i][j] == 0)     return;\\n        if (grid1[i][j] == 0) {\\n            isSubIsland = false;\\n        }\\n        grid2[i][j] = 0;\\n        \\n        dfs(grid1, grid2, m, n, i+1, j);\\n        dfs(grid1, grid2, m, n, i-1, j);\\n        dfs(grid1, grid2, m, n, i, j+1);\\n        dfs(grid1, grid2, m, n, i, j-1);\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        int count=0;\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid2[i][j] == 1) {\\n                    isSubIsland = true;\\n                    dfs(grid1, grid2, m, n, i, j);\\n                    if (isSubIsland) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    boolean isSubIsland;\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int m, int n, int i, int j) {\\n        if (i<0 || j<0 || i>=m || j>=n || grid2[i][j] == 0)     return;\\n        if (grid1[i][j] == 0) {\\n            isSubIsland = false;\\n        }\\n        grid2[i][j] = 0;\\n        \\n        dfs(grid1, grid2, m, n, i+1, j);\\n        dfs(grid1, grid2, m, n, i-1, j);\\n        dfs(grid1, grid2, m, n, i, j+1);\\n        dfs(grid1, grid2, m, n, i, j-1);\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int m = grid1.length;\\n        int n = grid1[0].length;\\n        int count=0;\\n        \\n        for (int i=0; i<m; i++) {\\n            for (int j=0; j<n; j++) {\\n                if (grid2[i][j] == 1) {\\n                    isSubIsland = true;\\n                    dfs(grid1, grid2, m, n, i, j);\\n                    if (isSubIsland) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1807221,
                "title": "one-of-the-best-and-easiest-sol-out-there-guaranteed",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m || grid2[i][j]==0)return;\\n\\n        grid2[i][j]=0;\\n        dfs(grid1,grid2,i+1,j,n,m);\\n        dfs(grid1,grid2,i,j+1,n,m);\\n        dfs(grid1,grid2,i-1,j,n,m);\\n        dfs(grid1,grid2,i,j-1,n,m);\\n\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n\\t\\t\\n\\t\\t//removing all the non-common sub-islands\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j] && grid1[i][j]==0)\\n                   dfs(grid1,grid2,i,j,n,m); \\n          \\n\\t\\t //counting sub-islands \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j]){\\n                   ans++;\\n                   dfs(grid1,grid2,i,j,n,m); \\n                }\\n \\n        return ans;\\n    }\\n};\\n```\\n\\nplz upvote if uh like",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int n,int m){\\n        if(i<0 || j<0 || i>=n || j>=m || grid2[i][j]==0)return;\\n\\n        grid2[i][j]=0;\\n        dfs(grid1,grid2,i+1,j,n,m);\\n        dfs(grid1,grid2,i,j+1,n,m);\\n        dfs(grid1,grid2,i-1,j,n,m);\\n        dfs(grid1,grid2,i,j-1,n,m);\\n\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n\\t\\t\\n\\t\\t//removing all the non-common sub-islands\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j] && grid1[i][j]==0)\\n                   dfs(grid1,grid2,i,j,n,m); \\n          \\n\\t\\t //counting sub-islands \\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n                if(grid2[i][j]){\\n                   ans++;\\n                   dfs(grid1,grid2,i,j,n,m); \\n                }\\n \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1629708,
                "title": "c-dsu-o-mn-o-mn",
                "content": "Solution repeats the idea of the solution from [here](https://leetcode.com/problems/count-sub-islands/discuss/1284325/Python-Union-Find). Although with some minor changes \\n\\n```\\nclass UF {\\n    std::vector<int> ranks;\\n    std::vector<int> parents;\\npublic:\\n    UF( int size ) {\\n        ranks.resize( size, 1 );\\n        parents.resize( size );\\n        std::iota( std::begin( parents ), std::end( parents ), 0 );\\n    }\\n    \\n    int find( int x ) {\\n        if( x == parents[ x ] )\\n            return x;\\n        return find( parents[ x ] );\\n    }\\n    \\n    void unite( int x, int y ) {\\n        auto xroot = find( x );\\n        auto yroot = find( y );\\n        if( xroot == yroot )\\n            return;\\n        \\n        if( ranks[ xroot ] >= ranks[ yroot ] ) {\\n            parents[ yroot ] = xroot;\\n            ranks[ xroot ] += ranks[ yroot ];\\n        } else {\\n            parents[ xroot ] = yroot;\\n            ranks[ yroot ] += ranks[ xroot ];            \\n        }\\n    }\\n    \\n    bool are_connected( int x, int y ) {\\n        return find( x ) == find( y );\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    // time O( N * M )\\n    // space O( N * M )\\n    UF build_uf( const vector<vector<int>>& grid ) {\\n        int h = grid.size(); /// O( 1 )\\n        int w = grid.front().size(); // O( 1 )\\n        UF uf( w * h );\\n        std::vector<std::vector<int>> moves{ { 0, 1 }, { 1, 0 } };\\n        auto point = [w]( int x, int y ){\\n            return y * w + x;\\n        };\\n\\n        for( int i = 0; i < h; ++i ) {\\n            for( int j = 0; j < w; ++j ) {\\n                if( !grid[ i ][ j ] ) // O( 1 )\\n                    continue;\\n\\n                for( const auto& move : moves ) {\\n                    auto y = i + move[ 1 ];\\n                    auto x = j + move[ 0 ];\\n                    if( x >= w || y >= h || !grid[ y ][ x ] )\\n                        continue;\\n                    \\n                    uf.unite( point( j, i ), point( x, y ) );\\n                }\\n            }\\n        }\\n        \\n        return uf;\\n    }\\n    \\n    // time O( ( N * M )\\n    // space O( N * M )\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        auto uf1 = build_uf( grid1 ); // O( N * M )\\n        auto uf2 = build_uf( grid2 ); // O( N * M )\\n\\n        int h = grid2.size();\\n        int w = grid2.front().size();\\n        auto point = [w]( int x, int y ) {\\n            return y * w + x;\\n        };\\n\\n        std::unordered_map<int, std::vector<std::pair<int, int>>> islands2;\\n        for( int i = 0; i < h; ++i ) {\\n            for( int j = 0; j < w; ++j ) {\\n                if( !grid2[ i ][ j ] )\\n                    continue;\\n                \\n                islands2[ uf2.find( point( j, i ) ) ].push_back( std::make_pair( i, j ) );\\n            }\\n        }\\n        \\n        int cnt{ 0 };\\n        for( const auto& [root, lands] : islands2 ) {\\n            std::unordered_set<int> islands;\\n            bool is_water{ false };\\n            for( const auto& coord : lands ) {\\n                if( !grid1[ std::get<0>( coord ) ][ std::get<1>( coord ) ] ) {\\n                    is_water = true;\\n                    break;\\n                }\\n                \\n                islands.insert( uf1.find( point( std::get<1>( coord ), std::get<0>( coord ) ) ) );\\n            }\\n\\n            if( !is_water && islands.size() == 1 )\\n                ++cnt;\\n        }\\n\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass UF {\\n    std::vector<int> ranks;\\n    std::vector<int> parents;\\npublic:\\n    UF( int size ) {\\n        ranks.resize( size, 1 );\\n        parents.resize( size );\\n        std::iota( std::begin( parents ), std::end( parents ), 0 );\\n    }\\n    \\n    int find( int x ) {\\n        if( x == parents[ x ] )\\n            return x;\\n        return find( parents[ x ] );\\n    }\\n    \\n    void unite( int x, int y ) {\\n        auto xroot = find( x );\\n        auto yroot = find( y );\\n        if( xroot == yroot )\\n            return;\\n        \\n        if( ranks[ xroot ] >= ranks[ yroot ] ) {\\n            parents[ yroot ] = xroot;\\n            ranks[ xroot ] += ranks[ yroot ];\\n        } else {\\n            parents[ xroot ] = yroot;\\n            ranks[ yroot ] += ranks[ xroot ];            \\n        }\\n    }\\n    \\n    bool are_connected( int x, int y ) {\\n        return find( x ) == find( y );\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    // time O( N * M )\\n    // space O( N * M )\\n    UF build_uf( const vector<vector<int>>& grid ) {\\n        int h = grid.size(); /// O( 1 )\\n        int w = grid.front().size(); // O( 1 )\\n        UF uf( w * h );\\n        std::vector<std::vector<int>> moves{ { 0, 1 }, { 1, 0 } };\\n        auto point = [w]( int x, int y ){\\n            return y * w + x;\\n        };\\n\\n        for( int i = 0; i < h; ++i ) {\\n            for( int j = 0; j < w; ++j ) {\\n                if( !grid[ i ][ j ] ) // O( 1 )\\n                    continue;\\n\\n                for( const auto& move : moves ) {\\n                    auto y = i + move[ 1 ];\\n                    auto x = j + move[ 0 ];\\n                    if( x >= w || y >= h || !grid[ y ][ x ] )\\n                        continue;\\n                    \\n                    uf.unite( point( j, i ), point( x, y ) );\\n                }\\n            }\\n        }\\n        \\n        return uf;\\n    }\\n    \\n    // time O( ( N * M )\\n    // space O( N * M )\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        auto uf1 = build_uf( grid1 ); // O( N * M )\\n        auto uf2 = build_uf( grid2 ); // O( N * M )\\n\\n        int h = grid2.size();\\n        int w = grid2.front().size();\\n        auto point = [w]( int x, int y ) {\\n            return y * w + x;\\n        };\\n\\n        std::unordered_map<int, std::vector<std::pair<int, int>>> islands2;\\n        for( int i = 0; i < h; ++i ) {\\n            for( int j = 0; j < w; ++j ) {\\n                if( !grid2[ i ][ j ] )\\n                    continue;\\n                \\n                islands2[ uf2.find( point( j, i ) ) ].push_back( std::make_pair( i, j ) );\\n            }\\n        }\\n        \\n        int cnt{ 0 };\\n        for( const auto& [root, lands] : islands2 ) {\\n            std::unordered_set<int> islands;\\n            bool is_water{ false };\\n            for( const auto& coord : lands ) {\\n                if( !grid1[ std::get<0>( coord ) ][ std::get<1>( coord ) ] ) {\\n                    is_water = true;\\n                    break;\\n                }\\n                \\n                islands.insert( uf1.find( point( std::get<1>( coord ), std::get<0>( coord ) ) ) );\\n            }\\n\\n            if( !is_water && islands.size() == 1 )\\n                ++cnt;\\n        }\\n\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1545068,
                "title": "python3-remove-the-non-common-and-the-count-the-island",
                "content": "```\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        Rows = len(grid1)\\n        Cols = len(grid1[0])\\n        count = 0\\n        def dfs(r,c):\\n            if r < 0 or r >= Rows or c < 0 or c >= Cols or grid2[r][c] == 0:\\n                return \\n            grid2[r][c] = 0\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n            \\n        # removing all the non-common subIsland\\n        for r in range(Rows):\\n            for c in range(Cols):\\n                if grid2[r][c] == 1 and grid1[r][c] == 0:\\n                    dfs(r,c)\\n        \\n        # counting the subisland\\n        for r in range(Rows):\\n            for c in range(Cols):\\n                if grid2[r][c] == 1:\\n                    dfs(r,c)\\n                    count += 1\\n        return count\\n\\t\\t```\\n\\t\\tfeel free to ask Q...\\n\\t\\t#happytohelp",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        Rows = len(grid1)\\n        Cols = len(grid1[0])\\n        count = 0\\n        def dfs(r,c):\\n            if r < 0 or r >= Rows or c < 0 or c >= Cols or grid2[r][c] == 0:\\n                return \\n            grid2[r][c] = 0\\n            dfs(r+1,c)\\n            dfs(r-1,c)\\n            dfs(r,c+1)\\n            dfs(r,c-1)\\n            \\n        # removing all the non-common subIsland\\n        for r in range(Rows):\\n            for c in range(Cols):\\n                if grid2[r][c] == 1 and grid1[r][c] == 0:\\n                    dfs(r,c)\\n        \\n        # counting the subisland\\n        for r in range(Rows):\\n            for c in range(Cols):\\n                if grid2[r][c] == 1:\\n                    dfs(r,c)\\n                    count += 1\\n        return count\\n\\t\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 1469745,
                "title": "java-faster-than-99-explained",
                "content": "```\\nclass Solution \\n{\\n    int flag = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) \\n    {\\n        int count = 0;\\n        for( int i = 0 ; i < grid2.length ; i++ )\\n        {\\n            for( int j = 0 ; j < grid2[i].length ; j++ )\\n            {\\n                if( grid2[i][j] == 1 )\\n                {\\n                    traverse( grid1,grid2,i,j );\\n                    if(flag == 0) count++;\\n                    flag = 0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void traverse(int[][] grid1,int[][] grid2, int i , int j )\\n    {\\n        if( i >= 0 && i < grid2.length && j >= 0 && j < grid2[i].length && grid2[i][j] == 1 )\\n        {\\n            if( grid1[i][j] == 0 )\\n            {\\n                flag = 1;\\n            }\\n            grid2[i][j] = 0;\\n            traverse( grid1, grid2, i+1, j );\\n            traverse( grid1, grid2, i-1, j );\\n            traverse( grid1, grid2, i, j+1 );\\n            traverse( grid1, grid2, i, j-1 );\\n        }\\n    }\\n}\\n/*\\nMark islands in grid2 irrespective of whether they are present in grid1 or not\\nIf any part of island is not present in grid1 then make flag to 1\\nIf flag remains 0 only then increment count\\n*/\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    int flag = 0;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) \\n    {\\n        int count = 0;\\n        for( int i = 0 ; i < grid2.length ; i++ )\\n        {\\n            for( int j = 0 ; j < grid2[i].length ; j++ )\\n            {\\n                if( grid2[i][j] == 1 )\\n                {\\n                    traverse( grid1,grid2,i,j );\\n                    if(flag == 0) count++;\\n                    flag = 0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    public void traverse(int[][] grid1,int[][] grid2, int i , int j )\\n    {\\n        if( i >= 0 && i < grid2.length && j >= 0 && j < grid2[i].length && grid2[i][j] == 1 )\\n        {\\n            if( grid1[i][j] == 0 )\\n            {\\n                flag = 1;\\n            }\\n            grid2[i][j] = 0;\\n            traverse( grid1, grid2, i+1, j );\\n            traverse( grid1, grid2, i-1, j );\\n            traverse( grid1, grid2, i, j+1 );\\n            traverse( grid1, grid2, i, j-1 );\\n        }\\n    }\\n}\\n/*\\nMark islands in grid2 irrespective of whether they are present in grid1 or not\\nIf any part of island is not present in grid1 then make flag to 1\\nIf flag remains 0 only then increment count\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348370,
                "title": "java-dfs-o-n-m",
                "content": "We take a island from grid2 one by one and turn the land (1) to water (0) so that we don\\'t counter that island again and DSF function returns true if the whole island has also been found in grid1 otherwise false.\\n```\\nclass Solution {\\n    private boolean DFS(int[][] grid1, int[][] grid2, int i, int j, int n, int m){\\n        if(i < 0 || j < 0 || i == n || j == m || grid2[i][j] == 0) return true;\\n        grid2[i][j] = 0;\\n        boolean ret = grid1[i][j] == 1;\\n        ret &= DFS(grid1, grid2, i + 1, j, n, m);\\n        ret &= DFS(grid1, grid2, i, j + 1, n, m);\\n        ret &= DFS(grid1, grid2, i - 1, j, n, m);\\n        ret &= DFS(grid1, grid2, i, j - 1, n, m);\\n        return ret;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length, m = grid1[0].length, count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid2[i][j] == 1){\\n                    if(DFS(grid1, grid2, i, j, n, m))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private boolean DFS(int[][] grid1, int[][] grid2, int i, int j, int n, int m){\\n        if(i < 0 || j < 0 || i == n || j == m || grid2[i][j] == 0) return true;\\n        grid2[i][j] = 0;\\n        boolean ret = grid1[i][j] == 1;\\n        ret &= DFS(grid1, grid2, i + 1, j, n, m);\\n        ret &= DFS(grid1, grid2, i, j + 1, n, m);\\n        ret &= DFS(grid1, grid2, i - 1, j, n, m);\\n        ret &= DFS(grid1, grid2, i, j - 1, n, m);\\n        return ret;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length, m = grid1[0].length, count = 0;\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                if(grid2[i][j] == 1){\\n                    if(DFS(grid1, grid2, i, j, n, m))\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325319,
                "title": "short-with-picture-and-commented-code",
                "content": "*Key Point here is,\\nwe do not return instantly if we found a false as answer\\nbut instead we are going to traverse the whole portion\\nso that the remaining part will not make any difficulty in future.*\\n\\n**This is how we are going to make tree.**\\n![image](https://assets.leetcode.com/users/images/ed2487ec-69d4-4da7-9bcf-86a0a71aef3c_1625763540.6736279.jpeg)\\n\\n**Code**\\n## Java\\n```\\nclass Solution {\\n    int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int n, m;\\n    private boolean dfs(int[][] grid1, int[][] grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n        boolean res = true;\\n        for (int d = 0; d < dir.length; ++d) {\\n            int r = i + dir[d][0];\\n            int c = j + dir[d][1];\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid2[r][c] == 1) {\\n                res = dfs(grid1, grid2, r, c) && res;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tThis is the portion where we are applying the key point\\n\\t\\t\\t\\twe putted res, after the dfs call,\\n\\t\\t\\t\\tso that it will traverse the whole island and convert it to sea\\n\\t\\t\\t\\tand after that only it will return false/true as answer.\\n\\t\\t\\t\\t*/\\n            }\\n        }\\n        return res && grid1[i][j] == 1;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        n = grid1.length;\\n        m = grid1[0].length;\\n        int count = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m ; ++j)\\n                if (grid2[i][j] == 1)\\n                    count += dfs(grid1, grid2, i, j) ? 1 : 0;\\n        return count;\\n    }\\n}\\n```\\n## C++\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int n;\\n    int m;\\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n        bool res = true;\\n        for (int d = 0; d < dir.size(); ++d) {\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            if (x >= 0 and y >= 0 and x < n and y < m and grid2[x][y] == 1) {\\n                res = dfs(grid1, grid2, x, y) and res;\\n            }\\n        }\\n        return grid1[i][j] == 1 and res;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n = grid1.size();\\n        m = grid1[0].size();\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid2[i][j] == 1) {\\n                    count += dfs(grid1, grid2, i, j) ? 1 : 0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    int[][] dir = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int n, m;\\n    private boolean dfs(int[][] grid1, int[][] grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n        boolean res = true;\\n        for (int d = 0; d < dir.length; ++d) {\\n            int r = i + dir[d][0];\\n            int c = j + dir[d][1];\\n            if (r >= 0 && c >= 0 && r < n && c < m && grid2[r][c] == 1) {\\n                res = dfs(grid1, grid2, r, c) && res;\\n\\t\\t\\t\\t/*\\n\\t\\t\\t\\tThis is the portion where we are applying the key point\\n\\t\\t\\t\\twe putted res, after the dfs call,\\n\\t\\t\\t\\tso that it will traverse the whole island and convert it to sea\\n\\t\\t\\t\\tand after that only it will return false/true as answer.\\n\\t\\t\\t\\t*/\\n            }\\n        }\\n        return res && grid1[i][j] == 1;\\n    }\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        n = grid1.length;\\n        m = grid1[0].length;\\n        int count = 0;\\n        for (int i = 0; i < n; ++i)\\n            for (int j = 0; j < m ; ++j)\\n                if (grid2[i][j] == 1)\\n                    count += dfs(grid1, grid2, i, j) ? 1 : 0;\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dir {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\\n    int n;\\n    int m;\\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        grid2[i][j] = 0;\\n        bool res = true;\\n        for (int d = 0; d < dir.size(); ++d) {\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            if (x >= 0 and y >= 0 and x < n and y < m and grid2[x][y] == 1) {\\n                res = dfs(grid1, grid2, x, y) and res;\\n            }\\n        }\\n        return grid1[i][j] == 1 and res;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        n = grid1.size();\\n        m = grid1[0].size();\\n        int count = 0;\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (grid2[i][j] == 1) {\\n                    count += dfs(grid1, grid2, i, j) ? 1 : 0;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321673,
                "title": "python-dfs-memoization",
                "content": "Solution 1: I started with a brute force solution in which I first performed dfs on Grid1 and from that I marked all corresponding cells in Grid2 with value 1 to value 2. Then, another DFS on Grid2 in which values should be only contains 2s and no 1s. It gave Timeout\\nSolution 2: Then, as a improvement, I applied memoization on Grid2. It passed with acceptance%- 10%.\\nSolution 3: Then, as a improvement, I found that the first DFS can be eliminated by checking Grid1 from Grid2. Before I was checking Grid2 from Grid1. Passed at acceptance-  >90%.\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        visited=set()\\n        n=len(grid1)\\n        m=len(grid1[0])\\n        \\n        @lru_cache(None)\\n        def find_subisland(i,j):\\n            if(i<0 or j<0 or i==n or j==m or grid2[i][j]==0):\\n                return True\\n            if(grid1[i][j]==0):\\n                return False\\n            if((i,j) in visited):\\n                return True\\n            visited.add((i,j))\\n            \\n            return find_subisland(i+1,j) and find_subisland(i-1,j) and find_subisland(i,j-1) and find_subisland(i,j+1)\\n        \\n        visited=set()\\n        ans=0\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid2[i][j]==1 and (i,j) not in visited):\\n                    if(find_subisland(i,j)):\\n                        ans+=1\\n        return ans\\n",
                "solutionTags": [],
                "code": "Solution 1: I started with a brute force solution in which I first performed dfs on Grid1 and from that I marked all corresponding cells in Grid2 with value 1 to value 2. Then, another DFS on Grid2 in which values should be only contains 2s and no 1s. It gave Timeout\\nSolution 2: Then, as a improvement, I applied memoization on Grid2. It passed with acceptance%- 10%.\\nSolution 3: Then, as a improvement, I found that the first DFS can be eliminated by checking Grid1 from Grid2. Before I was checking Grid2 from Grid1. Passed at acceptance-  >90%.\\n\\n```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        visited=set()\\n        n=len(grid1)\\n        m=len(grid1[0])\\n        \\n        @lru_cache(None)\\n        def find_subisland(i,j):\\n            if(i<0 or j<0 or i==n or j==m or grid2[i][j]==0):\\n                return True\\n            if(grid1[i][j]==0):\\n                return False\\n            if((i,j) in visited):\\n                return True\\n            visited.add((i,j))\\n            \\n            return find_subisland(i+1,j) and find_subisland(i-1,j) and find_subisland(i,j-1) and find_subisland(i,j+1)\\n        \\n        visited=set()\\n        ans=0\\n        for i in range(n):\\n            for j in range(m):\\n                if(grid2[i][j]==1 and (i,j) not in visited):\\n                    if(find_subisland(i,j)):\\n                        ans+=1\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 1312631,
                "title": "python-3-math-dfs-explanation",
                "content": "### Intuition\\n- To see if cell in `grid1` covers cell in `grid2`, we can add `grid1[i][j]` onto `grid2[i][j]` **whenever `grid2[i][j]` is part of an island** (when `grid2[i][j] == 1`) \\n- To make sure if island on `grid2` is a sub-island of `grid1`, we can simply do a depth-first search on the new matrix from previous step whenever we see a `grid2[i][j] == 2` (**meaning `grid2[i][j]` is an island and covered by `grid1[i][j]`**)\\n\\t- If the island of `grid2[i][j]` contains only values `2`, meaning it\\'s **fully covered (thus it\\'s a sub-island)**, if there is a `1` on this island meaning it\\'s not fully covered.\\n\\t- In DFS, we will return `True` if island of `grid2[i]j]` is part of a sub-island, otherwise return `False`\\n- Keep counting `True` and return the total count\\n### Explanation\\n- Iterate over `grid2` and add `grid1` onto it whenever part of an island is met (`grid2[i][j] == 1`)\\n- Iterate again on `grid2`, find sub-island and count\\n\\t- For each visited sub-island or island (not covered by `grid1`), mark it as `-1` (visited, to avoid repeat)\\n- Return total count of sub-island\\n### Implementation\\n- Time Complexity: `O(m*n)`, where `m` and `n` is the dimension of matrix. Assign value takes `O(m*n)`, *check island* takes `O(m*n)`. Even if `dfs(i, j)` is nested in the *checking island* process, the total time of DFS is only `O(m*n)`, since at most each `(i, j)` will only be visited once in the entire DFS process. So, in total it\\'s **_`O(m*n) + O(m*n) = O(m*n)`_**, **NOT** `O(m*n) * O(m*n)`.\\n- Space Complexity: `O(m*n)` for stack usage during recursion, other operations use the exsiting matrix, so no extra space being used.\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid1), len(grid1[0])\\n        for i in range(m):                          # Add grid1 to grid2, total time: O(m*n)\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    grid2[i][j] += grid1[i][j]\\n\\t\\t\\t\\t\\t\\n        def dfs(i, j):                              # Find sub-island, return true if grid2[i][j] is part of an sub-island\\n            if i < 0 or i > m-1 or j < 0 or j > n-1:# If out of bound, return True\\n                return True      \\n            if grid2[i][j] < 1: return True         # If met water or visited node, return True\\n            tmp = grid2[i][j]\\n            grid2[i][j] = -1                        # Mark as visited\\n            a = dfs(i-1, j)                         # DFS on each direction\\n            b = dfs(i+1, j)\\n            c = dfs(i, j+1)\\n            d = dfs(i, j-1)\\n\\t\\t\\t# If current node is covered, return True if all 4 directions are also of the sub-island\\n\\t\\t\\t# otherwise return False\\n            return a and b and c and d if tmp == 2 else False  \\n\\t\\t\\t\\n        ans = 0\\n        for i in range(m):                          # DFS on each (i, j), O(m*n) on nested loop + O(m*n) on DFS\\n            for j in range(n):\\n                if grid2[i][j] == 2 and dfs(i, j):  # DFS on only covered islands, dfs(i, j) will take only O(m*n) during iterating the ENTIRE matrix, since each node will only be visited once\\n                    ans += 1\\n        return ans\\n```\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid1), len(grid1[0])\\n        for i in range(m):                          # Add grid1 to grid2, total time: O(m*n)\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    grid2[i][j] += grid1[i][j]\\n\\t\\t\\t\\t\\t\\n        def dfs(i, j):                              # Find sub-island, return true if grid2[i][j] is part of an sub-island\\n            if i < 0 or i > m-1 or j < 0 or j > n-1:# If out of bound, return True\\n                return True      \\n            if grid2[i][j] < 1: return True         # If met water or visited node, return True\\n            tmp = grid2[i][j]\\n            grid2[i][j] = -1                        # Mark as visited\\n            a = dfs(i-1, j)                         # DFS on each direction\\n            b = dfs(i+1, j)\\n            c = dfs(i, j+1)\\n            d = dfs(i, j-1)\\n\\t\\t\\t# If current node is covered, return True if all 4 directions are also of the sub-island\\n\\t\\t\\t# otherwise return False\\n            return a and b and c and d if tmp == 2 else False  \\n\\t\\t\\t\\n        ans = 0\\n        for i in range(m):                          # DFS on each (i, j), O(m*n) on nested loop + O(m*n) on DFS\\n            for j in range(n):\\n                if grid2[i][j] == 2 and dfs(i, j):  # DFS on only covered islands, dfs(i, j) will take only O(m*n) during iterating the ENTIRE matrix, since each node will only be visited once\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284884,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> nbrs = {{0,1},{1,0},{-1,0},{0,-1}};\\n    void dfs(int i, int j, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool & res){\\n        grid2[i][j] = 0;\\n    \\n        for(auto& nbr: nbrs){\\n            int x = nbr[0]+i;\\n            int y = nbr[1]+j;\\n            \\n            if(x<0 || y<0 || x>=grid1.size() || y>= grid1[0].size() || grid2[x][y] == 0) continue;\\n            if(grid2[x][y] == 1 && grid1[x][y] == 0) res = false;\\n                \\n            dfs(x, y, grid1, grid2, res);\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count  =0;\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                bool res = true;\\n                if(grid2[i][j]==1 && grid1[i][j] == 1){\\n                     dfs(i, j, grid1, grid2, res);\\n                    if(res == true)\\n                    count++;\\n                } \\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> nbrs = {{0,1},{1,0},{-1,0},{0,-1}};\\n    void dfs(int i, int j, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool & res){\\n        grid2[i][j] = 0;\\n    \\n        for(auto& nbr: nbrs){\\n            int x = nbr[0]+i;\\n            int y = nbr[1]+j;\\n            \\n            if(x<0 || y<0 || x>=grid1.size() || y>= grid1[0].size() || grid2[x][y] == 0) continue;\\n            if(grid2[x][y] == 1 && grid1[x][y] == 0) res = false;\\n                \\n            dfs(x, y, grid1, grid2, res);\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count  =0;\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        \\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                bool res = true;\\n                if(grid2[i][j]==1 && grid1[i][j] == 1){\\n                     dfs(i, j, grid1, grid2, res);\\n                    if(res == true)\\n                    count++;\\n                } \\n            }\\n        }\\n       return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284391,
                "title": "c-bfs",
                "content": "```\\nint vis[501][501];\\nint n,m;\\nint dx[]={1,0,-1,0};\\nint dy[]={0,1,0,-1};\\nclass Solution {\\n    public: bool safe(int x,int y,int n,int m){\\n        return (x>=0 && x<n && y>=0 && y<m);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size(),m=grid1[0].size(),ans=0;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) vis[i][j]=0;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) {\\n            if(!vis[i][j] && grid2[i][j]==1){\\n                pair<int,int> st={i,j};\\n                set<pair<int,int>> s1;\\n                s1.insert(st);\\n                int flag=1;\\n                while(s1.size()!=0){\\n                   st=*s1.begin();\\n                   s1.erase(s1.begin());\\n                   vis[st.first][st.second]=1;\\n                   if(!grid1[st.first][st.second]) flag=0;\\n                   for(int k=0;k<4;k++){\\n                        int x=st.first+dx[k],y=st.second+dy[k];\\n                        if(safe(x,y,n,m) && vis[x][y]==0 && grid2[x][y]==1) s1.insert({x,y});\\n                   } \\n                }\\n                if(flag) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint vis[501][501];\\nint n,m;\\nint dx[]={1,0,-1,0};\\nint dy[]={0,1,0,-1};\\nclass Solution {\\n    public: bool safe(int x,int y,int n,int m){\\n        return (x>=0 && x<n && y>=0 && y<m);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size(),m=grid1[0].size(),ans=0;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) vis[i][j]=0;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++) {\\n            if(!vis[i][j] && grid2[i][j]==1){\\n                pair<int,int> st={i,j};\\n                set<pair<int,int>> s1;\\n                s1.insert(st);\\n                int flag=1;\\n                while(s1.size()!=0){\\n                   st=*s1.begin();\\n                   s1.erase(s1.begin());\\n                   vis[st.first][st.second]=1;\\n                   if(!grid1[st.first][st.second]) flag=0;\\n                   for(int k=0;k<4;k++){\\n                        int x=st.first+dx[k],y=st.second+dy[k];\\n                        if(safe(x,y,n,m) && vis[x][y]==0 && grid2[x][y]==1) s1.insert({x,y});\\n                   } \\n                }\\n                if(flag) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284249,
                "title": "c-bfs-just-do-normal-bfs-with-a-condition",
                "content": "```\\nclass Solution {\\n    vector<vector<int>> directions = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int M = grid2.size();\\n        int N = grid2[0].size();\\n        int subIslandCount = 0;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid2[i][j] == 1) {\\n                    bool hasSubIslandFound = bfs(i, j, M, N, grid1, grid2);\\n                    subIslandCount += hasSubIslandFound;\\n                }\\n            }   \\n        }\\n        return subIslandCount;\\n    }\\n    \\n    bool bfs(int i, int j, int &M, int &N, vector<vector<int>> &grid1, vector<vector<int>> &grid2) {\\n        queue<vector<int>> todo;\\n        todo.push({ i, j });\\n        grid2[i][j] = 0; // Mark the cell\\n        bool hasSubIslandFound = true;\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front();\\n            todo.pop();\\n            // Check if grid1 has also same cell?\\n            if (grid1[cur[0]][cur[1]] != 1) {\\n                hasSubIslandFound = false; // Not found, but keep BFS anyways\\n            }\\n            for (vector<int> &dir : directions) {\\n                int nx = dir[0] + cur[0];\\n                int ny = dir[1] + cur[1];\\n                if (inside(nx, ny, M, N) && grid2[nx][ny] == 1) {\\n                    todo.push({ nx, ny });\\n                    grid2[nx][ny] = 0; // Mark the cell\\n                }\\n            }\\n        }\\n        return hasSubIslandFound;\\n    }\\n    \\n    bool inside(int i, int j, int &M, int &N) {\\n        if (i < 0 || i >= M || j < 0 || j >= N) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<int>> directions = { {1, 0}, {-1, 0}, {0, 1}, {0, -1} };\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int M = grid2.size();\\n        int N = grid2[0].size();\\n        int subIslandCount = 0;\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                if (grid2[i][j] == 1) {\\n                    bool hasSubIslandFound = bfs(i, j, M, N, grid1, grid2);\\n                    subIslandCount += hasSubIslandFound;\\n                }\\n            }   \\n        }\\n        return subIslandCount;\\n    }\\n    \\n    bool bfs(int i, int j, int &M, int &N, vector<vector<int>> &grid1, vector<vector<int>> &grid2) {\\n        queue<vector<int>> todo;\\n        todo.push({ i, j });\\n        grid2[i][j] = 0; // Mark the cell\\n        bool hasSubIslandFound = true;\\n        while (!todo.empty()) {\\n            vector<int> cur = todo.front();\\n            todo.pop();\\n            // Check if grid1 has also same cell?\\n            if (grid1[cur[0]][cur[1]] != 1) {\\n                hasSubIslandFound = false; // Not found, but keep BFS anyways\\n            }\\n            for (vector<int> &dir : directions) {\\n                int nx = dir[0] + cur[0];\\n                int ny = dir[1] + cur[1];\\n                if (inside(nx, ny, M, N) && grid2[nx][ny] == 1) {\\n                    todo.push({ nx, ny });\\n                    grid2[nx][ny] = 0; // Mark the cell\\n                }\\n            }\\n        }\\n        return hasSubIslandFound;\\n    }\\n    \\n    bool inside(int i, int j, int &M, int &N) {\\n        if (i < 0 || i >= M || j < 0 || j >= N) {\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1284241,
                "title": "python-3-disjoint-sets-bfs-o-mn",
                "content": "Build DSU by `grid1` and perform BFS on `grid2`.\\n\\nTime: `O(MN)`\\nSpace: `O(MN)`\\n```\\nimport collections\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        def find(pos: tuple) -> tuple:\\n            if parent[pos] != pos:\\n                parent[pos] = find(parent[pos])\\n            return parent[pos]\\n\\n        def union(x: tuple, y: tuple):\\n            px, py = map(find, (x, y))\\n            if px != py:\\n                if rank[px] > rank[py]: px, py = py, px\\n                parent[px] = py\\n                rank[py] += int(rank[px] == rank[py])\\n\\n        def sink(x: int, y: int) -> bool:\\n            queue = collections.deque([(x, y)])\\n            grid2[x][y] = 0\\n            ans = True\\n            while queue:\\n                i, j = queue.popleft()\\n                for r, c in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\\n                    if 0 <= r < m and 0 <= c < n and grid2[r][c] == 1:\\n                        ans &= find((r, c)) == find((x, y))\\n                        grid2[r][c] = 0\\n                        queue.append((r, c))\\n            return ans\\n\\n        m, n = len(grid1), len(grid1[0])\\n        parent = {(i, j): (i, j) for i in range(m) for j in range(n)}\\n        rank = collections.Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 1:\\n                    if i > 0 and grid1[i-1][j] == 1:\\n                        union((i, j), (i-1, j))\\n                    if j > 0 and grid1[i][j-1] == 1:\\n                        union((i, j), (i, j-1))\\n\\n        return sum(sink(i, j) for i in range(m) for j in range(n)\\n                   if grid1[i][j] == 1 and grid2[i][j] == 1)\\n```",
                "solutionTags": [],
                "code": "```\\nimport collections\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        def find(pos: tuple) -> tuple:\\n            if parent[pos] != pos:\\n                parent[pos] = find(parent[pos])\\n            return parent[pos]\\n\\n        def union(x: tuple, y: tuple):\\n            px, py = map(find, (x, y))\\n            if px != py:\\n                if rank[px] > rank[py]: px, py = py, px\\n                parent[px] = py\\n                rank[py] += int(rank[px] == rank[py])\\n\\n        def sink(x: int, y: int) -> bool:\\n            queue = collections.deque([(x, y)])\\n            grid2[x][y] = 0\\n            ans = True\\n            while queue:\\n                i, j = queue.popleft()\\n                for r, c in (i+1, j), (i-1, j), (i, j+1), (i, j-1):\\n                    if 0 <= r < m and 0 <= c < n and grid2[r][c] == 1:\\n                        ans &= find((r, c)) == find((x, y))\\n                        grid2[r][c] = 0\\n                        queue.append((r, c))\\n            return ans\\n\\n        m, n = len(grid1), len(grid1[0])\\n        parent = {(i, j): (i, j) for i in range(m) for j in range(n)}\\n        rank = collections.Counter()\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 1:\\n                    if i > 0 and grid1[i-1][j] == 1:\\n                        union((i, j), (i-1, j))\\n                    if j > 0 and grid1[i][j-1] == 1:\\n                        union((i, j), (i, j-1))\\n\\n        return sum(sink(i, j) for i in range(m) for j in range(n)\\n                   if grid1[i][j] == 1 and grid2[i][j] == 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856738,
                "title": "c-dfs",
                "content": "# DFS\\n```\\nclass Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid1[0].size(), result = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bool isSubIsland = true;\\n                if (grid2[i][j] == 1) {\\n                    dfs(grid1, grid2, m, n, i, j, isSubIsland);\\n                    if (isSubIsland)\\n                        result++;\\n                }\\n            }\\n        } \\n\\n        return result;\\n    }\\n\\nprivate:\\n    // Mark result true if island in grid2 is a subisland of island in grid1.\\n    // Else mark result false. Don\\'t stop, mark the whole island in grid2 as visited.\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int& m, int& n,\\n        int r, int c, bool& result)\\n    {\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} }; // left, up, right, down\\n\\n        if (grid1[r][c] != 1) result = false;\\n        grid2[r][c] = -1; // mark as visited\\n\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n            if (nr < 0 || nc < 0 || nr == m || nc == n || grid2[nr][nc] != 1)\\n                continue;\\n            dfs(grid1, grid2, m, n, nr, nc, result);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(), n = grid1[0].size(), result = 0;\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                bool isSubIsland = true;\\n                if (grid2[i][j] == 1) {\\n                    dfs(grid1, grid2, m, n, i, j, isSubIsland);\\n                    if (isSubIsland)\\n                        result++;\\n                }\\n            }\\n        } \\n\\n        return result;\\n    }\\n\\nprivate:\\n    // Mark result true if island in grid2 is a subisland of island in grid1.\\n    // Else mark result false. Don\\'t stop, mark the whole island in grid2 as visited.\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int& m, int& n,\\n        int r, int c, bool& result)\\n    {\\n        int DIR[][2] = { {0, -1}, {1, 0}, {0, 1}, {-1, 0} }; // left, up, right, down\\n\\n        if (grid1[r][c] != 1) result = false;\\n        grid2[r][c] = -1; // mark as visited\\n\\n        for (int i = 0; i < 4; i++) {\\n            int nr = r + DIR[i][0], nc = c + DIR[i][1];\\n            if (nr < 0 || nc < 0 || nr == m || nc == n || grid2[nr][nc] != 1)\\n                continue;\\n            dfs(grid1, grid2, m, n, nr, nc, result);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808532,
                "title": "a-c-solution",
                "content": "primarily searching through grid 2 \\n# Code\\n```\\nint search(int** grid1, int** grid2, int row, int col, int rLimit, int cLimit, int* diff) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid2[row][col] == 0) return 0;\\n    if(grid1[row][col] != grid2[row][col]) (*diff)++;\\n    grid2[row][col] = 0;\\n    grid1[row][col] = 0;\\n\\n    search(grid1, grid2, row - 1, col, rLimit, cLimit, diff);\\n    search(grid1, grid2, row + 1, col, rLimit, cLimit, diff);\\n    search(grid1, grid2, row, col - 1, rLimit, cLimit, diff);\\n    search(grid1, grid2, row, col + 1, rLimit, cLimit, diff);\\n\\n    if(*diff != 0) return 0;\\n    else return 1;\\n}\\n\\nint countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\\n    int rLimit = grid1Size - 1;\\n    int cLimit = *grid1ColSize - 1;\\n    int ans = 0;\\n    int diff = 0;\\n\\n    for(int i = 0; i < rLimit + 1; i++) {\\n        for(int j = 0; j < cLimit + 1; j++) {\\n            if(grid2[i][j] == 1) {\\n                if(search(grid1, grid2, i, j, rLimit, cLimit, &diff)) ans++;\\n                diff = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint search(int** grid1, int** grid2, int row, int col, int rLimit, int cLimit, int* diff) {\\n    if(row < 0 || row > rLimit || col < 0 || col > cLimit || grid2[row][col] == 0) return 0;\\n    if(grid1[row][col] != grid2[row][col]) (*diff)++;\\n    grid2[row][col] = 0;\\n    grid1[row][col] = 0;\\n\\n    search(grid1, grid2, row - 1, col, rLimit, cLimit, diff);\\n    search(grid1, grid2, row + 1, col, rLimit, cLimit, diff);\\n    search(grid1, grid2, row, col - 1, rLimit, cLimit, diff);\\n    search(grid1, grid2, row, col + 1, rLimit, cLimit, diff);\\n\\n    if(*diff != 0) return 0;\\n    else return 1;\\n}\\n\\nint countSubIslands(int** grid1, int grid1Size, int* grid1ColSize, int** grid2, int grid2Size, int* grid2ColSize){\\n    int rLimit = grid1Size - 1;\\n    int cLimit = *grid1ColSize - 1;\\n    int ans = 0;\\n    int diff = 0;\\n\\n    for(int i = 0; i < rLimit + 1; i++) {\\n        for(int j = 0; j < cLimit + 1; j++) {\\n            if(grid2[i][j] == 1) {\\n                if(search(grid1, grid2, i, j, rLimit, cLimit, &diff)) ans++;\\n                diff = 0;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484621,
                "title": "java-solution-bfs-approach-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Pair\\n{\\n    int x,y;\\n    public Pair(int x,int y)\\n    {\\n        this.x=x;\\n        this.y=y;\\n    }\\n}\\nclass Solution {\\n    int n,m,n1,m1;\\n    public int bfs2(int[][] grid1, int[][] grid2,int[][] vis_grid2,int r,int c)\\n    {\\n        int val=0;\\n        vis_grid2[r][c]=1;\\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(r,c));\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={-1,0,1,0};\\n\\n        while(!q.isEmpty())\\n        {\\n            int x=q.peek().x;\\n            int y=q.peek().y;\\n            q.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid2[d_row][d_col]==1 && vis_grid2[d_row][d_col]==0)\\n                {\\n                    if(grid1[d_row][d_col]==0)\\n                    {\\n                        val=1;\\n                    }\\n                    vis_grid2[d_row][d_col]=1;\\n                    q.add(new Pair(d_row,d_col));\\n                }\\n            }\\n        }\\n        if(val==1)\\n            return 0;\\n        else\\n            return 1;\\n\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        n=grid2.length;\\n        m=grid2[0].length;\\n        n1=grid1.length;\\n        m1=grid1[0].length;\\n\\n        int[][] vis_grid2=new int[n][m];\\n        int count=0;\\n        Set<Pair> set_grid1=new HashSet<>();\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid2[i][j]==1 && grid1[i][j]==1 && vis_grid2[i][j]==0)\\n                {\\n                    int value=bfs2(grid1,grid2,vis_grid2,i,j);\\n                    if(value==1)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Pair\\n{\\n    int x,y;\\n    public Pair(int x,int y)\\n    {\\n        this.x=x;\\n        this.y=y;\\n    }\\n}\\nclass Solution {\\n    int n,m,n1,m1;\\n    public int bfs2(int[][] grid1, int[][] grid2,int[][] vis_grid2,int r,int c)\\n    {\\n        int val=0;\\n        vis_grid2[r][c]=1;\\n        Queue<Pair> q=new LinkedList<>();\\n        q.add(new Pair(r,c));\\n        int[] del_row={0,1,0,-1};\\n        int[] del_col={-1,0,1,0};\\n\\n        while(!q.isEmpty())\\n        {\\n            int x=q.peek().x;\\n            int y=q.peek().y;\\n            q.remove();\\n            for(int i=0;i<4;i++)\\n            {\\n                int d_row=x+del_row[i];\\n                int d_col=y+del_col[i];\\n                if(d_row>=0 && d_row<n && d_col>=0 && d_col<m && grid2[d_row][d_col]==1 && vis_grid2[d_row][d_col]==0)\\n                {\\n                    if(grid1[d_row][d_col]==0)\\n                    {\\n                        val=1;\\n                    }\\n                    vis_grid2[d_row][d_col]=1;\\n                    q.add(new Pair(d_row,d_col));\\n                }\\n            }\\n        }\\n        if(val==1)\\n            return 0;\\n        else\\n            return 1;\\n\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        n=grid2.length;\\n        m=grid2[0].length;\\n        n1=grid1.length;\\n        m1=grid1[0].length;\\n\\n        int[][] vis_grid2=new int[n][m];\\n        int count=0;\\n        Set<Pair> set_grid1=new HashSet<>();\\n    \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid2[i][j]==1 && grid1[i][j]==1 && vis_grid2[i][j]==0)\\n                {\\n                    int value=bfs2(grid1,grid2,vis_grid2,i,j);\\n                    if(value==1)\\n                        count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3429566,
                "title": "very-easy-simple-dfs-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n=grid2.length;\\n        int m=grid2[0].length;\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        int sub=0;\\n        for(int i=0;i<n;i++){\\n            boolean[] flag={true};\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid2[i][j]==1){\\n                    dfs(i,j,grid1,grid2,flag,delRow,delCol);\\n                    if(flag[0]) sub++;\\n                    flag[0]=true;\\n                }\\n            }\\n        }\\n        return sub;\\n    }\\n\\n    public void dfs(int i,int j,int[][] grid1, int[][] grid2,boolean[] flag,int delRow[],int delCol[]){\\n        \\n        if(grid1[i][j]==0) {\\n            flag[0]=false;\\n            return;\\n        }\\n\\n        grid2[i][j]=0;\\n        int n=grid2.length;\\n        int m=grid2[0].length;\\n\\n        for(int k=0;k<4;k++){\\n            int nrow=i+delRow[k];\\n            int ncol=j+delCol[k];\\n\\n            if(nrow<n && ncol<m && nrow>=0 && ncol>=0 && grid2[nrow][ncol]==1){\\n                dfs(nrow,ncol,grid1,grid2,flag,delRow,delCol);\\n            }\\n  \\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n=grid2.length;\\n        int m=grid2[0].length;\\n\\n        int delRow[]={1,-1,0,0};\\n        int delCol[]={0,0,1,-1};\\n\\n        int sub=0;\\n        for(int i=0;i<n;i++){\\n            boolean[] flag={true};\\n            for(int j=0;j<m;j++){\\n                \\n                if(grid2[i][j]==1){\\n                    dfs(i,j,grid1,grid2,flag,delRow,delCol);\\n                    if(flag[0]) sub++;\\n                    flag[0]=true;\\n                }\\n            }\\n        }\\n        return sub;\\n    }\\n\\n    public void dfs(int i,int j,int[][] grid1, int[][] grid2,boolean[] flag,int delRow[],int delCol[]){\\n        \\n        if(grid1[i][j]==0) {\\n            flag[0]=false;\\n            return;\\n        }\\n\\n        grid2[i][j]=0;\\n        int n=grid2.length;\\n        int m=grid2[0].length;\\n\\n        for(int k=0;k<4;k++){\\n            int nrow=i+delRow[k];\\n            int ncol=j+delCol[k];\\n\\n            if(nrow<n && ncol<m && nrow>=0 && ncol>=0 && grid2[nrow][ncol]==1){\\n                dfs(nrow,ncol,grid1,grid2,flag,delRow,delCol);\\n            }\\n  \\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3338733,
                "title": "php-dfs-100-explanation",
                "content": "# Intuition\\nTo solve this problem, we can iterate over every cell of grid2 and check if it is a part of an island. If it is, then we can check if this island is a sub-island of grid1. We can do this by performing a Depth-First Search (DFS) on grid2 and checking if the corresponding cells in grid1 are also 1s. If all cells of the island in grid2 are also 1s in grid1, then it is a sub-island.\\n# Approach\\nWe start by initializing a variable count to 0. We then iterate over every cell of grid2. If the current cell is 0, we skip it. Otherwise, we perform a DFS on grid2 starting from the current cell. During the DFS, we also check if the corresponding cells in grid1 are also 1s. If they are, we mark them as 0 in grid2 to avoid revisiting them. If all cells of the island in grid2 are also 1s in grid1, then we increment count.\\n\\nFinally, we return count, which represents the number of sub-islands in grid2.\\n\\n# Complexity\\n- Time complexity:\\nO(mn), where m is the number of rows and n is the number of columns in grid2. This is because we visit every cell in grid2 once.\\n\\n- Space complexity:\\nO(mn), where m is the number of rows and n is the number of columns in grid2. This is because we use a recursive DFS function, which can go as deep as the number of cells in grid2.\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $grid1\\n     * @param Integer[][] $grid2\\n     * @return Integer\\n     */\\n    function countSubIslands($grid1, $grid2) {\\n        $m = count($grid2);\\n        $n = count($grid2[0]);\\n        $count = 0;\\n        for ($i = 0; $i < $m; $i++) {\\n            for ($j = 0; $j < $n; $j++) {\\n                if ($grid2[$i][$j] == 0) {\\n                    continue;\\n                }\\n                if ($this->dfs($grid2, $grid1, $i, $j)) {\\n                    $count++;\\n                }\\n            }\\n        }\\n        return $count;\\n    }\\n\\n    function dfs(&$grid2, $grid1, $i, $j) {\\n        $current = $grid2[$i][$j] == $grid1[$i][$j];\\n        $grid2[$i][$j] = 0;\\n        $left = $right = $up = $down = true;\\n\\n        if (isset($grid2[$i][$j+1]) && $grid2[$i][$j+1] == 1) {\\n            $left = $this->dfs($grid2, $grid1, $i, $j+1);\\n        }\\n\\n        if (isset($grid2[$i][$j-1]) && $grid2[$i][$j-1] == 1) {\\n            $right = $this->dfs($grid2, $grid1, $i, $j-1);\\n        }\\n\\n        if (isset($grid2[$i+1][$j]) && $grid2[$i+1][$j] == 1) {\\n            $up = $this->dfs($grid2, $grid1, $i+1, $j);\\n        }\\n\\n        if (isset($grid2[$i-1][$j]) && $grid2[$i-1][$j] == 1) {\\n            $down = $this->dfs($grid2, $grid1, $i-1, $j);\\n        }\\n\\n        return $current && $left && $right && $up && $down;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[][] $grid1\\n     * @param Integer[][] $grid2\\n     * @return Integer\\n     */\\n    function countSubIslands($grid1, $grid2) {\\n        $m = count($grid2);\\n        $n = count($grid2[0]);\\n        $count = 0;\\n        for ($i = 0; $i < $m; $i++) {\\n            for ($j = 0; $j < $n; $j++) {\\n                if ($grid2[$i][$j] == 0) {\\n                    continue;\\n                }\\n                if ($this->dfs($grid2, $grid1, $i, $j)) {\\n                    $count++;\\n                }\\n            }\\n        }\\n        return $count;\\n    }\\n\\n    function dfs(&$grid2, $grid1, $i, $j) {\\n        $current = $grid2[$i][$j] == $grid1[$i][$j];\\n        $grid2[$i][$j] = 0;\\n        $left = $right = $up = $down = true;\\n\\n        if (isset($grid2[$i][$j+1]) && $grid2[$i][$j+1] == 1) {\\n            $left = $this->dfs($grid2, $grid1, $i, $j+1);\\n        }\\n\\n        if (isset($grid2[$i][$j-1]) && $grid2[$i][$j-1] == 1) {\\n            $right = $this->dfs($grid2, $grid1, $i, $j-1);\\n        }\\n\\n        if (isset($grid2[$i+1][$j]) && $grid2[$i+1][$j] == 1) {\\n            $up = $this->dfs($grid2, $grid1, $i+1, $j);\\n        }\\n\\n        if (isset($grid2[$i-1][$j]) && $grid2[$i-1][$j] == 1) {\\n            $down = $this->dfs($grid2, $grid1, $i-1, $j);\\n        }\\n\\n        return $current && $left && $right && $up && $down;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311673,
                "title": "python3-easy-solution",
                "content": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        rows, cols, count = len(grid1), len(grid1[0]), 0\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= rows or j < 0 or j >= cols or grid2[i][j] != 1:\\n                return\\n            \\n            grid2[i][j] = 0\\n            for x, y in [(0,-1), (0,1), (-1,0), (1,0)]:\\n                dfs(i+x, j+y)\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid2[i][j] == 1 and grid1[i][j] == 0:\\n                    dfs(i, j)\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid2[i][j] == 1:\\n                    dfs(i, j)\\n                    count += 1\\n                    \\n        return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Python ML"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        rows, cols, count = len(grid1), len(grid1[0]), 0\\n        \\n        def dfs(i, j):\\n            if i < 0 or i >= rows or j < 0 or j >= cols or grid2[i][j] != 1:\\n                return\\n            \\n            grid2[i][j] = 0\\n            for x, y in [(0,-1), (0,1), (-1,0), (1,0)]:\\n                dfs(i+x, j+y)\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid2[i][j] == 1 and grid1[i][j] == 0:\\n                    dfs(i, j)\\n        \\n        for i in range(rows):\\n            for j in range(cols):\\n                if grid2[i][j] == 1:\\n                    dfs(i, j)\\n                    count += 1\\n                    \\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252101,
                "title": "dfs-python-graph-traversal-similar-to-number-of-islands",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove all non-common islands in grid2.\\nThen count the number of islands in grid2.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n=len(grid1),len(grid1[0])\\n        ans=0\\n        def dfs(i,j):\\n            grid2[i][j]=0\\n            for a,b in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\\n                if a in range(m) and b in range(n) and grid2[a][b]==1:\\n                    dfs(a,b)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    dfs(i,j)\\n                    ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n=len(grid1),len(grid1[0])\\n        ans=0\\n        def dfs(i,j):\\n            grid2[i][j]=0\\n            for a,b in [[i+1,j],[i-1,j],[i,j+1],[i,j-1]]:\\n                if a in range(m) and b in range(n) and grid2[a][b]==1:\\n                    dfs(a,b)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1 and grid1[i][j]==0:\\n                    dfs(i,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j]==1:\\n                    dfs(i,j)\\n                    ans+=1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236768,
                "title": "c-solution-using-bfs-bfs",
                "content": "```\\nbool bfs(int x,int y,vector<vector<int>>& grid2,\\n                         vector<vector<int>>& grid1){\\n        int m = grid2.size();\\n        int n = grid2[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        int dx[]= {-1,0,1,0};\\n        int dy[]= {0,1,0,-1};\\n        bool flag = true;\\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<4;i++){\\n                int nr = r+dx[i];\\n                int nc = c+dy[i];\\n                if(nr>=0 && nc>=0&& nr<m && nc < n && grid2[nr][nc]==1){\\n                    if(grid1[nr][nc]==0)\\n                        flag = false;\\n                    else {\\n                        grid1[nr][nc] = 0;\\n                        grid2[nr][nc] = 0;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return flag;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count = 0;\\n        for(int i = 0;i<grid2.size();i++){\\n            for(int j = 0;j<grid2[i].size();j++){\\n                if(grid2[i][j] && grid1[i][j]){\\n                    count += bfs(i,j,grid2,grid1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```\\nupvote if it helps :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nbool bfs(int x,int y,vector<vector<int>>& grid2,\\n                         vector<vector<int>>& grid1){\\n        int m = grid2.size();\\n        int n = grid2[0].size();\\n        queue<pair<int,int>> q;\\n        q.push({x,y});\\n        int dx[]= {-1,0,1,0};\\n        int dy[]= {0,1,0,-1};\\n        bool flag = true;\\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i = 0;i<4;i++){\\n                int nr = r+dx[i];\\n                int nc = c+dy[i];\\n                if(nr>=0 && nc>=0&& nr<m && nc < n && grid2[nr][nc]==1){\\n                    if(grid1[nr][nc]==0)\\n                        flag = false;\\n                    else {\\n                        grid1[nr][nc] = 0;\\n                        grid2[nr][nc] = 0;\\n                        q.push({nr,nc});\\n                    }\\n                }\\n                \\n            }\\n            \\n        }\\n        return flag;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count = 0;\\n        for(int i = 0;i<grid2.size();i++){\\n            for(int j = 0;j<grid2[i].size();j++){\\n                if(grid2[i][j] && grid1[i][j]){\\n                    count += bfs(i,j,grid2,grid1);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3229721,
                "title": "easy-dfs-solution-using-visited-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(m*n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>a={0,1,-1,0};\\n    vector<int>b={1,0,0,-1};\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,vector<vector<int>>&vis,int x,int y,int &flag){\\n        vis[x][y]=1;\\n        if(grid1[x][y]!=1){\\n            flag=0;\\n        }\\n        for(int i=0;i<4;i++){\\n            int ax=x+a[i];\\n            int ay=y+b[i];\\n            if(ax>=0&&ay>=0&&ax<grid1.size()&&ay<grid1[0].size()&&grid2[ax][ay]==1&&!vis[ax][ay]){\\n                dfs(grid1,grid2,vis,ax,ay,flag);\\n            }\\n        }\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n          int n=grid1.size();\\n          int m=grid1[0].size();\\n          vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n          int ans=0;\\n          for(int i=0;i<n;i++){\\n              for(int j=0;j<m;j++){\\n                 if(!vis[i][j]&&grid2[i][j]==1&&grid1[i][j]==1){\\n                   int flag=1;\\n                   dfs(grid1,grid2,vis,i,j,flag);\\n                   if(flag) ans++;\\n                 }\\n              }\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>a={0,1,-1,0};\\n    vector<int>b={1,0,0,-1};\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,vector<vector<int>>&vis,int x,int y,int &flag){\\n        vis[x][y]=1;\\n        if(grid1[x][y]!=1){\\n            flag=0;\\n        }\\n        for(int i=0;i<4;i++){\\n            int ax=x+a[i];\\n            int ay=y+b[i];\\n            if(ax>=0&&ay>=0&&ax<grid1.size()&&ay<grid1[0].size()&&grid2[ax][ay]==1&&!vis[ax][ay]){\\n                dfs(grid1,grid2,vis,ax,ay,flag);\\n            }\\n        }\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n          int n=grid1.size();\\n          int m=grid1[0].size();\\n          vector<vector<int>>vis(n+1,vector<int>(m+1,0));\\n          int ans=0;\\n          for(int i=0;i<n;i++){\\n              for(int j=0;j<m;j++){\\n                 if(!vis[i][j]&&grid2[i][j]==1&&grid1[i][j]==1){\\n                   int flag=1;\\n                   dfs(grid1,grid2,vis,i,j,flag);\\n                   if(flag) ans++;\\n                 }\\n              }\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137213,
                "title": "c-using-dfs-t-c-o-m-n-s-c-o-1",
                "content": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(M*N)\\n\\t\\tSpace Complexity : O(1)\\n\\t*/\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++){\\n            for(int j=0; j<grid2[i].size(); j++){\\n                if(grid2[i][j] == 1 && grid2[i][j] == grid1[i][j]){\\n                    int flag = 1;\\n                    dfs(grid1, grid2, i, j, flag);\\n                    ans += flag;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int &flag){\\n        if(i>=0 && i<grid2.size() && j>=0 && j<grid2[0].size() && grid2[i][j] == 1){\\n            grid2[i][j] = 2;\\n            \\n            if(grid1[i][j] == 0){\\n                flag = 0;\\n            }\\n            \\n            dfs(grid1, grid2, i+1, j, flag);\\n            dfs(grid1, grid2, i-1, j, flag);\\n            dfs(grid1, grid2, i, j+1, flag);\\n            dfs(grid1, grid2, i, j-1, flag);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n\\t/*\\n\\t\\tTime Complexity : O(M*N)\\n\\t\\tSpace Complexity : O(1)\\n\\t*/\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++){\\n            for(int j=0; j<grid2[i].size(); j++){\\n                if(grid2[i][j] == 1 && grid2[i][j] == grid1[i][j]){\\n                    int flag = 1;\\n                    dfs(grid1, grid2, i, j, flag);\\n                    ans += flag;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int &flag){\\n        if(i>=0 && i<grid2.size() && j>=0 && j<grid2[0].size() && grid2[i][j] == 1){\\n            grid2[i][j] = 2;\\n            \\n            if(grid1[i][j] == 0){\\n                flag = 0;\\n            }\\n            \\n            dfs(grid1, grid2, i+1, j, flag);\\n            dfs(grid1, grid2, i-1, j, flag);\\n            dfs(grid1, grid2, i, j+1, flag);\\n            dfs(grid1, grid2, i, j-1, flag);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136539,
                "title": "easy-c-solution-in-place-matrix-dfs-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Array + Matrix + DFS (Brute Force).\\n2. Using Array + Matrix + DFS - In-place (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N*M), where N is the number of rows and M is the number of columns of matrix(grid).\\n    Space Complexity : O(N*M), Visited matrix space.\\n\\n    Solved Using Array + Matrix + DFS.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int row, int col, \\n    vector<vector<int>>& visited, int dxdy[][4], bool& flag){\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n\\n        if(grid1[row][col] == 0){\\n            flag = false;\\n        }\\n        \\n        visited[row][col] = 1;\\n\\n        for(int i=0; i<4; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && !visited[newrow][newcol] && \\n            grid2[newrow][newcol]){\\n                dfs(grid1, grid2, newrow, newcol, visited, dxdy, flag);\\n            }\\n        } \\n        return flag;  \\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        int dxdy[][4] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n        vector<vector<int>> visited(n, vector<int>(m,0));\\n\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid2[i][j] == 1 && !visited[i][j]){\\n                    bool flag = true;\\n                    if(dfs(grid1, grid2, i, j, visited, dxdy, flag)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), where N is the number of rows and M is the number of columns of matrix(grid).\\n    Space Complexity : O(1), Constant space (In-place).\\n\\n    Solved Using Array + Matrix + DFS.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int row, int col, bool& flag){\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n\\n        if(row<0 || col<0 || row>=n || col>=m || grid2[row][col] == 0){\\n            return true;\\n        }\\n        \\n        if(grid1[row][col] == 0){\\n            flag = false;\\n        }\\n        \\n        grid2[row][col] = 0;\\n\\n        dfs(grid1, grid2, row-1, col, flag);\\n        dfs(grid1, grid2, row, col+1, flag);\\n        dfs(grid1, grid2, row+1, col, flag);\\n        dfs(grid1, grid2, row, col-1, flag);\\n \\n        return flag;  \\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        int dxdy[][4] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid2[i][j] == 1){\\n                    bool flag = true;\\n                    if(dfs(grid1, grid2, i, j, flag)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N*M), where N is the number of rows and M is the number of columns of matrix(grid).\\n    Space Complexity : O(N*M), Visited matrix space.\\n\\n    Solved Using Array + Matrix + DFS.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int row, int col, \\n    vector<vector<int>>& visited, int dxdy[][4], bool& flag){\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n\\n        if(grid1[row][col] == 0){\\n            flag = false;\\n        }\\n        \\n        visited[row][col] = 1;\\n\\n        for(int i=0; i<4; i++){\\n            int newrow = row + dxdy[i][0];\\n            int newcol = col + dxdy[i][1];\\n            if(newrow>=0 && newcol>=0 && newrow<n && newcol<m && !visited[newrow][newcol] && \\n            grid2[newrow][newcol]){\\n                dfs(grid1, grid2, newrow, newcol, visited, dxdy, flag);\\n            }\\n        } \\n        return flag;  \\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        int dxdy[][4] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n        vector<vector<int>> visited(n, vector<int>(m,0));\\n\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid2[i][j] == 1 && !visited[i][j]){\\n                    bool flag = true;\\n                    if(dfs(grid1, grid2, i, j, visited, dxdy, flag)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(N*M), where N is the number of rows and M is the number of columns of matrix(grid).\\n    Space Complexity : O(1), Constant space (In-place).\\n\\n    Solved Using Array + Matrix + DFS.\\n\\n*/\\n\\nclass Solution {\\nprivate: \\n    bool dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int row, int col, bool& flag){\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n\\n        if(row<0 || col<0 || row>=n || col>=m || grid2[row][col] == 0){\\n            return true;\\n        }\\n        \\n        if(grid1[row][col] == 0){\\n            flag = false;\\n        }\\n        \\n        grid2[row][col] = 0;\\n\\n        dfs(grid1, grid2, row-1, col, flag);\\n        dfs(grid1, grid2, row, col+1, flag);\\n        dfs(grid1, grid2, row+1, col, flag);\\n        dfs(grid1, grid2, row, col-1, flag);\\n \\n        return flag;  \\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid1.size();\\n        int m = grid1[0].size();\\n        int dxdy[][4] = {{-1,0}, {0,1}, {1,0}, {0,-1}};\\n\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(grid2[i][j] == 1){\\n                    bool flag = true;\\n                    if(dfs(grid1, grid2, i, j, flag)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2943062,
                "title": "c-easy-to-understand-solution",
                "content": "```\\nclass Solution { \\npublic:\\n    void fxn(vector<vector<int>>&grid1,vector<vector<int>>&grid2,vector<vector<int>>&vis,int row,int col,int &count)\\n    {\\n        vis[row][col]=1;\\n        int n=grid2.size();\\n        int m=grid2[0].size();\\n        if(grid1[row][col]==0)\\n        {\\n            count=0;\\n        }\\n        int delrow[]={-1,0,+1,0};\\n        int delcol[]={0,+1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\nif(nrow<n&&ncol<m&&nrow>=0&&ncol>=0&&grid2[nrow][ncol]==1&&!vis[nrow][ncol])\\n{\\n    fxn(grid1,grid2,vis,nrow,ncol,count);\\n}\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid2[0].size();\\n        int ans=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid2[i][j]==1)\\n                {\\n                    int count=1;\\n                    fxn(grid1,grid2,vis,i,j,count);\\n                    if(count==1)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Graph"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    void fxn(vector<vector<int>>&grid1,vector<vector<int>>&grid2,vector<vector<int>>&vis,int row,int col,int &count)\\n    {\\n        vis[row][col]=1;\\n        int n=grid2.size();\\n        int m=grid2[0].size();\\n        if(grid1[row][col]==0)\\n        {\\n            count=0;\\n        }\\n        int delrow[]={-1,0,+1,0};\\n        int delcol[]={0,+1,0,-1};\\n        for(int i=0;i<4;i++)\\n        {\\n            int nrow=row+delrow[i];\\n            int ncol=col+delcol[i];\\nif(nrow<n&&ncol<m&&nrow>=0&&ncol>=0&&grid2[nrow][ncol]==1&&!vis[nrow][ncol])\\n{\\n    fxn(grid1,grid2,vis,nrow,ncol,count);\\n}\\n        }\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid2[0].size();\\n        int ans=0;\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(!vis[i][j]&&grid2[i][j]==1)\\n                {\\n                    int count=1;\\n                    fxn(grid1,grid2,vis,i,j,count);\\n                    if(count==1)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694898,
                "title": "java-dfs-concise",
                "content": "Process every island in grid2. Calculate whether it\\'s subisland at the same time as sinking it, making it water, so that it no longer impacts subsequent iterations.\\n\\n```\\nclass Solution {\\n    private int[] dirs = {0, 1, 0, -1, 0};\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int ans = 0;\\n        for (int r = 0; r < grid2.length; r++)\\n            for (int c = 0; c < grid2[0].length; c++)\\n                if (grid2[r][c] == 1)\\n                    ans += dfs(grid1, grid2, r, c);\\n        return ans;\\n    }\\n    \\n    private int dfs(int[][] grid1, int[][] grid2, int r, int c) {\\n        grid2[r][c] = 0;\\n        int ans = grid1[r][c] == 1 ? 1 : 0;\\n        for (int i = 0; i < dirs.length - 1; i++) {\\n            int newR = r + dirs[i], newC = c + dirs[i+1];\\n            if (isValid(grid2, newR, newC) && grid2[newR][newC] == 1)\\n                ans &= dfs(grid1, grid2, newR, newC);\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isValid(int[][] grid2, int r, int c) {\\n        return !(r < 0 || r > grid2.length - 1 || c < 0 || c > grid2[0].length - 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int[] dirs = {0, 1, 0, -1, 0};\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int ans = 0;\\n        for (int r = 0; r < grid2.length; r++)\\n            for (int c = 0; c < grid2[0].length; c++)\\n                if (grid2[r][c] == 1)\\n                    ans += dfs(grid1, grid2, r, c);\\n        return ans;\\n    }\\n    \\n    private int dfs(int[][] grid1, int[][] grid2, int r, int c) {\\n        grid2[r][c] = 0;\\n        int ans = grid1[r][c] == 1 ? 1 : 0;\\n        for (int i = 0; i < dirs.length - 1; i++) {\\n            int newR = r + dirs[i], newC = c + dirs[i+1];\\n            if (isValid(grid2, newR, newC) && grid2[newR][newC] == 1)\\n                ans &= dfs(grid1, grid2, newR, newC);\\n        }\\n        return ans;\\n    }\\n    \\n    private boolean isValid(int[][] grid2, int r, int c) {\\n        return !(r < 0 || r > grid2.length - 1 || c < 0 || c > grid2[0].length - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2627431,
                "title": "pythonic-way",
                "content": "\\tclass Solution:\\n\\t\\tdef countSubIslands(self, B: List[List[int]], A: List[List[int]]) -> int:\\n\\t\\t\\tn, m = len(A), len(A[0])\\n\\n\\t\\t\\tdef dfs(i, j):\\n\\t\\t\\t\\tif not (0 <= i < n and 0 <= j < m and A[i][j] == 1): return 1\\n\\t\\t\\t\\tA[i][j] = 0\\n\\t\\t\\t\\tres = B[i][j]\\n\\t\\t\\t\\tfor di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n\\t\\t\\t\\t\\tres &= dfs(i + di, j + dj)\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\treturn sum(dfs(i, j) for i in range(n) for j in range(m) if A[i][j])\\n\\t\\t#why we are returning 1 ?\\n\\t\\t#because when we got an 0 or outside the range we are returning a one but if we see in the res it is storing the B[i][j] which is the value in the grid1 so if we are returing one also then also we will have 1\\n\\t\\t#then why we are returning one what is the purpose?\\n\\t\\t#the purpose is we go to all possible connected land and make them 0(visited) and they will not contribute anything because B[i][j] will be responsible for 0 and 1",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef countSubIslands(self, B: List[List[int]], A: List[List[int]]) -> int:\\n\\t\\t\\tn, m = len(A), len(A[0])\\n\\n\\t\\t\\tdef dfs(i, j):\\n\\t\\t\\t\\tif not (0 <= i < n and 0 <= j < m and A[i][j] == 1): return 1\\n\\t\\t\\t\\tA[i][j] = 0\\n\\t\\t\\t\\tres = B[i][j]\\n\\t\\t\\t\\tfor di, dj in [[0, 1], [1, 0], [-1, 0], [0, -1]]:\\n\\t\\t\\t\\t\\tres &= dfs(i + di, j + dj)\\n\\t\\t\\t\\treturn res\\n\\n\\t\\t\\treturn sum(dfs(i, j) for i in range(n) for j in range(m) if A[i][j])\\n\\t\\t#why we are returning 1 ?\\n\\t\\t#because when we got an 0 or outside the range we are returning a one but if we see in the res it is storing the B[i][j] which is the value in the grid1 so if we are returing one also then also we will have 1\\n\\t\\t#then why we are returning one what is the purpose?\\n\\t\\t#the purpose is we go to all possible connected land and make them 0(visited) and they will not contribute anything because B[i][j] will be responsible for 0 and 1",
                "codeTag": "Java"
            },
            {
                "id": 2606586,
                "title": "simple-c-dfs-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<int>> &g1,vector<vector<int>> &g2,int i,int j,int &m,int &n){\\n        if(i<0||j<0||i>=m||j>=n||g1[i][j]==3||g2[i][j]==3||(g1[i][j]==g2[i][j] && g1[i][j]==0)||g2[i][j]==0)return true;\\n        if(g1[i][j]==0 && g2[i][j]==1)return false;\\n        g1[i][j]= 3;\\n        g2[i][j]= 3;\\n        bool a1 = solve(g1,g2,i-1,j,m,n);\\n        bool a2 = solve(g1,g2,i,j-1,m,n);\\n        bool a3 = solve(g1,g2,i+1,j,m,n);\\n        bool a4 = solve(g1,g2,i,j+1,m,n);\\n        return (a1 && a2 && a3 && a4);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans = 0,i,j,m = grid1.size(), n = grid1[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid2[i][j] == 1 && grid2[i][j]==1){\\n                    ans += solve(grid1,grid2,i,j,m,n);\\n                }\\n            }\\n        }\\n        // for(auto &i: grid1){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;for(auto &i: grid1){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool solve(vector<vector<int>> &g1,vector<vector<int>> &g2,int i,int j,int &m,int &n){\\n        if(i<0||j<0||i>=m||j>=n||g1[i][j]==3||g2[i][j]==3||(g1[i][j]==g2[i][j] && g1[i][j]==0)||g2[i][j]==0)return true;\\n        if(g1[i][j]==0 && g2[i][j]==1)return false;\\n        g1[i][j]= 3;\\n        g2[i][j]= 3;\\n        bool a1 = solve(g1,g2,i-1,j,m,n);\\n        bool a2 = solve(g1,g2,i,j-1,m,n);\\n        bool a3 = solve(g1,g2,i+1,j,m,n);\\n        bool a4 = solve(g1,g2,i,j+1,m,n);\\n        return (a1 && a2 && a3 && a4);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans = 0,i,j,m = grid1.size(), n = grid1[0].size();\\n        for(i = 0; i < m; i++){\\n            for(j = 0; j < n; j++){\\n                if(grid2[i][j] == 1 && grid2[i][j]==1){\\n                    ans += solve(grid1,grid2,i,j,m,n);\\n                }\\n            }\\n        }\\n        // for(auto &i: grid1){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        // cout<<endl;for(auto &i: grid1){\\n        //     for(auto &j: i)cout<<j<<\" \";\\n        //     cout<<endl;\\n        // }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2602824,
                "title": "easiest-and-cleanest-c-code",
                "content": "class Solution {\\npublic:\\n    \\n    map<pair<int,int>,bool>vis;\\n    int k=0;\\n    bool check(vector<vector<int>>&g2,int x,int y){\\n        if(x>=g2.size() or x<0 or y>=g2[0].size() or y<0 or g2[x][y]==0)return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<int>>&g1,vector<vector<int>>&g2,int x,int y){\\n        vis[{x,y}]=true;\\n        if(g1[x][y]!=1)k=1;\\n        if(check(g2,x+1,y) and vis[{x+1,y}]==false)dfs(g1,g2,x+1,y);\\n        if(check(g2,x-1,y) and vis[{x-1,y}]==false)dfs(g1,g2,x-1,y);\\n        if(check(g2,x,y+1) and vis[{x,y+1}]==false)dfs(g1,g2,x,y+1);\\n        if(check(g2,x,y-1) and vis[{x,y-1}]==false)dfs(g1,g2,x,y-1);\\n        \\n    }\\n    \\n    int countSubIslands(vector<vector<int>>&g1, vector<vector<int>>&g2) {\\n        int n=g1.size();\\n        int m=g1[0].size();\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[{i,j}] or g2[i][j]==0)continue;\\n                dfs(g1,g2,i,j);\\n                if(k==0)cnt++;\\n                k=0;\\n            }\\n        }return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    map<pair<int,int>,bool>vis;\\n    int k=0;\\n    bool check(vector<vector<int>>&g2,int x,int y){\\n        if(x>=g2.size() or x<0 or y>=g2[0].size() or y<0 or g2[x][y]==0)return false;\\n        return true;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2535873,
                "title": "c-clean-code-fully-commented",
                "content": "```\\nvoid dfs(vector<vector<int>>& g1, vector<vector<int>>& g2,int i,int j,int n,int m,int &f)\\n    {\\n        //if put of bounds or we have a 0 cell then return\\n        if(i<0||j<0||i>=n||j>=m||g2[i][j]==0)\\n            return;\\n        //if we have a 0 in g1 at (i,j) cell then that means we do not have a matching island hence change flag f to 0 and return\\n        if(g1[i][j]==0)\\n        {\\n            f=0;\\n            return;\\n        }\\n        //if not the above conditions then mark the current g2 cell visited by making it 0 and make the adjacent cells visited by making recursive calls on all 4 directions\\n        g2[i][j]=0;\\n        dfs(g1,g2,i+1,j,n,m,f);\\n        dfs(g1,g2,i-1,j,n,m,f);\\n        dfs(g1,g2,i,j+1,n,m,f);\\n        dfs(g1,g2,i,j-1,n,m,f);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& g1, vector<vector<int>>& g2) {\\n        int n=g1.size(),m=g1[0].size(),ans=0;\\n        //apply dfs of marking island on every cell having 1 in g2\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //if we have a 1 cell\\n                if(g2[i][j]==1)\\n                {\\n                    //initially we consider that we have a matching island in g1 by keeping f=1\\n                    int f=1;\\n                    //we will change f if we do not find a match in g1\\n                    dfs(g1,g2,i,j,n,m,f);\\n                    //add the altered f\\n                    ans+=f;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nvoid dfs(vector<vector<int>>& g1, vector<vector<int>>& g2,int i,int j,int n,int m,int &f)\\n    {\\n        //if put of bounds or we have a 0 cell then return\\n        if(i<0||j<0||i>=n||j>=m||g2[i][j]==0)\\n            return;\\n        //if we have a 0 in g1 at (i,j) cell then that means we do not have a matching island hence change flag f to 0 and return\\n        if(g1[i][j]==0)\\n        {\\n            f=0;\\n            return;\\n        }\\n        //if not the above conditions then mark the current g2 cell visited by making it 0 and make the adjacent cells visited by making recursive calls on all 4 directions\\n        g2[i][j]=0;\\n        dfs(g1,g2,i+1,j,n,m,f);\\n        dfs(g1,g2,i-1,j,n,m,f);\\n        dfs(g1,g2,i,j+1,n,m,f);\\n        dfs(g1,g2,i,j-1,n,m,f);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& g1, vector<vector<int>>& g2) {\\n        int n=g1.size(),m=g1[0].size(),ans=0;\\n        //apply dfs of marking island on every cell having 1 in g2\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                //if we have a 1 cell\\n                if(g2[i][j]==1)\\n                {\\n                    //initially we consider that we have a matching island in g1 by keeping f=1\\n                    int f=1;\\n                    //we will change f if we do not find a match in g1\\n                    dfs(g1,g2,i,j,n,m,f);\\n                    //add the altered f\\n                    ans+=f;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2518012,
                "title": "count-sub-islands-java-detailed-solution",
                "content": "```\\nclass Solution {\\n     public void DFS(int[][]grid, int r, int c, int m, int n){\\n        \\n        if(r<0 || c<0 ||  r>=m || c>=n ||  grid[r][c]!=1 )return;\\n       \\n        grid[r][c]=2;\\n        DFS(grid,r+1,c,m,n);\\n         DFS(grid,r,c+1,m,n);\\n        DFS(grid,r-1,c,m,n);\\n       \\n        DFS(grid,r,c-1,m,n);\\n      \\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n\\t\\n\\t/*\\n\\tTo be a sub island, grid2,grid1 both should be land, if it happen like grid2  is land and grid1 is water\\n\\tthen there can\\'t be a sub islands.\\n\\n\\t\\n\\t*/\\n\\t// this loop i am iterating to mark all those grid of grid2, which is not going to be a part of subisland..\\n\\t\\n        int n = grid2.length, m = grid2[0].length;\\n       for(int i =0;i<n;i++){\\n           for(int j =0;j<m;j++){\\n               if(grid2[i][j]==1 && grid1[i][j]==0){\\n                   DFS(grid2,i,j,n,m);\\n               }\\n           }\\n       }\\n\\t   \\n\\t   //after marking grid, we have to count number of island.... and that will be our answer.\\n\\t   \\n        int count =0;\\n        for(int i =0;i<n;i++){\\n           for(int j =0;j<m;j++){\\n               if(grid2[i][j]==1 ){\\n                   count++;\\n                   DFS(grid2,i,j,n,m);\\n               }\\n           }\\n       }\\n        return count;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public void DFS(int[][]grid, int r, int c, int m, int n){\\n        \\n        if(r<0 || c<0 ||  r>=m || c>=n ||  grid[r][c]!=1 )return;\\n       \\n        grid[r][c]=2;\\n        DFS(grid,r+1,c,m,n);\\n         DFS(grid,r,c+1,m,n);\\n        DFS(grid,r-1,c,m,n);\\n       \\n        DFS(grid,r,c-1,m,n);\\n      \\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n\\t\\n\\t/*\\n\\tTo be a sub island, grid2,grid1 both should be land, if it happen like grid2  is land and grid1 is water\\n\\tthen there can\\'t be a sub islands.\\n\\n\\t\\n\\t*/\\n\\t// this loop i am iterating to mark all those grid of grid2, which is not going to be a part of subisland..\\n\\t\\n        int n = grid2.length, m = grid2[0].length;\\n       for(int i =0;i<n;i++){\\n           for(int j =0;j<m;j++){\\n               if(grid2[i][j]==1 && grid1[i][j]==0){\\n                   DFS(grid2,i,j,n,m);\\n               }\\n           }\\n       }\\n\\t   \\n\\t   //after marking grid, we have to count number of island.... and that will be our answer.\\n\\t   \\n        int count =0;\\n        for(int i =0;i<n;i++){\\n           for(int j =0;j<m;j++){\\n               if(grid2[i][j]==1 ){\\n                   count++;\\n                   DFS(grid2,i,j,n,m);\\n               }\\n           }\\n       }\\n        return count;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2514498,
                "title": "straight-forward-solution",
                "content": "```\\n     public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int rowLength = grid2.length;\\n        int colLength = grid2[0].length;\\n        // handle non-overlapped islands\\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (grid1[row][col] == 0 && grid2[row][col] == 1) {\\n                    dfs(grid2, row, col);\\n                }\\n            }\\n        }\\n\\n        // calculate the overlapped islands\\n        int res = 0;\\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (grid2[row][col] == 1) {\\n                    res++;\\n                    dfs(grid2, row, col);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        int rowLength = grid.length;\\n        int colLength = grid[0].length;\\n\\n        if (row < 0 || col < 0 || row >= rowLength || col >= colLength) {\\n            return;\\n        }\\n\\n        if (grid[row][col] == 0) {\\n            return;\\n        }\\n\\n        grid[row][col] = 0;\\n\\n        dfs(grid, row - 1, col);\\n        dfs(grid, row + 1, col);\\n        dfs(grid, row, col - 1);\\n        dfs(grid, row, col + 1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n     public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int rowLength = grid2.length;\\n        int colLength = grid2[0].length;\\n        // handle non-overlapped islands\\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (grid1[row][col] == 0 && grid2[row][col] == 1) {\\n                    dfs(grid2, row, col);\\n                }\\n            }\\n        }\\n\\n        // calculate the overlapped islands\\n        int res = 0;\\n        for (int row = 0; row < rowLength; row++) {\\n            for (int col = 0; col < colLength; col++) {\\n                if (grid2[row][col] == 1) {\\n                    res++;\\n                    dfs(grid2, row, col);\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    private void dfs(int[][] grid, int row, int col) {\\n        int rowLength = grid.length;\\n        int colLength = grid[0].length;\\n\\n        if (row < 0 || col < 0 || row >= rowLength || col >= colLength) {\\n            return;\\n        }\\n\\n        if (grid[row][col] == 0) {\\n            return;\\n        }\\n\\n        grid[row][col] = 0;\\n\\n        dfs(grid, row - 1, col);\\n        dfs(grid, row + 1, col);\\n        dfs(grid, row, col - 1);\\n        dfs(grid, row, col + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2501981,
                "title": "c-very-simple-approach-dfs-number-of-island-with-small-change",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& sub, vector<vector<int>>& super,int i,int j,int m,int n)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || sub[i][j]==0)\\n            return true;\\n        bool ans=super[i][j]==sub[i][j];\\n        sub[i][j]=0;\\n        ans = dfs(sub, super, i+1, j, m, n) && ans;\\n        ans = dfs(sub, super, i, j+1, m, n) && ans;\\n        ans = dfs(sub, super, i-1, j, m, n) && ans;\\n        ans = dfs(sub, super, i, j-1, m, n) && ans;\\n        return ans;\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        int count =0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid2[i][j]==1)\\n                {\\n                    if(dfs(grid2, grid1, i, j, m, n)){\\n                        count++;\\n                    };\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>& sub, vector<vector<int>>& super,int i,int j,int m,int n)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || sub[i][j]==0)\\n            return true;\\n        bool ans=super[i][j]==sub[i][j];\\n        sub[i][j]=0;\\n        ans = dfs(sub, super, i+1, j, m, n) && ans;\\n        ans = dfs(sub, super, i, j+1, m, n) && ans;\\n        ans = dfs(sub, super, i-1, j, m, n) && ans;\\n        ans = dfs(sub, super, i, j-1, m, n) && ans;\\n        return ans;\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        int count =0;\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid2[i][j]==1)\\n                {\\n                    if(dfs(grid2, grid1, i, j, m, n)){\\n                        count++;\\n                    };\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501331,
                "title": "c-start-with-the-second-grid-and-check-if-sub-islands-are-there-in-the-first-or-not",
                "content": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\nprivate:   \\n    bool flag;\\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,-1,1};\\n    void dfs(vvi &g1, vvi &g2, int i, int j, int &n, int &m)\\n    {\\n        if(i<0 || j<0 || i>n-1 || j>m-1 || g2[i][j]==0) return;\\n        flag &= (g2[i][j] == g1[i][j]);\\n        g2[i][j] = 0;\\n        for(int a=0; a<4; a++) dfs(g1,g2,i+dx[a],j+dy[a],n,m);\\n    }\\n    \\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size(), m = grid2[0].size(), cnt = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid2[i][j]==1)\\n                {\\n                    flag = true;\\n                    dfs(grid1,grid2,i,j,n,m);\\n                    if(flag) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\nprivate:   \\n    bool flag;\\n    int dx[4] = {-1,1,0,0};\\n    int dy[4] = {0,0,-1,1};\\n    void dfs(vvi &g1, vvi &g2, int i, int j, int &n, int &m)\\n    {\\n        if(i<0 || j<0 || i>n-1 || j>m-1 || g2[i][j]==0) return;\\n        flag &= (g2[i][j] == g1[i][j]);\\n        g2[i][j] = 0;\\n        for(int a=0; a<4; a++) dfs(g1,g2,i+dx[a],j+dy[a],n,m);\\n    }\\n    \\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size(), m = grid2[0].size(), cnt = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid2[i][j]==1)\\n                {\\n                    flag = true;\\n                    dfs(grid1,grid2,i,j,n,m);\\n                    if(flag) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500539,
                "title": "java-bfs-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public class pair{\\n        int row;\\n        int col;\\n        \\n        pair(int row,int col){\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int [][] dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        int n = grid1.length,m = grid1[0].length;\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                \\n                if(grid2[i][j] == 0)\\n                    continue;\\n                \\n                LinkedList<pair> que = new LinkedList<>();\\n                que.addLast(new pair(i,j));\\n                boolean flag = true;\\n                while(que.size() != 0){\\n                    pair rm = que.removeFirst();\\n                    \\n                    int row = rm.row;\\n                    int col = rm.col;\\n                    \\n                    if(grid1[row][col] == 0)\\n                        flag = false;\\n                    \\n                    for(int[] d : dir){\\n                        int r = row + d[0];\\n                        int c = col + d[1];\\n                        \\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid2[r][c] == 1){\\n                            grid2[r][c] = 0;\\n                            que.addLast(new pair(r,c));\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public class pair{\\n        int row;\\n        int col;\\n        \\n        pair(int row,int col){\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int [][] dir = {{0,1},{1,0},{-1,0},{0,-1}};\\n        \\n        int n = grid1.length,m = grid1[0].length;\\n        int count = 0;\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                \\n                if(grid2[i][j] == 0)\\n                    continue;\\n                \\n                LinkedList<pair> que = new LinkedList<>();\\n                que.addLast(new pair(i,j));\\n                boolean flag = true;\\n                while(que.size() != 0){\\n                    pair rm = que.removeFirst();\\n                    \\n                    int row = rm.row;\\n                    int col = rm.col;\\n                    \\n                    if(grid1[row][col] == 0)\\n                        flag = false;\\n                    \\n                    for(int[] d : dir){\\n                        int r = row + d[0];\\n                        int c = col + d[1];\\n                        \\n                        if(r >= 0 && c >= 0 && r < n && c < m && grid2[r][c] == 1){\\n                            grid2[r][c] = 0;\\n                            que.addLast(new pair(r,c));\\n                        }\\n                    }\\n                }\\n                \\n                if(flag)\\n                    count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499752,
                "title": "python-easy-understanding-100-00",
                "content": "Runtime: 2586 ms, faster than 100.00% of Python3 online submissions for Count Sub Islands.\\nMemory Usage: 83.7 MB, less than 52.34% of Python3 online submissions for Count Sub Islands.\\n\\n```py\\nclass Solution:\\n  def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n    m, n, count = len(grid2), len(grid2[0]), 0\\n    \\n    def getIsland(i: int, j: int, b: int): # b is like bool\\n      grid2[i][j] = 0\\n      \\n      if i+1 < m and grid2[i+1][j]: # down\\n        b = getIsland(i+1, j, b)\\n      if j+1 < n and grid2[i][j+1]: # right\\n        b = getIsland(i, j+1, b)\\n      if i > 0 and grid2[i-1][j]: # up\\n        b = getIsland(i-1, j, b)\\n      if j > 0 and grid2[i][j-1]: # left\\n        b = getIsland(i, j-1, b)\\n      return grid1[i][j] & b\\n\\n    for i in range(m):\\n      for j in range(n):\\n        if grid2[i][j]:\\n          count += getIsland(i, j, 1)\\n    return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\nclass Solution:\\n  def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n    m, n, count = len(grid2), len(grid2[0]), 0\\n    \\n    def getIsland(i: int, j: int, b: int): # b is like bool\\n      grid2[i][j] = 0\\n      \\n      if i+1 < m and grid2[i+1][j]: # down\\n        b = getIsland(i+1, j, b)\\n      if j+1 < n and grid2[i][j+1]: # right\\n        b = getIsland(i, j+1, b)\\n      if i > 0 and grid2[i-1][j]: # up\\n        b = getIsland(i-1, j, b)\\n      if j > 0 and grid2[i][j-1]: # left\\n        b = getIsland(i, j-1, b)\\n      return grid1[i][j] & b\\n\\n    for i in range(m):\\n      for j in range(n):\\n        if grid2[i][j]:\\n          count += getIsland(i, j, 1)\\n    return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499581,
                "title": "1905-count-sub-islands",
                "content": "To solve this problem check out the below problem\\'s solution.\\nhttps://leetcode.com/problems/max-area-of-island/discuss/2498565/695-max-area-of-island\\n\\nIn the below problem just check if the group of 1\\'s in grid2 is a sub group of grid1 or not.\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                   boolean call = dfs(grid1,grid2,i,j,n,m);\\n                    if(call){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean dfs(int[][] b1,int[][] b2,int i,int j,int n,int m){\\n      \\n        if(i<0 || j<0 || i>=n || j>=m || b2[i][j]==0){\\n            return true;\\n        }\\n          if(b2[i][j]==1 && b1[i][j]==0) return false;\\n        b2[i][j]=0;\\n        boolean c1 = dfs(b1,b2,i+1,j,n,m);\\n        boolean c2 = dfs(b1,b2,i-1,j,n,m);\\n        boolean c3 = dfs(b1,b2,i,j+1,n,m);\\n        boolean c4 = dfs(b1,b2,i,j-1,n,m);\\n        return c1 && c2 && c3 && c4;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        int ans = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                   boolean call = dfs(grid1,grid2,i,j,n,m);\\n                    if(call){\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    public boolean dfs(int[][] b1,int[][] b2,int i,int j,int n,int m){\\n      \\n        if(i<0 || j<0 || i>=n || j>=m || b2[i][j]==0){\\n            return true;\\n        }\\n          if(b2[i][j]==1 && b1[i][j]==0) return false;\\n        b2[i][j]=0;\\n        boolean c1 = dfs(b1,b2,i+1,j,n,m);\\n        boolean c2 = dfs(b1,b2,i-1,j,n,m);\\n        boolean c3 = dfs(b1,b2,i,j+1,n,m);\\n        boolean c4 = dfs(b1,b2,i,j-1,n,m);\\n        return c1 && c2 && c3 && c4;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498263,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int j, vector<vector<int>>& p,\\n            vector<vector<int>>& q, bool& obs){\\n        if(i<0 or j<0 or i>=q.size() or j>=q[0].size() or q[i][j]==0){ return; }\\n        if(p[i][j]==0 && q[i][j]==1){\\n            obs=true;\\n        }\\n        q[i][j]=0;\\n        dfs(i+1,j,p,q,obs);\\n        dfs(i-1,j,p,q,obs);\\n        dfs(i,j+1,p,q,obs);\\n        dfs(i,j-1,p,q,obs);\\n    }\\n    int countSubIslands(vector<vector<int>>& p, vector<vector<int>>& q) {\\n        int cnt=0;\\n        for(int i=0; i<q.size(); i++){\\n            for(int j=0; j<q[0].size(); j++){\\n                if(q[i][j]==1 && p[i][j]==1){\\n                    bool obs=false;\\n                    dfs(i,j,p,q,obs);\\n                    if(!obs){ cnt++; }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int j, vector<vector<int>>& p,\\n            vector<vector<int>>& q, bool& obs){\\n        if(i<0 or j<0 or i>=q.size() or j>=q[0].size() or q[i][j]==0){ return; }\\n        if(p[i][j]==0 && q[i][j]==1){\\n            obs=true;\\n        }\\n        q[i][j]=0;\\n        dfs(i+1,j,p,q,obs);\\n        dfs(i-1,j,p,q,obs);\\n        dfs(i,j+1,p,q,obs);\\n        dfs(i,j-1,p,q,obs);\\n    }\\n    int countSubIslands(vector<vector<int>>& p, vector<vector<int>>& q) {\\n        int cnt=0;\\n        for(int i=0; i<q.size(); i++){\\n            for(int j=0; j<q[0].size(); j++){\\n                if(q[i][j]==1 && p[i][j]==1){\\n                    bool obs=false;\\n                    dfs(i,j,p,q,obs);\\n                    if(!obs){ cnt++; }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462931,
                "title": "c-no-of-island-with-one-more-line-of-code-dfs-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n// this question is similar as count no of island except that there is one more condition that we need to count only those island whose all cells are 1 (land) in grid1 //\\n    //  So we will count the number of island in grid2 and just keep a track with a flag or bool variable that there should be no cell in grid2 having 0(water) value//\\n    \\n    int res; // to keep track wheter there is any cell in grid1 having 0\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid2.size()||j>=grid2[0].size()||grid2[i][j]==0)return;\\n        // except this condition everything is same as no of island \\n        if(grid2[i][j]==1&&grid1[i][j]==0)res=1;\\n        \\n        grid2[i][j]=0;\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j-1);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int cnt=0;\\n        for(int i=0;i<grid1.size();i++)\\n        {\\n            for(int j=0;j<grid1[0].size();j++)\\n            {\\n                res=0;\\n                if(grid2[i][j]==1){\\n                   dfs(grid1,grid2,i,j);\\n                if(res==0)cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n// DO UPVOTE IF U LIKE THE SOLUTION",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n// this question is similar as count no of island except that there is one more condition that we need to count only those island whose all cells are 1 (land) in grid1 //\\n    //  So we will count the number of island in grid2 and just keep a track with a flag or bool variable that there should be no cell in grid2 having 0(water) value//\\n    \\n    int res; // to keep track wheter there is any cell in grid1 having 0\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j)\\n    {\\n        if(i<0||j<0||i>=grid2.size()||j>=grid2[0].size()||grid2[i][j]==0)return;\\n        // except this condition everything is same as no of island \\n        if(grid2[i][j]==1&&grid1[i][j]==0)res=1;\\n        \\n        grid2[i][j]=0;\\n        dfs(grid1,grid2,i+1,j);\\n        dfs(grid1,grid2,i,j+1);\\n        dfs(grid1,grid2,i-1,j);\\n        dfs(grid1,grid2,i,j-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2441548,
                "title": "simple-java-solution-dfs",
                "content": "* Treverse in grid2 and check for 1\\n* Satrt dfs from that location\\n* 1 should be present in both grid1 and grid2\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid2[0].length; j++) {\\n                \\n                if (grid1[i][j] == 1 && grid2[i][j] == 1)\\n                {\\n                    if (countIsland(grid1, grid2, i, j)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    private boolean countIsland(int[][] grid1, int[][] grid2, int row, int col) {\\n        \\n        if (row < 0 || col < 0 || row >= grid2.length || col >= grid2[0].length\\n           || grid2[row][col] != 1) return true; // out of boundary and visited will be treated as positive cases\\n        \\n        if (grid2[row][col] == 1 && grid1[row][col] != 1) return false; //false only when both places dont have 1\\n        \\n        grid2[row][col] = -1; //making visited\\n        boolean left = countIsland(grid1, grid2, row -1, col);\\n        boolean right = countIsland(grid1, grid2, row +1, col);\\n        boolean down = countIsland(grid1, grid2, row, col+1);\\n        boolean up = countIsland(grid1, grid2, row, col-1);\\n        \\n        if (left && right && up && down) return true;\\n        \\n        return false;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        \\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid2[0].length; j++) {\\n                \\n                if (grid1[i][j] == 1 && grid2[i][j] == 1)\\n                {\\n                    if (countIsland(grid1, grid2, i, j)){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n    \\n    private boolean countIsland(int[][] grid1, int[][] grid2, int row, int col) {\\n        \\n        if (row < 0 || col < 0 || row >= grid2.length || col >= grid2[0].length\\n           || grid2[row][col] != 1) return true; // out of boundary and visited will be treated as positive cases\\n        \\n        if (grid2[row][col] == 1 && grid1[row][col] != 1) return false; //false only when both places dont have 1\\n        \\n        grid2[row][col] = -1; //making visited\\n        boolean left = countIsland(grid1, grid2, row -1, col);\\n        boolean right = countIsland(grid1, grid2, row +1, col);\\n        boolean down = countIsland(grid1, grid2, row, col+1);\\n        boolean up = countIsland(grid1, grid2, row, col-1);\\n        \\n        if (left && right && up && down) return true;\\n        \\n        return false;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2437931,
                "title": "python-dfs-solution-counting-on-the-fly",
                "content": "Istead of storing every island and checking if its corresponding cell is 1 or not in the grid1, we can mark this in our dfs code only, which reduces the TC to O(mn).\\n```\\n m,n = len(mat1),len(mat1[0])\\n        def valid(i,j):\\n            if i>m-1 or j>n-1 or i<0 or j<0:\\n                return False\\n            if vis[i][j]==1 or mat2[i][j]==0:\\n                return False\\n            return True\\n        \\n        dx = [1,0,0,-1]\\n        dy = [0,1,-1,0]\\n        vis = [[0 for j in range(n)]for i in range(m)]\\n        \\n        def dfs(i,j,ans):\\n            vis[i][j] = 1\\n            if mat1[i][j]==0:\\n\\t\\t\\t    #this island will not be considered in counting\\n                ans[0] = False\\n            \\n            for d in range(4):\\n                a,b = i+dx[d],j+dy[d]\\n                if valid(a,b):\\n                    dfs(a,b,ans)\\n\\n        cnt = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if vis[i][j]==0 and mat2[i][j]==1:\\n                    #cc = []\\n                    ans = [True]\\n                    dfs(i,j,ans)\\n                    \\n                    if ans[0]:\\n                        cnt+=1\\n        return cnt\\n        \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n m,n = len(mat1),len(mat1[0])\\n        def valid(i,j):\\n            if i>m-1 or j>n-1 or i<0 or j<0:\\n                return False\\n            if vis[i][j]==1 or mat2[i][j]==0:\\n                return False\\n            return True\\n        \\n        dx = [1,0,0,-1]\\n        dy = [0,1,-1,0]\\n        vis = [[0 for j in range(n)]for i in range(m)]\\n        \\n        def dfs(i,j,ans):\\n            vis[i][j] = 1\\n            if mat1[i][j]==0:\\n\\t\\t\\t    #this island will not be considered in counting\\n                ans[0] = False\\n            \\n            for d in range(4):\\n                a,b = i+dx[d],j+dy[d]\\n                if valid(a,b):\\n                    dfs(a,b,ans)\\n\\n        cnt = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if vis[i][j]==0 and mat2[i][j]==1:\\n                    #cc = []\\n                    ans = [True]\\n                    dfs(i,j,ans)\\n                    \\n                    if ans[0]:\\n                        cnt+=1\\n        return cnt\\n        \\n        \\n            \\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2433698,
                "title": "with-without-visited-array-brute-to-optimal-c",
                "content": "I have *explained everything with comments*, but if you still have some doubts, Please ask\\nif it Helped, Please **UpVote** \\uD83D\\uDD3C :)\\n\\n1. **with** Visited Array\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int rows, int cols, vector<vector<bool>> &visited, bool &flag) {\\n        // checking bounds\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0)\\n            return ;\\n        \\n        // if any cell of this region/island is outside of first grid\\n        if(visited[i][j] == false) { // visited[i][j] == false means the area does not lie in first grid\\n            flag = false;\\n            return ;\\n        }\\n        \\n        grid[i][j] = 0; // marking visited\\n        \\n        // checking for neighbour cells\\n        dfs(grid, i + 1, j, rows, cols, visited, flag);\\n        dfs(grid, i - 1, j, rows, cols, visited, flag);\\n        dfs(grid, i, j + 1, rows, cols, visited, flag);\\n        dfs(grid, i, j - 1, rows, cols, visited, flag);\\n    }\\n\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        \\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // filling visited from grid1\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid1[i][j] == 1) {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        // for grid2\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid2[i][j] == 1) {\\n                    bool flag = true;\\n                    \\n                    dfs(grid2, i, j, rows, cols, visited, flag);\\n                    \\n                    if(flag) // means after dfs check, it\\'s region is inside grid1\\'s\\n                        ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n2. **without** Visited Array\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int rows, int cols, bool &flag) {\\n        // checking bounds\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid2[i][j] == 0)\\n            return ;\\n        \\n        if(grid1[i][j] == 0 && grid2[i][j] == 1) { // means the grid2\\'s area does not lie in grid1\\'s\\n            flag = false;\\n            return ;\\n        }\\n\\n        grid2[i][j] = 0; // marking visited\\n        \\n        // checking for neighbour cells\\n        dfs(grid1, grid2, i + 1, j, rows, cols, flag);\\n        dfs(grid1, grid2, i - 1, j, rows, cols, flag);\\n        dfs(grid1, grid2, i, j + 1, rows, cols, flag);\\n        dfs(grid1, grid2, i, j - 1, rows, cols, flag);\\n    }\\n\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        \\n        int count = 0;\\n\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid2[i][j] == 1) {\\n                    bool flag = true;\\n                    \\n                    dfs(grid1, grid2, i, j, rows, cols, flag);\\n                    \\n                    if(flag) // means after dfs check, grid2\\'s region is inside grid1\\'s\\n                        ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid, int i, int j, int rows, int cols, vector<vector<bool>> &visited, bool &flag) {\\n        // checking bounds\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid[i][j] == 0)\\n            return ;\\n        \\n        // if any cell of this region/island is outside of first grid\\n        if(visited[i][j] == false) { // visited[i][j] == false means the area does not lie in first grid\\n            flag = false;\\n            return ;\\n        }\\n        \\n        grid[i][j] = 0; // marking visited\\n        \\n        // checking for neighbour cells\\n        dfs(grid, i + 1, j, rows, cols, visited, flag);\\n        dfs(grid, i - 1, j, rows, cols, visited, flag);\\n        dfs(grid, i, j + 1, rows, cols, visited, flag);\\n        dfs(grid, i, j - 1, rows, cols, visited, flag);\\n    }\\n\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        \\n        vector<vector<bool>> visited(rows, vector<bool>(cols, false));\\n        \\n        // filling visited from grid1\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid1[i][j] == 1) {\\n                    visited[i][j] = true;\\n                }\\n            }\\n        }\\n        \\n        int count = 0;\\n        \\n        // for grid2\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid2[i][j] == 1) {\\n                    bool flag = true;\\n                    \\n                    dfs(grid2, i, j, rows, cols, visited, flag);\\n                    \\n                    if(flag) // means after dfs check, it\\'s region is inside grid1\\'s\\n                        ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int rows, int cols, bool &flag) {\\n        // checking bounds\\n        if(i < 0 || i >= rows || j < 0 || j >= cols || grid2[i][j] == 0)\\n            return ;\\n        \\n        if(grid1[i][j] == 0 && grid2[i][j] == 1) { // means the grid2\\'s area does not lie in grid1\\'s\\n            flag = false;\\n            return ;\\n        }\\n\\n        grid2[i][j] = 0; // marking visited\\n        \\n        // checking for neighbour cells\\n        dfs(grid1, grid2, i + 1, j, rows, cols, flag);\\n        dfs(grid1, grid2, i - 1, j, rows, cols, flag);\\n        dfs(grid1, grid2, i, j + 1, rows, cols, flag);\\n        dfs(grid1, grid2, i, j - 1, rows, cols, flag);\\n    }\\n\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        \\n        int count = 0;\\n\\n        for(int i = 0; i < rows; ++i) {\\n            for(int j = 0; j < cols; ++j) {\\n                if(grid2[i][j] == 1) {\\n                    bool flag = true;\\n                    \\n                    dfs(grid1, grid2, i, j, rows, cols, flag);\\n                    \\n                    if(flag) // means after dfs check, grid2\\'s region is inside grid1\\'s\\n                        ++count;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432640,
                "title": "c-fast-solution-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,vector<vector<bool>>&vis,int i,int j,int n,int m,bool & bol){\\n\\t\\t\\tif(i<0 || i>=n || j<0 || j>=m)\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\tif(grid2[i][j]==0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(vis[i][j])\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tvis[i][j]=true;\\n\\n\\t\\t\\tif(grid1[i][j]==0)\\n\\t\\t\\t\\tbol= false;\\n\\t\\t\\tdfs(grid1,grid2,vis,i+1,j,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i-1,j,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i,j+1,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i,j-1,n,m,bol);\\n\\n\\t\\t}\\n\\t\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n\\t\\t\\tconst int n=grid1.size(),m=grid1[0].size();\\n\\t\\t\\tvector<vector<bool>>vis(n,vector<bool>(m,false));\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tbool bol=true;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tfor(int j=0;j<m;j++){\\n\\t\\t\\t\\t\\tif(grid2[i][j]==1 && vis[i][j]==false){\\n\\t\\t\\t\\t\\t\\tdfs(grid1,grid2,vis,i,j,n,m,bol);\\n\\t\\t\\t\\t\\t\\tif(bol)\\n\\t\\t\\t\\t\\t\\t\\tans+=1;\\n\\t\\t\\t\\t\\t\\tbol=true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,vector<vector<bool>>&vis,int i,int j,int n,int m,bool & bol){\\n\\t\\t\\tif(i<0 || i>=n || j<0 || j>=m)\\n\\t\\t\\t\\treturn ;\\n\\t\\t\\tif(grid2[i][j]==0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tif(vis[i][j])\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tvis[i][j]=true;\\n\\n\\t\\t\\tif(grid1[i][j]==0)\\n\\t\\t\\t\\tbol= false;\\n\\t\\t\\tdfs(grid1,grid2,vis,i+1,j,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i-1,j,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i,j+1,n,m,bol);\\n\\t\\t\\tdfs(grid1,grid2,vis,i,j-1,n,m,bol);\\n\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2431250,
                "title": "c-dfs",
                "content": "```\\npublic class Solution{\\n    public int CountSubIslands(int[][] grid1, int[][] grid2){\\n        int subIslands = 0;\\n        for (int r = 0; r < grid2.Length; r++)\\n            for (int c = 0; c < grid2[r].Length; c++)\\n                if (grid2[r][c] == 1 && SinkSubIsland(grid1, grid2, r, c))\\n                    subIslands++;\\n        return subIslands;\\n    }\\n\\t\\n    private bool SinkSubIsland(int[][] grid1, int[][] grid2, int r, int c){\\n        if (r < 0 || c < 0 || r >= grid2.Length || c >= grid2[r].Length || grid2[r][c] == 0){return true;}\\n\\t\\t\\n        grid2[r][c] = 0;\\n        bool stillASubIsland=true;\\n\\t\\t\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r - 1, c);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r, c + 1);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r + 1, c);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r, c - 1);\\n        return stillASubIsland & grid1[r][c] == 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution{\\n    public int CountSubIslands(int[][] grid1, int[][] grid2){\\n        int subIslands = 0;\\n        for (int r = 0; r < grid2.Length; r++)\\n            for (int c = 0; c < grid2[r].Length; c++)\\n                if (grid2[r][c] == 1 && SinkSubIsland(grid1, grid2, r, c))\\n                    subIslands++;\\n        return subIslands;\\n    }\\n\\t\\n    private bool SinkSubIsland(int[][] grid1, int[][] grid2, int r, int c){\\n        if (r < 0 || c < 0 || r >= grid2.Length || c >= grid2[r].Length || grid2[r][c] == 0){return true;}\\n\\t\\t\\n        grid2[r][c] = 0;\\n        bool stillASubIsland=true;\\n\\t\\t\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r - 1, c);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r, c + 1);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r + 1, c);\\n        stillASubIsland &= SinkSubIsland(grid1, grid2, r, c - 1);\\n        return stillASubIsland & grid1[r][c] == 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410622,
                "title": "c-dfs-clean-code",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid1, vector<vector<int>> &grid2, vector<vector<int>> &vis, int i, int j, bool &isIceland){\\n        \\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        \\n        if(i<0 or i>=n or j<0 or j>=m) return;\\n        \\n        if(grid2[i][j] == 0 or vis[i][j] == 1) return;\\n        \\n        if(grid1[i][j] == 0){\\n            isIceland = false;\\n        }\\n        vis[i][j] = 1;\\n        \\n        int x[4] = {-1, 0, 1, 0};\\n        int y[4] = {0, -1, 0, 1};\\n        \\n        for(int k=0; k<4; k++){\\n            dfs(grid1, grid2, vis, i+x[k], j+y[k], isIceland);\\n        }\\n        \\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int n = grid2.size();\\n        int  m = grid2[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        int ans = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            \\n            for(int j=0; j<m; j++){\\n                \\n                if(vis[i][j] == 1 or grid2[i][j] == 0) continue;\\n                bool isIceland = true;\\n                \\n                dfs(grid1, grid2, vis, i, j, isIceland);\\n                \\n                if(isIceland) ans++;\\n            }\\n            \\n        }\\n        \\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid1, vector<vector<int>> &grid2, vector<vector<int>> &vis, int i, int j, bool &isIceland){\\n        \\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        \\n        if(i<0 or i>=n or j<0 or j>=m) return;\\n        \\n        if(grid2[i][j] == 0 or vis[i][j] == 1) return;\\n        \\n        if(grid1[i][j] == 0){\\n            isIceland = false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2393252,
                "title": "dfs-java-easy-and-simple-code",
                "content": "\\n\\n```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(!visited[i][j] && grid1[i][j] == 1 && grid2[i][j] == 1 && traverseIsland(grid1,grid2,i,j,visited)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    boolean traverseIsland(int[][] grid1, int[][] grid2, int row, int col, boolean[][] visited) {\\n        if(row<0 || col<0 || row>=grid1.length || col>= grid1[0].length || visited[row][col] || grid2[row][col]!=1) return true;\\n        if(grid1[row][col]!=1)\\n            return false;\\n        visited[row][col] = true;\\n        boolean ans = true;\\n        ans = ans & traverseIsland(grid1,grid2,row-1,col,visited);\\n        ans = ans & traverseIsland(grid1,grid2,row+1,col,visited);\\n\\t\\tans = ans & traverseIsland(grid1,grid2,row,col-1,visited);\\n        ans = ans & traverseIsland(grid1,grid2,row,col+1,visited);\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nCreate method traverseIsland that will return true if that island is a subIsland of grid1 or else false.\\nAlgorithm\\n1. If we get out of index or cell is already visited and its not possible to go further return true, this will terminate the function. \\n2.  Lets say this element which we are on is not a part of any island in grid1 we return false as per our method definition.\\n3.  We traverse in all four directions and we see if we can traverse there or not, if the next cell is part of island in grid2 and is not part of island in grid1 false will be returned giving the conclusion that this island is not the right island and should not be included in our ans.",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        boolean[][] visited = new boolean[n][m];\\n        int ans = 0;\\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(!visited[i][j] && grid1[i][j] == 1 && grid2[i][j] == 1 && traverseIsland(grid1,grid2,i,j,visited)) {\\n                    ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    \\n    boolean traverseIsland(int[][] grid1, int[][] grid2, int row, int col, boolean[][] visited) {\\n        if(row<0 || col<0 || row>=grid1.length || col>= grid1[0].length || visited[row][col] || grid2[row][col]!=1) return true;\\n        if(grid1[row][col]!=1)\\n            return false;\\n        visited[row][col] = true;\\n        boolean ans = true;\\n        ans = ans & traverseIsland(grid1,grid2,row-1,col,visited);\\n        ans = ans & traverseIsland(grid1,grid2,row+1,col,visited);\\n\\t\\tans = ans & traverseIsland(grid1,grid2,row,col-1,visited);\\n        ans = ans & traverseIsland(grid1,grid2,row,col+1,visited);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2372770,
                "title": "c-dfs-easy-solution",
                "content": "Just do dfs in grid 2 while maintaining a check variable that checks whether there exist a 1 in grid2 that is not present in grid 1 if yes than don\\'t count that island\\n\\n```\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int M,int N,int i,int j,int &check)\\n    {\\n        if(grid2[i][j]==1 && grid1[i][j]==0)\\n            check=0;\\n        grid2[i][j]=0;\\n        if(i+1<M && grid2[i+1][j]==1)\\n                  dfs(grid1,grid2,M,N,i+1,j,check);\\n        if(j+1<N && grid2[i][j+1]==1)\\n                  dfs(grid1,grid2,M,N,i,j+1,check);\\n        if(i-1>=0 && grid2[i-1][j]==1)\\n                  dfs(grid1,grid2,M,N,i-1,j,check);\\n        if(j-1>=0 && grid2[i][j-1]==1)\\n                  dfs(grid1,grid2,M,N,i,j-1,check);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m=grid1.size();\\n        int n=grid1[0].size();\\n        int check=1;\\n        int count=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                check=1;\\n                if(grid2[i][j]==1)\\n                { \\n                  dfs(grid1,grid2,m,n,i,j,check);\\n                  if(check==1)\\n                      count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int M,int N,int i,int j,int &check)\\n    {\\n        if(grid2[i][j]==1 && grid1[i][j]==0)\\n            check=0;\\n        grid2[i][j]=0;\\n        if(i+1<M && grid2[i+1][j]==1)\\n                  dfs(grid1,grid2,M,N,i+1,j,check);\\n        if(j+1<N && grid2[i][j+1]==1)\\n                  dfs(grid1,grid2,M,N,i,j+1,check);\\n        if(i-1>=0 && grid2[i-1][j]==1)\\n                  dfs(grid1,grid2,M,N,i-1,j,check);\\n        if(j-1>=0 && grid2[i][j-1]==1)\\n                  dfs(grid1,grid2,M,N,i,j-1,check);\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m=grid1.size();\\n        int n=grid1[0].size();\\n        int check=1;\\n        int count=0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                check=1;\\n                if(grid2[i][j]==1)\\n                { \\n                  dfs(grid1,grid2,m,n,i,j,check);\\n                  if(check==1)\\n                      count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352554,
                "title": "c-dfs-without-extra-space-clean-code",
                "content": "To solve this problem, we\\'ll start a DFS on every 1 i.e. land cell of grid2. This DFS will iterate over an island of grid2 and checks if all the cells found in the current island are preset in grid1. We do this iteratively for all islands of grid2. We don\\'t need to keep visited grid for performing DFS as we\\'ll mark the land cell to 0 (water cell) when we visit it and make sure that it will be visited only once. (DFS does that ;) ). \\n\\n**Time Complexity O(M * N)\\nAuxillary Space O(1)**\\n```\\nclass Solution {\\n    bool isSubIsland;\\n    vector<vector<int>> directions;\\npublic:\\n    void init(){\\n        isSubIsland = true; // flag to detect if an island is sub island or not\\n        directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}}; // define directions to move 4-directionally (up, down, right left)\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans=0;\\n        init();\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++)\\n                if(grid2[i][j]){ // apply DFS from starting cell of each island in grid2\\n                  dfs(grid1, grid2, i, j);\\n                  if(isSubIsland)\\n                      ans++; // add 1 to ans each time when a sub island found\\n                  else\\n                      isSubIsland = true; // reset the flag to true \\n                }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y){\\n        int m = grid2.size(), n = grid2[0].size();\\n\\t\\tif(x < 0 || y < 0 || x >= m || y >= n || grid2[x][y] == 0) // check bounds of the grid\\n            return;\\n\\t\\tif(!grid1[x][y])\\n            isSubIsland = false; // set the flag to false even if a single cell is \\'0\\' in grid 1 (as we want every cell of an island in grid1 to be present in grid1)     \\n        grid2[x][y] = 0; // mark the as cell visited (this will not impact as we\\'ll not be visiting the same cell again and we have added this case while checking the bounds) \\n        for(auto & dir: directions){\\n            int nx = dir[0] + x;\\n            int ny = dir[1] + y;\\n            dfs(grid1, grid2, nx, ny); // apply DFS 4-directionally \\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool isSubIsland;\\n    vector<vector<int>> directions;\\npublic:\\n    void init(){\\n        isSubIsland = true; // flag to detect if an island is sub island or not\\n        directions = {{0, -1}, {0, 1}, {1, 0}, {-1, 0}}; // define directions to move 4-directionally (up, down, right left)\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int ans=0;\\n        init();\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++)\\n                if(grid2[i][j]){ // apply DFS from starting cell of each island in grid2\\n                  dfs(grid1, grid2, i, j);\\n                  if(isSubIsland)\\n                      ans++; // add 1 to ans each time when a sub island found\\n                  else\\n                      isSubIsland = true; // reset the flag to true \\n                }\\n        return ans;\\n    }\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y){\\n        int m = grid2.size(), n = grid2[0].size();\\n\\t\\tif(x < 0 || y < 0 || x >= m || y >= n || grid2[x][y] == 0) // check bounds of the grid\\n            return;\\n\\t\\tif(!grid1[x][y])\\n            isSubIsland = false; // set the flag to false even if a single cell is \\'0\\' in grid 1 (as we want every cell of an island in grid1 to be present in grid1)     \\n        grid2[x][y] = 0; // mark the as cell visited (this will not impact as we\\'ll not be visiting the same cell again and we have added this case while checking the bounds) \\n        for(auto & dir: directions){\\n            int nx = dir[0] + x;\\n            int ny = dir[1] + y;\\n            dfs(grid1, grid2, nx, ny); // apply DFS 4-directionally \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347807,
                "title": "java-dfs-solution-faster-than-96",
                "content": "```\\nclass Solution {\\n    boolean exists;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < grid2.length; i++) {\\n            for(int j = 0; j < grid2[0].length; j++) {\\n                if(grid2[i][j] == 1) {\\n                    exists = true;\\n                    \\n                    dfs(grid1, grid2, i, j);\\n                    \\n                    if(exists) count++;\\n                }\\n            }\\n        }\\n         \\n        return count;\\n    }\\n\\n    private void dfs(int[][] grid1, int[][] grid2, int row, int col) {\\n        if(row < 0 || row >= grid2.length || col < 0 || col >= grid2[0].length) return;\\n        if(grid2[row][col] == 0) return;\\n\\n        if(grid1[row][col] != grid2[row][col]) exists = false;\\n        grid2[row][col] = 0;\\n\\n        dfs(grid1, grid2, row + 1, col);\\n        dfs(grid1, grid2, row - 1, col);\\n        dfs(grid1, grid2, row, col + 1);\\n        dfs(grid1, grid2, row, col - 1);\\n    }\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "class Solution {\\n    boolean exists;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < grid2.length; i++) {\\n            for(int j = 0; j < grid2[0].length; j++) {\\n                if(grid2[i][j] == 1) {\\n                    exists = true;\\n                    \\n                    dfs(grid1, grid2, i, j);\\n                    \\n                    if(exists) count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2335983,
                "title": "c-dfs-solution",
                "content": "class Solution {\\npublic:\\n    int m,n;\\n    void isSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, bool& isSub) {\\n        if(i < 0 || j < 0 || i >= m || j >= n || grid2[i][j] != 1)\\n            return;\\n        \\n        if(grid1[i][j] != 1)\\n            isSub = false;\\n        grid2[i][j] = 0;\\n        isSubIslands(grid1, grid2, i-1, j, isSub);\\n        isSubIslands(grid1, grid2, i+1, j, isSub);\\n        isSubIslands(grid1, grid2, i, j-1, isSub);\\n        isSubIslands(grid1, grid2, i, j+1, isSub);\\n            \\n        return;\\n        \\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        m = grid2.size();\\n        n = grid2[0].size();\\n        int count = 0;\\n        bool isSub;\\n        \\n        for(int i=0; i < m; i++) {\\n            for(int j=0; j < n; j++) {\\n                if(grid2[i][j] == 1) {\\n                    isSub = true;\\n                    isSubIslands(grid1,grid2, i, j, isSub);\\n                    if(isSub == true) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int m,n;\\n    void isSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, bool& isSub) {\\n        if(i < 0 || j < 0 || i >= m || j >= n || grid2[i][j] != 1)\\n            return;\\n        \\n        if(grid1[i][j] != 1)\\n            isSub = false;\\n        grid2[i][j] = 0;\\n        isSubIslands(grid1, grid2, i-1, j, isSub);\\n        isSubIslands(grid1, grid2, i+1, j, isSub);\\n        isSubIslands(grid1, grid2, i, j-1, isSub);\\n        isSubIslands(grid1, grid2, i, j+1, isSub);\\n            \\n        return;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2303544,
                "title": "dfs-c-simple-implementation",
                "content": "```\\npublic class Solution {\\n    public int CountSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        int m = grid1.Length, n = grid1[0].Length, ans = 0;\\n\\t\\t//Remove Uncommon Islands\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid1[i][j] == 0 && grid2[i][j] == 1)\\n                {\\n                    DFS(grid2, i, j);\\n                }\\n            }\\n        }\\n        //Count Final number of islands.\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    ans++;\\n                    DFS(grid2, i, j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public void DFS(int[][] grid, int i, int j)\\n    {\\n        if(i < 0 || j < 0 || i >= grid.Length || j >= grid[0].Length || grid[i][j] != 1)\\n            return;\\n        grid[i][j] = 0;\\n        DFS(grid, i-1, j);\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        int m = grid1.Length, n = grid1[0].Length, ans = 0;\\n\\t\\t//Remove Uncommon Islands\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid1[i][j] == 0 && grid2[i][j] == 1)\\n                {\\n                    DFS(grid2, i, j);\\n                }\\n            }\\n        }\\n        //Count Final number of islands.\\n        for(int i = 0 ; i < m ; i++)\\n        {\\n            for(int j = 0 ; j < n ; j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    ans++;\\n                    DFS(grid2, i, j);\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n    \\n    public void DFS(int[][] grid, int i, int j)\\n    {\\n        if(i < 0 || j < 0 || i >= grid.Length || j >= grid[0].Length || grid[i][j] != 1)\\n            return;\\n        grid[i][j] = 0;\\n        DFS(grid, i-1, j);\\n        DFS(grid, i+1, j);\\n        DFS(grid, i, j-1);\\n        DFS(grid, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275048,
                "title": "python3-simple-solution-do-dfs-twice",
                "content": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n,result = len(grid1), len(grid1[0]), 0\\n        \\n        def dfs(i,j):\\n            if i < 0 or i>= m or j < 0 or j >= n or grid2[i][j]!=1:\\n                return\\n            \\n            grid2[i][j] = 0\\n            for x,y in [(0,-1), (0,1), (-1,0), (1,0)]:\\n                dfs(i+x, j+y)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1 and grid1[i][j] == 0:\\n                    dfs(i,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    dfs(i,j)\\n                    result+=1\\n                    \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m,n,result = len(grid1), len(grid1[0]), 0\\n        \\n        def dfs(i,j):\\n            if i < 0 or i>= m or j < 0 or j >= n or grid2[i][j]!=1:\\n                return\\n            \\n            grid2[i][j] = 0\\n            for x,y in [(0,-1), (0,1), (-1,0), (1,0)]:\\n                dfs(i+x, j+y)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1 and grid1[i][j] == 0:\\n                    dfs(i,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    dfs(i,j)\\n                    result+=1\\n                    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2258612,
                "title": "c-soluition-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid, vector<vector<int>> &grid1, int i, int j, bool* status)\\n    {\\n        if(i<grid.size() && i>= 0 && j<grid[0].size() && j>=0 && grid[i][j] != 0)\\n        {\\n            if(grid1[i][j] == 0) \\n            {\\n                *status = false;\\n            }\\n            \\n            grid[i][j] = 0;\\n            dfs(grid, grid1, i, j+1, status);\\n            dfs(grid, grid1, i, j-1, status);\\n            dfs(grid, grid1, i-1, j, status);\\n            dfs(grid, grid1, i+1, j, status);\\n        }\\n        else\\n        {\\n            return;\\n        }\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        bool status = true;\\n        int count = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++)\\n        {\\n            for(int j=0; j<grid2[0].size(); j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    dfs(grid2, grid1, i, j, &status);\\n                    if(status == true) count++;\\n                    status = true;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>> &grid, vector<vector<int>> &grid1, int i, int j, bool* status)\\n    {\\n        if(i<grid.size() && i>= 0 && j<grid[0].size() && j>=0 && grid[i][j] != 0)\\n        {\\n            if(grid1[i][j] == 0) \\n            {\\n                *status = false;\\n            }\\n            \\n            grid[i][j] = 0;\\n            dfs(grid, grid1, i, j+1, status);\\n            dfs(grid, grid1, i, j-1, status);\\n            dfs(grid, grid1, i-1, j, status);\\n            dfs(grid, grid1, i+1, j, status);\\n        }\\n        else\\n        {\\n            return;\\n        }\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        bool status = true;\\n        int count = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++)\\n        {\\n            for(int j=0; j<grid2[0].size(); j++)\\n            {\\n                if(grid2[i][j] == 1)\\n                {\\n                    dfs(grid2, grid1, i, j, &status);\\n                    if(status == true) count++;\\n                    status = true;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2226971,
                "title": "simple-c-code",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\nclass Solution {\\n    bool island = true;\\n    int dirx[4] = {-1,1,0,0};\\n    int diry[4] = {0,0,-1,1};\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, int n, int m)\\n    {\\n        if(grid1[x][y] == 0)\\n            island = false;\\n        grid2[x][y] = 0;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nxtx = x + dirx[i];\\n            int nxty = y + diry[i];\\n            if(nxtx >= n || nxty >= m || nxtx < 0 || nxty < 0) continue;\\n            if(grid2[nxtx][nxty] == 0) continue;\\n            dfs(grid1, grid2, nxtx, nxty, n, m);\\n        }\\n        return;\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid2[i][j] == 0) continue;\\n                dfs(grid1, grid2, i, j, n, m);\\n                if(island) ans++;\\n                island = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    bool island = true;\\n    int dirx[4] = {-1,1,0,0};\\n    int diry[4] = {0,0,-1,1};\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x, int y, int n, int m)\\n    {\\n        if(grid1[x][y] == 0)\\n            island = false;\\n        grid2[x][y] = 0;\\n        for(int i = 0; i < 4; i++)\\n        {\\n            int nxtx = x + dirx[i];\\n            int nxty = y + diry[i];\\n            if(nxtx >= n || nxty >= m || nxtx < 0 || nxty < 0) continue;\\n            if(grid2[nxtx][nxty] == 0) continue;\\n            dfs(grid1, grid2, nxtx, nxty, n, m);\\n        }\\n        return;\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        int ans = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = 0; j < m; j++)\\n            {\\n                if(grid2[i][j] == 0) continue;\\n                dfs(grid1, grid2, i, j, n, m);\\n                if(island) ans++;\\n                island = true;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2213917,
                "title": "python-dfs-solution",
                "content": "Floodfill the island that are not sub island in grid2. And then count the number of remaining island (sub island).\\n\\n```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        \\n        def dfs(grid, i, j):\\n            m, n = len(grid), len(grid[0])\\n            if i<0 or i>=m or j<0 or j>=n:\\n                return\\n            if grid[i][j] == 0:\\n                return\\n            grid[i][j] = 0\\n            dfs(grid, i-1, j)\\n            dfs(grid, i+1, j)\\n            dfs(grid, i, j-1)\\n            dfs(grid, i, j+1)\\n            \\n            \\n        m, n = len(grid1), len(grid1[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n                    \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    res += 1\\n                    dfs(grid2, i, j)\\n                    \\n        return res\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        \\n        def dfs(grid, i, j):\\n            m, n = len(grid), len(grid[0])\\n            if i<0 or i>=m or j<0 or j>=n:\\n                return\\n            if grid[i][j] == 0:\\n                return\\n            grid[i][j] = 0\\n            dfs(grid, i-1, j)\\n            dfs(grid, i+1, j)\\n            dfs(grid, i, j-1)\\n            dfs(grid, i, j+1)\\n            \\n            \\n        m, n = len(grid1), len(grid1[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n                    \\n        res = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    res += 1\\n                    dfs(grid2, i, j)\\n                    \\n        return res\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191290,
                "title": "c-dfs-similar-to-count-number-of-islands",
                "content": "\\nTime complexity : O(mn)\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int row,int col,int& flag){\\n        if(row<0 || col<0 || row>=grid2.size() || col >=grid2[0].size()) return;\\n        if(grid2[row][col]==0) return;\\n        \\n        if(grid2[row][col]==1){\\n            if(grid1[row][col]==0){flag=0;return;}\\n            grid2[row][col]=0;\\n       }\\n                    \\n            dfs(grid1,grid2,row+1,col,flag);\\n            dfs(grid1,grid2,row-1,col,flag);\\n            dfs(grid1,grid2,row,col+1,flag);\\n            dfs(grid1,grid2,row,col-1,flag);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count=0;\\n        for(int i=0;i<grid2.size();i++){\\n            for(int j=0;j<grid2[0].size();j++){\\n                int flag=1;\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag) count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int row,int col,int& flag){\\n        if(row<0 || col<0 || row>=grid2.size() || col >=grid2[0].size()) return;\\n        if(grid2[row][col]==0) return;\\n        \\n        if(grid2[row][col]==1){\\n            if(grid1[row][col]==0){flag=0;return;}\\n            grid2[row][col]=0;\\n       }\\n                    \\n            dfs(grid1,grid2,row+1,col,flag);\\n            dfs(grid1,grid2,row-1,col,flag);\\n            dfs(grid1,grid2,row,col+1,flag);\\n            dfs(grid1,grid2,row,col-1,flag);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int count=0;\\n        for(int i=0;i<grid2.size();i++){\\n            for(int j=0;j<grid2[0].size();j++){\\n                int flag=1;\\n                if(grid2[i][j]==1){\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag) count++;\\n                }\\n            }\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2170906,
                "title": "c-dfs-easy-solution",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int &flag)\\n    {\\n        if(i<0 or j<0 or i>=grid2.size() or j>=grid2[0].size() or grid2[i][j] != 1) return;\\n        \\n        if(grid1[i][j] == 0)\\n        {\\n            flag = 0;\\n            return;\\n        }\\n        \\n        grid2[i][j] = 0;\\n        \\n        dfs(grid1,grid2,i+1,j,flag);\\n        dfs(grid1,grid2,i-1,j,flag);\\n        dfs(grid1,grid2,i,j+1,flag);\\n        dfs(grid1,grid2,i,j-1,flag);\\n    }    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++)\\n        {\\n            for(int j=0; j<grid2[0].size(); j++)\\n            {\\n                int flag = 1;\\n                if(grid2[i][j] == 1)\\n                {\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag == 1)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, int &flag)\\n    {\\n        if(i<0 or j<0 or i>=grid2.size() or j>=grid2[0].size() or grid2[i][j] != 1) return;\\n        \\n        if(grid1[i][j] == 0)\\n        {\\n            flag = 0;\\n            return;\\n        }\\n        \\n        grid2[i][j] = 0;\\n        \\n        dfs(grid1,grid2,i+1,j,flag);\\n        dfs(grid1,grid2,i-1,j,flag);\\n        dfs(grid1,grid2,i,j+1,flag);\\n        dfs(grid1,grid2,i,j-1,flag);\\n    }    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int cnt = 0;\\n        \\n        for(int i=0; i<grid2.size(); i++)\\n        {\\n            for(int j=0; j<grid2[0].size(); j++)\\n            {\\n                int flag = 1;\\n                if(grid2[i][j] == 1)\\n                {\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag == 1)\\n                    {\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166203,
                "title": "modify-count-number-of-islands-c",
                "content": "Okay, so this problem is very very similar to counting the number of islands in a matrix.\\nHere while we are in the dfs function to mark all the current island indexes as 0, if there exists any index in grid1 that has water but we have land on that place in grid2, then this means it is not a valid sub island. So, we will mark the current island as false, and thus does not increase our final count.\\nIf otherwise, we increase the count.\\n```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, bool &flag) {\\n        if(i>=0 && j>=0 && i<grid2.size() && j<grid2[0].size() && grid2[i][j] == 1){\\n            grid2[i][j] = 0;\\n            if(grid1[i][j] == 0){\\n                flag = false;\\n            }\\n            dfs(grid1,grid2,i+1,j,flag);\\n            dfs(grid1,grid2,i-1,j,flag);\\n            dfs(grid1,grid2,i,j-1,flag);\\n            dfs(grid1,grid2,i,j+1,flag);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j] == 1){\\n                    bool flag = true;\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag == true)\\n                        ans++;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j, bool &flag) {\\n        if(i>=0 && j>=0 && i<grid2.size() && j<grid2[0].size() && grid2[i][j] == 1){\\n            grid2[i][j] = 0;\\n            if(grid1[i][j] == 0){\\n                flag = false;\\n            }\\n            dfs(grid1,grid2,i+1,j,flag);\\n            dfs(grid1,grid2,i-1,j,flag);\\n            dfs(grid1,grid2,i,j-1,flag);\\n            dfs(grid1,grid2,i,j+1,flag);\\n        }\\n    }\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        int ans = 0;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(grid2[i][j] == 1){\\n                    bool flag = true;\\n                    dfs(grid1,grid2,i,j,flag);\\n                    if(flag == true)\\n                        ans++;   \\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161297,
                "title": "c-simple-dfs-solution-98-faster",
                "content": "This one is very similar to the other graph problems on this site. In this one you basically want to overlay grid1 over grid2; however, if there is water in grid1 where there is land in grid2, you want to remove that entire Island from grid2.\\n```\\nclass Solution\\n{\\npublic:\\n\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2)\\n\\t{\\n\\t\\tint subIslands = 0;\\n\\t\\tmaxRows = grid1.size();\\n\\t\\tmaxCols = grid1[0].size();\\n\\t\\tfor(int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor(int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid1[row][col] == 0 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\n\\t\\tfor (int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor (int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid2[row][col] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++subIslands;\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\t\\t\\t\\t}\\n\\t\\treturn subIslands;\\n\\t}\\nprivate:\\n\\tint maxRows = 0;\\n\\tint maxCols = 0;\\n\\tvoid turnToWater(vector<vector<int>>& grid, int row, int col)\\n\\t{\\n\\t\\tgrid[row][col] = 0;\\n\\t\\tif (row && grid[row - 1][col] == 1) turnToWater(grid, row - 1, col);\\n\\t\\tif (col && grid[row][col - 1] == 1) turnToWater(grid, row, col - 1);\\n\\t\\tif (row < maxRows - 1 && grid[row + 1][col] == 1) turnToWater(grid, row + 1, col);\\n\\t\\tif (col < maxCols - 1 && grid[row][col + 1] == 1) turnToWater(grid, row, col + 1);\\n\\t}\\n};\\n```\\nIn this solution, we push the possible islands into a vector, and iterator through that instead of going through the entire grid again, reducing the amount of loops overall.\\n```\\nclass Solution\\n{\\npublic:\\n\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2)\\n\\t{\\n\\t\\tint subIslands = 0;\\n\\t\\tmaxRows = grid1.size();\\n\\t\\tmaxCols = grid1[0].size();\\n\\t\\tvector<vector<int>> que;\\n\\t\\tfor (int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor (int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid1[row][col] == 0 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\t\\t\\t\\telse if (grid1[row][col] == 1 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tque.push_back({ row, col });\\n\\n\\t\\tfor (vector<int> i : que)\\n\\t\\t\\t\\tif (grid2[i[0]][i[1]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++subIslands;\\n\\t\\t\\t\\t\\tturnToWater(grid2, i[0], i[1]);\\n\\t\\t\\t\\t}\\n\\t\\treturn subIslands;\\n\\t}\\nprivate:\\n\\tint maxRows = 0;\\n\\tint maxCols = 0;\\n\\tvoid turnToWater(vector<vector<int>>& grid, int row, int col)\\n\\t{\\n\\t\\tgrid[row][col] = 0;\\n\\t\\tif (row && grid[row - 1][col] == 1) turnToWater(grid, row - 1, col);\\n\\t\\tif (col && grid[row][col - 1] == 1) turnToWater(grid, row, col - 1);\\n\\t\\tif (row < maxRows - 1 && grid[row + 1][col] == 1) turnToWater(grid, row + 1, col);\\n\\t\\tif (col < maxCols - 1 && grid[row][col + 1] == 1) turnToWater(grid, row, col + 1);\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2)\\n\\t{\\n\\t\\tint subIslands = 0;\\n\\t\\tmaxRows = grid1.size();\\n\\t\\tmaxCols = grid1[0].size();\\n\\t\\tfor(int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor(int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid1[row][col] == 0 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\n\\t\\tfor (int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor (int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid2[row][col] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++subIslands;\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\t\\t\\t\\t}\\n\\t\\treturn subIslands;\\n\\t}\\nprivate:\\n\\tint maxRows = 0;\\n\\tint maxCols = 0;\\n\\tvoid turnToWater(vector<vector<int>>& grid, int row, int col)\\n\\t{\\n\\t\\tgrid[row][col] = 0;\\n\\t\\tif (row && grid[row - 1][col] == 1) turnToWater(grid, row - 1, col);\\n\\t\\tif (col && grid[row][col - 1] == 1) turnToWater(grid, row, col - 1);\\n\\t\\tif (row < maxRows - 1 && grid[row + 1][col] == 1) turnToWater(grid, row + 1, col);\\n\\t\\tif (col < maxCols - 1 && grid[row][col + 1] == 1) turnToWater(grid, row, col + 1);\\n\\t}\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n\\tint countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2)\\n\\t{\\n\\t\\tint subIslands = 0;\\n\\t\\tmaxRows = grid1.size();\\n\\t\\tmaxCols = grid1[0].size();\\n\\t\\tvector<vector<int>> que;\\n\\t\\tfor (int row = 0; row < maxRows; ++row)\\n\\t\\t\\tfor (int col = 0; col < maxCols; ++col)\\n\\t\\t\\t\\tif (grid1[row][col] == 0 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tturnToWater(grid2, row, col);\\n\\t\\t\\t\\telse if (grid1[row][col] == 1 && grid2[row][col] == 1)\\n\\t\\t\\t\\t\\tque.push_back({ row, col });\\n\\n\\t\\tfor (vector<int> i : que)\\n\\t\\t\\t\\tif (grid2[i[0]][i[1]] == 1)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t++subIslands;\\n\\t\\t\\t\\t\\tturnToWater(grid2, i[0], i[1]);\\n\\t\\t\\t\\t}\\n\\t\\treturn subIslands;\\n\\t}\\nprivate:\\n\\tint maxRows = 0;\\n\\tint maxCols = 0;\\n\\tvoid turnToWater(vector<vector<int>>& grid, int row, int col)\\n\\t{\\n\\t\\tgrid[row][col] = 0;\\n\\t\\tif (row && grid[row - 1][col] == 1) turnToWater(grid, row - 1, col);\\n\\t\\tif (col && grid[row][col - 1] == 1) turnToWater(grid, row, col - 1);\\n\\t\\tif (row < maxRows - 1 && grid[row + 1][col] == 1) turnToWater(grid, row + 1, col);\\n\\t\\tif (col < maxCols - 1 && grid[row][col + 1] == 1) turnToWater(grid, row, col + 1);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2156560,
                "title": "explanatory-solution-using-dfs-96-faster",
                "content": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m = len(grid1) # No. of rows of a grid, say grid1\\n        n = len(grid1[0]) # Size of list at position 0 of grid1\\n        \\n        def dfs(grid, i, j):\\n            if i<0 or j<0 or i>=m or j>=n: # If we are outside grid, return False\\n                return False\\n            \\n            if grid[i][j] == 0: # If element of grid is water, return True\\n                return True\\n            \\n            grid[i][j] = 0 # Mark traversed element as water in grid\\n            \\n            # Do this same recursively for it\\'s surroundings\\n            dfs(grid, i+1,j)\\n            dfs(grid, i-1,j)\\n            dfs(grid, i,j+1)\\n            dfs(grid, i,j-1)\\n        \\n        \\n        # We remove the cases where grid1 has water and grid2 has land\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n        \\n        # Here once we get the final grid2 matrix, we check how many sub-islands are present in grid2\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    count+=1\\n                    dfs(grid2, i, j)\\n        return count # Returns the count of sub-islands\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        \\n        m = len(grid1) # No. of rows of a grid, say grid1\\n        n = len(grid1[0]) # Size of list at position 0 of grid1\\n        \\n        def dfs(grid, i, j):\\n            if i<0 or j<0 or i>=m or j>=n: # If we are outside grid, return False\\n                return False\\n            \\n            if grid[i][j] == 0: # If element of grid is water, return True\\n                return True\\n            \\n            grid[i][j] = 0 # Mark traversed element as water in grid\\n            \\n            # Do this same recursively for it\\'s surroundings\\n            dfs(grid, i+1,j)\\n            dfs(grid, i-1,j)\\n            dfs(grid, i,j+1)\\n            dfs(grid, i,j-1)\\n        \\n        \\n        # We remove the cases where grid1 has water and grid2 has land\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n        \\n        # Here once we get the final grid2 matrix, we check how many sub-islands are present in grid2\\n        count = 0\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    count+=1\\n                    dfs(grid2, i, j)\\n        return count # Returns the count of sub-islands\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2144172,
                "title": "java-dfs-easy-to-understand-with-explanation",
                "content": "Trick here is to use flags.\\n\\nWe need to keep iterating the blocks of grid2 even if they don\\'t match with grid1 because they form an island and island needs to be traversed as a whole, no matter if it\\'s there in grid1 or not.\\n\\nTo counter this we use flag, which makes sure that we note the fact that Land in grid2 isn\\'t an island wrt to GRID1. \\n\\nThus we update the \"answer\" only on  cases where flag==1.\\n\\n```\\nclass Solution {\\n    int vis[][];\\n     int ans=0;\\n     int flag=1;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        vis= new int[grid2.length][grid2[0].length];\\n       \\n        for(int i=0; i<grid2.length; i++){\\n           \\n            for(int j=0; j<grid2[0].length; j++){\\n                if(vis[i][j]==0 && grid2[i][j]==1){\\n                    dfs(i, j, grid1, grid2);\\n                    if(flag==1)\\n                        ans++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public void dfs(int i, int j, int[][] grid1, int[][] grid2){\\n        if(i<0 || i>=grid2.length || j<0 || j>=grid2[0].length || vis[i][j]==1 || grid2[i][j]==0){\\n            return ;\\n        }\\n        \\n        if(grid1[i][j]==0)\\n            flag=0;\\n        \\n        vis[i][j]=1;\\n        dfs(i+1, j, grid1, grid2);\\n        dfs(i-1, j, grid1, grid2);\\n        dfs(i, j+1, grid1, grid2);\\n        dfs(i, j-1, grid1, grid2);\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int vis[][];\\n     int ans=0;\\n     int flag=1;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        vis= new int[grid2.length][grid2[0].length];\\n       \\n        for(int i=0; i<grid2.length; i++){\\n           \\n            for(int j=0; j<grid2[0].length; j++){\\n                if(vis[i][j]==0 && grid2[i][j]==1){\\n                    dfs(i, j, grid1, grid2);\\n                    if(flag==1)\\n                        ans++;\\n                    flag=1;\\n                }\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n    \\n    public void dfs(int i, int j, int[][] grid1, int[][] grid2){\\n        if(i<0 || i>=grid2.length || j<0 || j>=grid2[0].length || vis[i][j]==1 || grid2[i][j]==0){\\n            return ;\\n        }\\n        \\n        if(grid1[i][j]==0)\\n            flag=0;\\n        \\n        vis[i][j]=1;\\n        dfs(i+1, j, grid1, grid2);\\n        dfs(i-1, j, grid1, grid2);\\n        dfs(i, j+1, grid1, grid2);\\n        dfs(i, j-1, grid1, grid2);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143476,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\nbool flag=true;\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int r, int c)\\n    {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        if(r<0 || c<0 || r>=n || c>=m)\\n            return;\\n        if(grid2[r][c]==0)\\n            return;\\n        if(grid2[r][c]==1 && grid1[r][c]==0)\\n            flag=false;\\n        grid2[r][c]=0;\\n        dfs(grid1,grid2,r-1,c);\\n        dfs(grid1,grid2,r,c-1);\\n        dfs(grid1,grid2,r+1,c);\\n        dfs(grid1,grid2,r,c+1);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid2[i][j])\\n                {\\n                    dfs(grid1,grid2,i,j);\\n                    if(flag==true)\\n                    count++;\\n                    flag=true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\nbool flag=true;\\npublic:\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int r, int c)\\n    {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        if(r<0 || c<0 || r>=n || c>=m)\\n            return;\\n        if(grid2[r][c]==0)\\n            return;\\n        if(grid2[r][c]==1 && grid1[r][c]==0)\\n            flag=false;\\n        grid2[r][c]=0;\\n        dfs(grid1,grid2,r-1,c);\\n        dfs(grid1,grid2,r,c-1);\\n        dfs(grid1,grid2,r+1,c);\\n        dfs(grid1,grid2,r,c+1);\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n=grid1.size();\\n        int m=grid1[0].size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(grid2[i][j])\\n                {\\n                    dfs(grid1,grid2,i,j);\\n                    if(flag==true)\\n                    count++;\\n                    flag=true;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130973,
                "title": "count-sub-islands",
                "content": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if(grid1 ==null || grid1.length==0)return 0;\\n        \\n        for(int i = 0  ; i < grid2.length;i++){\\n            for(int j = 0 ; j < grid2[0].length;j++ ){\\n                if(grid1[i][j] == 0 & grid2[i][j]==1){\\n                    dfs(grid2,i,j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n          for(int i = 0  ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length;j++ ){\\n                if( grid2[i][j] == 1){\\n                    ans++;\\n                    dfs(grid2,i,j);\\n                    \\n                }\\n            }\\n        }\\n        \\n     return ans;   \\n    }\\n    void dfs(int[][] grid, int i, int j) {\\n      \\n        if (i < 0 || j < 0 || i == grid.length || grid[0].length  == j) return;\\n         if (grid[i][j] == 0) return;\\n          grid[i][j] = 0;\\n          dfs(grid, i - 1, j) ;\\n          dfs(grid, i + 1, j) ;\\n          dfs(grid, i, j - 1) ;\\n          dfs(grid, i, j + 1);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        if(grid1 ==null || grid1.length==0)return 0;\\n        \\n        for(int i = 0  ; i < grid2.length;i++){\\n            for(int j = 0 ; j < grid2[0].length;j++ ){\\n                if(grid1[i][j] == 0 & grid2[i][j]==1){\\n                    dfs(grid2,i,j);\\n                }\\n            }\\n        }\\n        int ans = 0;\\n          for(int i = 0  ; i < grid2.length ; i++){\\n            for(int j = 0 ; j < grid2[0].length;j++ ){\\n                if( grid2[i][j] == 1){\\n                    ans++;\\n                    dfs(grid2,i,j);\\n                    \\n                }\\n            }\\n        }\\n        \\n     return ans;   \\n    }\\n    void dfs(int[][] grid, int i, int j) {\\n      \\n        if (i < 0 || j < 0 || i == grid.length || grid[0].length  == j) return;\\n         if (grid[i][j] == 0) return;\\n          grid[i][j] = 0;\\n          dfs(grid, i - 1, j) ;\\n          dfs(grid, i + 1, j) ;\\n          dfs(grid, i, j - 1) ;\\n          dfs(grid, i, j + 1);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2130313,
                "title": "python3-solution-dfs",
                "content": "class Solution:\\n\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        #create variable to store result\\n        res = 0\\n        #get number of columns and rows\\n        m = len(grid1)\\n        n = len(grid1[0])\\n        \\n        #create dfs function\\n        def dfs(grid, i, j):\\n             #if current position out of boundary,return\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return\\n            \\n            #if current position is water,return\\n            if grid[i][j] == 0:\\n                return\\n            \\n            #set current location as water to avoid repetition\\n            grid[i][j] = 0\\n            #check surrounding \\n            dfs(grid, i + 1, j)\\n            dfs(grid, i - 1, j)\\n            dfs(grid, i, j + 1)\\n            dfs(grid, i, j - 1)\\n            \\n        #get rid of lands on grid2 \\n        #where same area on grid1 is water\\n        #these lands will not be sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n        \\n        #traverse through grid two to count number of islands left\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    res += 1\\n                    dfs(grid2, i, j)\\n                    \\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "class Solution:\\n\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        #create variable to store result\\n        res = 0\\n        #get number of columns and rows\\n        m = len(grid1)\\n        n = len(grid1[0])\\n        \\n        #create dfs function\\n        def dfs(grid, i, j):\\n             #if current position out of boundary,return\\n            if i < 0 or j < 0 or i >= m or j >= n:\\n                return\\n            \\n            #if current position is water,return\\n            if grid[i][j] == 0:\\n                return\\n            \\n            #set current location as water to avoid repetition\\n            grid[i][j] = 0\\n            #check surrounding \\n            dfs(grid, i + 1, j)\\n            dfs(grid, i - 1, j)\\n            dfs(grid, i, j + 1)\\n            dfs(grid, i, j - 1)\\n            \\n        #get rid of lands on grid2 \\n        #where same area on grid1 is water\\n        #these lands will not be sub-islands\\n        for i in range(m):\\n            for j in range(n):\\n                if grid1[i][j] == 0 and grid2[i][j] == 1:\\n                    dfs(grid2, i, j)\\n        \\n        #traverse through grid two to count number of islands left\\n        for i in range(m):\\n            for j in range(n):\\n                if grid2[i][j] == 1:\\n                    res += 1\\n                    dfs(grid2, i, j)\\n                    \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2123251,
                "title": "java-using-dfs",
                "content": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int row = grid2.length;\\n        int col = grid2[0].length;\\n        boolean[][] visit = new boolean[row][col];\\n        int subIsland = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid2[i][j] == 1 && !visit[i][j] && dfs(grid1, grid2, visit, i, j)) {\\n                    subIsland += 1;\\n                }\\n            }\\n        }\\n        \\n        return subIsland;\\n    }\\n    \\n    private static boolean dfs(int[][] grid1, int[][] grid2, boolean[][] visit, int i, int j) {\\n        if (i < 0 || i >= grid2.length || j < 0 || j >= grid2[i].length || visit[i][j] || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        visit[i][j] = true;\\n        boolean isMatched = true;\\n        if (grid1[i][j] == 0) {\\n            isMatched = false;\\n        }\\n        \\n        isMatched = dfs(grid1, grid2, visit, i+1, j) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i-1, j) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i, j+1) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i, j-1) && isMatched;\\n        \\n        return isMatched;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int row = grid2.length;\\n        int col = grid2[0].length;\\n        boolean[][] visit = new boolean[row][col];\\n        int subIsland = 0;\\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n                if (grid2[i][j] == 1 && !visit[i][j] && dfs(grid1, grid2, visit, i, j)) {\\n                    subIsland += 1;\\n                }\\n            }\\n        }\\n        \\n        return subIsland;\\n    }\\n    \\n    private static boolean dfs(int[][] grid1, int[][] grid2, boolean[][] visit, int i, int j) {\\n        if (i < 0 || i >= grid2.length || j < 0 || j >= grid2[i].length || visit[i][j] || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        visit[i][j] = true;\\n        boolean isMatched = true;\\n        if (grid1[i][j] == 0) {\\n            isMatched = false;\\n        }\\n        \\n        isMatched = dfs(grid1, grid2, visit, i+1, j) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i-1, j) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i, j+1) && isMatched;\\n        isMatched = dfs(grid1, grid2, visit, i, j-1) && isMatched;\\n        \\n        return isMatched;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114315,
                "title": "c-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int m,int n)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || (grid1[i][j]==0 && grid2[i][j]==0) || (grid1[i][j]==1 && grid2[i][j]==0))    //conditions for island2 be a sub-island of island 1\\n            return true;\\n        if(grid1[i][j]==1 && grid2[i][j]==1)\\n        {\\n            grid1[i][j] = 0;\\n            grid2[i][j] = 0;\\n        }\\n        else if(grid1[i][j]==0 && grid2[i][j]==1)      //island2 is not a sub-island of island 1\\n            return false;\\n\\t\\t// check in all the four direction \\n        bool a = possible(grid1,grid2,i+1,j,m,n);\\n        bool b = possible(grid1,grid2,i,j+1,m,n);\\n        bool c = possible(grid1,grid2,i,j-1,m,n);\\n        bool d = possible(grid1,grid2,i-1,j,m,n);\\n        return a && b && c && d;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(),n = grid2[0].size();\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid1[i][j]==1 && grid2[i][j]==1)\\n                {\\n                    if(possible(grid1,grid2,i,j,m,n))        //if island 2 is a sub-island of island 1\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool possible(vector<vector<int>>& grid1, vector<vector<int>>& grid2,int i,int j,int m,int n)\\n    {\\n        if(i<0 || j<0 || i>=m || j>=n || (grid1[i][j]==0 && grid2[i][j]==0) || (grid1[i][j]==1 && grid2[i][j]==0))    //conditions for island2 be a sub-island of island 1\\n            return true;\\n        if(grid1[i][j]==1 && grid2[i][j]==1)\\n        {\\n            grid1[i][j] = 0;\\n            grid2[i][j] = 0;\\n        }\\n        else if(grid1[i][j]==0 && grid2[i][j]==1)      //island2 is not a sub-island of island 1\\n            return false;\\n\\t\\t// check in all the four direction \\n        bool a = possible(grid1,grid2,i+1,j,m,n);\\n        bool b = possible(grid1,grid2,i,j+1,m,n);\\n        bool c = possible(grid1,grid2,i,j-1,m,n);\\n        bool d = possible(grid1,grid2,i-1,j,m,n);\\n        return a && b && c && d;\\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size(),n = grid2[0].size();\\n        int count = 0;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid1[i][j]==1 && grid2[i][j]==1)\\n                {\\n                    if(possible(grid1,grid2,i,j,m,n))        //if island 2 is a sub-island of island 1\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2104512,
                "title": "java-dfs-solution",
                "content": "```\\n\\nclass Solution {\\n    \\n    int n2 ;\\n    int m2 ;\\n    boolean isSub_Island ;\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        this.n2 = grid2.length ;\\n        this.m2 = grid2[0].length ;\\n        int count = 0 ;\\n        \\n        for(int i=0 ; i<n2 ; i++){\\n            for(int j=0 ; j<m2 ; j++){                \\n                if(grid2[i][j] == 1 ){\\n                    isSub_Island = true ;\\n                    dfs(grid1 , grid2 , i , j) ;\\n                    if(isSub_Island){\\n                        count++ ;\\n                    }\\n                }                \\n            }\\n        }\\n        \\n        return count ;        \\n    }\\n    \\n    void dfs(int[][] grid1, int[][] grid2 , int i , int j){\\n        \\n        if(i < 0 || i >= n2 || j < 0 || j >= m2 || grid2[i][j] != 1 ){\\n            return ;\\n        }\\n        \\n        if(grid1[i][j] != 1){\\n            isSub_Island = false ;\\n        }\\n        \\n        grid2[i][j] = 0 ;\\n        \\n        dfs(grid1 , grid2 , i+1 , j) ;\\n        dfs(grid1 , grid2 , i-1 , j) ;\\n        dfs(grid1 , grid2 , i , j+1) ;\\n        dfs(grid1 , grid2 , i , j-1) ;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    \\n    int n2 ;\\n    int m2 ;\\n    boolean isSub_Island ;\\n    \\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        \\n        this.n2 = grid2.length ;\\n        this.m2 = grid2[0].length ;\\n        int count = 0 ;\\n        \\n        for(int i=0 ; i<n2 ; i++){\\n            for(int j=0 ; j<m2 ; j++){                \\n                if(grid2[i][j] == 1 ){\\n                    isSub_Island = true ;\\n                    dfs(grid1 , grid2 , i , j) ;\\n                    if(isSub_Island){\\n                        count++ ;\\n                    }\\n                }                \\n            }\\n        }\\n        \\n        return count ;        \\n    }\\n    \\n    void dfs(int[][] grid1, int[][] grid2 , int i , int j){\\n        \\n        if(i < 0 || i >= n2 || j < 0 || j >= m2 || grid2[i][j] != 1 ){\\n            return ;\\n        }\\n        \\n        if(grid1[i][j] != 1){\\n            isSub_Island = false ;\\n        }\\n        \\n        grid2[i][j] = 0 ;\\n        \\n        dfs(grid1 , grid2 , i+1 , j) ;\\n        dfs(grid1 , grid2 , i-1 , j) ;\\n        dfs(grid1 , grid2 , i , j+1) ;\\n        dfs(grid1 , grid2 , i , j-1) ;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2089082,
                "title": "js-dfs-solution-88-faster",
                "content": "```\\nvar countSubIslands = function(grid1, grid2) { \\n    var m = grid2.length;\\n    var n = grid2[0].length;\\n    var subIslands = 0;\\n    \\n    function dfs(r,c) {\\n        if(r<0 || c<0 || r>=m || c>=n || grid2[r][c] !== 1) return;\\n        grid2[r][c] = 2;\\n        if(grid1[r][c] !== 1) potentialSub = false;\\n        dfs(r-1,c);\\n        dfs(r+1,c);\\n        dfs(r,c-1);\\n        dfs(r,c+1);\\n    }    \\n    \\n    for(var r=0; r<m; r++) {\\n        for(var c=0; c<n; c++) {\\n            if(grid2[r][c] === 1) {\\n                var potentialSub = true;\\n                dfs(r,c);\\n                if(potentialSub) subIslands++;\\n            }\\n        }\\n    }\\n    return subIslands;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar countSubIslands = function(grid1, grid2) { \\n    var m = grid2.length;\\n    var n = grid2[0].length;\\n    var subIslands = 0;\\n    \\n    function dfs(r,c) {\\n        if(r<0 || c<0 || r>=m || c>=n || grid2[r][c] !== 1) return;\\n        grid2[r][c] = 2;\\n        if(grid1[r][c] !== 1) potentialSub = false;\\n        dfs(r-1,c);\\n        dfs(r+1,c);\\n        dfs(r,c-1);\\n        dfs(r,c+1);\\n    }    \\n    \\n    for(var r=0; r<m; r++) {\\n        for(var c=0; c<n; c++) {\\n            if(grid2[r][c] === 1) {\\n                var potentialSub = true;\\n                dfs(r,c);\\n                if(potentialSub) subIslands++;\\n            }\\n        }\\n    }\\n    return subIslands;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2080614,
                "title": "very-easy-c-solution-with-comments-and-the-basic-trick",
                "content": "The solution is just basic dfs on 2d grid twice\\n1. First go through the first grid and check if there is any 0(water) for which there is 1(land) in grid 2\\n      If yes make all such land in grid 2 as visited.\\n2. Second just traverse through the grid 2 and count the no of connected components.\\nThis is the basic intuition. \\n##### Do upvote if it was helpful\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    int vis[501][501];\\n    bool isValid(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x,int y){\\n        if(x<0||x>=grid2.size()||y<0||y>=grid2[0].size()||grid2[x][y]==0||grid2[x][y]!=grid1[x][y]||vis[x][y]==1)\\n            return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x,int y){\\n        \\n        vis[x][y]=1;\\n        for(int i=0;i<4;i++){\\n            if(isValid(grid1,grid2,x+dx[i],y+dy[i]))\\n            dfs(grid1,grid2,x+dx[i],y+dy[i]);\\n        }\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int cnt=0;\\n        //Traverse through the first grid and check if for any water there is land in grid 2\\n        // if true then make that land and its connected component as visited\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++){\\n                if(grid1[i][j]==0 && grid2[i][j]==1)\\n                    dfs(grid1,grid2,i,j);\\n            }\\n        //Traverse through the seconnd grid and count the no of connected components\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++)\\n                if(grid2[i][j]==1 && vis[i][j]==0){\\n                    cnt++;\\n                    dfs(grid1,grid2,i,j);\\n                    \\n                }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dx[4]={0,1,0,-1};\\n    int dy[4]={1,0,-1,0};\\n    int vis[501][501];\\n    bool isValid(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x,int y){\\n        if(x<0||x>=grid2.size()||y<0||y>=grid2[0].size()||grid2[x][y]==0||grid2[x][y]!=grid1[x][y]||vis[x][y]==1)\\n            return false;\\n        return true;\\n    }\\n    void dfs(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int x,int y){\\n        \\n        vis[x][y]=1;\\n        for(int i=0;i<4;i++){\\n            if(isValid(grid1,grid2,x+dx[i],y+dy[i]))\\n            dfs(grid1,grid2,x+dx[i],y+dy[i]);\\n        }\\n        \\n    }\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int cnt=0;\\n        //Traverse through the first grid and check if for any water there is land in grid 2\\n        // if true then make that land and its connected component as visited\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++){\\n                if(grid1[i][j]==0 && grid2[i][j]==1)\\n                    dfs(grid1,grid2,i,j);\\n            }\\n        //Traverse through the seconnd grid and count the no of connected components\\n        for(int i=0;i<grid2.size();i++)\\n            for(int j=0;j<grid2[0].size();j++)\\n                if(grid2[i][j]==1 && vis[i][j]==0){\\n                    cnt++;\\n                    dfs(grid1,grid2,i,j);\\n                    \\n                }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066185,
                "title": "c-intuitive-simple-approach-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid1,vector<vector<int>>&grid2,int i,int j,int m,int n)\\n    {\\n        if(i<0||j<0||i>=m||j>=n)return 1;\\n        \\n        if(grid2[i][j]==1&&grid1[i][j]==0)return 0;\\n        if(grid2[i][j]==0)return 1;\\n        grid2[i][j]=0;grid1[i][j]=0;\\n        bool a=dfs(grid1,grid2,i+1,j,m,n);\\n          a&=dfs(grid1,grid2,i-1,j,m,n);\\n           a&=dfs(grid1,grid2,i,j+1,m,n);\\n           a&=dfs(grid1,grid2,i,j-1,m,n);\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n   int count=0;int m=grid1.size();int n=grid1[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            \\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid2[i][j]==1&&grid1[i][j]==1)\\n                {\\n                   \\n                    \\n                    if(dfs(grid1,grid2,i,j,m,n))\\n                        count++;\\n                }\\n                \\n            }\\n                \\n        }\\n        return count;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool dfs(vector<vector<int>>&grid1,vector<vector<int>>&grid2,int i,int j,int m,int n)\\n    {\\n        if(i<0||j<0||i>=m||j>=n)return 1;\\n        \\n        if(grid2[i][j]==1&&grid1[i][j]==0)return 0;\\n        if(grid2[i][j]==0)return 1;\\n        grid2[i][j]=0;grid1[i][j]=0;\\n        bool a=dfs(grid1,grid2,i+1,j,m,n);\\n          a&=dfs(grid1,grid2,i-1,j,m,n);\\n           a&=dfs(grid1,grid2,i,j+1,m,n);\\n           a&=dfs(grid1,grid2,i,j-1,m,n);\\n        return a;\\n        \\n        \\n    }\\n    \\n    \\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n   int count=0;int m=grid1.size();int n=grid1[0].size();\\n        \\n        for(int i=0;i<m;i++)\\n        {\\n            \\n            \\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid2[i][j]==1&&grid1[i][j]==1)\\n                {\\n                   \\n                    \\n                    if(dfs(grid1,grid2,i,j,m,n))\\n                        count++;\\n                }\\n                \\n            }\\n                \\n        }\\n        return count;\\n        \\n        \\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066076,
                "title": "java-dfs-solution",
                "content": "```\\n\\nclass Solution {\\n    boolean ans;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        //none of element must be outside of grid1\\'s land in grid2\\'s land\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        int count = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(grid1[i][j] == 1 && grid2[i][j] == 1) //only possible sub island can be found\\n                {\\n                    ans = true;\\n                    dfs(grid1, grid2, i, j);\\n                    if(ans)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    //grid1[i][j] == 0, grid[i][j] == 1 is not acceptable\\n    //0, 0\\n    //1, 1\\n    //1, 0 these are acceptable in case of sub island\\n    int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j)\\n    {\\n        if(grid1[i][j] == 0) ans = false; //simply if grid2[i][j] is 1 but grid1[i][j] = 0 (only false case)\\n        grid2[i][j] = 0;\\n        \\n        for(int[] dir : dirs)\\n        {\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x>=0 && y>=0 && x<grid2.length && y<grid2[0].length && grid2[x][y] == 1)\\n            {\\n                dfs(grid1, grid2, x, y);\\n            }\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    boolean ans;\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        //none of element must be outside of grid1\\'s land in grid2\\'s land\\n        int n = grid1.length;\\n        int m = grid1[0].length;\\n        int count = 0;\\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(grid1[i][j] == 1 && grid2[i][j] == 1) //only possible sub island can be found\\n                {\\n                    ans = true;\\n                    dfs(grid1, grid2, i, j);\\n                    if(ans)\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    //grid1[i][j] == 0, grid[i][j] == 1 is not acceptable\\n    //0, 0\\n    //1, 1\\n    //1, 0 these are acceptable in case of sub island\\n    int[][] dirs = {{1,0},{0,1},{-1,0},{0,-1}};\\n    \\n    public void dfs(int[][] grid1, int[][] grid2, int i, int j)\\n    {\\n        if(grid1[i][j] == 0) ans = false; //simply if grid2[i][j] is 1 but grid1[i][j] = 0 (only false case)\\n        grid2[i][j] = 0;\\n        \\n        for(int[] dir : dirs)\\n        {\\n            int x = i+dir[0];\\n            int y = j+dir[1];\\n            if(x>=0 && y>=0 && x<grid2.length && y<grid2[0].length && grid2[x][y] == 1)\\n            {\\n                dfs(grid1, grid2, x, y);\\n            }\\n        }\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012991,
                "title": "easy-javascript-solution",
                "content": "```\\nvar countSubIslands = function(grid1, grid2) {\\n  let row=grid2.length; let colm=grid2[0].length;\\n  let bool; let count=0;  \\n  for(let i=0; i<row; i++){\\n    for(let j=0; j<colm; j++){\\n      if(grid2[i][j]===1){\\n        bool=true;\\n        island(i,j);\\n        if(bool){ count++; }\\n      }\\n    }\\n  }\\n  return count;\\n  function island(i,j){\\n    if(i<0 || j<0 || i===row || j===colm || grid2[i][j]===0){\\n      return;\\n    }\\n    grid2[i][j]=0;\\n    if(grid1[i][j]===0){ bool=false; } \\n    island(i+1,j); island(i-1,j); \\n    island(i,j+1); island(i,j-1);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar countSubIslands = function(grid1, grid2) {\\n  let row=grid2.length; let colm=grid2[0].length;\\n  let bool; let count=0;  \\n  for(let i=0; i<row; i++){\\n    for(let j=0; j<colm; j++){\\n      if(grid2[i][j]===1){\\n        bool=true;\\n        island(i,j);\\n        if(bool){ count++; }\\n      }\\n    }\\n  }\\n  return count;\\n  function island(i,j){\\n    if(i<0 || j<0 || i===row || j===colm || grid2[i][j]===0){\\n      return;\\n    }\\n    grid2[i][j]=0;\\n    if(grid1[i][j]===0){ bool=false; } \\n    island(i+1,j); island(i-1,j); \\n    island(i,j+1); island(i,j-1);\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2001755,
                "title": "c-easy-dfs-approach-with-commented-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void DFS(int i, int j, int m, int n, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& res) {\\n        \\n        // Corner cases\\n        if(i<0 || i>=m || j<0 || j>=n || grid2[i][j] == 0) return;\\n        \\n        // If grid1 does not have land for the corresponding cell in grid2\\n        if(grid1[i][j] == 0) {\\n            res = false;\\n            return;\\n        }\\n        \\n        // Marking visited\\n        grid2[i][j] = 0;\\n        \\n        // DFS in four directions\\n        DFS(i+1, j, m, n, grid1, grid2, res);\\n        DFS(i-1, j, m, n, grid1, grid2, res);\\n        DFS(i, j+1, m, n, grid1, grid2, res);\\n        DFS(i, j-1, m, n, grid1, grid2, res);\\n\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid2.size();\\n        int n = grid2[0].size();\\n        \\n        int ans=0;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid2[i][j] == 1) {\\n                    bool res = true;\\n                    DFS(i, j, m, n, grid1, grid2, res);\\n                    \\n                    // If grid1 has land for every corresponding land (single component) in grid2\\n                    if (res) ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(int i, int j, int m, int n, vector<vector<int>>& grid1, vector<vector<int>>& grid2, bool& res) {\\n        \\n        // Corner cases\\n        if(i<0 || i>=m || j<0 || j>=n || grid2[i][j] == 0) return;\\n        \\n        // If grid1 does not have land for the corresponding cell in grid2\\n        if(grid1[i][j] == 0) {\\n            res = false;\\n            return;\\n        }\\n        \\n        // Marking visited\\n        grid2[i][j] = 0;\\n        \\n        // DFS in four directions\\n        DFS(i+1, j, m, n, grid1, grid2, res);\\n        DFS(i-1, j, m, n, grid1, grid2, res);\\n        DFS(i, j+1, m, n, grid1, grid2, res);\\n        DFS(i, j-1, m, n, grid1, grid2, res);\\n\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid2.size();\\n        int n = grid2[0].size();\\n        \\n        int ans=0;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid2[i][j] == 1) {\\n                    bool res = true;\\n                    DFS(i, j, m, n, grid1, grid2, res);\\n                    \\n                    // If grid1 has land for every corresponding land (single component) in grid2\\n                    if (res) ans++;\\n                }\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979317,
                "title": "c-100-easy-with-explanation",
                "content": "In this question, we can solve it step by step:\\n\\n1.we can just copy use grid2 to find grid1. \\n2.The main idea is on the dfs function. if there exists that the point at grid2 is 1 while the point at grid1 is 0, then boolean check will be false. \\n3.If and only if boolean check is true after the end of the dfs function, it means the grid1 contained all points of the island at grid2.\\n\\nThat is my idea about this question.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool check = true; // to check whether grid1 is contained grid2\\n    \\n    void dfs(vector<vector<int>>& grid2, vector<vector<int>>& grid1, int row, int col){\\n        // bundary checking\\n        if(row<0 || col<0 || row>=grid2.size() || col >=grid2[0].size() || grid2[row][col] == 0) return;\\n        \\n        grid2[row][col] = 0;\\n        // if do not equal to 1, it means grid1 does not contain this point of grid2.\\n        if(grid1[row][col] != 1){\\n             check = false;\\n        }\\n        // go to up/down/left/right, this four directions\\n        dfs(grid2, grid1, row+1, col);\\n        dfs(grid2, grid1, row-1, col);\\n        dfs(grid2, grid1, row, col+1);\\n        dfs(grid2, grid1, row, col-1);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int R = grid1.size();\\n        int C = grid1[0].size();\\n        int ans = 0;\\n        for(int row = 0; row<R; row++){\\n            for(int col=0; col<C; col++){\\n                if(grid2[row][col] == 1){\\n                    dfs(grid2, grid1, row, col); \\n                    \\n                    // if check is true, it means grid1 contained grid2\\n                    if(check) ans++;\\n                    check = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check = true; // to check whether grid1 is contained grid2\\n    \\n    void dfs(vector<vector<int>>& grid2, vector<vector<int>>& grid1, int row, int col){\\n        // bundary checking\\n        if(row<0 || col<0 || row>=grid2.size() || col >=grid2[0].size() || grid2[row][col] == 0) return;\\n        \\n        grid2[row][col] = 0;\\n        // if do not equal to 1, it means grid1 does not contain this point of grid2.\\n        if(grid1[row][col] != 1){\\n             check = false;\\n        }\\n        // go to up/down/left/right, this four directions\\n        dfs(grid2, grid1, row+1, col);\\n        dfs(grid2, grid1, row-1, col);\\n        dfs(grid2, grid1, row, col+1);\\n        dfs(grid2, grid1, row, col-1);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int R = grid1.size();\\n        int C = grid1[0].size();\\n        int ans = 0;\\n        for(int row = 0; row<R; row++){\\n            for(int col=0; col<C; col++){\\n                if(grid2[row][col] == 1){\\n                    dfs(grid2, grid1, row, col); \\n                    \\n                    // if check is true, it means grid1 contained grid2\\n                    if(check) ans++;\\n                    check = true;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1972788,
                "title": "c-easy-dfs",
                "content": "we are taking a bool var to check if there is 1 in grid1 or not and doing floodfill for grid2\\n\\n```\\nbool res;\\n    int countSubIslands(vector<vector<int>>& A, vector<vector<int>>& B) {\\n        int m = B.size();\\n        int count = 0;\\n        int n = B[0].size();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(B[i][j]==1){\\n                    res = true;\\n                    dfs(A, B, i, j);\\n                    if(res)count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    void dfs(vector<vector<int>>& A, vector<vector<int>>& B, int x, int y){\\n        \\n        if(x<0 || x>=B.size() || y<0 || y>=B[0].size() || B[x][y]==0)return;\\n        if(A[x][y]==0){\\n            res = false;\\n            return;\\n        }\\n        \\n        B[x][y]=0;\\n        \\n        dfs(A, B, x+1, y);\\n        dfs(A, B, x, y+1);\\n        dfs(A, B, x-1, y);\\n        dfs(A, B, x, y-1);\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nbool res;\\n    int countSubIslands(vector<vector<int>>& A, vector<vector<int>>& B) {\\n        int m = B.size();\\n        int count = 0;\\n        int n = B[0].size();\\n\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(B[i][j]==1){\\n                    res = true;\\n                    dfs(A, B, i, j);\\n                    if(res)count+=1;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n    void dfs(vector<vector<int>>& A, vector<vector<int>>& B, int x, int y){\\n        \\n        if(x<0 || x>=B.size() || y<0 || y>=B[0].size() || B[x][y]==0)return;\\n        if(A[x][y]==0){\\n            res = false;\\n            return;\\n        }\\n        \\n        B[x][y]=0;\\n        \\n        dfs(A, B, x+1, y);\\n        dfs(A, B, x, y+1);\\n        dfs(A, B, x-1, y);\\n        dfs(A, B, x, y-1);\\n        \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1970271,
                "title": "c-simple-dfs-approach",
                "content": "Points:\\n1. In first DFS, convert islands of grid2 not in grid1 to 0\\n2. In second DFS, count islands in grid2\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i, int j, vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i==grid.size() or j==grid[0].size() or grid[i][j]==0)\\n            return;\\n        grid[i][j] = 0;\\n        dfs(i+1, j, grid);\\n        dfs(i-1, j, grid);\\n        dfs(i, j+1, grid);\\n        dfs(i, j-1, grid);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1 and grid1[i][j]==0){\\n                    dfs(i, j, grid2);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(i, j, grid2);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int i, int j, vector<vector<int>>& grid){\\n        if(i<0 or j<0 or i==grid.size() or j==grid[0].size() or grid[i][j]==0)\\n            return;\\n        grid[i][j] = 0;\\n        dfs(i+1, j, grid);\\n        dfs(i-1, j, grid);\\n        dfs(i, j+1, grid);\\n        dfs(i, j-1, grid);\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int n = grid2.size();\\n        int m = grid2[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1 and grid1[i][j]==0){\\n                    dfs(i, j, grid2);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(grid2[i][j]==1){\\n                    dfs(i, j, grid2);\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961157,
                "title": "python-3-solution-golang-solution-faster-than-97",
                "content": "### Python\\n\\n```py\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid2), len(grid2[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i == m or j == n or grid2[i][j] == 0:\\n                return True\\n            \\n            is_subisland = True\\n            if grid1[i][j] == 0:\\n                is_subisland = False\\n            \\n            grid2[i][j] = 0\\n            \\n            is_subisland = dfs(i+1, j) and is_subisland\\n            is_subisland = dfs(i-1, j) and is_subisland\\n            is_subisland = dfs(i, j+1) and is_subisland\\n            is_subisland = dfs(i, j-1) and is_subisland\\n            \\n            return is_subisland\\n        \\n        sub_islands = sum(grid2[i][j] and dfs(i, j) for i in range(m) for j in range(n))\\n        return sub_islands\\n```\\n\\n### GoLang\\n\\n```go\\nfunc countSubIslands(grid1 [][]int, grid2 [][]int) int {\\n    m, n := len(grid2), len(grid2[0])\\n    var subIslands int\\n    \\n    for i := 0; i< m; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid2[i][j] == 1 && dfs(i, j, grid1, grid2) {\\n                subIslands++\\n            }\\n        }\\n    }\\n    return subIslands\\n}\\n\\nfunc dfs(i, j int, grid1, grid2 [][]int) bool {\\n    if i < 0 || j < 0 || i == len(grid2) || j == len(grid2[0]) || grid2[i][j] == 0 {\\n        return true\\n    }\\n\\t\\n    isSubIsland := true\\n\\t\\n    if grid1[i][j] == 0 {\\n        isSubIsland = false\\n    }\\n\\t\\n    grid2[i][j] = 0\\n    \\n    isSubIsland = dfs(i+1, j, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i-1, j, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i, j+1, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i, j-1, grid1, grid2) && isSubIsland\\n    \\n    return isSubIsland\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```py\\nclass Solution:\\n    def countSubIslands(self, grid1: List[List[int]], grid2: List[List[int]]) -> int:\\n        m, n = len(grid2), len(grid2[0])\\n        \\n        def dfs(i, j):\\n            if i < 0 or j < 0 or i == m or j == n or grid2[i][j] == 0:\\n                return True\\n            \\n            is_subisland = True\\n            if grid1[i][j] == 0:\\n                is_subisland = False\\n            \\n            grid2[i][j] = 0\\n            \\n            is_subisland = dfs(i+1, j) and is_subisland\\n            is_subisland = dfs(i-1, j) and is_subisland\\n            is_subisland = dfs(i, j+1) and is_subisland\\n            is_subisland = dfs(i, j-1) and is_subisland\\n            \\n            return is_subisland\\n        \\n        sub_islands = sum(grid2[i][j] and dfs(i, j) for i in range(m) for j in range(n))\\n        return sub_islands\\n```\n```go\\nfunc countSubIslands(grid1 [][]int, grid2 [][]int) int {\\n    m, n := len(grid2), len(grid2[0])\\n    var subIslands int\\n    \\n    for i := 0; i< m; i++ {\\n        for j := 0; j < n; j++ {\\n            if grid2[i][j] == 1 && dfs(i, j, grid1, grid2) {\\n                subIslands++\\n            }\\n        }\\n    }\\n    return subIslands\\n}\\n\\nfunc dfs(i, j int, grid1, grid2 [][]int) bool {\\n    if i < 0 || j < 0 || i == len(grid2) || j == len(grid2[0]) || grid2[i][j] == 0 {\\n        return true\\n    }\\n\\t\\n    isSubIsland := true\\n\\t\\n    if grid1[i][j] == 0 {\\n        isSubIsland = false\\n    }\\n\\t\\n    grid2[i][j] = 0\\n    \\n    isSubIsland = dfs(i+1, j, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i-1, j, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i, j+1, grid1, grid2) && isSubIsland\\n    isSubIsland = dfs(i, j-1, grid1, grid2) && isSubIsland\\n    \\n    return isSubIsland\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1919890,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    static int f=1;\\n    public int countSubIslands(int[][] g1, int[][] g2) {\\n        int c=0;\\n        for(int i=0;i<g2.length;i++)\\n        {\\n            for(int j=0;j<g2[0].length;j++)\\n            {\\n                if(g2[i][j]==1)\\n                {\\n                    f=1;\\n                    task(g1,g2,i,j);\\n                    c+=f;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    static void task(int[][] g1, int[][] g2, int i, int j)\\n    {\\n        if(i<0||j<0||i>=g2.length||j>=g2[0].length||g2[i][j]==0)\\n            return;\\n        if(g1[i][j]==0)\\n            f=0;\\n        g2[i][j]=0;\\n        task(g1,g2,i+1,j);\\n        task(g1,g2,i,j+1);\\n        task(g1,g2,i,j-1);\\n        task(g1,g2,i-1,j);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    static int f=1;\\n    public int countSubIslands(int[][] g1, int[][] g2) {\\n        int c=0;\\n        for(int i=0;i<g2.length;i++)\\n        {\\n            for(int j=0;j<g2[0].length;j++)\\n            {\\n                if(g2[i][j]==1)\\n                {\\n                    f=1;\\n                    task(g1,g2,i,j);\\n                    c+=f;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1913621,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSubIsland(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid2[i][j] == 2 || grid2[i][j] == 0)\\n            return true;\\n        if (grid2[i][j] == 3)\\n            return false;\\n        \\n        if (grid1[i][j] == 1) {\\n            grid2[i][j] = 2;\\n            bool res = isSubIsland(grid1, grid2, i - 1, j) && isSubIsland(grid1, grid2, i + 1, j) && isSubIsland(grid1, grid2, i, j - 1) && isSubIsland(grid1, grid2, i, j + 1);\\n            if (!res)\\n                grid2[i][j] = 3;\\n            return res;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        \\n        int subIslands = 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                if (grid2[i][j] == 1) \\n                    if (isSubIsland(grid1, grid2, i, j)) \\n                        subIslands++;\\n        return subIslands;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSubIsland(vector<vector<int>>& grid1, vector<vector<int>>& grid2, int i, int j) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        \\n        if (i < 0 || i >= m || j < 0 || j >= n || grid2[i][j] == 2 || grid2[i][j] == 0)\\n            return true;\\n        if (grid2[i][j] == 3)\\n            return false;\\n        \\n        if (grid1[i][j] == 1) {\\n            grid2[i][j] = 2;\\n            bool res = isSubIsland(grid1, grid2, i - 1, j) && isSubIsland(grid1, grid2, i + 1, j) && isSubIsland(grid1, grid2, i, j - 1) && isSubIsland(grid1, grid2, i, j + 1);\\n            if (!res)\\n                grid2[i][j] = 3;\\n            return res;\\n        }\\n        else \\n            return false;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int m = grid1.size();\\n        int n = grid1[0].size();\\n        \\n        int subIslands = 0;\\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                if (grid2[i][j] == 1) \\n                    if (isSubIsland(grid1, grid2, i, j)) \\n                        subIslands++;\\n        return subIslands;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901235,
                "title": "simple-c-dfs-based-solution",
                "content": "\\n\\n\\n    bool islands(int r, int c, vector<vector<int>> &grid1, vector<vector<int>>  &grid2)\\n    {\\n        if(r < 0 || c < 0 || r >= grid1.size() || c >= grid1[0].size())\\n            return true;\\n        \\n        if(grid1[r][c] == 0 && grid2[r][c] == 0)\\n            return true;\\n        else if(grid2[r][c] == 1 && grid1[r][c] == 0)\\n            return false;\\n        else if(grid1[r][c] == 1 && grid2[r][c] == 0)\\n            return true;\\n        \\n        grid1[r][c] = 0;\\n        grid2[r][c] = 0;\\n        \\n        bool l = islands(r,c-1,grid1,grid2);\\n        bool ri = islands(r,c+1,grid1,grid2);\\n        bool d = islands(r+1,c,grid1,grid2);\\n        bool u = islands(r-1,c,grid1,grid2);\\n        \\n        return l && ri && d && u;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int cnt = 0;\\n        for(int i=0; i<grid1.size(); i++)\\n        {\\n            for(int j=0; j<grid1[0].size(); j++)\\n            {\\n                if(grid2[i][j] == 1 && islands(i,j,grid1,grid2))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\n\\n\\n    bool islands(int r, int c, vector<vector<int>> &grid1, vector<vector<int>>  &grid2)\\n    {\\n        if(r < 0 || c < 0 || r >= grid1.size() || c >= grid1[0].size())\\n            return true;\\n        \\n        if(grid1[r][c] == 0 && grid2[r][c] == 0)\\n            return true;\\n        else if(grid2[r][c] == 1 && grid1[r][c] == 0)\\n            return false;\\n        else if(grid1[r][c] == 1 && grid2[r][c] == 0)\\n            return true;\\n        \\n        grid1[r][c] = 0;\\n        grid2[r][c] = 0;\\n        \\n        bool l = islands(r,c-1,grid1,grid2);\\n        bool ri = islands(r,c+1,grid1,grid2);\\n        bool d = islands(r+1,c,grid1,grid2);\\n        bool u = islands(r-1,c,grid1,grid2);\\n        \\n        return l && ri && d && u;\\n    }\\n    \\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        \\n        int cnt = 0;\\n        for(int i=0; i<grid1.size(); i++)\\n        {\\n            for(int j=0; j<grid1[0].size(); j++)\\n            {\\n                if(grid2[i][j] == 1 && islands(i,j,grid1,grid2))\\n                    cnt++;\\n            }\\n        }\\n        \\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1899039,
                "title": "c-simple-approach-dfs",
                "content": "class Solution {\\npublic:\\n    \\n    int flag;\\n    \\n    void helper(vector<vector<int>>& g1, vector<vector<int>>& g2,int n,int m,int i,int j,vector<vector<bool>>&visit)\\n    {\\n        if(i>=n||i<0||j<0||j>=m||g2[i][j]==0||visit[i][j])\\n        {\\n            return;\\n        }\\n        else if(g1[i][j]==0)// if g2 cell contain land but g1 cell contain water it means that island is not the suitable    for subisland.\\n        {\\n            flag=false;\\n            return;\\n        }\\n        \\n        visit[i][j]=true;\\n        int dx[]={-1,0,1,0};\\n        int dy[]={0,1,0,-1};\\n        for(int t=0;t<4;t++)\\n        {\\n            int x=i+dx[t];\\n            int y=j+dy[t];\\n            helper(g1,g2,n,m,x,y,visit);\\n        }\\n    }\\n    \\n    \\n    \\n    int countSubIslands(vector<vector<int>>& g1, vector<vector<int>>& g2) {\\n        int n=g1.size(),m=g1[0].size();\\n        int ans=0;\\n        vector<vector<bool>>visit(n,vector<bool>(m,false));\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {            \\n                flag=true;\\n                if(g2[i][j]==1&&!visit[i][j])\\n                {\\n                    helper(g1,g2,n,m,i,j,visit);\\n                    if(flag)\\n                    {\\n                        ans++;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int flag;\\n    \\n    void helper(vector<vector<int>>& g1, vector<vector<int>>& g2,int n,int m,int i,int j,vector<vector<bool>>&visit)\\n    {\\n        if(i>=n||i<0||j<0||j>=m||g2[i][j]==0||visit[i][j])\\n        {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1892244,
                "title": "c-two-time-of-dfs-easy-to-understand-89-83-faster",
                "content": "First DFS\\n\\nMark grid2 entries which are not sub-islands. Start by checking grid1[y][x]==0 and grid2[y][x]==1.\\n\\nSecond DFS;\\n\\nCount the number of rest islands. \\n\\n```\\nclass Solution {\\n    \\n    std::vector<std::vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void MarkZeros(vector<vector<int>>& grid, int yy, int xx) {\\n        grid[yy][xx] = 0;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        for(auto &dir:dirs) {\\n            int y = yy + dir[0];\\n            int x = xx + dir[1];\\n            if(y>=0&&y<rows&&x>=0&&x<cols&&grid[y][x]==1) {\\n                MarkZeros(grid, y, x);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        for(int y=0;y<rows;y++) {\\n            for(int x=0;x<cols;x++) {\\n                if(grid1[y][x]==0&&grid2[y][x]==1) {\\n                    MarkZeros(grid2, y, x);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int y=0;y<rows;y++) {\\n            for(int x=0;x<cols;x++) {\\n                if(grid2[y][x]==1) {\\n                    count++;\\n                    MarkZeros(grid2, y, x);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    std::vector<std::vector<int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n    \\n    void MarkZeros(vector<vector<int>>& grid, int yy, int xx) {\\n        grid[yy][xx] = 0;\\n        int rows = grid.size();\\n        int cols = grid[0].size();\\n        for(auto &dir:dirs) {\\n            int y = yy + dir[0];\\n            int x = xx + dir[1];\\n            if(y>=0&&y<rows&&x>=0&&x<cols&&grid[y][x]==1) {\\n                MarkZeros(grid, y, x);\\n            }\\n        }\\n    }\\n    \\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        int rows = grid1.size();\\n        int cols = grid1[0].size();\\n        for(int y=0;y<rows;y++) {\\n            for(int x=0;x<cols;x++) {\\n                if(grid1[y][x]==0&&grid2[y][x]==1) {\\n                    MarkZeros(grid2, y, x);\\n                }\\n            }\\n        }\\n        int count = 0;\\n        for(int y=0;y<rows;y++) {\\n            for(int x=0;x<cols;x++) {\\n                if(grid2[y][x]==1) {\\n                    count++;\\n                    MarkZeros(grid2, y, x);\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1720758,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1675218,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 2037578,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1987400,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1942212,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1880176,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1812243,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1803231,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1793146,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1788756,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1720758,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1675218,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 2037578,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1987400,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1942212,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1880176,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1812243,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1803231,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1793146,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            },
            {
                "id": 1788756,
                "content": [
                    {
                        "username": "mishrahimanshu2000",
                        "content": "`    private boolean dfs(int[][] grid1, int[][] grid2, int row, int col){\\n\\n        if(row<0 || row>=grid2.length || col<0 || col>=grid2[0].length || grid2[row][col]==0){\\n            return true;\\n        }\\n\\n        if(grid1[row][col] != 1){\\n            return false;\\n        }\\n\\n        grid2[row][col] = 0;\\n        \\n        return (dfs(grid1, grid2, row+1, col)  & dfs(grid1, grid2, row-1, col) & dfs(grid1, grid2, row, col+1) & dfs(grid1, grid2, row, col-1));\\n`\\n\\nin the last line of this code when I was using && instead of & it was giving the wrong answer why so?\\nCan anybody please help me out understanding the logic behind this?"
                    },
                    {
                        "username": "harshit_leetxurde",
                        "content": "yeah! I too tried this and got the same issue, if anyone here could help with this, please do the needfull."
                    },
                    {
                        "username": "roeycode",
                        "content": "so confused. why?"
                    },
                    {
                        "username": "tu_22",
                        "content": "variation of 200. Number of Islands"
                    },
                    {
                        "username": "A_Y",
                        "content": "class Solution {\\nbool isValid(int r, int c, vector<vector<int>>& matrix) {\\n\\treturn ((r >= 0 && r < (int)matrix.size()) && (c >= 0 && c < (int)matrix[0].size()));\\n}\\n\\nvoid dfs_connection(vector<vector<int>>& grid2,vector<vector<int>>&grid1, vector<vector<bool>>& visited , int i , int j , bool& check) {\\n\\tif (!isValid(i, j, grid2) || visited[i][j] || grid2[i][j] != 1)\\n\\t\\treturn;\\n\\n\\tif (grid2[i][j] == 1 && grid2[i][j] != grid1[i][j])\\n\\t\\tcheck = true;\\n\\n\\tvisited[i][j] = true;\\n\\n\\tint dr[] = { -1 , 0, 1, 0 };\\n\\tint dc[] = { 0 , 1 , 0, -1 };\\n\\tfor (auto d = 0; d < 4; ++d)\\n\\t\\tdfs_connection(grid2,grid1, visited, i + dr[d], j + dc[d] , check);\\n}\\npublic:\\n    int countSubIslands(vector<vector<int>>& grid1, vector<vector<int>>& grid2) {\\n        vector<vector<bool>>visited(grid2.size(), vector<bool>(grid2[0].size()));\\n\\n        int cnt = 0;\\n        bool check = false;\\n\\n        for (auto i = 0; i < (int)grid2.size(); ++i)\\n            for (auto j = 0; j < (int)grid2[i].size(); ++j) {\\n\\n                if (!visited[i][j] && grid2[i][j]) {\\n                    dfs_connection(grid2, grid1, visited, i, j , check);\\n                    \\n                    check ? check = false : ++cnt;\\n                }\\n            }\\n\\n        return cnt;\\n    }\\n};"
                    },
                    {
                        "username": "webguru77777",
                        "content": "Some test cases:\\n\\ngrid1=\\n```\\n[[1, 0, 1, 1, 1, 0], [1, 1, 0, 1, 0, 1], [0, 0, 1, 1, 1, 1], [1, 1, 1, 0, 0, 1], [1, 0, 1, 0, 1, 0]]\\n```\\ngrid2=\\n```\\n[[0, 0, 1, 1, 0, 1], [1, 1, 1, 1, 0, 0], [1, 0, 0, 0, 1, 0], [0, 0, 0, 1, 0, 1], [1, 0, 0, 1, 0, 0]]\\n```\\n\\ngrid1=\\n```\\n[[0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 1, 1, 1]]\\n```\\ngrid2=\\n```\\n[[1, 1, 1, 0, 1, 0, 1, 0, 1, 0], [1, 0, 1, 1, 0, 0, 0, 1, 0, 0], [1, 0, 1, 0, 1, 1, 0, 1, 1, 0]]\\n```\\n\\nPython script to generate test cases\\n```\\nimport random\\nimport json\\n\\nm, n = 10, 30\\nprint(\"grid1=\")\\ngrid1 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid1))\\nprint(\"grid2=\")\\ngrid2 = [[random.randint(0, 1) for _ in range(n)] for _ in range(m)]\\nprint(json.dumps(grid2))\\n\\n```"
                    },
                    {
                        "username": "Gurudev18",
                        "content": "class Solution {\\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\\n        int count = 0;\\n        for (int i = 0; i < grid1.length; i++) {\\n            for (int j = 0; j < grid1[0].length; j++) {\\n                if (grid2[i][j] == 1) {\\n                    if (count(i, j, grid1, grid2)) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n    public boolean count(int i, int j, int[][] grid1, int[][] grid2) {\\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\\n            return true;\\n        }\\n        if (grid1[i][j] == 0) {\\n            return false;\\n        }\\n        grid2[i][j] = 0;\\n        return count(i + 1, j, grid1, grid2) &&\\n               count(i - 1, j, grid1, grid2) &&\\n               count(i, j + 1, grid1, grid2) &&\\n               count(i, j - 1, grid1, grid2);\\n    }\\n}\\n\\nInput\\ngrid1 =\\n[[1,0,1,0,1],[1,1,1,1,1],[0,0,0,0,0],[1,1,1,1,1],[1,0,1,0,1]]\\ngrid2 =\\n[[0,0,0,0,0],[1,1,1,1,1],[0,1,0,1,0],[0,1,0,1,0],[1,0,0,0,1]]\\nOutput\\n3\\nExpected\\n2\\n\\nsomeone correct the code\\n"
                    },
                    {
                        "username": "chinmaysk_19",
                        "content": "Question should me more clear.\nIt would say the particular cell of grid1 should be 1 also as it was in grid2."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is the Approach:-\n\nInitialize a counter variable subislands to 0, and two 2D arrays visited1 and visited2 of size m x n, where m and n are the number of rows and columns of the input grids respectively. visited1 and visited2 will be used to mark the visited cells of grid1 and grid2 respectively.\n\nTraverse each cell of grid2 in row-major order, and for each land cell that has not been visited yet, perform a BFS to visit all the cells in the current island in grid2. While visiting the cells, check if the corresponding cell in grid1 is also a land cell. If it is not, then set a match variable to false.\n\nAfter visiting all the cells in the current island, check the value of match. If match is still true, it means that all the cells in the current island are present in grid1, so increment the subislands counter by 1.\n\nReturn the subislands counter as the final result."
                    },
                    {
                        "username": "xeniawann",
                        "content": "I think there\\'s no need for `visited1` right? Since we only do BFS on grid2."
                    },
                    {
                        "username": "vedantalim",
                        "content": "Can anyone tell me why DFS traversal but BFS does not?\\nI tried both but could not get rid of TLE in BFS at all.\\nBFS being iterative is said to be faster than DFS which has recursive calls overhead, but still I have this observation. \\nPlease answer if anyone knows."
                    },
                    {
                        "username": "2uringTested",
                        "content": "One thing which can cause TLE in bfs is that you may be marking the cells visited after popping from the queue. You have to mark the cells visited just as you are entering them to ensure you dont get a TLE"
                    },
                    {
                        "username": "neo9729",
                        "content": "Why is this code working\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag and dfs(i + 1, j)\\n            flag = flag and dfs(i, j + 1)\\n            flag = flag and dfs(i - 1, j)\\n            flag = flag and dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`\\n\\nand this one is not\\n `fun countSubIslands(grid1: Array<IntArray>, grid2: Array<IntArray>): Int {\\n        var result = 0\\n        fun dfs(i: Int, j: Int): Boolean {\\n            if(i < 0 || j < 0 || i >= grid2.size || j >= grid2[i].size || grid2[i][j] == 0) return true\\n            var flag: Boolean = grid1[i][j] == 1\\n            grid2[i][j] = 0\\n            flag = flag && dfs(i + 1, j)\\n            flag = flag && dfs(i, j + 1)\\n            flag = flag && dfs(i - 1, j)\\n            flag = flag && dfs(i, j - 1)\\n            return flag\\n        }\\n        for(i in grid2.indices) {\\n            for(j in grid2[i].indices) {\\n                if(grid2[i][j] == 1 && dfs(i, j)) {\\n                        result++  \\n                }\\n            }\\n        }\\n\\n        return result\\n    }`"
                    },
                    {
                        "username": "kajoldec",
                        "content": "https://leetcode.com/problems/count-sub-islands/submissions/891816086/ - this is my solution for this problem, I am getting wrong answer for one of the test case. Not able to figure out which edge case i am missing. Can someone pls take a look and let me know what is wrong in the code?"
                    }
                ]
            }
        ]
    }
]