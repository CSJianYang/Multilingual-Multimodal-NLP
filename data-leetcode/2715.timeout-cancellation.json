[
    {
        "title": "Row With Maximum Ones",
        "question_content": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n&nbsp;\nExample 1:\n\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\n\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\n\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n&nbsp;\nConstraints:\n\n\tm == mat.length&nbsp;\n\tn == mat[i].length&nbsp;\n\t1 <= m, n <= 100&nbsp;\n\tmat[i][j] is either 0 or 1.",
        "solutions": [
            {
                "id": 3421712,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int val=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    val++;\\n                }\\n            }\\n            if(val>max)\\n            {\\n                index=i;\\n                max=val;\\n            }\\n        }\\n        return new int[]{index,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421887,
                "title": "easy-solution-with-explaination",
                "content": "# Intuition\\nThe basic idea is to iterate over all rows of the matrix, and count the number of ones in each row. We keep track of the row with the maximum count of ones seen so far, and update it whenever we find a row with a larger count.\\n\\n# Approach\\nTo count the number of ones in a row, we simply iterate over all elements of the row and add up the ones.\\n\\nFinally, we return the index of the row with the maximum count of ones, along with the count itself, as a vector of two integers. If there are multiple rows with the maximum count, we return the one with the smallest row number, which is the first one encountered in the loop.\\n\\n# Complexity\\n- Time complexity:\\nThe solution has a time complexity of O(mn), which is the size of the matrix, since we need to iterate over all its elements. This is optimal, since we need to examine all rows and elements to determine the maximum count of ones.\\n\\n- Space complexity:\\nSpace complexity is O(1), since we aren\\'t using any extra space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int maxCount = 0;\\n        int maxRow = 0;\\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                count += mat[i][j];\\n            }\\n            if (count > maxCount) {\\n                maxCount = count;\\n                maxRow = i;\\n            }\\n        }\\n        return {maxRow, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421854,
                "title": "easiest-solution-python3",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:    \\n        ones = 0 \\n        index = 0\\n        for it, row in enumerate(mat):\\n            c = row.count(1)\\n            if ones < c:\\n                ones = c\\n                index = it\\n        \\n        return [index,ones]\\n",
                "codeTag": "Java"
            },
            {
                "id": 3421700,
                "title": "c-bruteforce",
                "content": "**Count Ones in each row and update the answer**\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        //         {index,frequency}\\n        vector<int> res{-1, -1};\\n        for(int i = 0; i < mat.size(); ++i){\\n            int one = count(mat[i].begin(), mat[i].end(), 1);\\n            if(one > res[1])\\n                res = {i, one};\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422458,
                "title": "c-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n * m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2);\\n        int ones = 0;\\n        for(int i = 0; i < mat.size(); i++) {\\n            for(int j = 0; j < mat[0].size(); j++) {\\n                if(mat[i][j] == 1) ones++;\\n            }\\n            if(ones > ans[1]) {\\n                ans[0] = i;\\n                ans[1] = ones;\\n            }\\n            ones = 0;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421881,
                "title": "simple-java-easy-explanation",
                "content": "# Intuition\\n\\nA straightforward method is to iterate through each row of the array and count the number of ones in each row. We can then keep track of the maximum number of ones seen so far and the index of the row with the maximum number of ones. At the end, we can return the index of the row with the maximum number of ones.\\n\\nTo implement this, we use two nested loops and one variable:\\n\\n\\u2022 \\'rowCount\\' to track the count of 1\\'s in each row.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n\\n# Complexity\\n- Time complexity:  O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i=0; i<mat.length; i++){\\n            int rowCount = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    rowCount++;\\n                }\\n            }\\n            if(rowCount > arr[1]){\\n                arr[1] = rowCount;\\n                arr[0] = i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421837,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxVal=0,ind=-1,c=0;\\n        \\n        for(int i=0;i<mat.size();i++){\\n            c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]){\\n                    c++;\\n                }\\n            }\\n            if(c > maxVal){\\n                maxVal = c;\\n                ind=i;\\n            }\\n        }\\n        if(ind==-1){\\n            return vector<int> {0,0};\\n        }\\n        return vector<int> {ind,maxVal};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421675,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[]=new int[2];\\n        int max=0;\\n        int ind=0;\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>max){\\n                max=count;\\n                ind=i;\\n            }\\n        }\\n        ans[0]=ind;\\n        ans[1]=max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510886,
                "title": "python-go-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\\n# Go\\u2705\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        output = [0,0]\\n        for index, item in enumerate(mat):\\n            one_count = item.count(1)\\n            if one_count > output[1]:\\n                output[0] = index\\n                output[1] = one_count\\n        return output\\n\\n```\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    output := []int{0,0}\\n    for index, item := range mat {\\n        oneCount := 0\\n        for _, v := range item {\\n            if v == 1{\\n                oneCount++\\n            }\\n        }\\n        if oneCount > output[1] {\\n            output[0] = index\\n            output[1] = oneCount\\n        }\\n    }\\n    return output\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503602,
                "title": "simple-sort-solution",
                "content": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        list1=[]\\n        for ind,row in enumerate(mat):\\n            list1.append([ind,row.count(1)])\\n        list1.sort(key=lambda x:[-x[1],x[0]])\\n        return list1[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459775,
                "title": "java-easy-soln-o-row-col",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat){\\n        int ans[]=new int [2];\\n        int maxSum=0;\\n        int row=0;\\n        for(int i=0;i<mat.length;i++){\\n            int sum=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j]!=0) sum+=1;\\n                }\\n                if(sum>maxSum){\\n                maxSum=sum;\\n                row=i;\\n            }\\n            }\\n        ans[0]=row;\\n        ans[1]=maxSum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423453,
                "title": "java-6ms-beats-85-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int index=0;\\n        int maxOne=0;\\n        \\n        for(int i=0; i<mat.length; i++){\\n            int rowOnes=0;\\n//to count the number of ones in each row\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1) rowOnes++;\\n            }\\n            if(rowOnes>maxOne){\\n//checking whether the number of ones if maximum till now and updatng its value\\n                index=i;\\n                maxOne=rowOnes;\\n            }\\n        }\\n        \\n//creating a new array and returning it with the row number and number of ones in it\\n        return new int[]{index,maxOne};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421932,
                "title": "easy-solution-go-c",
                "content": "Initialize variables c and m to 0. c represents the index of the row with the maximum count of ones, and m represents the number of ones in that row.\\n\\nIterate over each row i in the matrix using a for loop. For each row i, initialize a temporary variable temp to 0, which will count the number of ones in the row.\\n\\nIterate over each column j in the current row i using another for loop. For each cell in the row, if the value is 1, increment the value of temp by 1.\\n\\nCompare the value of temp with the current maximum count of ones m. If temp is greater than m, update the values of c and m to the current row i and the number of ones in the row temp, respectively.\\n\\nOnce all rows have been iterated, return an array containing the index of the row with the maximum count of ones c and the number of ones in that row m.\\n# Complexity\\n- Time complexity: $$O(m*n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nGo\\n```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\\nC#\\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```\\n![a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png](https://assets.leetcode.com/users/images/cc82e8aa-dc98-4f10-af4c-64b1528c0fb6_1680844232.130332.png)",
                "solutionTags": [
                    "C#",
                    "Go"
                ],
                "code": "```\\nfunc rowAndMaximumOnes(mat [][]int) []int {\\n    var c, m int\\n\\n    for i := 0; i < len(mat); i++ {\\n        temp := 0\\n        for j := 0; j < len(mat[i]); j++ {\\n            if mat[i][j] == 1 {\\n                temp++\\n            }\\n        }\\n\\n        if temp > m {\\n            m = temp\\n            c = i\\n        }\\n    }\\n\\n    return []int{c, m}\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] RowAndMaximumOnes(int[][] mat) {\\n        var c = 0;\\n        var m = 0;\\n\\n        for (var i = 0; i < mat.Length; i++)\\n        {\\n            var temp = 0;\\n            for (var j = 0; j < mat[i].Length; j++)\\n            {\\n                if (mat[i][j] == 1)\\n                {\\n                    temp++;\\n                }\\n            }\\n\\n            if (temp > m)\\n            {\\n                m = temp;\\n                c = i;\\n            }\\n        }\\n\\n        return new[] {c, m};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421897,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0};\\n        int i,j,m=mat.size(),n=mat[0].size(),x;\\n        for(i = 0; i < m; i++){\\n            x = 0;\\n            for(j = 0; j < n; j++){\\n                x += mat[i][j];\\n            }\\n            if(x>ans[1]){\\n                ans = {i,x};\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans = {0,0}",
                "codeTag": "Java"
            },
            {
                "id": 3421891,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    countone++;\\n                }\\n        }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n             }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421778,
                "title": "clean-easy-java-solution",
                "content": "\\n```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row=0, maxOnes=0;\\n        for(int i=0; i<mat.length; i++){\\n            int ones = 0;\\n            for(int j=0; j<mat[0].length; j++)\\n                if(mat[i][j] == 1) ones++;\\n            if(maxOnes < ones){\\n                row = i;\\n                maxOnes = ones;\\n            }\\n        }\\n        return new int[]{row,maxOnes};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044301,
                "title": "beats-100-beginner-friendly-approach-using-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int count, ansY=0, ansX=0;\\n        for(int i=0; i<mat.size();i++){\\n            count = 0;\\n            for(int j=0; j<mat[0].size();j++){\\n              count+=mat[i][j];\\n            }\\n            if(count>ansY){\\n                ansY=count;\\n                ansX=i;\\n            }\\n        }\\n\\n        return {ansX,ansY};\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596424,
                "title": "simple-brute-force-approach-tc-o-m-n-sc-o-1",
                "content": "\\n\\n# Approach\\nUse Nested loops & traverse on the complete matrix & just check the conditions & maitain the maxi variable\\n\\n# Complexity\\n- Time complexity: O( m*n )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n        int m = matrix.size(); // no. of rows\\n        int n = matrix[0].size(); //no. of column\\n        int maxi = 0 , cnt =0;\\n        int index = 0; // if no row found still retrun 0\\n        for(int i =0 ; i<m ;i++){\\n               cnt = 0;\\n            for(int j =0 ;j<n; j++){\\n                if(matrix[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > maxi ){\\n                index = i;\\n            }\\n            maxi = max(maxi, cnt);\\n          \\n        }\\n    \\n    return {index , maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478298,
                "title": "easy-beginner-friendly-faster-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     int res = 0, mx = 0;\\n        for(int i = 0 ; i < mat.size() ; i++) {\\n            int one = 0;\\n            for(int j = 0 ; j < mat[0].size() ; j++) one += (mat[i][j] == 1);\\n            if(one > mx) {\\n                mx = one;\\n                res = i;\\n            }\\n        }\\n        return {res, mx};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431777,
                "title": "dfs-solution-different-approach-full-explanation-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe dfs function is a helper function that performs a depth-first search (DFS) traversal on the input matrix mat starting from the cell at index (i, j). It uses recursion to explore neighboring cells in the matrix and counts the number of 1s encountered. It also marks the visited cells by setting their value to -1. This function updates the count parameter by reference, which keeps track of the number of 1s encountered during the traversal.\\n\\nThe rowAndMaximumOnes function is the main function that solves the problem. It takes a 2D vector mat as input, representing the matrix of 0s and 1s. The goal is to find the row in the matrix that contains the maximum number of 1s, and return that row index along with the count of 1s in that row.\\n\\nThe function iterates through the cells of the matrix using nested for-loops. For each cell that contains a 1, it calls the dfs function to count the number of 1s in the connected component of that 1. It keeps track of the maximum count of 1s encountered and the corresponding row index. It also uses some additional variables, such as prevCount and prevRow, to optimize the DFS traversal by reusing the count from the previous row if the current row is the same as the previous row. Finally, the function returns the row index and the maximum count of 1s as a vector of two integers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<int>>& mat,int i,int j,int &count){\\n\\n        if(i>=mat.size() || i<0 || j>=mat[0].size() || j<0){\\n            return;\\n        }\\n        if(mat[i][j]==1){\\n\\n            mat[i][j]=-1;\\n            count++;\\n            dfs(mat,i,j+1,count);\\n            dfs(mat,i,j-1,count);\\n        }\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCountRow,maxCount=0;\\n        int prevCount=0;\\n        int prevRow=-1;\\n        for(int i=0;i<mat.size();i++){\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1){\\n                    int count=0;\\n                    if(i==prevRow){\\n                        count = prevCount;\\n                    }\\n                    \\n                    dfs(mat,i,j,count);\\n                    if(count>maxCount){ maxCount=count; maxCountRow=i;}\\n                    prevCount=count;\\n                    prevRow = i;\\n                }\\n            }\\n        }\\n\\n        return {maxCountRow,maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3427083,
                "title": "easy-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row=0\\n        value=0\\n        for i,j in enumerate(mat):\\n            one=j.count(1)\\n            if one>value:\\n                value=one\\n                row=i\\n        return [row, value]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3423064,
                "title": "rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Array",
                    "Math",
                    "Iterator"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.into_iter().enumerate() {\\n            let ones = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if ones > res[1] {\\n                res[0] = i as i32;\\n                res[1] = ones;\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422647,
                "title": "python3-solutions-with-explanation-enumeration-numpy",
                "content": "\\u0421ount ones within rows and update index if number of ones exceeds current maximum\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\\nI would say it is a slower version, but at least something different:\\n1) Find indices of elements within rows that contain ones\\n2) Count occurrences of these elements along the rows\\n3) If there are ones, we output the index of the row containing the maximum number of ones, otherwise we return zeros as index and maximum count ones\\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        row_idx, max_ones = 0, 0\\n    \\n        for idx, row in enumerate(mat):\\n            cur_ones = sum(row)\\n\\n            if cur_ones > max_ones:\\n                row_idx, max_ones = idx, cur_ones\\n\\n        return [row_idx, max_ones]\\n```\n```\\nimport numpy as np\\n\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        ones = np.where(np.array(mat) == 1)[0]\\n        counts = np.bincount(ones)\\n        \\n        return [np.argmax(counts), counts[np.argmax(counts)]] if sum(counts) else [0, 0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421883,
                "title": "c-easy-peasy-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_count = 0;\\n        int max_row_index = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        \\n        for (int i = 0; i < m; i++) {\\n            int count = 0;\\n            for (int j = 0; j < n; j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            if (count > max_count) {\\n                max_count = count;\\n                max_row_index = i;\\n            }\\n        }\\n        \\n        if (max_row_index == -1) {\\n            return {0, 0};\\n        }\\n        \\n        vector<int> result = {max_row_index, max_count};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421864,
                "title": "c-linear-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $O(n*m)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size(),m=mat[0].size();\\n        vector<int> ans(2,0);\\n        for(int i=0;i<n;i++){\\n            for(int j=1;j<m;j++){\\n                mat[i][j]+=mat[i][j-1];\\n            }\\n            if(mat[i][m-1]>ans[1]){\\n                ans[0]=i;\\n                ans[1]=mat[i][m-1];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421800,
                "title": "java-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int maxCount = 0;\\n        int index = 0;\\n        \\n        for(int i = 0; i < mat.length; i++) {\\n            int countOne = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    countOne++;\\n                }\\n            }\\n            \\n            if(countOne > maxCount) {\\n                maxCount = countOne;\\n                index = i;\\n            }\\n        }\\n        return new int[] {index, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037301,
                "title": "easy-solution-in-c-2beats-86-31-of-users-with-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n//initilize a vector to store answer to return mac row with max ones\\n        vector<int>ans;\\n//it store row with max ones\\n        int maxrow=-1;\\n//it store max number of ones in a row\\n        int maxones=-1;\\n        int row=mat.size();\\n        for(int i=0;i<row;i++){\\n//count max ones in a row\\n            int countones=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    countones++;\\n                }\\n            }\\n//compare the maxones with countones and update \\n            if(maxones<countones){\\n                maxones=countones;\\n                maxrow=i;\\n            }\\n        }\\n//push in a vector to return answer\\n        ans.push_back(maxrow);\\n        ans.push_back(maxones);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3927224,
                "title": "easy-solution-for-begginer-fast-than-90-18-best-memory-than-99-14",
                "content": "![Screenshot_307.png](https://assets.leetcode.com/users/images/13fcd1a5-36fc-46f8-9070-42c6b3c3ae79_1692366483.620762.png)\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxValue = 0\\n        index = 0\\n        for m in range(len(mat)):\\n            sumN = 0\\n            sumN = sum(mat[m])\\n            if sumN > maxValue:\\n                index =  m\\n            maxValue=max(maxValue,sumN)\\n        return [index,maxValue]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806426,
                "title": "easy-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        Map<Integer,Integer>hash=new HashMap<>();\\n          int [] arr=new int[2];\\n\\n       for(int i=0;i<mat.length;i++){\\n           int max=0;\\n           for(int j=0;j<mat[i].length;j++){\\n                max+=mat[i][j];\\n           }\\n           hash.put(i,max);\\n       }\\n       int ind=0;\\n       int val=Integer.MIN_VALUE;;\\n        for(int i=0;i<hash.size();i++){\\n            if(val<hash.get(i)){\\n                val=hash.get(i);\\n                ind=i;\\n            }\\n        }\\narr[0]=ind;\\narr[1]=val;\\n               return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802330,
                "title": "binary-search-method",
                "content": "# Intuition\\n**Binary Search**\\n\\n# Approach\\n- traverse through matrix \\n- count the no. of 1s present in it using binary search\\n- for Binary search I have used function , which first sorts the row and the searches for the 1st One [ 0 0 0 **1** 1 1 1] \\n- when the while loop ends , our low will be pointing to the 1st One index\\n- total number of 1s present. = (n-1)-low+1 ( same as length of the sliding window j-i+1)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n O(N * NlogN) // here this could be optimised if we use linear search ,    because in that we don\\'t requie to sort the row, which could save our **nlogn** time\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint noOfOnes(vector<int>&row,int n){\\n    if(n==1)return row[0]==1;\\n    int low =0;\\n    int high = n-1;\\n    sort(row.begin(),row.end());\\n\\n    while(low<=high){\\n        int mid = low+(high-low)/2;\\n\\n        if(row[mid]==1){\\n            high = mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return (n-1)-low+1;\\n}\\nvector<int> rowAndMaximumOnes(vector<vector<int>>& matrix) {\\n   int max1=0;\\n   int indexOfMaxRow=0;\\n   int n= matrix.size();\\n       int m = matrix[0].size();\\n   for(int i=0;i<n;i++){\\n       int OneINThisRow = noOfOnes(matrix[i],m);\\n       if(OneINThisRow>max1){\\n           max1=OneINThisRow;\\n           indexOfMaxRow = i;\\n       }\\n   }\\n   return {indexOfMaxRow,max1};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700572,
                "title": "row-with-maximum-ones-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum = 0;\\n        int index = 0;\\n        int count = 0;\\n\\n        for(int i=0; i<mat.length; i++){\\n            count = 0;\\n            for(int j=0; j<mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > sum){\\n                sum = count;\\n                index = i;\\n            }\\n        }\\n        int[] arr ={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692917,
                "title": "very-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```\\n![leetcode upvote.jpg](https://assets.leetcode.com/users/images/4e3da845-1bff-4b18-b600-051d45d0cc61_1687953880.5652628.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcount=0;\\n        int index=0;\\n        for(int i=0;i<mat.size();i++){\\n            int countone=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1)\\n                    countone++;\\n                }\\n             if(countone>maxcount){\\n                 maxcount=countone;\\n                index=i;\\n                }\\n        }\\n        return{index,maxcount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541374,
                "title": "simple-java-solution-for-beginners-2ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count;\\n        int maxCount = 0;\\n        int maxCountRow = 0;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[0].length; j++) {\\n                count += mat[i][j];\\n            }\\n            if(count > maxCount) {\\n                maxCount = count;\\n                maxCountRow = i;\\n            }\\n        }\\n        return new int[]{maxCountRow, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541346,
                "title": "simple-java-solution-for-beginners-5ms-beats-84-48",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int arr[] = new int[2];\\n        int count;\\n        int maxCount = Integer.MIN_VALUE;\\n        int maxCountIndex = -1;\\n        for(int i = 0; i < mat.length; i++) {\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            maxCountIndex = count > maxCount ? i : maxCountIndex;\\n            maxCount = Integer.max(count, maxCount);\\n        }\\n        arr[0] = maxCountIndex;\\n        arr[1] = maxCount;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3519424,
                "title": "beginners-friendly-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    keep track of count of 1 for every row and \\n    update the row and max when we encounter greater count of 1 than \\n    previous\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0;\\n        int row=0;\\n        \\n\\n        for(int i=0;i<mat.length;i++){\\n            int count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) count++;\\n            }\\n            if(count>max){\\n                max= count;\\n                row=i;\\n            }\\n            \\n        }\\n\\n        return new int[] {row,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3484456,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted([(ind,val.count(1)) for ind,val in enumerate(mat)],key=lambda x:[-x[1],x[0]])[0]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455090,
                "title": "easy-solution-with-javascript-just-checkout-how-much-it-s-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n**2)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let ans=[-1,-1];\\n    let row=mat.length;\\n    let col=mat[0].length;\\n\\n    for(let i=0; i<row; i++){\\n        let zero=0;\\n        let ones=0;\\n        for(let j=0; j<col; j++){\\n            if(mat[i][j]==0){\\n                zero++;\\n            }else{\\n                ones++;\\n            }\\n        }\\n        let max=Math.max(ones, ans[1]);\\n        if(max>ans[1]){\\n            ans[0]=i;\\n            ans[1]=max;\\n        }\\n        \\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3434594,
                "title": "rust-sum-approach",
                "content": "Sum all the values to count number of 1s as it is just 1s and 0s. No need to filter.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut ans: Vec<i32> = vec![0,0];\\n        for (i, row) in mat.iter().enumerate(){\\n            let mut count: i32 = row.iter().sum();\\n            if count > ans[1]{\\n                ans[1] = count;\\n                ans[0] = i as i32;\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3432302,
                "title": "easy-iteration-and-updation-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1.For the counting the numbers of ones we have iterate in the matrix of rach row \\n2.then we have find the maximum value so we check by the comparision  if count of the one greater than max value then update\\n3.if it is equal then we have to we have to choose the min index value\\n \\nThis three points we have take in the mind\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple by iterating in the matrix finding count of ones and calculate the maximum count and we have to fing min value if its index if the count is same.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n0(n^2)\\n\\n<b> Easy question of Leetcode give me self satisfaction\\uD83D\\uDE02\\uD83D\\uDE02\\n![Bom dia ,Boa tarde ,Boa noite.png](https://assets.leetcode.com/users/images/dad35698-7331-414e-8f1c-acd427e371a7_1681842257.8646004.png)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        count=0\\n        max1=0\\n        ind=0\\n        for i in range (len(mat)):\\n            for j in range (len(mat[0])):\\n                if mat[i][j]==1:\\n                    count+=1\\n            if count>max1:\\n                max1=count\\n                ind=i\\n            elif max1==count:\\n                ind=min(ind,i)\\n            count=0\\n                \\n        return [ind,max1]\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3425963,
                "title": "counting-must-see",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& v) \\n    {\\n        int onecount = 0;\\n        int rowidx = 0;\\n        for(int i=0;i<v.size();i++)\\n        {\\n            int count = 0;\\n            for(int j=0;j<v[i].size();j++)\\n            {\\n                if(v[i][j] == 1) count++;\\n            }\\n            if(onecount < count)\\n            {\\n                onecount = count;\\n                rowidx = i;\\n            }\\n        }\\n        return {rowidx ,onecount};    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424763,
                "title": "c-easy-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int cnt=0, pos=0;\\n        for (int i=0; i<mat.size(); i++){\\n            int curr=0;\\n            for (int j=0; j<mat[0].size(); j++){\\n                if (mat[i][j]==1)curr++;\\n            }\\n            if (curr>cnt){\\n                cnt= curr;\\n                pos= i;\\n            }\\n        }\\n        return {pos,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424612,
                "title": "no-explanation-required",
                "content": "\\n# Solution:\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```\\n### Time complexity: $$O(nm)$$",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0, row = 0;\\n        for (int i = 0; i < mat.length; i++) {\\n            int ct = 0;\\n            for (int j = 0; j < mat[0].length; j++) {\\n                ct += mat[i][j];\\n            }\\n            if (ct > max) {\\n                max = ct;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3424231,
                "title": "python3-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        indicies = []\\n        for r in range(len(mat)):\\n            indicies.append(r)\\n        counts = []\\n        for row in mat:\\n            counts.append(row.count(1))\\n        for i in indicies:\\n            if counts[i] == max(counts):\\n                return [i, counts[i]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422669,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        n=len(mat)\\n        m=len(mat[0])\\n        row,count_one=0,0\\n        for i in range(n):\\n            one=0\\n            for j in range(m):\\n                if mat[i][j]==1:\\n                    one+=1\\n\\n            if one>count_one:\\n                count_one=one\\n\\n                row=i\\n\\n        return [row,count_one]                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422559,
                "title": "simple-and-easy-solution-easy-to-understand",
                "content": "# Intuition\\n**Just thought to update maxim whenever count exceedes maxim.**\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>grid) {\\n        int n=grid.size();\\n        int m=grid[0].size();\\n        int maxim=INT_MIN;\\n        bool falg=true;\\n        int z;\\n        int count;\\n        vector<int>arr;\\n        vector<pair<int,int>>v_p;\\n        for(int i=0; i<n; i++)\\n        {\\n            count=0;\\n            for(int j=0; j<m; j++)\\n            {\\n                if(grid[i][j]>0)\\n                {\\n                    count++;\\n                }\\n                \\n            }\\n           \\n            if(count>maxim)\\n            {\\n                z=i;\\n               maxim=max(maxim,count);\\n            }\\n            \\n            \\n        }\\n      arr.push_back(z);\\n      arr.push_back(maxim);\\n        return arr;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422292,
                "title": "very-easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n=mat.length;\\n        int m=mat[0].length;\\n        int ans[]=new int[2];\\n        \\n        int max=0;\\n        for(int i=0;i<n;i++){\\n            int countOnes=0;\\n            \\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                    countOnes++;\\n                }\\n            }\\n            if(countOnes>max){\\n                max=countOnes;\\n                ans[0]=i;\\n                ans[1]=max;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422251,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let mut res = vec![-1, -1];\\n        for (i, row) in mat.iter().enumerate() {\\n            let one = row.iter().filter(|&&x| x == 1).count() as i32;\\n            if one > res[1] {\\n                res = vec![i as i32, one];\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3422112,
                "title": "easyapproach-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. We initialize maxCount and maxRowIndex to 0. Then we loop through all the rows of the matrix mat.\\n\\n 2. For each row, we count the number of ones in it by looping through all its elements. \\n\\n3. If this count is greater than the current maximum count, we update maxCount and maxRowIndex.\\n\\n 4. Finally, we return an array containing maxRowIndex and maxCount.\\n\\n5. To ensure that the row with the smallest row number is selected in case of multiple rows with the maximum count of ones, we can modify the code to check for the smallest row number while updating the maxRowIndex.\\n\\n6. In addition to checking if count > maxCount, we also check if count == maxCount and the current row index i is less than maxRowIndex.\\n\\n 7. If these conditions are true, we update maxRowIndex to the current row index i.\\n\\n - 8. This ensures that we always select the row with the smallest row number among the rows with the maximum count of ones.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nxn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n    int maxCount = 0;\\n    int maxRowIndex = 0;\\n\\n    for (int i = 0; i < mat.length; i++) {\\n        int count = 0;\\n        for (int j = 0; j < mat[i].length; j++) {\\n            if (mat[i][j] == 1) {\\n                count++;\\n            }\\n        }\\n\\n        if (count > maxCount || (count == maxCount && i < maxRowIndex)) {\\n            maxCount = count;\\n            maxRowIndex = i;\\n        }\\n    }\\n\\n    return new int[] { maxRowIndex, maxCount };\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422079,
                "title": "optimized-java-solution-easy-structured-with-comments-and-approach",
                "content": "# Approach\\nIn this problem, we will simply iterate through the 2D array and keep track of count of 1 in that row.\\n\\nwe will store the max count in index 1 of ans array and row with max count at index 0.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(M*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        // {index, maxCount}\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            // number of 1 in ith row\\n            int count=0;\\n\\n            // getting count of 1s\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n\\n            // checking for maximum count\\n            if(count>ans[1]){\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422002,
                "title": "best-c-well-explained-linear-time",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\njust traverse every row and count  the number of one. and compare it with the maximum oneCnt\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n***O(row * column)***\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n***O(1)***\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int r=0, maxi=0;\\n        for(int i=0; i<mat.size(); i++) {\\n            int cnt = 0;\\n            for(int j=0; j<mat[0].size(); j++)  if(mat[i][j] == 1)  cnt++;\\n            if(cnt > maxi)  {\\n                maxi = cnt;\\n                r = i;\\n            }\\n        }\\n        return {r, maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421908,
                "title": "javascript-simple-one-line-109ms",
                "content": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sort",
                    "Matrix"
                ],
                "code": "```\\nconst rowAndMaximumOnes = (g) => g.map((a, i) => [i, a.filter(x => x == 1).length]).sort((x, y) => y[1] - x[1] || x[0] - y[0])[0];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3421856,
                "title": "ez-brute-force",
                "content": "# Intuition\\nJust count the number of ones in each row and find out the maximum out of it.\\n\\n# Complexity\\n- Time complexity:\\nO(m*n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat)\\n    {\\n        vector<int> res(2,0);\\n        int n = mat.size();\\n        int maxi = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            int cnt = 0;\\n            for(auto x : mat[i])\\n            {\\n                cnt+=x;\\n            }\\n            if(cnt > maxi)\\n            {\\n                res[0]=i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] res = new int[2];\\n        int n = mat.length;\\n        int maxi = 0;\\n        for(int i=0; i<n; i++) {\\n            int cnt = 0;\\n            for(int x : mat[i]) {\\n                cnt += x;\\n            }\\n            if(cnt > maxi) {\\n                res[0] = i;\\n                res[1] = cnt;\\n                maxi = cnt;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n```Python3 []\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        n = len(mat)\\n        maxi = 0\\n        for i in range(n):\\n            cnt = sum(mat[i])\\n            if cnt > maxi:\\n                res[0] = i\\n                res[1] = cnt\\n                maxi = cnt\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421828,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n     int[] ans = new int[2];\\n    \\n        int max=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int len=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n               if(mat[i][j]==1)\\n               {\\n                   len++;\\n                   \\n               }\\n            }\\n           if(max<len)\\n           {\\n               max=len;\\n               ans[0]=i;\\n           }\\n        }\\n        ans[1]=max;\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421822,
                "title": "easy-java-self-explanatory-o-mn",
                "content": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length, n = mat[0].length, max = -1, curr = 0, ans[] = new int[2];\\n        for(int row=0;row<m;row++){\\n           curr = 0;\\n           for(int col=0;col<n;col++){\\n             if(mat[row][col] == 1) curr++;  \\n           }\\n            if(curr > max){\\n                ans[0] = row;\\n                ans[1] = curr;\\n                max = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421767,
                "title": "c-brute-force-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int max_idx = 0;\\n        int maxi = INT_MIN;\\n        for(int i = 0; i < mat.size(); i++)\\n        {\\n            int count = 0;\\n            for(int j = 0; j < mat[0].size(); j++)\\n            {\\n                if(mat[i][j] == 1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(maxi < count)\\n            {\\n                maxi = count;\\n                max_idx = i;\\n            }\\n        }\\n        return {max_idx,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421733,
                "title": "c-count-one-in-each-row",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421732,
                "title": "c-easy-to-understand-for-begineer",
                "content": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Priyanshu\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n     vector<int> ans;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        // int one=0;\\n        vector<pair<int,int>>vec;\\n       for(int i=0;i<n;i++){\\n           int one=0;\\n           for(int j=0;j<m;j++){\\n               if(mat[i][j]==1)one++;\\n           }\\n           vec.push_back({one,i});\\n       }\\n        int x=vec.size();\\n        sort(vec.begin(),vec.end());\\n        int maxi=vec[x-1].first;\\n        for(auto it: vec){\\n            cout<<it.first<<\" \"<<it.second<<endl;\\n        }\\n        for(auto it: vec){\\n            if(it.first==maxi){\\n                ans.push_back(it.second);\\n                ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n        return ans;}};\\n\\t\\t```",
                "codeTag": "C++"
            },
            {
                "id": 3421689,
                "title": "simplest-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int> ans;\\n        int maxcount=0;\\n        int row=0;\\n        \\n        \\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1)\\n                count++;\\n              }\\n                if(count>maxcount){\\n                    maxcount=count;\\n                    row=i;\\n            }\\n        }\\n        ans.push_back(row);\\n        ans.push_back(maxcount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421677,
                "title": "simple-approach-brute-force-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i =0 ;i < mat.length;i++){\\n            int cnt =0;\\n            for(int j =0 ;j<mat[i].length;j++){\\n                if(mat[i][j] ==1){\\n                    cnt++;\\n                }\\n            }\\n            if(cnt > arr[1]){\\n                arr[1] = cnt;\\n                arr[0] = i;\\n            }\\n            \\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101358,
                "title": "easy-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int res=0;\\n        int k=0;\\n        for(int i=0;i<m;i++){\\n             int count=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n         if(count>res){\\n             res=count;\\n             k=i;\\n         }\\n        }\\n        ans.push_back(k);\\n        ans.push_back(res);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101082,
                "title": "simple-and-easy-to-understand-java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = Integer.MIN_VALUE;\\n        int index = -1;\\n        int result[] = new int[2];\\n        for(int i=0; i<mat.length; i++) {\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++) {\\n                if(mat[i][j]==1) {\\n                    count++;\\n                }\\n            }\\n            if(count > max) {\\n                max = count;\\n                index = i;\\n            }\\n        }\\n        result[0] = index;\\n        result[1] = max;\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101064,
                "title": "solved-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int count=0,max=0,i,j,row;\\n        for(i=0;i<mat.size();i++)\\n        {\\n            for(j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>max)\\n            {\\n                max = count;\\n                row = i;\\n\\n            }\\n            count=0;\\n        }\\n        ans.push_back(row);\\n        ans.push_back(max);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101032,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) \\n    {\\n        int ans[]=new int [2];\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(ans[1]<count)\\n            {\\n                ans[1]=count;\\n                ans[0]=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100296,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int onecount = INT_MIN;\\n        int row = -1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int cnt = 0;\\n            for(int j=0; j<mat[i].size(); ++j){\\n                if(mat[i][j] == 1) cnt++;\\n            }\\n\\n            if(cnt > onecount){\\n                onecount = cnt;\\n                row = i;\\n            }\\n\\n        }\\n\\n        ans.push_back(row);\\n        ans.push_back(onecount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4091988,
                "title": "bs-best-solution-o-n-logn",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void sortrow(vector<int> &row){\\n        sort(row.begin(),row.end());\\n    }\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& a) {\\n         int count=0,index=0;\\n         int n=a.size(),m=a[0].size();\\n        for(int i=0;i<n;i++){\\n            sortrow(a[i]);\\n            int low=0,high=m-1;\\n            int ind=m;\\n            while(low<=high){\\n                int mid=(low+high)/2;\\n                if(a[i][mid]==1){\\n                    ind=mid;\\n                    high=mid-1;\\n                }\\n                else\\n                low=mid+1;\\n            }\\n            int count_ones=m-ind;\\n            if(count_ones>count){\\n                count=count_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4088570,
                "title": "easy-solution-in-python-specially-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l = []\\n        m=0\\n        k=0\\n        x=0\\n        for i in mat:\\n            p = i.count(1)\\n            if m<p:\\n                m = p\\n                x = k\\n            k+=1\\n        l.append(x)\\n        l.append(m)\\n        return l\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085878,
                "title": "best-question-for-beginners-and-the-easiest-code-given-below",
                "content": "## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int count=0;\\n        int max=0;\\n        int index=0;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count=0;\\n            for(int j=0;j<mat[0].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n               \\n            }\\n            if(count>max)\\n            {\\n                max=count;\\n                index=i;\\n            }\\n           \\n        }\\n         \\n        return new int[] {index,max};\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085187,
                "title": "95-beats-in-c-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count = 0;\\n        int min_index = -1;\\n\\n        for(int i = 0; i < mat.size(); i++){\\n            int count2 = 0;\\n            for(int j = 0; j < mat[i].size(); j++){\\n                if(mat[i][j] == 1){\\n                    count2++;\\n                }\\n            }\\n            if(count2 > count){\\n                count = count2;\\n                min_index = i;\\n            }\\n        }\\n\\n        if(count == 0){\\n            return {0,0};\\n        }\\n        return {min_index,count};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081899,
                "title": "striver-approach-lower-bound-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint lowerBound(vector<int> &arr, int x){\\n    int n=arr.size();\\n    int low=0;\\n    int high = n-1;\\n    sort(arr.begin(),arr.end());\\n    int ans=n;\\n    while(low<=high){\\n        int mid=(low+high)/2;\\n        if(arr[mid] >= x){\\n            ans=mid;\\n            high=mid-1;\\n        }else{\\n            low=mid+1;\\n        }\\n    }\\n    return ans;\\n}\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m=mat.size();\\n        int n=mat[0].size();\\n        int maxCount=0;\\n        int index=0;\\n        vector<int> ans;\\n        for(int i=0; i<m; i++){\\n            int onesCount = n-lowerBound(mat[i], 1);\\n            if(onesCount > maxCount){\\n                maxCount = onesCount;\\n                index=i;\\n            }\\n        }\\n        return {index, maxCount};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080350,
                "title": "beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        maxOne=-9999\\n        index =-1\\n        for i in range(len(mat)):\\n            if maxOne < mat[i].count(1):\\n                maxOne = mat[i].count(1)\\n                index= i\\n        return [index,maxOne]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4079830,
                "title": "simple-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let index = 0;\\n    let maxCount = 0;\\n    for(let i=0; i< mat.length; i++){\\n        let count = 0\\n        for(let j=0; j< mat[i].length; j++){\\n            if(mat[i][j] === 1){\\n                count++\\n            }\\n        }\\n        if(count > maxCount){\\n         maxCount = count;\\n         index = i;\\n        }\\n    }  \\n    return [index,  maxCount]  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079790,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n      vector<int>ans;\\n      int n=mat.size();\\n      int oneCount = INT_MIN;\\n      int rowNo;\\n\\n      for(int i=0;i<n;i++){\\n        int count=0;\\n        for(int j=0;j<mat[i].size();j++){\\n          if(mat[i][j]==1){\\n            count++;\\n          }\\n        }\\n        if(count>oneCount){\\n          oneCount=count;\\n          rowNo=i;\\n        }\\n      }\\n      ans.push_back(rowNo);\\n      ans.push_back(oneCount);\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074711,
                "title": "easy-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        arr=[]\\n        res=[]\\n        for i in mat:\\n            count=0\\n            for j in i:\\n                if j==1:\\n                    print(j)\\n                    count+=1\\n                if j==0:\\n                    continue\\n            arr.append(count)\\n        print(arr)\\n        if arr:\\n            for l in range(len(arr)):\\n                if arr[l]==max(arr):\\n                    res.append(l)\\n                    res.append(max(arr))\\n                    break\\n        else:\\n            res.append(0)\\n            res.append(0)\\n        return res\\n        \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072903,
                "title": "o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(m*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int a=0,c=0,b=0;\\n        for(int i=0;i<mat.length;i++){\\n            c=0;\\n            for(int j=0;j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    c++;\\n                }\\n                if(c>a){\\n                    b = i;\\n                }\\n                a = Math.max(a,c);\\n            }\\n        }\\n        int[] ans = {b,a};\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070947,
                "title": "easy-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int n =mat.length;\\n        int m = mat[0].length;\\n\\n        int index =0;\\n        int max =0;\\n\\n        for(int i =0;i<n; i++){\\n          int sum =0;\\n          for(int j =0;j<m;j++){\\n            sum = sum + mat[i][j];\\n            \\n          }\\n         if(sum > max){\\n           index =i;\\n           max =sum;\\n         }\\n        \\n        }\\n        return new int[] {index,max};\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070818,
                "title": "use-c-stl",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(c)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans(2,0);\\n        for(int i=0; i<mat.size(); ++i)\\n        {\\n            int sum = accumulate(mat[i].begin(), mat[i].end(),0);\\n            if(sum > ans[1])\\n            {\\n                ans[1] = sum;\\n                ans[0] = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068780,
                "title": "python-simple-with-explanation",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #INITIALISE ANS WITH 0\\n        ans=0\\n        res=[]\\n        #COUNT THE MAX NUMBER OF 1\\'S IN EACH LIST\\n        for i in mat:\\n            ans=max(ans,i.count(1))\\n        #SEARCH FOR THAT LIST AND RETURN ITS INDEX\\n        for i in range(len(mat)):\\n            if mat[i].count(1)==ans:\\n                res.append(i)\\n                res.append(ans)\\n                return res\\n                break\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066516,
                "title": "python-solution-easy-to-understand-for-beginners",
                "content": "\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        temp=[]\\n        count1=0\\n        for i in range(len(mat)):\\n            new=mat[i].count(1)\\n            if new>count1:\\n                count1=new\\n                temp=[i,count1]\\n        if temp==[]:\\n            return [0,0]\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4064962,
                "title": "a-bit-lenthy-solution-but-easy-to-understand-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[100];\\n        int count = 0;\\n        int k = 0;\\n        for(int i=0;i<mat.length;i++){\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j] == 1){\\n                    count ++;\\n                }\\n                \\n            }\\n            arr[k++] = count;\\n                count = 0;\\n        }\\n        int max = arr[0];\\n        for(int i=1;i<arr.length;i++){\\n            if(arr[i] > max){\\n                max = arr[i];\\n            }\\n        }\\n        int ans = position(arr,max);\\n        int[] nums = {ans,max};\\n        return nums;\\n    }\\n        public int position(int[] arr,int target){\\n            for(int i=0;i<arr.length;i++){\\n                if(arr[i] == target){\\n                    return i;\\n                    \\n                }\\n            }\\n            return -1;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063673,
                "title": "easy-and-clean-code-c-solution-clean-code-easy-to-understand-o-n-2-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        vector<int>anss;\\n        int max=INT_MIN;\\n        for(int i=0;i<mat.size();i++){\\n            int cnt=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    cnt+=1;\\n                }\\n            }\\n           ans.push_back(i);\\n           anss.push_back(cnt);\\n            \\n        }\\n        int  index;\\n        for(int i=0;i<anss.size();i++){\\n            if(anss[i]>max){\\n                max=anss[i];\\n                index=i;\\n            }\\n        }\\n    \\n        return {index,max};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063205,
                "title": "h",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int>ans;\\n        int row_size=mat.size();\\n        int oneCount=INT_MIN;\\n        int rowNo=0;\\n        for(int i=0;i<row_size;i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>oneCount)\\n            {\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062082,
                "title": "simple-fast-and-100-accepted-c-c-bruteforce-approach-beats-maximum-users-check-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-> Assume ansr, Row number = 0\\n-> Assume ans, Maximum no. of 1\\'s =0\\n-> Count the no. of 1\\'s in each row.\\n-> Then, Store it in ansr, ans variable.\\n\\nReturn the ans, ansr.\\nans = maximum no. of 1s\\nansr = minimum row which contain maximum 1\\'s. \\n\\n# Approach\\nBruteForce Approach\\n\\n# Complexity\\n- Time complexity:\\nO(m x n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n        int ansr=0,ans=0;\\n        for(int i = 0;i<m;i++)\\n        {\\n            int count = 0;\\n            for(int j = 0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                    count++;\\n            }\\n            if(count>ans)\\n            {\\n                ans = count;\\n                ansr = i; \\n            }\\n        }\\n        return {ansr,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060971,
                "title": "easy-java-approach",
                "content": "## ****Bold****# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=0,maxrow=0;\\n        int m=mat.length;\\n        int n=mat[0].length;\\n        for(int i=0;i<m;i++)\\n        {\\n            int c=0;\\n            for(int j=0;j<n;j++)\\n            {\\n                if(mat[i][j]==1)\\n                 c++;\\n            }\\n            if(c>max)\\n            {\\n            max=c;\\n            maxrow=i;\\n            }\\n        }\\n        int[] arr = new int[2];\\n        arr[1]=max;\\n        arr[0]=maxrow;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060192,
                "title": "simple-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>ans;\\n        \\n        int index=0;\\n        int OnesCount=0;\\n        for(int i=0;i<n;i++){\\n            int count=0;\\n            for(int j=0;j<m;j++){\\n                if(mat[i][j]==1){\\n                 count++;\\n                }\\n            }\\n\\n           if(count>OnesCount) {\\n            OnesCount=count;\\n             index=i;\\n             }\\n        }\\n\\n        ans.push_back(index);\\n        ans.push_back(OnesCount);\\n        return ans;\\n          \\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4058731,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(m*n)**\\n\\nThe countOnes function iterates through a row of length \\'n\\' once and counts the number of ones. So, its time complexity is O(n).\\n\\nIn the rowAndMaximumOnes function, there is a loop that iterates through all \\'m\\' rows of the matrix. Inside the loop, it calls the countOnes function, which has a time complexity of O(n). Therefore, the time complexity of the loop is O(m * n).\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int countOnes(vector<int>& row) {\\n        int count = 0;\\n        for (int num : row) {\\n            if (num == 1) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxCount = 0;\\n        int rowIndex = -1;\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        for (int i = 0; i < m; i++) {\\n            int onesCount = countOnes(mat[i]);\\n            if (onesCount > maxCount) {\\n                maxCount = onesCount;\\n                rowIndex = i;\\n            }\\n        }\\n        if (rowIndex == -1) {\\n            return {0, 0};  // No ones found in any row\\n        }\\n        vector<int> result = {rowIndex, maxCount};\\n        return result;\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055258,
                "title": "fast-and-easy-code-by-using-python3",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n-> first we are taking each row and finding number of 1\\'s in it by using count meathod ad appedning it into num_1 list\\n-> next we are finding index of the row by finding index of the max element in the num_1 list because its index match with the row index \\n-> finally we are taking index i and no. of times 1 repeated into a final list and returning it \\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        num_1 = []\\n        for i in mat:\\n            # finding nuo. of times 1 repeated in each row \\n            num_1.append(i.count(1))\\n        # finding index of max element in num_1\\n        i = num_1.index(max(num_1))\\n        final = [i,max(num_1)]\\n        return final\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054975,
                "title": "beat-90-in-memory-and-easy-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        l=[0,0]\\n        for i in range(len(mat)):\\n            if sum(mat[i])>l[1]:\\n                l[1]=sum(mat[i])\\n                l[0]=i\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054524,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int row = 0;\\n        int count = 0;\\n        int maxCount = 0;\\n        for(int i = 0 ;  i< mat.length; i++){\\n            count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > maxCount){\\n                maxCount = count;\\n                row = i;\\n            }\\n        }\\n        return new int[] {row, maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053693,
                "title": "using-count-p",
                "content": "# Intuition\\nOn a first thought, i used 2 for\\'s, but that\\'s not necessary\\n# Approach\\nbc python gives us \"count\" wich you call with the array and, as a parameter, you put the element.. Of course it probably cycles the list so it\\'s still a O(n^2) but the guy who made count is way better than me so my code si 50ms faster :P I just check if the counter of 1\\'s in a array is bigger than the actual, i just keep the big one and the index, which probally isn\\'t necesary as variable, but i\\'m not a py programmer D:\\n\\n# Complexity\\n- Time complexity:\\nO(n^2).. but i\\'m having doubts with that if, maybe hurts more than what it helps\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nnot really sure about space, i mean i use 2 variables and un array length==2 D:\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        counter = 0\\n        i = 0\\n        salida = [0,0]\\n        for array in mat:\\n            if(1 in array):\\n                counter = array.count(1)\\n                if(counter > salida[1]):\\n                    salida = [i, counter]\\n            i += 1\\n            counter = 0\\n        return salida\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048826,
                "title": "cpp-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        vector<int> answer(2 , 0);\\n        int n = mat.size();\\n        int m = mat[0].size();\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            int count = 0;\\n            for(int j = 0 ; j < m ; j++)\\n            {\\n                count += mat[i][j];\\n            }\\n            if(answer[1] < count)\\n            {\\n                answer[0] = i;\\n                answer[1] = count;\\n            }\\n        }    \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047801,
                "title": "easy-c-solution-without-taking-extra-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> result(2);\\n       //  have created one vector with size 2 because we have to return a vector, IN the fist index  result[0] we will be storing index of the max row and second position  result[1] we will be storing max 1 count;\\n\\n        for(int i=0 ;i<mat.size() ; i++){  // for row\\n            int oneCount = 0;    // to count 1 each row\\n            for(int j=0 ; j<mat[0].size() ; j++){  // for column\\n                if(mat[i][j] == 1){\\n                    oneCount++;  // if 1 fount in the row then we will count\\n                }\\n            }\\n            if( oneCount > result[1]){    //if max row found with respect to the previous row then we will update vector\\n                result[0] = i;\\n                result[1] = oneCount;\\n\\n            }\\n        }\\n        return result; // return the vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047187,
                "title": "74ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let result = [];\\n    let tmpCount = -1;\\n    mat.forEach((item, i) => {\\n        let count = item.reduce((n, sum) => (n + sum), 0);\\n        if (count > tmpCount) {\\n            result[0] = i;\\n            result[1] = count\\n            tmpCount = count;\\n        }\\n        \\n    });\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045304,
                "title": "brute-force-and-simple-to-understand-100",
                "content": "# Intuition\\n![cat_image.jpeg](https://assets.leetcode.com/users/images/84b86bbb-442c-414d-9e18-6b1057407c45_1694716995.6876135.jpeg)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxcont=0;\\n        int cont=0;\\n        int ind;\\n\\n        for(int i=0;i<mat.size();i++)\\n        {\\n            cont=0;\\n            for(int j=0;j<mat[0].size();j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                   cont++;\\n                }\\n            }\\n\\n            if(cont>maxcont)\\n            {\\n                maxcont=cont;\\n                ind=i;\\n            }\\n        }\\n\\n        vector<int> ans;\\n        ans.push_back(ind);\\n        ans.push_back(maxcont);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045214,
                "title": "easy-and-simple-c-solution-row-with-maximum-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row. ---->**Idea :-** We\\'ll count one\\'s value in each row by traversing the matrix , then store the ans and return the value of rowNo and max oneCount. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst of all , initialize a vector array of int type as \"ans\" `vector<int> ans;`to store the index of the row, and the number of ones in it. \\nInitializes two variables \\n-> `oneCount=INT_MIN` (that have the maximum count of ones)\\n->`rowNo = -1` (the row with the smallest row number having max no. of 1\\'s)\\n1) Using nested loop to check whether `mat[i][j]==1` or not, if mat[i][j]==1, then increment `count++`. \\n2) Check `if(count > onecount)` then  oneCount=count , rowNo= i\\n3) push_back rowNo and oneCount in \"ans\" vector array , then return ans `ans.push_back(rowNo);`\\n `ans.push_back(oneCount);`\\n `return ans;`\\n\\n# Complexity\\n- Time complexity: O( m*n ) `traversal of matrix`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```\\n![canUpleaseUpvote.jpeg](https://assets.leetcode.com/users/images/8d39986a-7aae-4ac6-8605-00bda5df2579_1694715765.6027052.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount-> will store max number of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowNo-> will store index of max no. of 1\\'s wali row\\n        int rowNo=-1;\\n\\n        for(int i=0;i<n;i++){\\n            //har row start hone se phele intialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row completion , compare count with oneCount\\n            if(count> oneCount){\\n                oneCount=count;\\n                rowNo= i;\\n            }\\n        }\\n       \\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4043733,
                "title": "row-wise-counting",
                "content": "# Intuition\\nstep 1: Traversing row wise and count 1 and compare max and count if count > max then max = count. Then count -> 0\\nstep 2: storing row idx\\nstep 3: return row idx and maximum count of 1\\n\\n# Approach\\nRow-wise Counting\\n\\n# Complexity\\n- Time complexity:\\nO(m * n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector <int> ans;\\n        int Max = INT_MIN, row_Idx;\\n        for(int i = 0 ; i<mat.size(); i++){\\n            int count = 0;\\n        for(int j = 0 ; j<mat[0].size(); j++){\\n            if(mat[i][j] == 1){\\n                count++;\\n            }\\n        }\\n        if(Max < count){\\n            Max = count;\\n            row_Idx = i;\\n        }\\n        }\\n        ans.push_back(row_Idx);\\n        ans.push_back(Max);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4042974,
                "title": "row-with-maximum-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int onecount =INT_MIN;\\n        int n=mat.size();\\n        vector<int>ans;\\n        int rowno = -1;\\n        for(int i=0 ;i<n ;i++){\\n            int count =0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count >  onecount){\\n                onecount =count;\\n                rowno =i;\\n            }\\n        }\\n        ans.push_back(rowno);\\n        ans.push_back(onecount);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041660,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        vector<int>ans;\\n        int row = mat.size();\\n        int col = mat[0].size();\\n        // for max count of one\\n        int oneCount = INT_MIN;\\n        // for which row has max one count\\n        int rowNo = 0;\\n\\n        for(int i=0 ; i<row ; i++){\\n            int count = 0;\\n            for(int j=0 ; j<col ; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n\\n            if(count > oneCount){\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041598,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int n = mat.size();\\n        int oneCount = 0;\\n        int rowNo ;\\n        vector<int> ans;\\n\\n        for(int i=0 ; i<n ;i++){\\n            int count=0;\\n            for(int j=0 ; j<mat[i].size() ; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n\\n                if(count>oneCount){\\n                    oneCount = count;\\n\\n                    rowNo = i;\\n                }\\n            }\\n        }\\n            ans.push_back(rowNo);\\n            ans.push_back(oneCount);\\n            \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040180,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> v;\\n        int max1 = 0;\\n        int maxi = 0;\\n\\n        for (int i = 0; i < mat.size(); i++) {\\n            int count = 0;\\n\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if (count > max1) {\\n                max1 = count;\\n                maxi = i;\\n            }\\n        }\\n\\n        v.push_back(maxi);\\n        v.push_back(max1);\\n\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039370,
                "title": "beats-98-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n=mat.size();\\n        //oneCount ->will store max no of 1\\'s in a row\\n        int oneCount=INT_MIN;\\n        //rowno-->  will store index of max no of 1/s wali row\\n        int rowNo=-101;\\n\\n        for(int i=0;i<n;i++){\\n            //hr row start hone se phle initialize count with 0\\n            int count=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                //if one found then increment one\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            //after row comple compare with one count\\n            if(count>oneCount){\\n                oneCount=count;\\n                rowNo=i;\\n            }\\n        }\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4037894,
                "title": "easy-c-solution-of-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int >ans;\\n        int n = mat.size();\\n        int onecount = INT_MIN;\\n        int rowno = -1;\\n\\n        for(int i = 0; i<n; i++ ){\\n            int count = 0; \\n            for(int  j = 0; j<mat[i].size(); j++ )\\n            {\\n                if(mat[i][j]  == 1){\\n                    count++;\\n                }\\n            }\\n            if(count > onecount )\\n            {\\n                onecount = count;\\n                rowno = i;\\n            }\\n        }\\n        ans.push_back(rowno); \\n        ans.push_back(onecount);\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036575,
                "title": "row-with-maximum-ones",
                "content": "# Intuition\\nWe are given a binary matrix where each row represents a set of elements with values 0 or 1. We need to find the row with the maximum number of 1s.\\n\\n# Approach\\n1. Initialize oneCount to a very small integer (e.g., INT_MIN) to keep track of the maximum number of 1s in a row.\\n2. Initialize rowNo to -1 to keep track of the row number with the maximum 1s.\\n3. Iterate through each row of the matrix.\\n->Initialize count to 0 for each row to count the number of 1s.\\n->Iterate through each element in the row.\\n->If an element is 1, increment count.\\n4. After counting the 1s in a row, compare count with oneCount.\\n->If count is greater than oneCount, update oneCount with count and rowNo with the current row number.\\n5. Finally, return a vector containing rowNo and oneCount, which represents the row with the maximum 1s and the count of maximum 1s in that row.\\n# Complexity\\n- Time complexity:\\nWe iterate through each row of the matrix once, and for each row, we iterate through all of its elements once. Therefore, the time complexity is O(n * m), where n is the number of rows and m is the number of columns in the matrix.\\n\\n- Space complexity:\\nWe use a constant amount of extra space for variables (oneCount, rowNo, and count) regardless of the input size. Therefore, the space complexity is O(1).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        vector<int> ans;\\n        int n = mat.size();\\n        // Will store the max number of 1s in a row\\n        int oneCount = INT_MIN;\\n        // Will store max row number with max 1s\\n        int rowNo = -1;\\n\\n        for (int i = 0; i < n; i++) {\\n            // Initialize count with 0 for each row\\n            int count = 0;\\n            for (int j = 0; j < mat[i].size(); j++) {\\n                if (mat[i][j] == 1) {\\n                    count++;\\n                }\\n            }\\n            // After row completion, compare count with oneCount\\n            if (count > oneCount) {\\n                oneCount = count;\\n                rowNo = i;\\n            }\\n        }\\n\\n        ans.push_back(rowNo);\\n        ans.push_back(oneCount);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035519,
                "title": "easy-java-sol-using-iterative-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max=Integer.MIN_VALUE;\\n        int ans[]=new int[2];\\n\\n        for(int i=0;i<mat.length;i++){\\n            int ones=0;\\n\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1) ones++;\\n            }\\n            if(ones>max){\\n                max=ones;\\n                ans[0]=i;\\n                ans[1]=ones;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028371,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n\\n        int count=0, index=0;\\n        int arr[] = new int[2];\\n\\n        for(int i=0; i<mat.length; i++){\\n            count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n          \\n            if(count>arr[1]){\\n                arr[1]=count;\\n                arr[0]=i;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022806,
                "title": "n-x-log2-m",
                "content": "# Intuition\\njust finding the no. of 1\\'s using lower bound and checking the condition that if maxcnt is larger than the instant cnt.\\n\\n# Approach\\nfirstly we know that the matrix is sorted at the column level .so, we cannot optimize row traversal the only thing we can optimize is that the way of computing no. of 1\\'s.\\nrun a for lopp for each row and find the no. of 1,s at each row by\\ncntones = m - lowerBound(matrix[i],m,1) .\\nand then check the condition.\\n\\n# Complexity\\n- Time complexity:O(N X log2(M))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int lowerBound(vector<int>& arr,int n,int x){\\n    \\n    int low = 0, high = n-1;\\n    \\n    while(low <= high){\\n        int mid = (low+high)/2;\\n        \\n        if(arr[mid] >= x){\\n            high=mid-1;\\n        }\\n        \\n        else{\\n            low=mid+1;\\n        }\\n    }\\n    return low;\\n}\\n\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        \\n        int n = mat.size();\\n        int m = mat[0].size();\\n\\n        for(int i=0;i<mat.size();i++){\\n            sort(mat[i].begin(),mat[i].end());\\n        }\\n            int index = -1;\\n    int max_cnt = -1;//don\\'t put max_cnt = -1; \\n    \\n    // n X log2 m\\n\\n    for(int i=0;i<n;i++){\\n        int cnt_ones = m-lowerBound(mat[i],m,1);\\n\\n        if(cnt_ones > max_cnt){\\n            max_cnt=cnt_ones;\\n            index=i;\\n        }\\n    }\\n    return {index,max_cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021509,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016559,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N^2)\\n\\n- Space complexity:\\nO(N^2)\\n\\n# Code\\n```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public static int[] rowAndMaximumOnes(int[][] mat) {\\n\\t\\tint maxCount = Integer.MIN_VALUE;\\n\\t\\tint index = 0;\\n\\t\\tfor (int i = 0; i < mat.length; i++) {\\n\\t\\t\\tint count = 0;\\n\\t\\t\\tfor (int j = 0; j < mat[0].length; j++) {\\n\\t\\t\\t\\tif(mat[i][j]==1) {\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(maxCount<count) {\\n\\t\\t\\t\\tmaxCount = count;\\n\\t\\t\\t\\tindex = i;\\n\\t\\t\\t}\\n\\t\\t}\\n        return new int[] {index,maxCount};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015231,
                "title": "short-and-simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse `sum` to find the number of ones in each row, then `max`.\\n\\n# Complexity\\n- Time complexity: $$ O(m*n) $$ - summing each row takes $$ O(n) $$ and we do this $$ m $$ times.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$ O(1) $$ - no additional memory is allocated.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        # Use the negative index here since we want the \"smallest row number\"\\n        count, index = max((sum(row), -i) for i, row in enumerate(mat))\\n        # Turn index back to positive\\n        return [-index, count]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4015006,
                "title": "javascript-max",
                "content": "# Code\\n```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// T: O(m*n) | S: O(1)\\nvar rowAndMaximumOnes = function(mat) {\\n    const m = mat.length;\\n    const n = mat[0].length;\\n    let max = 0;\\n    let ind = 0;\\n    for (let i = 0; i < m; i++) {\\n        let val = 0;\\n        for (let j = 0; j < n; j++) {\\n            val += mat[i][j];\\n        }\\n        if (val > max) {\\n            max = val;\\n            ind = i;\\n        }\\n    }\\n    return [ind, max];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4012313,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.reduce([0, 0], fn {row, i}, [r, ct] ->\\n      ones = Enum.count(row, &(&1 == 1))\\n\\n      if ones > ct do\\n        [i, ones]\\n      else\\n        [r, ct]\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4002799,
                "title": "93-beats-java-o-n-m",
                "content": "# Complexity\\n- Time complexity:O(n*m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] temp = new int[mat.length];\\n        int idx = -1,value = -1;\\n\\n        for(int i = 0; i<mat.length; i++){\\n            for(int j = 0; j<mat[0].length; j++){\\n                temp[i]+=mat[i][j];\\n            }\\n            if(value<temp[i]){\\n                    idx = i;\\n                    value = temp[i];\\n                }\\n        }\\n\\n        return new int[]{idx,value};\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3990845,
                "title": "java-soltuion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int ans[] = new int[2];\\n        int count=0,index=0,sum=0;\\n        int n=mat.length;int m=mat[0].length;\\n        for(int i=0;i<mat.length;i++)\\n        {\\n            count =0;\\n            for(int j=0;j <mat[i].length;j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n            sum=count;\\n            index=i;\\n            }\\n        }\\n        ans[0]=index;\\n        ans[1]=sum;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982528,
                "title": "click-drama-drama-alert-idiot-here-at-your-service-wow-big-big",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary meaning only zeroes and ones. If all rows are of same length then the maximum of the sums of each row should be the answer. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse list comprehension and the sum() function. max() to find the highest and find the index of the highest and index() returns the first occurrence if there are multiple.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        sums = [sum(i) for i in mat]\\n        high = max(sums)\\n        ind = sums.index(high)\\n        return [ind, high]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979126,
                "title": "sort-elixir",
                "content": "# Code\\n```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec row_and_maximum_ones(mat :: [[integer]]) :: [integer]\\n  def row_and_maximum_ones(mat) do\\n    mat\\n    |> Enum.with_index()\\n    |> Enum.map(fn {row, index} -> [index, count_ones(row)] end)\\n    |> sort_by()\\n    |> hd()\\n  end\\n\\n  defp count_ones(row) do\\n    Enum.count(row, fn x -> x == 1 end)\\n  end\\n\\n  defp sort_by(arr) do\\n    Enum.sort(arr, fn [a_idx, a_cnt], [b_idx, b_cnt] ->\\n      case a_cnt == b_cnt do\\n        true -> a_idx < b_idx\\n        false -> a_cnt > b_cnt\\n      end\\n    end)\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3978594,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n#include <bits/stdc++.h>\\n\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) \\n    {\\n        \\n        int index = -1;\\n        int max_count = -1;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            int row_count = 0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                row_count = row_count + mat[i][j];\\n            }\\n            if(row_count > max_count)\\n            {\\n                max_count = row_count;\\n                index = i;\\n            }\\n        }\\n        return {index, max_count};\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3975885,
                "title": "python-94-efficient-solution-space-using-lambda-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        result = []\\n        #Traversing row\\n        for i in range(len(mat)):\\n            counter = 0\\n            #Traversing elements of the row\\n            for j in mat[i]:\\n                if j == 1:\\n                    #Count the number of 1\\'s in the row\\n                    counter += 1\\n            result.append([i,counter])\\n        result.sort(reverse=True)\\n        #Sort the result along with the number of 1 present in that row\\n        result.sort(key=lambda x:x[1])\\n        return result[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966398,
                "title": "java-direct-to-the-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute force approach\\n\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        \\n       int ans[] = new int[2];\\n\\n       int count = 0;\\n\\n       for(int i=0; i<mat.length; i++ ){\\n\\n           int temp = 0;\\n\\n           for( int j=0; j<mat[0].length; j++){\\n\\n               if( mat[i][j] == 1 ){\\n                   temp++;\\n               }\\n           }\\n\\n           if( temp > count ){\\n\\n               count = temp;\\n               \\n               ans[0] = i;\\n               ans[1] = count;\\n\\n           }\\n       }\\n\\n       return ans;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965735,
                "title": "oneline-fast",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        return sorted((mat[i].count(1), -i, i, mat[i].count(1)) for i in range(len(mat)))[-1][2:]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963997,
                "title": "c-simple-solution-runtime-106-ms-beats-93-20-memory-60-5-mb-beats-59-69",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int row_size = mat.size(), col_size = mat[0].size();\\n        vector<int> ans(2);\\n        int mx_count = INT_MIN;\\n        for(int i = 0; i < row_size; ++i){\\n            int count = 0;\\n            for(int j = 0; j < col_size; ++j){\\n                if(mat[i][j] == 1) count++;\\n            }\\n            if(mx_count < count) {\\n                ans[0] = i;\\n                ans[1] = count;\\n                mx_count = count;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961693,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] arr = new int[2];\\n        for(int i = 0; i < mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j < mat[i].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n            }\\n            if(arr[1] < count){\\n                arr[0] = i;\\n                arr[1] = count;\\n            }\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959143,
                "title": "easiest-solution-possible-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] ar = new int[2];\\n        int maxi = 0;\\n       \\n        Map<Integer,Integer> map = new HashMap<>();\\n        for(int i = 0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j = 0; j<mat[0].length;j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n\\n            }\\n            if(!map.containsKey(count)){\\n                map.put(count,i);\\n            }\\n        }\\n       \\n        for(int i : map.keySet()){\\n            maxi = Math.max(maxi,i);\\n\\n\\n\\n        }\\n        ar[0] = map.get(maxi);\\n        ar[1] = maxi;\\n\\n    return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957817,
                "title": "optimal-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ind=0,cnt=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[0].size();j++){\\n                if(mat[i][j]==1) c+=1;\\n            }\\n            if(c>cnt){\\n                ind=i;\\n                cnt=c;\\n            }\\n        }\\n        \\n        return {ind,cnt};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3955950,
                "title": "too-easy-easiest-java-solution-beats-100-o-m-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(m * n) \\n    Where m is the number of rows and n is the number of columns in the input matrix mat.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr=new int [2];\\n        int min=Integer.MIN_VALUE;\\n        for (int i=0;i<mat.length;i++){\\n            int count=0;\\n            for (int j=0;j<mat[i].length;j++){\\n                if (mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            \\n            if (min<count){\\n                min=count;\\n                arr[0]=i;\\n            }\\n            \\n        }\\n        arr[1]=min;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954501,
                "title": "binary-search-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int rowWithone(int[] arr,int st,int end){\\n           Arrays.sort(arr);\\n            int firstOccurence=-1;\\n\\t\\t\\twhile(st<=end){\\n\\t\\t\\t\\tint mid=(st+end)/2;\\n\\t\\t\\t\\tif(arr[mid]==1){           \\n\\t\\t\\t\\t\\tfirstOccurence=mid;\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(arr[mid]<1){\\n\\t\\t\\t\\t\\tst=mid+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tend=mid-1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t    return firstOccurence;\\n    }\\n    public int[] rowAndMaximumOnes(int[][] arr) {\\n        int n=arr.length;\\n        int m=arr[0].length;\\n        int maxValue=0;     //varible store the max count of one\\'s;\\n\\t\\tint maxValueidx=-1;  //variable store the idx of max count of one\\'s;\\n\\t\\tfor(int i=0;i<n;i++){\\n\\n\\t\\t\\tint firstOccuridx=rowWithone(arr[i],0,m-1 );    //calling function which return the first occurence index of the 1 in that row;\\n\\t\\t\\tif(firstOccuridx!=-1 && m-firstOccuridx>maxValue ){   //if the firstOuccrenc is -1 which means no one is fount on that row \\n\\t\\t\\t\\tmaxValue=m-firstOccuridx;                         //else if it is not -1 then we have to count the no of one\\'s on that row \\n\\t\\t\\t\\tmaxValueidx=i;                                    // no of one\\'s on that row are the no of ele - first occure indx;\\n\\t\\t\\t\\t                                                  //if the max count of one is more then the previous count then update it and update the max value idx;else continue \\n\\t\\t\\t}\\n\\t\\t}\\t\\n        int[] res=new int[2];\\n        if(maxValueidx==-1) res[0]=0;\\n        else res[0]=maxValueidx;\\n        res[1]=maxValue;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3949019,
                "title": "beats-100-ruby-easy-to-understand-2643-row-with-maximum-ones",
                "content": "# Code\\n```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Array",
                    "Matrix"
                ],
                "code": "```\\n# @param {Integer[][]} mat\\n# @return {Integer[]}\\ndef row_and_maximum_ones(matrix)\\n    max = 0\\n    index = 0\\n    matrix.each_with_index do |mat, indx|\\n        tamp_max = 0\\n        mat.each do |mt|\\n            tamp_max += 1 if mt == 1\\n        end\\n        if tamp_max > max\\n            max = tamp_max\\n            index = indx\\n        end\\n    end\\n    return [index, max]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3945308,
                "title": "count-and-maximum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int [] arr = new int[mat.length];\\n        for(int i=0; i<mat.length; i++){\\n            int count=0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            arr[i]=count;\\n        }\\n\\n        int max=0;\\n        int ind=0;\\n        for(int i=0; i<arr.length; i++){\\n            if(arr[i]>max){\\n                max=arr[i];\\n                ind=i;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3942937,
                "title": "short-and-simple-python3-beats-99-9-runtime",
                "content": "# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, 0]\\n        for i, row in enumerate(mat):\\n            c = row.count(1)\\n            if c > res[1]:\\n                res[:] = i, c             \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938486,
                "title": "c-o-n-logm-solution",
                "content": "# Intuition\\nIf the row was sorted then I can easily find the count of ones using by finding first occurence of 1 using lower bound/first occurence\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort every row\\nFind the first occrrence of 1.\\nCount of 1s in the row is then just row.size() - firstOccurrence\\n\\n# Complexity\\n- Time complexity:\\nO(n* log m) when n is number of rows and m is number of columns\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        for(auto &row:mat){\\n            sort(row.begin(), row.end());\\n        }\\n\\n        int currentMax=-1, idx=-1;\\n\\n        for(int i=0; i<mat.size(); ++i){\\n            int firstOccurrence = lower_bound(mat[i].begin(), mat[i].end(), 1) - mat[i].begin();\\n            int currentCount = mat[i].size()-firstOccurrence;\\n            if(currentCount>currentMax){\\n                currentMax=currentCount;\\n                idx=i;\\n            }\\n        }\\n        return {idx, currentMax};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930828,
                "title": "easy-c-solution-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWith one row at a time,you just need to iterate over the column elements of respective rows and update curr element.If max>curr just update your max and index.It is important to keep note that the curr variable should be updated to zero after each iteration in order to avoid any discrepancy.Its using just an additional space for storing result which makes it quite efficient.\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n\\n- Space complexity: 0(m)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int m = mat.size();\\n        int n = mat[0].size();\\n\\n        int firstrow = 0;\\n        int lastrow = m-1;\\n        int firstcol = 0;\\n        int lastcol = n-1;\\n\\n        vector<int>ans;\\n        int max_one = 0;\\n        int index = 0;\\n\\n        for(int row = firstrow;row<=lastrow;row++){\\n            int curr = 0;\\n            for(int col = firstcol;col<=lastcol;col++){\\n                if(mat[row][col] == 1){\\n                    curr++;\\n                }\\n                else{\\n                    continue;\\n                }\\n                if(curr>max_one){\\n                    max_one = curr;\\n                    index = row;\\n                }\\n            }\\n        }\\n        ans.push_back(index);\\n        ans.push_back(max_one);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3929440,
                "title": "java-soluction",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int sum=0;\\n        int index=0;int count=0;\\n        for(int i=0;i<mat.length;i++){\\n            count=0;\\n            for(int j=0;j<mat[i].length;j++){\\n                if(mat[i][j]==1){\\n                    count++;\\n                }\\n            }\\n            if(count>sum){\\n                sum=count;\\n                index=i;\\n            }\\n        }\\n        int arr[]={index,sum};\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3926603,
                "title": "row-with-maximum-ones",
                "content": "# Complexity\\n- Time complexity:O(N*logM)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\nint lowerbound(vector<int>arr,int n){\\n        if(n==1) return arr[0]==1;\\n        int low=0,high=n-1;\\n        sort(arr.begin(),arr.end());\\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(arr[mid]==1){\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return (n-1)-low+1;\\n    }\\n    public:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int maxi=0;\\n        int index=0;\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        for(int i=0;i<n;i++){\\n            int cnt_ones=lowerbound(mat[i],m);\\n            if(cnt_ones>maxi){\\n                maxi=cnt_ones;\\n                index=i;\\n            }\\n        }\\n        return {index,maxi};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923778,
                "title": "python-beats-96-runtime-95-memory-coded-on-mobile",
                "content": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/4cbb30dd-9007-4e98-938e-aee6c806a6b8_1692295282.9749117.jpeg)\\n![image](https://assets.leetcode.com/users/images/c46adaeb-f468-4681-bf13-4e6e8c7bf59f_1692295283.356553.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3923316,
                "title": "iteration-and-reduce-ts-js",
                "content": "\\n# Approach\\ninitialize max variable with values = [-1,-1]\\niterate through each row \\nsum all 1s in the row using reduce\\nif sum is greater than the stored value in max, update max\\n\\n\\n# Code\\n```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction rowAndMaximumOnes(mat: number[][]): number[] {\\n  let max = [-1, -1]\\n  mat.forEach((val, i) => {\\n    const x = val.reduce((acc,val) => val ? (acc + val) : acc, 0)\\n    if (x > max[1]) { max = [i, x]}\\n  })\\n  return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3904858,
                "title": "simple-javascript-80-ms-beats-92",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} mat\\n * @return {number[]}\\n */\\nvar rowAndMaximumOnes = function(mat) {\\n    let m = mat.length;\\n    let n = mat[0].length;\\n\\n    let row = 0, count = 0;\\n\\n    for(let i = 0; i < m; i++) {\\n        let rowCount = 0;\\n        for(let j = 0; j < n; j++) {\\n            if(mat[i][j] === 1) {\\n                rowCount++;\\n            }\\n\\n            if(rowCount > count) {\\n                count = rowCount;\\n                row = i;\\n            }\\n        }\\n    }\\n    return [row, count];\\n};\\n\\n// TC: O(m * n)\\n// SC: O(1)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3903945,
                "title": "python-simple-solution-nested-loops-beginner-friendly",
                "content": "# Intuition\\n\\n---\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def rowAndMaximumOnes(self, mat):\\n        \"\"\"\\n        :type mat: List[List[int]]\\n        :rtype: List[int]\\n        \"\"\"\\n        m = len(mat)\\n        n = len(mat[0])\\n        maxcount = 0\\n        index = 0\\n\\n        for i in range(m):\\n            count = 0\\n            for j in range(n):\\n                if mat[i][j] == 1:\\n                    count +=1\\n\\n                    if count > maxcount:\\n                        maxcount = count\\n                        index = i\\n        return [index,maxcount]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894967,
                "title": "python3-solution-everything-explained-line-by-line-both-time-and-space-efficient",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        #Both time (828ms beats 94%) and memory (16.73mb beats 92.38%) effiecent\\n        max_ones = 0\\n        ans = []\\n        i = 0     # a variable to trace the index we are at.\\n        for lst in mat:\\n            lst_sum = sum(lst)\\n            if max_ones <= lst_sum:\\n                max_ones =  lst_sum\\n                ans.append([i,lst_sum])\\n            i+=1\\n        num_once  = []\\n        final_ans  = []\\n        #the following code block ensures the row with the smallest row number is selected. \\n        for i in range(len(ans)):\\n            if ans[i][-1] not in num_once:\\n                num_once.append(ans[i][-1])\\n                final_ans.append(ans[i])\\n           \\n        return final_ans[-1] # Since, the one which is lastly selected, for sure contains max_ones \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885537,
                "title": "simple-and-easy-java-soulution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int m = mat.length;\\n        int n = mat[0].length;\\n        int max=0,ind=0;\\n        for(int i=0;i<m;i++){\\n            int c=0;\\n            for(int j=0;j<n;j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(max<c){\\n                ind=i;\\n                max=c;\\n            }\\n        }\\n        return new int[]{ind,max};\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884509,
                "title": "rust-solution-easy-to-understand",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn row_and_maximum_ones(mat: Vec<Vec<i32>>) -> Vec<i32> {\\n        let (mut row_number, mut ones) = (0, 0);\\n        for (index, row) in mat.iter().enumerate() {\\n            let local_ones = row.iter().filter(|&&x| x == 1).count();\\n            if index == 0 {\\n                ones = local_ones;\\n                continue;\\n            }\\n            if local_ones > ones {\\n                row_number = index;\\n                ones = local_ones;\\n            }\\n        }\\n        vec![row_number as i32, ones as i32]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880237,
                "title": "swift-simple-solution-for-newbie",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func rowAndMaximumOnes(_ mat: [[Int]]) -> [Int] { \\n    var answer = [0,0]\\n\\n    for i in 0..<mat.count {\\n        let a = mat[i].reduce(0) {$0 + $1}\\n        if a > answer[1] {\\n            answer[1] = a\\n            answer[0] = i\\n        }\\n    }\\n\\n    return answer\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877382,
                "title": "100-efficiant-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int count;\\n        int ans=0;\\n        int row=0;\\n        for(int i=0; i<mat.size(); i++)\\n        {\\n            count=0;\\n            for(int j=0; j<mat[0].size(); j++)\\n            {\\n                if(mat[i][j]==1)\\n                {\\n                    count++;\\n                }\\n            }\\n            if (count>ans) \\n            {\\n                ans = count;\\n                row = i;\\n            }\\n        }\\n        return {row,ans};\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877021,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] ans = {0,0};\\n        int max  = 0, idx = 0;\\n        for(int i=0; i<mat.length; i++){\\n            int count = 0;\\n            for(int j=0; j<mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    count++;\\n                }\\n                if(count > max){\\n                    max  = count;\\n                    idx = i;\\n                }\\n            } \\n        }\\n        ans[0] = idx;\\n        ans[1] =  max;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3876131,
                "title": "java-clear-solution",
                "content": "\\n# Complexity\\n- Time complexity: *O(m * n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *O(1)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int[] result = new int[2];\\n        int n = mat.length, \\n            m = mat[0].length,\\n            max = 0,\\n            tem = 0;\\n\\n        for(int i = 0; i < n; i++){\\n            tem = 0;\\n            for(int j = 0; j < m; j++)\\n               if(mat[i][j] == 1) tem ++;\\n            \\n            if(tem > max){\\n                max = tem;\\n                result[0] = i;\\n                result[1] = max;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3874937,
                "title": "easy-solution-in-c-beats-93",
                "content": "# Intuition\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int ma=0;\\n        int mi=0;\\n        for(int i=0;i<mat.size();i++){\\n            int c=0;\\n            for(int j=0;j<mat[i].size();j++){\\n                if(mat[i][j]==1){\\n                    c++;\\n                }\\n            }\\n            if(ma<c && c!=0){\\n                ma=c;\\n                if(mi<i){\\n                    mi=i;\\n                }\\n            }\\n        }\\n        vector<int>ans;\\n        ans.push_back(mi);\\n        ans.push_back(ma);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873695,
                "title": "to-find-maximum-ones-in-2d-array-and-output-contains-index-of-maximum-ones-and-count-of-ones",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int counter[] = new int[mat.length];\\n\\n//the below code to find the ones in the 2D array\\n        for(int i =0; i<mat.length; i++){\\n            for(int j = 0; j< mat[0].length; j++){\\n                if(mat[i][j] == 1){\\n                    counter[i]++;\\n                }\\n            }\\n        }\\n\\n        int finalCount =Integer.MIN_VALUE; //to store minus infinity\\n       int m =0;\\n        for(int i = counter.length-1;i >= 0;i--){\\n            if(counter[i] >= finalCount){\\n                finalCount = counter[i];\\n                m = i;\\n            }\\n        }\\n     //  int max = finalCount;\\n       //int index = m;\\n        int con[] ={m,finalCount};\\n    return con;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870704,
                "title": "solution-with-enu",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        res = [0, float(\"-inf\")]\\n        for i, v in enumerate(mat):\\n            if res[1] < (s:=sum(v)):\\n                res[1] = s\\n                res[0] = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868524,
                "title": "simple-iterative-decision",
                "content": "## Code\\n![image.png](https://assets.leetcode.com/users/images/83391be2-74af-480c-bf4a-f1805a847370_1691256904.8159122.png)\\n\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        result = [0,0]\\n        for idx, row in enumerate(mat):\\n            s = sum(row)\\n            if s > result[1]:\\n                result = [idx, s]\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864083,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n          int rows=mat.length;\\n          int cols=mat[0].length;\\n          \\n          int ans[]=new int[2];\\n          int idx=0;\\n          int count=Integer.MIN_VALUE;\\n\\n          for(int i=0; i<rows; i++)\\n          {\\n                 int cnt=0;\\n             for(int j=0; j<cols; j++)\\n             {\\n                 if(mat[i][j]==1)\\n                 {\\n                   cnt++;\\n                 }\\n             }\\n             if(cnt>count)\\n             {\\n                 count=cnt;\\n                 idx=i;\\n             }\\n          }\\n          ans[0]=idx;\\n          ans[1]=count;\\n\\n          return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857580,
                "title": "the-realworld-solution-for-java",
                "content": "# Intuition\\nThinking about the solution\\n\\n# Approach\\nWriting the solution\\n\\n# Complexity\\n- Time complexity:\\n\\u044F \\u0434\\u0443\\u043C\\u0430\\u044E \\u0448\\u043E \\u041E(n)\\n\\n- Space complexity:\\n\\u043D\\u0435 \\u041E(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```\\n\\nUpvote if you want Andrew Tate to be free :)",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Matrix",
                    "Counting",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int[] rowAndMaximumOnes(int[][] mat) {\\n        int max = 0;\\n        int index = 0;\\n\\n        for(int i = 0; i < mat.length; i++) {\\n            int count = 0;\\n\\n            for(int j = 0; j < mat[i].length; j++) {\\n                if(mat[i][j] == 1) count++;\\n            }\\n\\n            if(count > max) index = i;\\n            max = Math.max(max, count);\\n        }\\n\\n        int[] RealWorld = new int[] {index, max};\\n\\n        return RealWorld;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854102,
                "title": "python-beginner-s-friendly-solution-think-easiest-way",
                "content": "I think the code is not like pythonic. But here is my simple solution.\\nPlease any advice me. It would be help.\\nThanks for reading. :)\\n\\n# Code\\n```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def rowAndMaximumOnes(self, mat: List[List[int]]) -> List[int]:\\n        max_cnt = 0\\n        answer = []\\n        for i in range(len(mat)):\\n            if mat[i].count(1) > max_cnt:\\n                answer = []\\n                max_cnt = mat[i].count(1)\\n                answer.append(i)\\n                answer.append(max_cnt)\\n        if max_cnt == 0:\\n            answer.append(0)\\n            answer.append(0)\\n        return answer\\n        \\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851496,
                "title": "easy-understandable",
                "content": "\\n# Complexity\\n- Time complexity: O (m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> rowAndMaximumOnes(vector<vector<int>>& mat) {\\n        int sz = mat.size();\\n        int szin = mat[0].size();\\n\\n        int cntofone = 0;\\n        int idx = 0;\\n\\n        for(int i = 0; i < sz; i++){\\n            int cnt = 0;\\n            for(int j = 0; j <szin ; j++){\\n\\n                if(mat[i][j]==1)cnt++;\\n\\n            }\\n\\n            if(cntofone < cnt){\\n                cntofone = cnt;\\n                idx = i;\\n            }\\n        }\\n        vector<int>result = {idx, cntofone};\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1865174,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1869530,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            },
            {
                "id": 1865186,
                "content": [
                    {
                        "username": "M1dn1ght",
                        "content": "Perfect way  to start your day with this easy beautiful problem"
                    },
                    {
                        "username": "shahil3303",
                        "content": "simple solution\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "If anyone enjoys one-line solutions, I explain one way to do it in great length, to give beginners some syntaxic ideas to work with:\n[Check it out!](https://leetcode.com/problems/row-with-maximum-ones/solutions/3422198/how-about-a-python-one-liner-detailed-begginer-friendly-explanations/)"
                    }
                ]
            }
        ]
    },
    {
        "title": "Sliding Subarray Beauty",
        "question_content": "<p>Given an integer array <code>nums</code> containing <code>n</code> integers, find the <strong>beauty</strong> of each subarray of size <code>k</code>.</p>\n\n<p>The <strong>beauty</strong> of a subarray is the <code>x<sup>th</sup></code><strong> smallest integer </strong>in the subarray if it is <strong>negative</strong>, or <code>0</code> if there are fewer than <code>x</code> negative integers.</p>\n\n<p>Return <em>an integer array containing </em><code>n - k + 1</code> <em>integers, which denote the </em><strong>beauty</strong><em> of the subarrays <strong>in order</strong> from the first index in the array.</em></p>\n\n<ul>\n\t<li>\n\t<p>A subarray is a contiguous <strong>non-empty</strong> sequence of elements within an array.</p>\n\t</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,-1,-3,-2,3], k = 3, x = 2\n<strong>Output:</strong> [-1,-2,-2]\n<strong>Explanation:</strong> There are 3 subarrays with size k = 3. \nThe first subarray is <code>[1, -1, -3]</code> and the 2<sup>nd</sup> smallest negative integer is -1.&nbsp;\nThe second subarray is <code>[-1, -3, -2]</code> and the 2<sup>nd</sup> smallest negative integer is -2.&nbsp;\nThe third subarray is <code>[-3, -2, 3]&nbsp;</code>and the 2<sup>nd</sup> smallest negative integer is -2.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,-2,-3,-4,-5], k = 2, x = 2\n<strong>Output:</strong> [-1,-2,-3,-4]\n<strong>Explanation:</strong> There are 4 subarrays with size k = 2.\nFor <code>[-1, -2]</code>, the 2<sup>nd</sup> smallest negative integer is -1.\nFor <code>[-2, -3]</code>, the 2<sup>nd</sup> smallest negative integer is -2.\nFor <code>[-3, -4]</code>, the 2<sup>nd</sup> smallest negative integer is -3.\nFor <code>[-4, -5]</code>, the 2<sup>nd</sup> smallest negative integer is -4.&nbsp;</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-3,1,2,-3,0,-3], k = 2, x = 1\n<strong>Output:</strong> [-3,0,-3,-3,-3]\n<strong>Explanation:</strong> There are 5 subarrays with size k = 2<strong>.</strong>\nFor <code>[-3, 1]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[1, 2]</code>, there is no negative integer so the beauty is 0.\nFor <code>[2, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[-3, 0]</code>, the 1<sup>st</sup> smallest negative integer is -3.\nFor <code>[0, -3]</code>, the 1<sup>st</sup> smallest negative integer is -3.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length&nbsp;</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= k &lt;= n</code></li>\n\t<li><code>1 &lt;= x &lt;= k&nbsp;</code></li>\n\t<li><code>-50&nbsp;&lt;= nums[i] &lt;= 50&nbsp;</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3445659,
                "title": "c-java-python3-simple-counting",
                "content": "\\n# Intuition\\nSince the range of numbers is small `-50 <= nums[i] <= 50`  we can use this to our advantage. Store counts of numbers smaller than 0 in a counter array and use that to find the `xth` smallest number.  \\n\\n# Approach\\nIterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to `x` we have found out `xth` smallest number. If sum of counts is never greater than or equal to `x` there aren\\'t enough negative numbers.\\nLine by line explanation:\\n1. `if nums[i] < 0: counter[nums[i] + 50] += 1` For negative numbers increment counter, -50 is mapped to 0, -1 is mapped to 49.\\n2. `if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1` Since we only have to consider a window of size k, we need to remove elements on the front of the sliding window. The front will be at  index `i - k`. Now since we only added negative numbers to the counter we\\'ll remove only if `nums[i - k]` is negative.\\n3. `if i - k + 1 < 0: continue` This checks if the sliding window has atleast k elements\\n4. The rest of the code iterates over the `counter` array to find the `xth` smallest number.\\n\\n# Complexity\\n- Time complexity: `O(n * 50)`\\n\\n- Space complexity: `O(n - k + 1 + 50)`\\n\\n# Code\\n**Python3**:\\n```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\\n\\n**C++**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**C++ but more concise**:\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n**Java**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\\n\\n**Java but more concise**:\\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\\n\\n## Bonus:\\nUse `SortedList` in Python:\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```\\nTime Complexity: `O(nlogk)`",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```\\ndef getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    counter, ans = [0] * 50, [0] * (len(nums) - k + 1)\\n    for i in range(len(nums)):\\n        if nums[i] < 0: counter[nums[i] + 50] += 1\\n        if i - k >= 0 and nums[i - k] < 0: counter[nums[i - k] + 50] -= 1\\n        if i - k + 1 < 0: continue\\n        count = 0\\n        for j in range(50):\\n            count += counter[j]\\n            if count >= x:\\n                ans[i - k + 1] = j - 50\\n                break\\n    return ans\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    vector<int> ans(nums.size() - k + 1), counter(50);\\n    for (int i = 0; i < nums.size(); i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        if (i - k + 1 < 0) continue;\\n        for (int j = 0, count = 0; j < 50; j++) {\\n            count += counter[j];\\n            if (count >= x) {\\n                ans[i - k + 1] = j - 50;\\n                break;\\n            }\\n        }\\n    }\\n    return ans;\\n}\\n```\n```\\npublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int[] counter = new int[50], ans = new int[nums.length - k + 1];;\\n    for (int i = 0; i < nums.length; i++) {\\n        if (nums[i] < 0) counter[nums[i] + 50]++;\\n        if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n        for (int j = 0, count = 0; j < 50 && count < x && i >= k - 1; j++)\\n            if ((count += counter[j]) >= x)\\n                ans[i - k + 1] = j - 50;\\n    }\\n    return ans;\\n}\\n```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl, ans = SortedList(), []\\n        for i, y in enumerate(nums):\\n            sl.add(y)\\n            if len(sl) > k: sl.remove(nums[i - k])\\n            if i >= k - 1: ans.append(min(0, sl[x - 1]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445677,
                "title": "cpp-java-python-sliding-window-explanation-with-comments",
                "content": "\\n\\n>##### \\uD83D\\uDD3C IF YOU HELPFUL, PLEASE UPVOTE \\n---\\n\\n#### Approach :\\n* First observation is `-50 <= nums[i] <= 50`, we have only 50 negative numbers so we track of them in freq array\\n* Calculate xth smallest number in freq array\\n\\n---\\n#### Explanation : \\n* In given question, we have `-50 <= nums[i] <= 50` means only ` -50 to -1` negative elements and we need to calculate `xth` smallest negative element. We only deal with negative element in `k` size of sliding window.\\n* But one question like that How to calculate `xth smallest negative element` in current sliding windows bcz each time smallest element change?\\n* We just track of negative number of each sliding window and calculate `xth` smallest element.\\n* But, How to calculate `xth` negative element in current windows?\\n* We have freq of negative numbers in current windows so just calculate from `-50 to -1` xth negative element in `O(50)` constant time.\\n---\\n\\n#### Coplexity :\\n* Time Complexity : `O(N * 50)`\\n* Space Complexity : `O(50)`\\n---\\n\\n\\n###### Special Thanks to `@ManojKumarPatnaik` for `Java` solution\\n---\\n#### Solution :\\n\\n```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\\n\\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```\\n\\n>Have a good day. Happy Coding!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(51, 0), ans;\\n        \\n        for(int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if(nums[i] < 0) freq[abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { ans.push_back(-L); break;}\\n                }\\n                // No xth smallest number present \\n                if(cnt < x) ans.push_back(0);\\n                if(nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```java []\\n public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        ArrayList<Integer> ans = new ArrayList<>();\\n\\n        for (int i = 0, j = 0; i < n; i++) {\\n            // count freq of negative numbers in current sliding windows\\n            if (nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                // calculate xth smallest number in current sliding windows\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) { \\n                        ans.add(-L);\\n                        break;\\n                    }\\n                }\\n                // No xth smallest number present \\n                if (cnt < x) ans.add(0);\\n                if (nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return ans.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n```\n```python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        freq, ans, j = [0] * 51, [], 0\\n\\n        for i in range(len(nums)):\\n            # count freq of negative numbers in current sliding windows\\n            if nums[i] < 0 : freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k :\\n                cnt = 0\\n                # calculate xth smallest number in current sliding windows\\n                for L in reversed(range(51)):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        ans.append(-L)\\n                        break\\n                # No xth smallest number present \\n                if cnt < x : ans.append(0)\\n                if nums[j] < 0 : freq[abs(nums[j])] -= 1\\n                j += 1\\n            \\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445945,
                "title": "using-map-sliding-window-very-simple-easy-to-understand",
                "content": "<b> Up Vote if you like the solution</b>\\n# Approach\\nUsing map we will keep storing the count of -50 to 50 in each window of size k.\\nThen with each window need to search the xth smallest element by counting the number of occurance of each element, in the map.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n        for(int i = 0; i < nums.size(); ++i){\\n            mp[nums[i]]++;\\n            if(i >= k-1){ \\n                if(i >= k) mp[nums[i-k]]--;\\n                int sum = 0, t = 0;\\n                for(auto m: mp){\\n                    sum += m.second;\\n                    if(sum >= x){\\n                        t = (m.first < 0)? m.first: 0;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(t);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445735,
                "title": "c-multiset-using-next-function-explained",
                "content": "**DISCLAIMER: This is not an optimised approach but it is working**\\t\\n\\n\\n**C++ Code:**\\n```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size(), j = 0;\\n        \\n        multiset<int> ms;\\n        vector<int> res;\\n        \\n        for(int i = 0; i < n; i++) {\\n            \\n            if(nums[i] < 0) ms.insert(nums[i]);\\n            \\n            if(i-j+1 == k) {\\n                \\n                if(ms.size() < x)res.push_back(0);\\n                else res.push_back(*next(ms.begin(), x - 1));\\n                \\n                if(nums[j] < 0) ms.erase(ms.find(nums[j]));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445781,
                "title": "python3-sortedlist",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k: vals.remove(nums[i-k])\\n            if i >= k-1: ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446019,
                "title": "policy-based-c",
                "content": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include<iostream>\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp> \\n\\nusing namespace __gnu_pbds; \\nusing namespace std;\\n\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n    int rank = t.order_of_key(v);\\n    ordered_set::iterator it = t.find_by_order(rank);\\n    t.erase(it);\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set st;\\n        int i=0,j=0;\\n        vector<int> ans;\\n        while(j<nums.size())\\n        {\\n            if(nums[j]<0)\\n            st.insert(nums[j]);\\n            if(j-i+1==k)\\n            {\\n                if(st.size()<x)\\n                ans.push_back(0);\\n                else\\n                {\\n                    auto temp = st.find_by_order(x-1);\\n                    ans.push_back(*temp);\\n                }\\n                if(nums[i]<0)\\n                myerase(st,nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446035,
                "title": "javascript-2653-sliding-subarray-beauty",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n1\\n```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```\\n\\n---\\n\\n**Contest**\\n- https://leetcode.com/contest/weekly-contest-342/ranking/67/\\n\\n**All Answers**\\n- **Q1** - https://leetcode.com/problems/calculate-delayed-arrival-time/solutions/3446023/javascript-2651-calculate-delayed-arrival-time/?orderBy=most_votes\\n- **Q2** - https://leetcode.com/problems/sum-multiples/solutions/3446027/javascript-2652-sum-multiples/?orderBy=most_votes\\n- **Q3** - https://leetcode.com/problems/sliding-subarray-beauty/solutions/3446035/javascript-2653-sliding-subarray-beauty/?orderBy=most_votes\\n- **Q4** - https://leetcode.com/problems/minimum-number-of-operations-to-make-all-array-elements-equal-to-1/solutions/3446411/javascript-2654-minimum-number-of-operations-to-make-all-array-elements-equal-to-1/?orderBy=most_votes\\n\\n---\\n\\n![image.png](https://assets.leetcode.com/users/images/37970e7b-b559-4aa9-834c-e178df5ddaa7_1682232917.7638698.png)\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar getSubarrayBeauty = function (a, k, x) {\\n    let n = a.length;\\n\\n    let f = {}; // frequency count\\n    for (let i = -50; i <= 50; i++) {\\n        f[i] = 0;\\n    }\\n\\n    let an = [];\\n    let j = 0;\\n    for (let i = 0; i < n; i++) {\\n        f[a[i]]++;\\n        if (i < k - 1) continue; // skip first k-1 elements\\n\\n        let c = 0; // count\\n        for (let i2 = -50; i2 <= 50; i2++)\\n            if (f[i2]) {\\n                c += f[i2]; // add frequency to count\\n                if (c >= x) {\\n                    if (i2 < 0) an.push(i2);\\n                    else an.push(0);\\n                    break;\\n                }\\n            }\\n\\n        f[a[j]]--;\\n        j++;\\n    }\\n\\n    return an;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3445753,
                "title": "cpp-window-sliding-open-addressing-map",
                "content": "### Intuition : \\nAs the numbers are in the range `[-50,50]` we can just increase , decrease count as we move ahead the window.\\nand loop through `[-50,50]` and keep on adding int `cnt` if `cnt >= x` that means that particular number is xth smallest.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n#### Optimisation 1 : \\nWe can just count instead of storing .\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<vector<int>> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50].push_back(v[end++]);\\n            if(end - start > k) {\\n                mp[v[start] + 50].pop_back();\\n                start++;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i].size();\\n                    if(cnt >= x) {\\n                        val = mp[i][0];\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        vector<int> ans;\\n        vector<int> mp(101);\\n        int start = 0,end = 0,n = v.size();\\n        while(end < n) {\\n            mp[v[end] + 50]++;\\n            end++;\\n            if(end - start > k) {\\n                mp[v[start++] + 50]--;\\n            }\\n            if(end - start == k) {\\n                int cnt = 0, val;\\n                for(int i = 0; i <= 100; i += 1) {\\n                    cnt += mp[i];\\n                    if(cnt >= x) {\\n                        val = i - 50;\\n                        break;\\n                    }\\n                }\\n                ans.push_back(val > 0 ? 0 : val);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445694,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int a[] = new int[101];\\n        int res[] = new int[n - k + 1];\\n        for (int i=0;i<k;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for (int i=0;i<=n-k;i++)\\n        {\\n            int count=0,val=-1;\\n            for(int j=0;j<=49;j++)\\n            {\\n                if(a[j]>0)\\n                {\\n                    count+=a[j];\\n                    if(count>=x)\\n                    {\\n                        val=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            a[nums[i]+50]--;\\n            if(i<n-k)\\n            {\\n                a[nums[i+k]+50]++;\\n            }\\n            res[i] = val == -1 ? 0 : val-50;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445893,
                "title": "sliding-window-map-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nConstraints are low like value of elements of array are between -50 to 50, so we can use map to optimise sliding window here.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Push first k element in Map\\n2. Find second smallest element using counting if we find we compare the value with 0 and take minimum of it. (positive element is second smallest take ans[i] as 0).\\n3. push the second smallest element in ans,repeat this process n-k-1 times using sliding window.\\n4. Return the ans\\n\\n# Complexity\\n- Time complexity: O(N*LogN) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     \\n        int n=nums.size();\\n        map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        vector<int> answer;\\n        int cnt=0;\\n        int res=0;\\n        for(auto y:mp)\\n        {\\n          cnt+=y.second;\\n            if(cnt>=x)\\n            {\\n                res=min(res,y.first);\\n                break;\\n            }\\n        }\\n        answer.push_back(res);\\n        for(int i=k;i<n;i++)\\n        {\\n            mp[nums[i-k]]--;\\n            if(mp[nums[i-k]]==0) mp.erase(nums[i-k]);\\n            mp[nums[i]]++;\\n            int cnt=0;\\n            int res=0;\\n          for(auto y:mp)\\n          {\\n             cnt+=y.second;\\n             if(cnt>=x)\\n             {\\n                res=min(res,y.first);\\n                break;\\n             }\\n       \\n          }\\n         answer.push_back(res);     \\n        }\\n    return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445704,
                "title": "python-3-sorted-containers",
                "content": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        win = SortedList()\\n        \\n        for i in range(k):\\n            win.add(nums[i])\\n        \\n        res = []\\n        if win[x - 1] < 0:\\n            res.append(win[x - 1])\\n        else:\\n            res.append(0)\\n        \\n        for i in range(k, len(nums)):\\n            win.add(nums[i])\\n            win.discard(nums[i - k])\\n            \\n            if win[x - 1] < 0:\\n                res.append(win[x - 1])\\n            else:\\n                res.append(0)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445678,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int func(int x){\\n        int val=0;\\n        for(auto ele:mp){\\n            if(ele.second+val >= x){\\n                if(ele.first > 0)\\n                    return 0;\\n                return ele.first;\\n            }\\n            val += ele.second;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int> ans;\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n            if(i>=k)\\n                mp[nums[i-k]]--;\\n            if(i>=k-1)\\n                ans.push_back(func(x));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446469,
                "title": "unordered-map-o-n-50-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(), i = 0;\\n        unordered_map<int, int> m;\\n        vector<int> ans;\\n        \\n        for(int j=0; j<n; j++) {\\n            m[nums[j]]++;\\n            if(j - i + 1 == k) {\\n                int cnt = x;\\n                for(int val=-50; val<=-1; val++) {\\n                    cnt -= m[val];\\n                    if(cnt <= 0) {\\n                        ans.push_back(val);\\n                        break;\\n                    }\\n                }\\n                if(cnt > 0) ans.push_back(0);\\n                m[nums[i++]]--;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446816,
                "title": "python-easiest-3-three-approach-hash-map-sortedlist-ds-slinding-windows",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIntuition behind question is very simple sliding window but the extra things is added we have to find the xth smallest number so, we are using either sort again again or some data structure like sorted list to find the xth smallest number.\\nI think in this question only we have deal with optimization.\\nFirst i think in the slinding window we make the k size window and find x the minimum element by sorting again again but it giving TLE \\nafter so many TLE i think of the sortedList data structure.\\n\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote:SortedList Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n**Step1:First we are add element of k-1 range  make window of k-1 range in a sortedList\\nSTEP2: Then we are iterate from iterate from the( k+1,len(nums)) and if len(a)>=x and xth smallest is <0 negative number and add in ans list otherwise we are adding 0\\nSTEP3: Slide the window by adding and the remove first element**\\n![WhatsApp Image 2023-04-23 at 2.24.39 PM.jpeg](https://assets.leetcode.com/users/images/ada39c63-3883-4f25-a877-1a46e2c02c9f_1682240267.7857494.jpeg)\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n(log(n)))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**GIVING LEETCODE CONTEST IN MORNING BE LIKE\\uD83D\\uDE05\\uD83D\\uDE05**\\n**US BRO US\\uD83E\\uDD72**\\n![6b6a5f7b23bcfbbea25e680b77369890.jpg](https://assets.leetcode.com/users/images/468495ef-994e-49d1-a69a-e0e12b96137e_1682239704.2012587.jpeg)\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        # Its Time Complexity is 0(log(n)) that\\'s why we are using SortedList Data structure \\n        a=SortedList([])\\n        ans=[]\\n        #STEP1: First we are add element of k-1 range  make window of k-1 range\\n        for ws in range(k):\\n            a.add(nums[ws])\\n        #STEP2: Then we are iterate from iterate from the k+1,len(nums) and if len(a)>=x and xth smallest is <0 \\n        for i in range(k,len(nums)):\\n            if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n            else:\\n                ans.append(0)\\n        #STEP3: Slide the window by adding and the remove first element\\n            a.remove(nums[i-k])\\n            a.add(nums[i])\\n         \\n        # print(ans)\\n    #Remaining last element \\n        if x<=len(a) and a[x-1]<0:\\n                ans.append(a[x-1])\\n        else:\\n            ans.append(0)\\n \\n            # a.remove(nums[i-k])\\n            # a.add(nums[i])\\n        return ans\\n```\n```python []\\n#TLE GIVING FOR THE 10 TASTE CASES THIS IS BRUTE FORCE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ws=0\\n        we=k-1\\n        l1=[]\\n        for i in range (we,len(nums)):\\n            arr=sorted(nums[ws:i+1])\\n            min1=arr[x-1]\\n            if min1>0:\\n                l1.append(0)\\n            else:\\n                l1.append(arr[x-1])\\n            ws+=1\\n        return l1\\n\\n\\n\\n```\n```python []\\n#IN python their is no such ordered map so we make ordered hash map but is is also giving TLE\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n    \\n        dict1={}\\n        c=0\\n        w_start=0\\n        l1=[]\\n        def solve(dict1):\\n            c=0\\n            myKeys = list(dict1.keys())\\n            myKeys.sort()\\n            sorted_dict = {i: dict1[i] for i in myKeys}\\n            for i in sorted_dict  :\\n                c+=dict1[i]\\n                if c>=x:\\n                    return i\\n            return float(\\'inf\\')\\n        for we in range (len(nums)):\\n            if nums[we] not in dict1:\\n                dict1[nums[we]]=1\\n            else:\\n                dict1[nums[we]]+=1\\n            while we-w_start+1>k:\\n                dict1[nums[w_start]]-=1\\n                if dict1[nums[w_start]]==0:\\n                    del dict1[nums[w_start]]\\n                w_start+=1\\n            if we-w_start+1==k:\\n                #search for x smallest\\n                min1=solve(dict1)\\n                if min1>0 or min1==float(\\'inf\\'):\\n                    l1.append(0)\\n                else:\\n                    l1.append(min1)\\n        return l1\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446064,
                "title": "leetcode-the-hard-way-sortedlist",
                "content": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```py\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        w = SortedList(nums[:k])\\n        res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        for i in range(k, len(nums)) :\\n            w.remove(nums[i - k])\\n            w.add(nums[i])\\n            res.append(0 if w[x - 1] > 0 else w[x - 1])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445758,
                "title": "ez-c-using-sliding-window",
                "content": "**Time Complexity : O(Nlog N)\\nSpace Complexity : O(N)**\\n\\nInitial Thought Process : \\n* I thought of using a multiset to store the \\'k\\' elements and during each iteration add the \\'x\\' th smallest negative number to our answer.\\n* This resulted in TLE since the find opeartion takes O(log N) and erase also took time.\\n* Since multiset uses bidirectional iterator we won\\'t be directly able to access the xth element by doing `ms.begin()+x` . We need to advance the iterator, which is also very time consuming.\\n* So the next approach I thought was the sliding window approach and after a few trial and error I came upwith the solution.\\n\\n```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find_element(map<int,int>&m,int x){\\n        int c=0;\\n        for(auto i:m){\\n             c+=i.second;//Incrementing counter to point to the corresponding elment in our key-value pair\\n            if(c>=x) //This means that the \\'x\\' element is present so we return it\\n                return i.first;\\n           \\n        }\\n        return INT_MAX; // \\'x\\' the smallest element not in our window\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        map<int,int>m;\\n        int i=0;\\n       vector<int>res;\\n        \\n        for(int j=0;j<nums.size();j++){\\n            \\n            m[nums[j]]++; // Add element to the window\\n            while((j-i+1)>k){           //Invalid Window Size     \\n                m[nums[i]]--;// Removing element from our window\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n                i++;\\n            }\\n            \\n            if((j-i+1)==k){//Valid Window\\n                int minX=find_element(m,x);//Searching for the \\'x\\' th smallest negative element in our window\\n                if(minX==INT_MAX||minX>0)\\n                    res.push_back(0);\\n                else\\n                    res.push_back(minX);\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445737,
                "title": "c-code-using-multi-set-erase-without-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution { \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    { \\n        multiset<int> negNums = getInitialSet(nums, k);\\n        vector<int> ans = getBeautyArray(negNums, x);\\n        for (int i = k; i < nums.size(); i++) \\n        {\\n            updateSet(negNums, nums[i - k], nums[i]);\\n            ans.push_back(getBeautyElement(negNums, x));\\n        } \\n        return ans;  \\n    } \\nprivate:\\n    multiset<int> getInitialSet(const vector<int>& nums, int k) \\n    {\\n        multiset<int> negNums; \\n        for (int i = 0; i < k; i++) \\n        { \\n            if (nums[i] < 0) \\n            { \\n                negNums.insert(nums[i]); \\n            } \\n        } \\n        return negNums;\\n    }\\n    \\n    vector<int> getBeautyArray(const multiset<int>& negNums, int x) \\n    {\\n        vector<int> ans; \\n        if (negNums.size() >= x) \\n        { \\n            ans.push_back(*next(negNums.begin(), x - 1)); \\n        } \\n        else \\n        { \\n            ans.push_back(0); \\n        } \\n        return ans;\\n    }\\n    void updateSet(multiset<int>& negNums, int oldNum, int newNum) \\n    {\\n        if (oldNum < 0) \\n        { \\n            negNums.erase(negNums.lower_bound(oldNum)); \\n        } \\n        if (newNum < 0) \\n        { \\n            negNums.insert(newNum); \\n        }\\n    }\\n    int getBeautyElement(const multiset<int>& negNums, int x) \\n    {\\n        if (negNums.size() >= x) \\n        { \\n            return *next(negNums.begin(), x - 1); \\n        } \\n        else \\n        { \\n            return 0; \\n        } \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446465,
                "title": "c-easiest-solution-using-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0;\\n        int j=0;\\n        int n=nums.size();\\n        vector<int> v(51,0);\\n        vector<int> ans;\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            v[(nums[j]+50)%50]++;\\n            if(j-i+1==k)\\n            {\\n                int p=x;\\n                bool flag=false;\\n                vector<int> v1=v;\\n                for(int i=0;i<=50;i++)\\n                {\\n                    if(v1[i]>0)\\n                    {\\n                        p-=v1[i];\\n                    }\\n                    if(p<=0)\\n                    {\\n                        ans.push_back(i-50);\\n                        flag=true;\\n                        break;\\n                    }\\n                }\\n                if(!flag)\\n                ans.push_back(0);\\n                if(nums[i]<0)\\n                v[(nums[i]+50)%50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445799,
                "title": "c-soutions-explained-line-by-line-easy-to-understand-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe function takes an input array of integers, the length of the subarray to be considered, and a count x. It then returns an array of integers that contains the maximum negative integer of the subarrays of length k that contain at least x negative integers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a sliding window approach to go through the input array nums. We maintain a counter for negative integers in negative_count initialized with 50 elements (covering the range from -49 to 0). Whenever we add a new integer to the current window, we increment the counter at the corresponding index if it\\'s negative. Similarly, when we move the window to the right, we decrement the counter at the corresponding index if the element falling out of the window is negative.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(nk), where n is the size of the input array nums, and k is the input parameter representing the size of the subarrays.\\n\\nThe function iterates through the array nums once, and for each element it performs three operations: updating the counter for the current element, removing the counter for the element outside the current subarray, and finding the smallest negative element with frequency >= x.\\n\\nEach of these operations takes O(1) time, except for finding the smallest negative element with frequency >= x, which takes O(50) time (since there are at most 50 distinct negative numbers in the input).\\n\\nSince the function iterates through nums once and performs O(1) operations for each element, the overall time complexity is O(nk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this function is O(1) for the input array nums and the input parameters k and x.\\n\\nThe function uses two additional vectors: ans and counter. The size of ans is nums.size() - k + 1, which is O(n) in the worst case. The size of counter is 50, which is a constant. Therefore, the space complexity of the function is O(n) in the worst case.\\n\\nHowever, we can optimize the space complexity by using a sliding window approach to update the counter vector, and computing the result for each subarray as we go along, instead of storing it in the ans vector. This would reduce the space complexity to O(1), since we would only need to store a constant amount of additional variables to compute the result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans(nums.size() - k + 1, 0), counter(50, 0);\\n        for (int i = 0; i < nums.size(); i++) {\\n            // Update counter for current element\\n            if (nums[i] < 0) counter[nums[i] + 50]++;\\n            // Remove counter for the element outside the current subarray\\n            if (i - k >= 0 && nums[i - k] < 0) counter[nums[i - k] + 50]--;\\n            // Check if current subarray size is greater than k\\n            if (i - k + 1 < 0) continue;\\n            // Find the smallest negative element with frequency >= x\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3448390,
                "title": "easy-understable-sliding-window-using-map",
                "content": "# Intuition\\nUSe sliding window and use map to find the Xth smallest negative number.\\n\\n# Approach\\nRun a loop and count the frequency of negative number and check if frequency is equal to the X. If yes then push that element in ans vector and if no then just push 0.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int,int>mp;\\n        for(int i=0;i<k;++i){\\n            mp[nums[i]]++;\\n        } \\n        \\n        vector<int>ans;\\n        int j=0;\\n        for(int i=k;i<=n;++i){\\n            int cnt=0;\\n            for(auto m:mp){\\n                if(m.first<=0){\\n                    if(m.second>0) cnt+=m.second;\\n                    if(cnt>=x){\\n                        ans.push_back(m.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            if(cnt<x) ans.push_back(0);\\n            if(i==n) break;\\n            mp[nums[i]]++;\\n            mp[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447155,
                "title": "brute-force-200-717-tc-priority-queue-702-717-tc-passed-optimised-queue-map-c",
                "content": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }\\n            return pq.top();\\n        }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //APPROACH-1 BRUTE FORCE\\n        int n=nums.size();\\n       \\n        int i=0,j=0;\\n        bool ok=false;\\n            priority_queue<int,vector<int>,greater<int>> pq;\\n        vector<int> ans;\\n        if(k==1 && x==1) {\\n            ok=true;\\n            for(int i=0;i<nums.size();i++){\\n                if(nums[i]<0)ans.push_back(nums[i]);\\n                else ans.push_back(0);\\n            }\\n        }\\n        if(ok==false)\\n        while(j<nums.size()){\\n            pq.push(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1<=k){\\n                int temp=0;\\n                int cnt=0;\\n                bool flag=false;\\n                for(int k=0;k<x;k++){\\n                     if(pq.top()>0){ \\n                            cnt++;\\n                        }\\n                    else break;\\n                }\\n                if(k==cnt){\\n                    temp=0;\\n                    flag=true;\\n                }\\n               if(flag==false) for(int k=0;k<x;k++){\\n                       \\n                        temp=(pq.top());\\n                        //cout<<pq.top()<<\" \";\\n                   if(k==0)pq.pop();\\n                    if(k==x-1) break;\\n                    \\n                }\\n                if(temp>0) temp=0;\\n                //cout<<pq.top()<<\" \";\\n              //  cout<<temp<<\" \";\\n                ans.push_back(temp);\\n               // for(auto it:ans) cout<<it<<\" \";\\n                pq.push(nums[j]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n        \\n        \\n    \\n        //APPROACH 2- PRIORITY QUEUE\\n        int n=nums.size();\\n        int i=0;\\n        vector<int> ans;\\n        int j=k;\\n        while(j-1!=n){\\n            int minElement=priority(nums,i,j,x);\\n            if(minElement>0) ans.push_back(0);\\n            else ans.push_back(minElement);\\n            i++;\\n            j++;\\n        }\\n        return ans;\\n        \\n        //OPTIMISED QUEUE+MAP\\n         int n=nums.size();\\n         map<int,int> mp;\\n        vector<int> ans;\\n        queue<int> q;\\n        for(auto it:nums){\\n            mp[it]++;\\n            q.push(it);\\n        \\n        if(q.size()==k){\\n        int curr=q.front();\\n        q.pop();\\n        int siz=0;\\n        for(auto it:mp){\\n            siz+=it.second;\\n            if(siz>=x){\\n                if(it.first>0) ans.push_back(0);\\n                else ans.push_back(it.first);\\n                break;\\n            }\\n        }\\n            if(mp[curr]>1)mp[curr]--;\\n            else mp.erase(curr);\\n         }\\n        }\\n        return ans;\\n        \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    //APPROACH 2- PRIORITY QUEUE TLE\\n        int priority(vector<int>&nums,int i,int j,int x){\\n            priority_queue<int> pq;\\n            for(int l=i;l<j;l++){\\n                pq.push(nums[l]);\\n                if(pq.size()>x)pq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3446993,
                "title": "easy-explanation-multiset-pointer-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince we require `xth` smallest element, we should use a container which keeps element sorted for quick queries. Also, note that the values may repeat.\\nSo we can use a `multiset`.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to always keep the pointer at the `xth` smallest element after insertion/deletion operations.\\n\\n**But exactly how?**\\nOnce, we insert first `k` set of numbers. We can simply move to the `xth` smallest element in the multiset from the begining to initialize our pointer `ptr`. This would take `x - 1` steps. \\nThen for each insertion/deletion we can follow below steps to maintain our pointer at correct position.\\n\\nAssume that we are at `ith` iteration and value at our `ptr` is `ptr_value`.\\n**Insertion**\\nElement to be inserted is `nums[i]`. First insert this element. Then:\\n* If `nums[i] < ptr_value`: \\nThis value is inserted to the left of `ptr` hence the `ptr` is now pointing to `x+1`th smallest element. Therefore, simply shift `ptr` to one place left(`ptr--`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\n**Deletion**\\nElement to be removed is `nums[i - k]`.\\n* If `nums[i - k] <= ptr_value`: \\nThis value was at left of `ptr`. After it gets removed, our `ptr` points to `x-1th` smallest element. Threfore, shift `ptr` to one position right(`ptr++`).\\n* Otherwise, the `ptr` remains at correct position.\\n\\nNow, remove `nums[i - k]`.\\n\\n**Note**\\nIf a new value is to be inserted which is already present in multiset then it gets inserted after all the same value element.\\nAnd, `st.find(e)` finds the first position of `e`. \\nThese properties helped us in considering edge cases in our if conditions of insertion and deletion.\\n\\n# Complexity\\n- Time complexity:$$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n\\nPlease upvote if it helped\\uD83D\\uDE42.",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        int n = nums.size();\\n        \\n        vector<int> res;\\n        multiset<int> st;\\n\\n        multiset<int>::iterator ptr;\\n        for(int i = 0; i < n; i++)\\n        {\\n            st.insert(nums[i]);\\n\\n            // initialize ptr\\n            if(i == k - 1)\\n                ptr = next(st.begin(), x - 1);\\n\\n            if(i >= k && nums[i] < *ptr)\\n                ptr--;\\n            \\n            if(i >= k)\\n            {\\n                if(nums[i - k] <= *ptr)  \\n                    ptr++;\\n                st.erase(st.find(nums[i - k]));\\n            }\\n\\n            if(i >= k - 1)\\n                res.push_back(min(0, *ptr));\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446927,
                "title": "pbds-c-helpful-data-structure-commented-code",
                "content": "# Intuition\\nWhen the question mentioned find the xth smallest element from the array I quickly thought of PBDS. It is basically a ordered set but the elements can be inedexed. Read more about it [here](https://codeforces.com/blog/entry/11080).\\n\\nTo handle the case of duplicate elements, I have stored the elements along with a index so that every element in the set is unique.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int, int>, null_type, less<pair<int, int>>, rb_tree_tag, tree_order_statistics_node_update>\\n\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &arr, int k, int x)\\n    {\\n        int i = 0, j = 0;\\n        ordered_set st;\\n        int n = arr.size();\\n        vector<int> temp;\\n        int ind = 0;\\n        while (j < n)\\n        {\\n            // Insert the current element into the ordered set along with its index\\n            st.insert({arr[j], ind});\\n\\n            // If the window size is less than k, increment j to expand the window\\n            if (j - i + 1 < k)\\n            {\\n                j++;\\n            }\\n\\n            // If the window size is equal to k\\n            else if (j - i + 1 == k)\\n            {\\n                // Find the x-th smallest element in the window and get its value\\n                int ans = (st.find_by_order(x - 1))->first;\\n                \\n                // If the value is non-negative, push 0 to the result vector\\n                if (ans >= 0)\\n                {\\n                    temp.push_back(0);\\n                }\\n                // Otherwise, push the value to the result vector\\n                else\\n                {\\n                    temp.push_back(ans);\\n                }\\n\\n                //Now to slide the window, Erase the element pointed by i from the window\\n                st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n\\n                // sliding the window\\n                i++;\\n                j++;\\n            }\\n            // Increment ind to keep track of the index of the current element\\n            ind++;\\n        }\\n        // Return the result vector\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446252,
                "title": "c-easy-to-understand-sliding-window",
                "content": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "````\\nclass Solution\\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int n = nums.size(), i, j, y;\\n        vector<int> count(50, 0), ans(n - k + 1, 0);\\n        for (i = 0; i < n; i++)\\n        {\\n            if (nums[i] < 0)\\n                count[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0)\\n                count[nums[i - k] + 50]--;\\n            y = 0;\\n            if (i - k + 1 >= 0)\\n            {\\n                for (j = 0; j < 50; j++)\\n                {\\n                    y += count[j];\\n                    if (y >= x)\\n                    {\\n                        ans[i - k + 1] = j - 50;\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446139,
                "title": "sliding-window-mapping-ve-integers-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int>m;\\n        \\n        int negcnt=0;          // Keeping Track Of Count Of Negative Numbers\\n        \\n        for(int i=0;i<k;i++)   //mapping first k elements\\n        {\\n            if(nums[i]<0) {\\n                m[nums[i]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        vector<int>res;\\n        int i=0,j=k-1;\\n        while(j<nums.size())     //sliding window\\n        {\\n            if(negcnt>=x)       //if we have sufficient element\\n            {\\n                int pos=x;\\n                for(auto ele:m)  //finding xth element\\n                {\\n                    if(pos-ele.second>0)\\n                    {\\n                        pos=pos-ele.second;\\n                    }\\n                    else\\n                    {\\n                        res.push_back(ele.first);\\n                        break;\\n                    }\\n                }\\n            }\\n            else             //if we do not have suficient elements the push 0\\n            {\\n                res.push_back(0);\\n            }\\n            \\n            if(nums[i]<0)     // removing element at ith position\\n            {\\n                m[nums[i]]--;\\n                negcnt--;\\n                if(m[nums[i]]==0)\\n                    m.erase(nums[i]);\\n            }\\n            \\n            i++;   //incrementing i\\n            if(j+1<nums.size()) j++;  //incrementing j\\n            else break;\\n            \\n            if(nums[j]<0)      //mapping new element in map\\n            {\\n                m[nums[j]]++;\\n                negcnt++;\\n            }\\n        }\\n        \\n        return res;    //return final result\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445867,
                "title": "sliding-window-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs mention in problem statement numbers are with in -50 to 50.\\nWith this we can Maintain a TreeMap with frequency. Once we reached the window size K compute the xth smallest in O(100) in worst case time complexity. This is enough to pass the Time limit.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(K log(K)) + O(100 * n)$$ \\n- \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int start = 0;\\n        int n = nums.length;\\n        int [] ans = new int[n - k + 1];\\n        int idx = 0;\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        \\n        for(int end = 0;end < n; end++){\\n            \\n            //System.out.println(\"Size = \" + (end - start + 1) + \" k = \" + k);\\n            if(end - start + 1 <= k){\\n                \\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n\\n            }else{\\n                //System.out.println(\"computing ans \" + getSecondSmall(tmap));\\n                ans[idx++] = Kth_smallest(tmap, x);//secmin;\\n                \\n                int val = nums[start];\\n                int tf = tmap.getOrDefault(nums[start], 0);\\n                if(tf <= 1)tmap.remove(nums[start]);\\n                else{\\n                    tmap.put(nums[start], tf-1);\\n                }\\n                start++;\\n\\n                tmap.put(nums[end], tmap.getOrDefault(nums[end], 0)+ 1);\\n            }\\n        }\\n        \\n        ans[idx++] = Kth_smallest(tmap, x);\\n        return ans;\\n    }\\n    \\n    int Kth_smallest(TreeMap<Integer, Integer> mp,int K){\\n        int freq = 0;\\n        for (Map.Entry it : mp.entrySet()) {\\n\\n            freq += (int)it.getValue();\\n\\n            if (freq >= K) {\\n                return Math.min((int)it.getKey(), 0);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445738,
                "title": "min-heap-java",
                "content": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n\\xA0\\xA0\\xA0 public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int n = nums.length;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int[] result = new int[n - k + 1];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 TreeMap<Integer, Integer> maxHeap = new TreeMap<>(Collections.reverseOrder());\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (int i = 0; i < n; i++) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int num = nums[i];\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Add the new element to the minHeap\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Remove the element that is out of the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int outOfWindow = nums[i - k];\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.put(outOfWindow, minHeap.get(outOfWindow) - 1);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (minHeap.get(outOfWindow) == 0) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 minHeap.remove(outOfWindow);\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 // Get the xth smallest element in the window\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (i >= k - 1) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int count = 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 int beautifulValue = 0;\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 for (Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 count += entry.getValue();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 if (count >= x) {\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 beautifulValue = entry.getKey();\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 break;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 result[i - k + 1] = beautifulValue < 0 ? beautifulValue : 0;\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 }\\n\\n\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0\\xA0 return result;\\n\\xA0\\xA0\\xA0 }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445727,
                "title": "simple-solution-with-explanation",
                "content": "# Description\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGiven an integer array nums containing n integers, find the beauty of each subarray of size k.\\n\\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\\n\\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\\n\\nA subarray is a contiguous non-empty sequence of elements within an array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe problem requires finding the \"beauty\" of all possible subarrays of a given length k in an array nums. The beauty of a subarray is defined as the smallest number that appears at least x times in the subarray. If no number appears at least x times, then the beauty is 0.\\n\\nTo solve this problem, we can use a sliding window approach, where we slide a window of length k over the array nums and calculate the beauty of each subarray. We can keep track of the counts of each number in the current window using a hash map. Then, for each subarray of length k, we can iterate through the hash map to find the smallest number that appears at least x times, and set the beauty of the subarray to that number. If no number appears at least x times, we set the beauty to 0.\\n\\nWe repeat this process for all possible subarrays of length k in the array nums and store the beauties in an output array of length n - k + 1, where n is the length of nums. Finally, we return the output array.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the getSubarrayBeauty method is O(nklogk), where n is the length of the input array nums and k is the length of the subarrays.\\n\\nThe method uses a sliding window approach to iterate through the input array nums, which takes O(n) time. Within each window of size k, the method performs the following operations:\\n\\nAdding an element to the minHeap takes O(logk) time.\\nRemoving an element from the minHeap takes O(logk) time.\\nIterating through the elements of the minHeap takes O(k) time in the worst case, since there can be up to k elements in the minHeap.\\nSince we perform these operations for each window of size k, the overall time complexity is O(nklogk).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity of the getSubarrayBeauty method is O(k), which is the space used by the minHeap and maxHeap data structures. This is because the method only needs to keep track of the counts of the numbers within the current window of size k, which is at most k distinct numbers. The output array of length n - k + 1 also takes O(n - k + 1) = O(n) space, but this is not considered as extra space used by the method.\\n\\n# Code\\n```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.*;\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] result = new int[n - k + 1];\\n\\n  \\n        TreeMap<Integer, Integer> minHeap = new TreeMap<>();\\n        \\n\\n        for (int i = 0; i < n; i++) {\\n            int num = nums[i];\\n\\n            \\n            minHeap.put(num, minHeap.getOrDefault(num, 0) + 1);\\n\\n            \\n            if (i >= k) {\\n                int out = nums[i - k];\\n                minHeap.put(out, minHeap.get(out) - 1);\\n                if (minHeap.get(out) == 0) {\\n                    minHeap.remove(out);\\n                }\\n            }\\n\\n            if (i >= k - 1) {\\n                int cnt = 0;\\n                int beauty = 0;\\n                Iterator<Map.Entry<Integer, Integer>> it = minHeap.entrySet().iterator();\\n                while (it.hasNext() && cnt < x) {\\n                    Map.Entry<Integer, Integer> entry = it.next();\\n                    cnt += entry.getValue();\\n                    if (cnt >= x) {\\n                        beauty = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                result[i - k + 1] = beauty < 0 ? beauty : 0;\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446913,
                "title": "map-and-sliding-window-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<int,int> mp;\\n    int checker(int x){\\n        for(auto k : mp){\\n            x -= k.second;\\n            if(x <= 0 && k.first < 0){\\n                return k.first;\\n            }\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        for(int i = 0; i < k; i++){\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(checker(x));\\n        int ptr = 0;\\n        for(int i = k; i < nums.size(); i++){\\n            mp[nums[ptr]]--;\\n            mp[nums[i]]++;\\n            if(mp[nums[ptr]] == 0) mp.erase(nums[ptr]);\\n            ans.push_back(checker(x));\\n            ptr++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446809,
                "title": "python-easy-to-read-solution-hashmap-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn this question most important hint to get solution is constraints. n <= 10^5 so you should look to solve this with  Time Complexity of O(N).\\n\\nNow how to get count of negative numbers in O(1) time. because if you do any other way you cant solve this problem in O(N). Again if you look at the constraint , -50 <= nums[i] <=50. Can we maintain hashmap of negative numbers ? to get x smallest negative numbers we can simply traverse from -50 to -1 and count frequency of negative numbers. The moment this frequency is more than or equal  to x, we can return negative number for which this is achieved while traversing from -50 to -1. I said \\'more than equal\\'  because same number can occur multiple times . egde case: [-46, -46 , -30]\\n\\n\\nIf this was helpful. Feel free to follow me on \\nhttps://www.youtube.com/@punitvara1924\\nhttps://medium.com/@punitvara\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445948,
                "title": "c-counting-sliding-window-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans, mp(101, 0);\\n        int s=0, e=0;\\n        while(e < nums.size())  {\\n            mp[nums[e] + 50]++;\\n            if(e-s+1 == k)    {\\n                int cnt = 0;\\n                for(int i=0; i<101; i++)    {\\n                    cnt += mp[i];\\n                    if(cnt >= x)    {\\n                        if(i > 50) ans.push_back(0);\\n                        else ans.push_back(i - 50);\\n                        break;\\n                    }\\n                }\\n                mp[nums[s] + 50]--;\\n                s++;\\n            }\\n            e++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445865,
                "title": "c-brute-force-optimized-simplest-solution-faster-than-95",
                "content": "# Code\\n##### Method 1\\nBrute Force ~ TLE - 703/717 \\nTime Complexity: $$O(nklok)$$\\n```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\\n\\n##### Method 2\\nFrequency Array \\nTime Complexity: $$O(50n)$$\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        int n = nums.size();\\n        vector<int> sub(k),alt(k);\\n        int j = 0;\\n        vector<int> beauty(n - k + 1);\\n\\n        for (int i = 0; i < k; i++) {\\n            alt[i] = nums[i];\\n        }\\n        for (int i = k; i <= n; i++) {\\n            sub=alt;\\n            sort(sub.begin(), sub.end());    \\n            beauty[j++] = (sub[x - 1] < 0) ? sub[x - 1] : 0;\\n\\n            if (i == n) {\\n                break;\\n            }\\n\\n            alt.erase(alt.begin());\\n            alt.push_back(nums[i]);\\n        }\\n\\n        return beauty;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans(n - k + 1, 0), freq(50, 0);\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[nums[i] + 50]++;\\n            if (i - k >= 0 && nums[i - k] < 0) freq[nums[i - k] + 50]--;\\n            if (i - k + 1 < 0) continue;\\n            int count = 0;\\n            for (int j = 0; j < 50; j++) {\\n                count += freq[j];\\n                if (count >= x) {\\n                    ans[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445830,
                "title": "sliding-window-with-ve-freq-counting-easy-explanation-o-n",
                "content": "# Intuition\\nThe code uses a sliding window technique to create subarrays of length `k`, and then counts the frequency of negative numbers in each subarray. It then finds the `xth` smallest element in the subarray by counting the frequencies of numbers from `50` down to `1` until it reaches the `xth` smallest element. If no `xth` smallest element is present, `0` is added to the answer list.\\n\\n# Complexity\\n- Time complexity:\\n`O(n*50)` = `O(n)`\\n\\n- Space complexity:\\n`O(50)` = `O(1)`\\n\\n# Code\\n``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] freq = new int[51];\\n        int[] res = new int[nums.length - k + 1];\\n        \\n        for(int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if(nums[i] < 0) freq[Math.abs(nums[i])]++;\\n            if(i - j + 1 >= k) {\\n                int cnt = 0;\\n                for(int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if(cnt >= x) { res[idx++] = -L; break;}\\n                }\\n                if(cnt < x) res[idx++] = 0;\\n                if(nums[j] < 0) freq[Math.abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    std::vector<int> getSubarrayBeauty(std::vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        std::vector<int> freq(51);\\n        std::vector<int> res(n - k + 1);\\n\\n        for (int i = 0, j = 0, idx = 0; i < n; i++) {\\n            if (nums[i] < 0) freq[abs(nums[i])]++;\\n            if (i - j + 1 >= k) {\\n                int cnt = 0;\\n                for (int L = 50; L >= 1; L--) {\\n                    cnt += freq[L];\\n                    if (cnt >= x) {\\n                        res[idx++] = -L;\\n                        break;\\n                    }\\n                }\\n                if (cnt < x) res[idx++] = 0;\\n                if (nums[j] < 0) freq[abs(nums[j])]--;\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n``` python []\\nfrom typing import List\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        freq = [0] * 51\\n        res = [0] * (n - k + 1)\\n\\n        j = 0\\n        idx = 0\\n        for i in range(n):\\n            if nums[i] < 0:\\n                freq[abs(nums[i])] += 1\\n            if i - j + 1 >= k:\\n                cnt = 0\\n                for L in range(50, 0, -1):\\n                    cnt += freq[L]\\n                    if cnt >= x:\\n                        res[idx] = -L\\n                        idx += 1\\n                        break\\n                if cnt < x:\\n                    res[idx] = 0\\n                    idx += 1\\n                if nums[j] < 0:\\n                    freq[abs(nums[j])] -= 1\\n                j += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445749,
                "title": "java-use-bucket-sort-with-sliding-window-given-the-constraints",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst thought is to observe the constraints since sorting for each subarray would not scale.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOnce I noticed the -50 < elem < 50 , try to either a map or array.\\nMap - would not keep things sorted. Has to be array, but\\narray cannot handle negative numbers. So, have to shift the \\nelements by 50 and get an index for each element - back and forth.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] rslt = new int[n-k+1];\\n        \\n        int[] bucket = new int[101];\\n        \\n        for(int i = 0; i < k; i++){\\n            int elem = nums[i];\\n            int bktidx = elem + 50;\\n            bucket[bktidx]++;\\n        }\\n        \\n        rslt[0] = getBucket(bucket, x);\\n        for(int i = k; i < n; i++){\\n            int outgoing = nums[i-k];\\n            int outbktidx = outgoing + 50;\\n            bucket[outbktidx]--;\\n            \\n            int incoming = nums[i];\\n            int inxbktidx = incoming + 50;\\n            bucket[inxbktidx]++;\\n            \\n            rslt[i-k+1] = getBucket(bucket, x);\\n        }\\n        return rslt;\\n    }\\n    private int getBucket(int[] bucket, int x){\\n        int cnt = 0;\\n        for(int i = 0; i < bucket.length; i++){\\n            int frqi = bucket[i];\\n            if (cnt + frqi >= x){\\n                return Math.min(0, i-50);\\n            } \\n            cnt += frqi;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671158,
                "title": "c-easiest-sliding-window-using-array-of-size-50",
                "content": "# Intuition\\nIntuition is to use an array of size 50 to keep track of 2nd -ve smallest element.\\n\\nif ```nums[i]<0``` then we will make ```mp[nums[i] + 50]+=1```, here 0th index is -50 and so on.\\n\\n# Approach\\n\\nif ```nums[i]<0``` we are incresing the count of that element in mp by help of ```mp[nums[i] + 50]+=1```.\\n\\nWhen our window will hit size k. then we will run a loop till 50 and find 2nd smallest number inside array. To find this we will have a temp varibale when it is ```temp>=x``` we will push that element in answer and break. And if ``` temp<x ``` then we will add mp[k1] in temp. Here mp[k1] is total number of negative element having value k1-50.\\n\\nAs we have hitted then window size we need to remove ith element. So if nums[i] < 0 then make mp[nums[i] - 50]--.\\n\\n\\n``` \\nHappy coding and do upvote if it helped :)\\n```\\n# Complexity\\n- Time complexity:\\n$$O(N*50)$$\\n\\n- Space complexity:\\n$$O(N)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```nums[i]<0```\n```mp[nums[i] + 50]+=1```\n```temp>=x```\n``` temp<x ```\n``` \\nHappy coding and do upvote if it helped :)\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        \\n        vector<int> mp(51);\\n\\n        int i=0,j=0;\\n        while(j<n){\\n            if(nums[j]<0){\\n                int ele = nums[j]+50;\\n                mp[ele]+=1;\\n            }\\n\\n            if(j-i+1>=k){\\n                int temp=0;\\n                bool ok=false;\\n                for(int k1=0;k1<50;++k1){\\n                    if(mp[k1]>0){\\n                        if(temp+mp[k1] >= x){\\n                            ans.push_back(k1-50);\\n                            ok= true;\\n                            break;\\n                        }else{\\n                            temp += mp[k1];\\n                        }\\n                    }\\n                }\\n                if(!ok){\\n                    ans.push_back(0);\\n                }\\n\\n                if(nums[i] < 0){\\n                    mp[nums[i]+50] -=1;\\n                }\\n                i+=1;\\n            }\\n            j+=1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501383,
                "title": "java-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int res[]=new int[n-k+1];\\n        int neg[]=new int[51];\\n        int index=0;\\n        int a=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)neg[-nums[i]]++;\\n            if(i+1>=k){\\n                int c=0;\\n                int j=0;\\n                for(j=50;j>0;j--)\\n                {\\n                    c+=neg[j];\\n                    if(x<=c){res[index]=-j;break;}\\n                }\\n                if(j==0)res[index]=0;\\n                if(nums[a]<0)neg[-nums[a]]--;\\n                index++;\\n                a++;\\n            }\\n        }\\n       return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3476254,
                "title": "python3-code",
                "content": "# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        beauts = []\\n        i = 0\\n        j = k\\n        LEN = len(nums)\\n        sortedL = SortedList(nums[i:j])\\n        while j - 1 < LEN:\\n            if x <= j and sortedL[x - 1] < 0:\\n                beauts.append(sortedL[x-1])\\n            else:\\n                beauts.append(0)\\n            if j < LEN:\\n                sortedL.add(nums[j])\\n            sortedL.discard(nums[i])\\n            i += 1\\n            j += 1\\n        return beauts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460286,
                "title": "super-easy-and-intuitive-problem-sliding-window-c",
                "content": "The problem that you will face will be to get the xth minimum element in less time .\\nJust see the constraints and you will notice that negative elements are just -50 to -1 that is only 50 elements.\\nso store it in array based on index and it will ofcourse be sorted.\\n**Note** store negative element on index along with its count.\\nGetting index using arr[50 + nums[i]] and getting the element from index back by i - 50.\\nExample: for -3 we get 50-3=47 as its index and from index 47 we can get 47-50=-3 the orginal elemnt back.\\n```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int gen(int x, int *arr)//getting xth smallest element.\\n        {\\n            int i = 0;\\n            while (i < 50)\\n            {\\n                if (arr[i] < x)\\n                    x -= arr[i];\\n                else\\n                    x = 0;\\n                if (x == 0)\\n                    return i - 50;\\n\\n                i++;\\n            }\\n            return 0;\\n        }\\n    vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n    {\\n        int arr[50] = { 0 };\\n        int start = 0;\\n        vector<int> ans;\\n        for (int end = k - 1; end < nums.size(); end++)\\n        {\\n            if (end == k - 1)//making window\\n            {\\n                for (int j = 0; j < k; j++)\\n                {\\n                    if (nums[j] < 0)\\n                        arr[50 + nums[j]] += 1;\\n                }\\n            }\\n            else\\n            {\\n                if (nums[start] < 0)//sliding the window\\n                    arr[50 + nums[start]] -= 1;\\n                start++;\\n                if (nums[end] < 0)\\n                    arr[50 + nums[end]] += 1;\\n            }\\n            ans.push_back(gen(x, arr));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454006,
                "title": "c-ordered-set-systematic-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n*logn)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\ntypedef tree<int,null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update> ordered_set;\\n  \\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_set s;\\n        vector<int>ans;\\n        int i=0, j=0;\\n        while(j<nums.size()){\\n            if(nums[j]<0){\\n                s.insert(nums[j]);\\n            }\\n            if(j-i+1==k){\\n                if(s.size()<x){\\n                    ans.push_back(0);\\n                }\\n                else{\\n                    auto it=s.find_by_order(x-1);\\n                    ans.push_back(*it);\\n                }\\n                if(nums[i]<0){\\n                    s.erase(s.find_by_order(s.order_of_key(nums[i])));\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3454001,
                "title": "without-using-stl-c",
                "content": "# ***Complexity-***\\n- **Time complexity:** *O(n * 101)* \\n\\n- **Space complexity:** *O(101)*\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```\\n\\n*Do Upvote!* \\uD83D\\uDE03\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> arr1(101, 0);\\n        vector<int> arr2(nums.size()-k+1);\\n        int index = 0, count = 0, temp = 0;\\n        for(int i = 0; i < k-1; i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n        }\\n        for(int i = k-1; i < nums.size(); i++)\\n        {\\n            arr1[nums[i] + 50]++;\\n            for(int j = 0; j < 101; j++)\\n            {\\n                count += arr1[j];\\n                if(x <= count)\\n                {\\n                    temp = j - 50;\\n                    if(temp > 0)\\n                    {\\n                        arr2[index++] = 0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        arr2[index++] = temp;\\n                        break;\\n                    }\\n                }\\n            }\\n            count = 0;\\n            arr1[nums[i-k+1] + 50]--;\\n        }\\n        return arr2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3452363,
                "title": "sliding-subarray-beauty-90-76-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size();\\n        vector<int> a(n-k+1);\\n        vector<int>b(50);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            b[nums[i]+50]++;\\n            if(i-k>=0 && nums[i-k]<0)\\n            b[nums[i-k]+50]--;\\n            if(i-k+1<0)\\n            continue;\\n        \\n            int c=0;\\n            for(int j=0;j<50;j++)\\n            {\\n                c+=b[j];\\n                if(c>=x)\\n                {\\n                    a[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3447388,
                "title": "java-solution-most-noob-solution",
                "content": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n# A Bit Optimized Solution\\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[52];// as all elements lie in between -50 to +50 {i have taken 2 extra elements}\\n        for (int i = 0; i < k; i++) { // for the 1st window of size k\\n            if (nums[i] < 0) {  // i will be only inserting the -ve elements but i will treat them positive \\n\\t\\t\\t// in order  to do that i will add 50 to them \\n                int val = nums[i] + 50; \\n                map[val]++; // increase the number\\'s frequency by 1 \\n            }\\n        }\\n        int cnt = 0;\\n        boolean flag = true;\\n        for (int a = 0; a < 52; a++) { // i will iterate over map    \\n            if (map[a] != 0) {\\n                if (map[a] + cnt >= x) { \\n                    ans[idx++] = a - 50;\\n                    flag = false;\\n                    cnt = 0;\\n                    break;\\n                } else {\\n                    cnt += map[a]; \\n                }\\n            }\\n        }\\n        if (flag) {// there doesn\\'t exist a xth smallest -ve number so i will put zero\\n            ans[idx++] = 0;\\n            cnt = 0;\\n        }\\n        int j = 0;\\n        for (int i = k; i < n; i++) {\\n\\t\\t// release the element outside the window\\n            if (nums[j] < 0) {\\n                int val = nums[j] + 50;\\n                map[val]--;\\n            }\\n            j++;\\n\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n\\n            flag = true;\\n            for (int a = 0; a < 52; a++) {\\n                if (map[a] != 0) {\\n                    if (map[a] + cnt >= x) {\\n                        ans[idx++] = a - 50;\\n                        flag = false;\\n                        cnt = 0;\\n                        break;\\n                    } else {\\n                        cnt += map[a];\\n                    }\\n                }\\n            }\\n            if (flag) {\\n                ans[idx++] = 0;\\n                cnt = 0;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int idx = 0;\\n        int[] map = new int[50];\\n        int j = 0;\\n        for (int i = 0; i < n; i++) {\\n            if (nums[i] < 0) {\\n                int val = nums[i] + 50;\\n                map[val]++;\\n            }\\n            if (i - j + 1 == k) {\\n                int cnt = 0;\\n                boolean flag = true;\\n                for (int a = 0; a < 50; a++) {\\n                    if (map[a] != 0) {\\n                        if (map[a] + cnt >= x) {\\n                            ans[idx++] = a - 50;\\n                            flag = false;\\n                            cnt = 0;\\n                            break;\\n                        } else {\\n                            cnt += map[a];\\n                        }\\n                    }\\n                }\\n                if (flag) {\\n                    ans[idx++] = 0;\\n                    cnt = 0;\\n                }\\n                if (nums[j] < 0) {\\n                    int val = nums[j] + 50;\\n                    map[val]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446917,
                "title": "video-explanation-includes-harder-follow-ups",
                "content": "# Explanation\\n\\nhttps://youtu.be/Atdtf57Cuj8\\n\\n[Click here if the preview above doesn\\'t works](https://youtu.be/Atdtf57Cuj8)\\n\\n# Code\\n```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    unordered_map <int, int> frq;\\n    \\n    void Add (int val) {\\n        frq [val] ++;\\n    }\\n    \\n    void Remove (int val) {\\n        frq [val] --;\\n    }\\n    \\n    int XthLargest (int x) {\\n        int cnt = 0;\\n        \\n        for (int val = -50; val < 0; val ++) {\\n            cnt += frq[val];\\n            if (cnt >= x) return val;\\n        }\\n        return 0;\\n    }\\n    \\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> result;\\n        int n = nums.size();\\n        \\n        for (int j = 0; j < k-1; j ++) Add (nums[j]);\\n        for (int j = k-1; j < n; j ++) {\\n            Add (nums[j]);\\n\\n            result.push_back(XthLargest (x));\\n            \\n            Remove (nums[j-k+1]);\\n        }\\n        \\n        frq.clear();\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446908,
                "title": "unique-solution-pbds-c",
                "content": "\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\nvector<int> getSubarrayBeauty(vector<int>& arr,int k, int x) {\\n       int i=0,j=0;\\n        ordered_set st;\\n        int n=arr.size();\\n        vector<int>temp;\\n        int y=0;\\n        while(j<n){\\n            st.insert({arr[j],y});          \\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n              int ans = (st.find_by_order(x-1))->first;\\n              if(ans>=0)temp.push_back(0);\\n              else temp.push_back(ans);\\n              st.erase(*st.find_by_order(st.order_of_key({arr[i], -1})));\\n              i++;\\n              j++;\\n            }\\n            y++;\\n        }\\n       return temp;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3446649,
                "title": "java-2-solution-easy-to-understand",
                "content": "# 1st :\\n# *** sliding window with frequency counter ***\\n# Complexity\\n- Time complexity: O(N*101)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(101 + (nums.length - k + 1))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\\n\\n# 2nd : \\n# ***************** Tree Set *******************\\n# Complexity\\n- Time complexity: O(N*logK)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(K)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] counter = new int[101];\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            counter[nums[i] + 50]++;\\n        }\\n\\n        int count = 0;\\n        for(int i = 0; i < counter.length; i++) {\\n            count += counter[i];\\n\\n            if(count >= x) {\\n                if(i - 50 < 0) {\\n                    arr[index++] = i - 50;\\n                } else {\\n                    index++;\\n                }   \\n                break;\\n            }\\n        }\\n\\n        if(count < x) {\\n            index++;\\n        }\\n        \\n        for(int i = k; i < nums.length; i++) {\\n            counter[nums[i] + 50]++;\\n            counter[nums[i-k] + 50]--;\\n\\n            int c = 0;\\n            for(int j = 0; j < counter.length; j++) {\\n                c += counter[j];\\n\\n                if(c >= x) {\\n                    if(j - 50 < 0) {\\n                        arr[index++] = j - 50;\\n                    } else {\\n                        index++;\\n                    }      \\n                    break;\\n                }\\n            }\\n\\n            if(c < x) {\\n                index++;\\n            }\\n        }\\n\\n        return arr;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n\\n        int[] arr = new int[nums.length - k + 1];\\n        int index = 0;\\n\\n        for(int i = 0; i < k; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n        }\\n\\n        arr[index++] = findXthSmallest(map, x);\\n\\n        for(int i = k; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i], 0) + 1);\\n            map.put(nums[i-k], map.getOrDefault(nums[i-k], 0) - 1);\\n            \\n            if(map.get(nums[i-k]) == 0) {\\n                map.remove(nums[i-k]);\\n            }\\n\\n            arr[index++] = findXthSmallest(map, x);\\n        }\\n\\n        return arr;\\n    }\\n\\n    private int findXthSmallest(TreeMap<Integer, Integer> map, int x) {\\n        int xth = 0;\\n        for(int n : map.keySet()) {\\n            if(n < 0) {\\n                xth += map.get(n);\\n            } else {\\n                break;\\n            }\\n\\n            if(xth >= x) {\\n                return n;\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446577,
                "title": "sliding-subarray-beauty-c-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n     int n=nums.size();\\n        vector<int> freq(51,0),ans;\\n        for(int i=0,j=0;i<n;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n                freq[abs(nums[i])]++;\\n            }\\n            if(i-j+1>=k)\\n            {\\n                int count=0;\\n                for(int L=50;L>=1;L--)\\n                {\\n                    count+=freq[L];\\n                    if(count>=x)\\n                    {\\n                        ans.push_back(-L);\\n                        break;\\n                    }\\n                }\\n                if(count<x)\\n                {\\n                    ans.push_back(0);\\n                }\\n                if(nums[j]<0)\\n                {\\n                    freq[abs(nums[j])]--;\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446342,
                "title": "c-easiest-code-explanation-with-comments-space-o-1-time-o-n",
                "content": "# Intuition\\nFirstly you need to check the constraints carefully, If you miss out on them than probably you wont be able to come out with viable solution . If you see, the range of numbers is onlyfrom [-50,50].Thus, We can simply Store counts of negative numbers only in a counter array and use it to find the xth smallest number.\\n\\n# Approach\\nNow Just iterate over the counter array and sum the counts of each number. When the sum of counts is greater than or equal to x we have found out xth smallest number and break the iteration . If sum of counts is never greater than or equal to x there aren\\'t enough negative numbers.\\n\\n# Complexity\\n- Time complexity: O(N*50)\\n\\n- Space complexity: O(1), as we have used constant extra space .\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        // Answer Array\\n        vector<int> ans;\\n        int n = nums.size();\\n\\n        // We declare a array of size 51 to store the count \\n        // of each negative element among last k elements .\\n        // and size is 51 because neative elements are in \\n        // range of [-50,-1] only \\n\\n        // Also we dont need to store the count of positive elements \\n        // because there is no need \\n        int mp[51] = {0};\\n\\n        // Step 1 : Stored the count of each negative elemnts among first k elements\\n        for(int i = 0 ; i< k ; i++){\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n        }\\n        \\n        // Now check the xth smallest element \\n        // If there are more than or qual to x elements store the ans \\n        // else store zero \\n        int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n        \\n        \\n        // Now simply increase the count of next element and decrease \\n        // the count of last (i-k) element if they are negative respectively.\\n        // And check for Xth smallest element .\\n        for(int i = k ; i<n ; i++)\\n        {\\n            \\n            if(nums[i-k]<0 )\\n                mp[-nums[i-k]]--;\\n            if(nums[i]<0)\\n                mp[-nums[i]]++;\\n            int count = 0;\\n            bool flag = true;\\n            for(int j = 50 ; j>= 1 ; j--){\\n                count += mp[j];\\n                \\n                if(count>= x){\\n                    ans.push_back(-j);\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            \\n            if(flag)\\n                ans.push_back(0);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446275,
                "title": "clean-c-code-tc-o-n-100",
                "content": "# Approach\\n-> take a freq array of size 101 as  -50 <= nums[i] <= 50\\n-> represent -50 -> 0       50 -> 100     nums[i] += 50 sot that all are done 0 based indexing\\n-> then simply for each subarry traverse over the freq array\\n\\n# Complexity\\n- Time complexity:\\nO(n * 100)\\n\\n- Space complexity:\\nO(100)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> freq(101), ans;\\n        for(int i = 0; i < k - 1; i++){\\n            freq[nums[i] + 50]++;\\n        }\\n        for(int i = k - 1; i < n; i++){\\n            freq[nums[i] + 50]++;\\n            int cnt = 0, val;\\n            for(int j = 0; j <= 100; j++){\\n                cnt += freq[j];\\n                if(cnt >= x){\\n                    val = min(0, j - 50);\\n                    ans.push_back(val);\\n                    break;\\n                }\\n            }\\n            freq[nums[i - k + 1] + 50]--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446205,
                "title": "easy-sorting-optimisation-c",
                "content": "# Explaination\\n We shall store the count of negative numbers and find Xth smallest number  \\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int it(vector<int>& a, int x){ // to find xth smallest integer in subarray\\n        int ans=0;\\n        for(int i=50;i>=0;i--){\\n           if(a[i]>0){ \\n               x-=a[i];\\n               if(x<=0){\\n                   ans=i;\\n                   break;\\n               }\\n           }\\n        }\\n        return ans;\\n     }\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> m(51,0); // constraints : -50 <= nums[i] <= 50 \\n        int n=nums.size();\\n        vector<int> ans(n-k+1); \\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0){\\n                m[abs(nums[i])]++; //Storing negative integer counts\\n            }\\n        }\\n        ans[0]=-it(m,x); \\n        for(int i=1;i<=n-k;i++){\\n            if(nums[i+k-1]<0){\\n                m[abs(nums[i+k-1])]++;\\n            }\\n            if(nums[i-1]<0){  //If previous index is -ve reduce that count\\n                m[abs(nums[i-1])]--; \\n            }\\n            ans[i]=-it(m,x);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446149,
                "title": "java-solution-1005-faster-frequency-array-sliding-window-o-n-x",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n=nums.length;\\n        int ans[]=new int[n-k+1];\\n        int count=0;\\n        int arr[]=new int[50+1];\\n        for(int i=0,j=0;i<n-k+1;i++){\\n            while(j<=i+k-1){\\n                if(nums[j]<0){\\n                    arr[Math.abs(nums[j])]++;\\n                    count++;\\n                }\\n                j++;\\n            }  \\n            if(count>=x){\\n                int pop=0;\\n                int idx=50;\\n                int small=0;\\n                while(pop<x){\\n                    if(arr[idx]!=0){\\n                        pop+=arr[idx];\\n                        small=idx;\\n                    }\\n                    idx--;\\n                }\\n                ans[i]=(-small);\\n            }\\n            \\n            if(nums[i]<0){\\n                count--;\\n                arr[Math.abs(nums[i])]--;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445994,
                "title": "best-solution-using-set-explained-in-detail",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$ \\n\\n- Space complexity: $$O(n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s; //we are using multiset because there can be multiple occurences of an element\\n        vector<int> ans;\\n        \\n        for(int i=0; i<k-1; i++)\\n        { \\n            if(nums[i] < 0)  //insert negative elements present in first window\\n            s.insert(nums[i]);\\n        }\\n        \\n        for(int i=k-1; i<nums.size(); i++)\\n        {\\n            if(nums[i] < 0)  //only insert -ve elements in the set\\n             s.insert(nums[i]);\\n\\n            if(s.size() < x)        //if current window does not have at least x -ve elements\\n                ans.push_back(0);   //then insert 0, as given in problem statement\\n            else\\n            {\\n            //otherwise, insert the xth element of the set \\n            //i.e. x-1 elements after the first element\\n              auto it = next(s.begin(), x-1); \\n              ans.push_back(*it);\\n            }\\n\\n        //now, window will shift by one place to the right, so we need to delete the first element of the window\\n        //but our set contains only -ve elements\\n        //so, if i-k+1 th was negative,then it must be in our set also, and we need to remove it\\n        //otherwise, no need to do anything\\n            if(nums[i-k+1] < 0) \\n            s.erase(s.find(nums[i-k+1]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445973,
                "title": "python3-solution",
                "content": "\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        vals = SortedList()\\n        for i, v in enumerate(nums): \\n            vals.add(v)\\n            if i >= k:\\n                vals.remove(nums[i-k])\\n            if i >= k-1: \\n                ans.append(min(0, vals[x-1]))\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445892,
                "title": "easy-c-sliding-window-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n= nums.size(), neg=0, hav=0;\\n\\t\\t\\n\\t\\t// TAKE HASHMAP OF SIZE 102 ( It take all neg & positive values )\\n        vector<int> hashMap(102,0), res;\\n        \\n        for(int i=0; i<k; i++){ \\n            if(nums[i]<0) { neg++; hashMap[nums[i]+50]++; }\\n        }\\n        \\n        if(neg<x) res.push_back(0);\\n        for(int i=0; i<102; i++){\\n            if(hashMap[i]>0) {\\n                if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                hav+= hashMap[i];\\n            }\\n        }\\n        \\n        for(int i=k; i<n; i++){\\n            hav=0;\\n            if(nums[i-k]<0){ neg--; hashMap[nums[i-k]+50]--; } \\n            if(nums[i]<0) { neg++;hashMap[nums[i]+50]++; } \\n    \\n            if(neg<x){ res.push_back(0); continue; }\\n            for(int i=0; i<102; i++){\\n                if(hashMap[i]>0) {\\n                    if(hashMap[i]+hav>=x){ res.push_back(i-50); break; } \\n                    hav+= hashMap[i];\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445866,
                "title": "simple-to-understand-just-count-and-traverse-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRange of an element is between -50 to 50 and we need just negative so at each element i have to find xth smallest that will be in betwenn -1 to -50;\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmake a array of size 50 to ->\\nsliding window = just store the frequency of each negative number in window in array and easily find the xth smallest by reversing the array the simple\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(n*50)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(int arr[],int x){\\n        for(int i=50;i>0;i--){\\n            if(arr[i]>0)x-=arr[i];\\n            if(x<=0)return i;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[52]={0};// to store freq in a window\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)\\n            arr[abs(nums[i])]+=1;\\n        }\\n        vector<int> ans(nums.size()-k+1,0);\\n        for(int i=k;i<=nums.size();i++){\\n            int l=find(arr,x);// seach xth smallest elementsl\\n            if(l>0)\\n            ans[i-k]=(-l);             \\n            if(i<nums.size()&&nums[i]<0)// to store new element\\n            arr[abs(nums[i])]+=1;\\n            if(nums[i-k]<0)// to remove out of window element\\n            arr[abs(nums[i-k])]-=1;\\n            \\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445858,
                "title": "c-easy-sliding-window-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n     void push_ele(map<int,int>&mp,vector<int>&ans,int x)\\n     { \\n         int num=0;   // if cnt of negative elements is less than x\\n         int cnt=0;\\n         for(auto it:mp)\\n         {\\n             cnt+=it.second;\\n             if(cnt>=x)  // if cnt becomes greater than or equals to x\\n             {\\n                 num=it.first;  // xth element equals it.first\\n                 break;\\n             }\\n         }\\n         ans.push_back(num);\\n\\n     }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x)\\n    {\\n        map<int,int>mp; // to cnt the number of elements \\n        int cnt=0;\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n            {\\n            mp[nums[i]]++; // if it is negative then insert in map\\n            \\n            }\\n        }\\n        vector<int>ans;\\n        push_ele(mp,ans,x); \\n        for(int i=k;i<nums.size();i++) // sliding the window\\n        {\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n            if(nums[i-k]<0)\\n            mp[nums[i-k]]--;\\n            push_ele(mp,ans,x); // function to insert xth negative element if exists\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445851,
                "title": "c-using-multiset",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n        1. To handle duplicates, use multiset.\\n        2. Use the next function to find the subarray\\'s xth smallest integer.\\n        3. There is no need to take care of positive integers (according to question).\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    multiset<int>mul;\\n    vector<int>result;\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        int z=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(nums[i]<0){\\n                mul.insert(nums[i]);\\n            }\\n            if(i-z+1==k){\\n                if(mul.size()<x){\\n                    result.push_back(0);\\n                }else{\\n                    result.push_back(*next(mul.begin(),x-1));\\n                }\\n                if(nums[z]<0){\\n                    mul.erase(mul.find(nums[z]));\\n                }\\n                z++;\\n            }\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445847,
                "title": "c-very-simple-explanation-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. take a freq array,f, where index(-50)=0, and index (50)= 100\\nas -50<=nums[i]<=50\\n2. take 2 pointers i,j..i points to start of window, j points to end of window...j is used to stretch the sliding window\\nas you increase j, do f[nums[j]+50]++ \\n3. for the current window find the xth smallest number,and push it to ans vector\\n\\nHow this freq array f helps in finding the xth smallest?\\nsay a window= [-2, -1, 3, -5, -5, -2], x= 5\\n5th smallest number= -1\\nso for the window, freq array will look like this\\nfreq(-5)= 2, freq(-2)= 2, freq(-1)= 1, freq(3)= 1\\nf[-5+50]= 2, f[-2+50]= 2, f[-1+50]= 1, f[3+50]= 1\\n\\nwe move from index 0 to 100 and we have totalCount=0 initially:\\ni=45: f[45]>0: totalCount=totalCount+ f[45]= 2\\ni=48: f[48]>0: totalCount=totalCount+ f[48]= 4\\ni=49: f[49]>0: totalCount=totalCount+ f[49]= 5\\nat i=49, totalCount=5 which is >=x..this means at i=49, we have the xth smallest number...hence i-50 is the xth smallest number ,which is 49-50, ie -1\\n\\n\\n# Complexity\\n- Time complexity: O(n)+ O((n-k+1)*100)= O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(100)= O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findXthSmallest(vector<int>&f, int x){\\n        int totalCount=0;\\n        for(int i=0;i<101;i++){\\n            totalCount+= f[i];\\n            if(totalCount>=x) {\\n                if(i-50<0) return i-50;//index i points to number i-50..if i-50 is negative return it \\n                else return 0;//if i-50 is +ve, return 0\\n            }\\n        }\\n        return 0;//return anything..Whatever is to be returned ,will return from loop only\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> f(105,0), ans;//index of (-50)= 0, index of (50)= 100\\n        int i=0, j=0, n=nums.size();\\n        \\n        while(j<n){\\n            while(j-i<k && j<n){\\n                f[nums[j]+50]++;\\n                j++;\\n            }\\n            //find x th smallest\\n            int xSmallest= findXthSmallest(f, x);\\n            ans.push_back(xSmallest);\\n            f[nums[i]+50]--;//sliding the subarray, so remove ith element\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445833,
                "title": "c-java-min-heap-using-maps",
                "content": "## Explanation\\nI tried to solve using priority queues and multisets initially but it gave me TLE as I was iterating over duplicate values every time !! Then I tried this approach where we use Maps as MinHeaps to store the values in the array and their frequencies so that while calculating the x-th smallest integer each time, the code runs fast as we don\\'t need to traverse over all the elements with same values in the subarray !!\\n\\n## Code\\n\\n**Code that gave me TLE using Multisets :**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\\n\\n**Working Code using Maps :**\\n\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```\\n## Complexity\\n- Time complexity: $$O(n log(k))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Hash Table",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int findKthSmallest(multiset <int> &pq, int x){\\n        int i = 1;\\n        for(auto it = pq.begin(); it != pq.end(); it++){\\n            if(*it >= 0) return 0;\\n            if(i == x) {\\n                return *it;\\n            }\\n            i++;\\n        }\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset <int> st;\\n        int n = size(nums);\\n        vector<int>res;\\n\\n        for(int i = 0; i < k; i++) st.insert(nums[i]);\\n        res.push_back(findKthSmallest(st,x));\\n\\n        for(int i = 0; i < n-k; i++){\\n            auto it = st.find(nums[i]);\\n            st.erase(it);\\n            st.insert(nums[i+k]);\\n            res.push_back(findKthSmallest(st,x));\\n        }\\n        return res;\\n        \\n    }\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n\\n        int n = size(nums);\\n        vector<int>res;\\n        map <int, int> minHeap;\\n\\n        for(int i = 0; i < n; i++){\\n            minHeap[nums[i]]++;\\n            if(i >= k){\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap[nums[i-k]]--;\\n                if(minHeap[nums[i-k]] == 0) minHeap.erase(nums[i-k]);\\n            }\\n            if(i >= k-1){\\n                int cnt = 0, val = 0;\\n                for(auto &[k,v] : minHeap){\\n                    cnt += v;\\n                    if(cnt >= x) {\\n                        val = k;\\n                        break;\\n                    }\\n                }\\n                res.push_back((val > 0)? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n};\\n```\n```Java []\\nimport java.util.*;\\n\\nclass Solution {\\n    public List<Integer> getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        List<Integer> res = new ArrayList<>();\\n        Map<Integer, Integer> minHeap = new TreeMap<>();\\n\\n        for(int i = 0; i < n; i++) {\\n            minHeap.put(nums[i], minHeap.getOrDefault(nums[i], 0) + 1);\\n            if(i >= k) {\\n                // erase the element at nums[i-k] ( sliding window moves)\\n                minHeap.put(nums[i-k], minHeap.get(nums[i-k]) - 1);\\n                if(minHeap.get(nums[i-k]) == 0) minHeap.remove(nums[i-k]);\\n            }\\n            if(i >= k-1) {\\n                int cnt = 0, val = 0;\\n                for(Map.Entry<Integer, Integer> entry : minHeap.entrySet()) {\\n                    cnt += entry.getValue();\\n                    if(cnt >= x) {\\n                        val = entry.getKey();\\n                        break;\\n                    }\\n                }\\n                res.add((val > 0) ? 0 : val);\\n            }\\n        } \\n        return res;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445804,
                "title": "ordered-set-map",
                "content": "# Method 1\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Method 2\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Ordered Map",
                    "Ordered Set"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_set tree<int, null_type,less_equal<int>,rb_tree_tag,tree_order_statistics_node_update>\\n  \\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        ordered_set st;\\n        int i=0,j=0,n=size(nums);\\n        while(j < n){\\n            st.insert(nums[j]);\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int e = *(st.find_by_order(x-1));\\n                ans.push_back(e < 0 ? e : 0);\\n                myerase(st,(nums[i]));\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = size(nums), i = 0, j = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            mp[nums[j]]++;\\n            if(j-i+1<k)j++;\\n            else if(j-i+1==k){\\n                int ct=0;\\n                for(auto&[k,e]: mp){\\n                    if(ct+e>=x){\\n                        ans.push_back(k>0?0:k);\\n                        break;\\n                    }\\n                    ct += e;\\n                }\\n                if(--mp[nums[i]] == 0) mp.erase(nums[i]);\\n                j++,i++;\\n            }\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445751,
                "title": "python3-sorted-list-solution-o-nlogn",
                "content": "**Approach**\\nMaintain an ordered list to store the integers and update it using two pointers.\\n\\n**Complexity**\\nO(NlogN)\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        sl = SortedList()\\n        n = len(nums)\\n        ng = 0\\n        for i in range(k):\\n            sl.add(nums[i])\\n\\n        ans = []\\n        ans.append(min(sl[x - 1], 0))\\n        \\n        i, j = 0, k\\n        \\n        while j < n:\\n            sl.discard(nums[i])\\n            sl.add(nums[j])\\n            i += 1\\n            j += 1\\n            ans.append(min(sl[x - 1], 0))\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445717,
                "title": "map-cpp-two-map-solution-with-detailed-explanation-o-n-log-n",
                "content": "### if you like the solution, please give me a up vote.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the xth smallest integer in subarray,\\nwhen we move the subarray, do following operations,\\n1. add new value `nums[i]`\\n2. remove the oldest value `nums[i-k+1]`\\n\\n### Concept\\n<!-- Describe your approach to solving the problem. -->\\nWe can use two map `lower, upper` to maintain the value order,\\nthe count of `lower` is x\\nthe count of `upper` is k - x\\n\\nso the xth smallest integer is at `lower.rbegin()`\\n\\n\\n\\n### Operation : remove the oldest value\\nafter remove the oldest value,\\nwe want to maintain map as below,\\n- the count of `lower` is `x - 1`\\n- the count of `upper` is `k - x`\\n\\nthe oldest value maybe in `lower` or `upper`\\n1. the oldest value in `lower`\\n    directly remove the oldest value from `lower`.\\n\\n2. the oldest value in `upper`\\na. remove the oldest value from `upper`.\\nb. get the largest value from `lower` and insert into `upper`\\n\\n\\n### Operation: add new value\\n1. insert the value into `upper`\\n2. get the smallest value from `upper` and insert into `lower`\\n\\n\\n\\n### Operation: get the xth smallest value\\nthe xth smallest integer is at `lower.rbegin()`\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void remove_val(map<int, int> &m, int val) {\\n        m[val]--;\\n        if(m[val] == 0) {\\n            m.erase(val);\\n        }\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> output(n-k+1, 0);\\n        int upper_cnt = 0;\\n        int val;\\n        map<int, int> lower;\\n        map<int, int> upper;\\n        \\n        for(int i = 0 ; i < (k-1) ; i++) {\\n            upper[nums[i]]++;\\n            upper_cnt++;\\n            if(upper_cnt <= (k - x)) {\\n                continue;\\n            }\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            \\n            remove_val(upper, val);\\n        }\\n        \\n        for(int i = k-1; i < n; i++) {\\n            int idx = i - k + 1;\\n            val = nums[i];\\n            upper[val]++;\\n            \\n            val = upper.begin()->first;\\n            lower[val]++;\\n            remove_val(upper, val);\\n            \\n            \\n            if(lower.rbegin()->first < 0) {\\n                output[idx] = lower.rbegin()->first;\\n            }\\n            \\n        \\n            //remove val\\n            val = nums[idx];\\n            if(val >= upper.begin()->first) {\\n                remove_val(upper, val);\\n                \\n                //move lower to upper;\\n                val = lower.rbegin()->first;\\n                upper[val]++;\\n                remove_val(lower, val);\\n            }\\n            else {\\n                remove_val(lower, val);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445702,
                "title": "sliding-window-ordered-set-c",
                "content": "# Intuition\\nProblem statement gives clear indication. All you need to is to think of a data structure which perofrms insertion and deletion in logn time and finds kth-element in logn. Ordered set is perfect for that\\n\\n# Approach\\nKeep moving the sliding window and find the kth element of each window using Ordered Set.\\n\\n# Complexity\\n- Time complexity:\\nNlogN for Ordered Set\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\n//INCLUDE ORDERED SET\\n\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n#define ordered_multiset tree<pair<int,int>, null_type,less<pair<int,int>>, rb_tree_tag,tree_order_statistics_node_update>\\n//ORDERED SET doesn\\'t contains duplicate so use pair and pass index along with number to avoid duplicates\\n\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ordered_multiset os;\\n        int start=0;\\n        int end=0;\\n        vector <int> ans;\\n        while(end<nums.size()){\\n            os.insert({nums[end],end});\\n            if(end-start+1>k){\\n                //MOVE the sliding window\\n                os.erase({nums[start],start});\\n                ++start;\\n            }\\n            if(end-start+1==k){\\n                //Find xth smallest element\\n                auto it = os.find_by_order(x - 1);\\n                ans.push_back(it->first);\\n            }\\n            ++end;\\n        }\\n        for(auto &it:ans)if(it>0)it=0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445695,
                "title": "pbds-policy-based-data-structure",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp> \\n#include <ext/pb_ds/tree_policy.hpp>\\n  \\n// namespace necessary for GNU based \\n// policy based data structures\\nusing namespace __gnu_pbds;\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        // multiset<int> m;\\n        ordered_set m;\\n        int i=0,j=0;\\n        while(i<n)\\n        {\\n            m.insert(nums[i]);\\n            if(i-j+1==k)\\n            {\\n                auto it = m.find_by_order(x-1); \\n                if((*it)>=0)\\n                    ans.push_back(0);\\n                else\\n                ans.push_back((*it));\\n                m.erase(--m.lower_bound(nums[j]));\\n                j++;\\n            }\\n            i++;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3445666,
                "title": "map-solution-c",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> ans;\\n        map<int, int> freq;\\n        \\n        int l = 0, r = 0;\\n        \\n        while (r < n) {\\n            freq[nums[r]]++;\\n            \\n            if (r >= k-1) {\\n                \\n                int cnt = 0;\\n                for (auto it : freq) {\\n                    cnt += it.second;\\n                    if (cnt >= x) {\\n                        ans.push_back((it.first < 0) ? it.first : 0);\\n                        break;\\n                    }\\n                }\\n                \\n                if (--freq[nums[l]] == 0) \\n                    freq.erase(nums[l]);\\n                \\n                l++;\\n            }\\n            \\n            r++;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4101014,
                "title": "simple-c-easy-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(nlogk)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int n = nums.size();\\n        for(int i=0;i<k-1;i++)   // to avoid computing for the first time min value\\n            mp[nums[i]]++;\\n        vector<int> ans;\\n        for(int i=k-1;i<nums.size();i++){\\n            mp[nums[i]]++;\\n            int count = 0;\\n            int num = 0;\\n            for(auto s:mp){\\n                count += s.second;\\n                if(count>=x){\\n                    num = min(num,s.first);\\n                    break;\\n                }\\n            }\\n            ans.push_back(num);\\n            mp[nums[i-k+1]]--;\\n            // if(mp[nums[i-k+1]]==0)\\n            //     mp.erase(nums[i-k+1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4062124,
                "title": "segment-tree-solution-o-n-log-64",
                "content": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "solutionTags": [],
                "code": "\\t# we utilize the fact that the range of negative numbers we have to track (-50 -> -1)\\n\\t# is small.  We build a segment tree where each leaf is the cnt of negative values in\\n\\t# the range and each parent is the count of negative numbers in its children.  We \\n\\t# scroll through the nums array, adding negative numbers as we see them and \\n\\t# removing them as they leave our window.  \\n\\t\\n\\tdef removeVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] -= 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def addVal(tree, val):\\n            index = 128 + val\\n            while index != 0:\\n                tree[index] += 1\\n                index = (index // 2)\\n            \\n            return(tree)\\n        \\n        def checkX(tree, x):\\n            index = 1\\n            while True:\\n                indexL = 2*index\\n                indexR = 2*index + 1\\n                \\n                if indexL >= len(tree):\\n                    return(index - 2*64)\\n                \\n                if tree[indexL] < x:\\n                    x -= tree[indexL]\\n                    index = indexR\\n                else:\\n                    index = indexL\\n                    \\n        #########\\n        n = len(nums)\\n        \\n        tree = [0]*(2*64)\\n        \\n        ans = []\\n\\t\\t# build the tree for our initial window of size k:\\n        for val in nums[:k]:\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n        if tree[1] < x:\\n            ans.append(0)\\n        else:\\n            ans.append(checkX(tree, x))\\n        \\n\\t\\t# scroll through nums, updating our segment tree and array ans:\\n        for ii in range(k, n):\\n            val = nums[ii]\\n            if val < 0:\\n                tree = addVal(tree, val)\\n            \\n            val2 = nums[ii-k]\\n            if val2 < 0:\\n                tree = removeVal(tree, val2)\\n                \\n            if tree[1] < x:\\n                ans.append(0)\\n            else:\\n                ans.append(checkX(tree, x))\\n        \\n        return(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 4032841,
                "title": "simple-java-o-n-50",
                "content": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```\\n***Please UpVote, if found useful :)***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] arr, int k, int x) {\\n        int[] ans = new int[arr.length - k + 1];\\n        int[] temp = new int[51];\\n        for(int i = 0 ; i < k ; i++){\\n            int ele = arr[i];\\n            if(ele < 0){\\n                temp[-1 * ele]++;\\n            }\\n        }\\n        int ptr = 0;\\n        ans[ptr++] = getValue(temp , x);\\n        for(int i = k ; i < arr.length ; i++){\\n            int prev = i - k;\\n            if(arr[prev] < 0)\\n                temp[arr[prev] * -1]--;\\n            if(arr[i] < 0)\\n                temp[arr[i] * -1]++;\\n            ans[ptr++] = getValue(temp , x);\\n        }\\n        return ans;\\n    }\\n    private int getValue(int[] arr , int x){\\n        int count = 0;\\n        int value = 0;\\n        for(int i = 50 ; i >= 0 ; i--){\\n            if(arr[i] > 0){\\n                count += arr[i];\\n                value = i;\\n            }\\n            if(count >= x) return i * -1;\\n        }\\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013740,
                "title": "c-easy-solution-using-sliding-window-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size(),i = 0,j = 0,sz = 0;\\n        vector<int> ans;\\n        map<int,int> mp;\\n        while(j < n){\\n            if(nums[j] < 0){ \\n                mp[nums[j]]++;\\n                sz++;\\n            }\\n            if(j-i+1 == k){\\n                if(sz >= x){\\n                    int ct = 0;\\n                    for(auto it:mp){\\n                        ct += it.second;\\n                        if(ct >= x){\\n                            ans.push_back(it.first);\\n                            break;\\n                        }\\n                    }\\n                }else{\\n                    ans.push_back(0);\\n                }\\n                if(nums[i] < 0){\\n                    mp[nums[i]]--;\\n                    if(mp[nums[i]] == 0) mp.erase(nums[i]);\\n                    sz--;\\n                }\\n                i++;\\n            }\\n\\t\\t\\tj++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002083,
                "title": "easy-java-o-n-time-and-o-1-memory-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nAfter reading the problem statement there is one thing which is quite apparent. All numbers >= 0 in the array are useless to us. They do not influence the \"beauty\" of any subarray in any way.\\n\\nAnother important thing to notice in the constraints is that nums[i] is between -50 and 50.\\n\\nSince we only care about negative values, this means that there are a total of 50 potential distinct values in this array which we care about [-50, -1]. Let\\'s try and use this!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s use our usual left and right pointer technique to create a window of k elements, and then shift it accordingly every iteration.\\n\\nFor every window let\\'s use an array of size 50 representing the count of all negative numbers in our window. We will update the count accordingly as we go left to right.\\n\\nOne task remains, checking for the Xth smallest negative number in each window. We can easily do this using our array of negative number counts. Index 0 represents the count of -50 in a given window, index 1 represents -49, and so on. The last index represents the count of -1. We can just traverse this small array of size 50 from left to right for every window and increase our count of the smallest negative numbers until we hit or surpass x. If we break out of the loop before hitting x that means that there are less than x negative numbers so we return 0.\\n\\n\\n# Complexity\\nTime complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- O(n)\\n- Going through the whole array with left and right pointers takes is a linear time operation. Going through the array of negative number counts is a constant time operation since there are only 50 entries.\\n\\n\\n\\nSpace complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- O(1)\\n- We are using an auxilary array of size 50, but size 50 is constant.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        \\n        int[] ans = new int[nums.length - k + 1];\\n        int[] negCount = new int[50];\\n        int left = 0;\\n        int ansPtr = 0;\\n\\n        for(int right = 0; right < nums.length; right++){\\n\\n            if(nums[right] < 0){\\n                negCount[nums[right] + 50] += 1;\\n            }\\n\\n            if(right - left >= k){\\n\\n                if(nums[left] < 0){\\n                    negCount[nums[left] + 50] -= 1;\\n                }\\n\\n                left+= 1;\\n\\n            }\\n\\n            if(right - left == k - 1){\\n                int result = findXSmallest(negCount, x);\\n                ans[ansPtr] = result;\\n                ansPtr += 1;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n\\n    public int findXSmallest(int[] negCount, int x){\\n        int count = 0;\\n\\n        for(int i = 0; i < negCount.length; i++){\\n\\n            count += negCount[i];\\n\\n            if(count >= x){\\n                return i - 50;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943657,
                "title": "beats-74-run-time-o-n",
                "content": "# Intuition\\nDefine a hash fuction for all -50 to -1 element and keep a tarck of the count. when window size got hit then start keeping track of count via prefix sum in for loop. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window",
                    "Prefix Sum"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        hm = defaultdict(int)\\n        i = 0 \\n        out = []\\n\\n        for h in range(-50,0):\\n            hm[h] = 0 \\n        \\n        for j in range(len(nums)):\\n            if nums[j] < 0 :\\n                hm[nums[j]] += 1\\n\\n            if j-i+1 == k : \\n                count = 0 \\n                for m in range(-50,0):\\n                    count += hm[m]\\n                    if count >= x :\\n                        out.append(m)\\n                        break \\n                if count < x: \\n                    out.append(0)\\n                hm[nums[i]] -= 1\\n                i += 1\\n        \\n        return out\\n                    \\n\\n                \\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3860893,
                "title": "c-beats-99-3-solution-o-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n*50)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:o(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int z) {\\n   \\n    vector<int>v(101,0);\\n     for(int i=0;i<k-1;i++)\\n     {\\n      \\n      v[nums[i]+50]++;\\n     }\\n     vector<int>ans;\\n     int l=0;\\n    for(int i=k-1;i<nums.size();i++)\\n    {\\n     v[nums[i]+50]++;\\n      int cnt=0;\\n      for(int j=0;j<=50;j++)\\n      { \\n        cnt+=v[j];\\n        if(cnt>=z){ans.push_back(j-50);\\n        break;\\n        }\\n\\n      }\\n      if(cnt<z)ans.push_back(0);\\n   v[nums[l]+50]--;\\n   \\n   \\n   l++;\\n\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3859545,
                "title": "easy-c-solution-using-map",
                "content": "# Complexity\\n- Time complexity:\\n(n*k)\\n\\n- Space complexity:\\n- O(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n// [1,2,3,3,3] k = 2, x = 2;\\n// ans = [0, 0, 0]  devil\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        map<int, int> mp;\\n\\n        for(int i=0 ;i<k ;i++){\\n            if(nums[i]<0)\\n            mp[nums[i]]++;\\n        }\\n        int temp = x, val = 0;\\n        for(auto pa:mp){\\n            temp -= pa.second;\\n            val = pa.first;\\n            if(temp<=0)\\n            break;\\n        }\\n        if(temp<=0)\\n        ans.push_back(val);\\n        else\\n        ans.push_back(0);\\n\\n        int start = 0;\\n        \\n        for(int i=k ;i<nums.size() ;i++){\\n            \\n            if(nums[start]<0){\\n                mp[nums[start]]--;\\n                if(mp[nums[start]] == 0)\\n                mp.erase(nums[start]);\\n            }\\n            start++;\\n\\n            if(nums[i]<0)\\n             mp[nums[i]]++;\\n            \\n            temp = x, val = 0;\\n            for(auto pa:mp){\\n                temp -= pa.second;\\n                val = pa.first;\\n                if(temp<=0)\\n                break;\\n            }\\n            if(temp<=0)\\n            ans.push_back(val);\\n            else\\n            ans.push_back(0);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837400,
                "title": "python3-2-methods",
                "content": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList \\n\\nclass Solution:\\n    def method1(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1) # O(n) initialization\\n        nums.append(0)\\n        sliding_window = SortedList(nums[:k]) # O(nlog(n)) initialization\\n        for start in range(len(ans)): # O(n) iterations\\n            ans[start] = min(sliding_window[x - 1], 0)\\n            sliding_window.remove(nums[start]) # O(log(n)) operation\\n            sliding_window.add(nums[start + k]) # O(log(n)) operation\\n        return ans\\n    \\n    def method2(self, nums: List[int], k: int, x: int) -> List[int]:\\n        n = len(nums)\\n        ans = [0] * (n - k + 1)\\n        \\n        counts = [0] * 101 # O(1) initialization\\n        # init snapshot of counts for first subarray\\n        for val in nums[:k]: # O(n) initialization\\n            counts[val] += 1\\n\\n        # pad nums to avoid index error at end of iteration\\n        nums += [0]\\n        for subarray_start in range(len(ans)): # O(n) iterations\\n            curr_count = 0\\n            for val in range(-50,0): # O(1) iterations\\n                curr_count += counts[val]\\n                if curr_count >= x:\\n                    ans[subarray_start] = val\\n                    break\\n            # update snapshot of counts for next subarray\\n            counts[nums[subarray_start]] -= 1\\n            counts[nums[subarray_start + k]] += 1\\n        return ans\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        return self.method2(nums, k, x)\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793367,
                "title": "golang-solution-without-sorting",
                "content": "# Code\\n```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n\\tcounter := make(map[int]int, 101)\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t}\\n\\tbeauty := make([]int, 0, len(nums)-k+1)\\n\\tfor i := k-1; i < len(nums); i++ {\\n\\t\\tcounter[nums[i]]++\\n\\t\\tif i - k >= 0 {\\n\\t\\t\\tcounter[nums[i-k]]--\\n\\t\\t}\\n\\t\\tnegative := 0\\n\\t\\tfor i := -50; i <= 50; i++ {\\n\\t\\t\\tif i >= 0 {\\n\\t\\t\\t\\tbeauty = append(beauty, 0)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnegative += counter[i]\\n\\t\\t\\tif negative >= x {\\n\\t\\t\\t\\tbeauty = append(beauty, i)\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn beauty\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3781954,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        int i=0,j=0;\\n        multiset<int> st;\\n        while(i < nums.size())\\n        {\\n            if(nums[i] < 0)\\n            {\\n               st.insert(nums[i]);\\n            }\\n            if(i-j+1==k)\\n            {\\n                if(st.size() < x)\\n                { \\n                  ans.push_back(0);\\n                }else\\n                {\\n                    ans.push_back(*next(st.begin(),x-1));\\n                }\\n                auto it=st.find(nums[j]);\\n                if(nums[j] < 0)\\n                {\\n                    st.erase(it);\\n                }\\n                j++;\\n                \\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3771657,
                "title": "easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> s;\\n        vector<int> v;\\n        for (int i = 0; i < k; i++) {\\n            s[nums[i]]++;\\n        }\\n        \\n        int i = 0, j = k - 1;\\n        while (j < nums.size()) {\\n            int x2 = x;\\n            for(auto x1:s){\\n                if(x1.first < 0){\\n                    if(x1.second>=x2){\\n                        v.push_back(x1.first);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }else{\\n                    if(x1.second>=x2){\\n                        v.push_back(0);\\n                        break;\\n                    }else{\\n                        x2=x2-x1.second;\\n                    }\\n                }\\n            }\\n            //if(v.size() <= x)v.push_back(0);\\n            if(s[nums[i]]==1){\\n                s.erase(nums[i]);\\n            }else{\\n                s[nums[i]]--;\\n            }\\n            i++;\\n            j++;\\n            if (j < nums.size()) {\\n                s[nums[j]]++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770589,
                "title": "easy-solution-using-map-c-not-using-any-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n            int i=0, j=0;\\n        map<int, int> mp; // it store the val key in sorted order\\n            vector<int> ans; // it is use for store ans\\n          while(j<nums.size()){\\n                mp[nums[j]]++;\\n              if(j-i+1<k){  // checking window size if size is less then k\\n                  j++;\\n              }else{  // if window size is equal to k\\n                   int mini=INT_MAX;  // it will store the xth min\\n                  int t=0;  \\n                  for(auto k:mp){\\n                      t+=k.second; // it is storing size\\n                      if(t>=x){ // here t is greter then or equal to x in this time  key is xth val \\n                          mini=k.first;\\n                          break;\\n                      }\\n                  }\\n                  if(mini>0){ // also if xth val is greter then 0 then  we have to made this 0;\\n                      mini=0;\\n                  }\\n                  ans.push_back(mini);\\n                  mp[nums[i]]--; \\n                  if(mp[nums[i]]==0){\\n                      mp.erase(nums[i]);\\n                  }\\n                  i++;\\n                  j++;\\n              }\\n          }\\n          \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750844,
                "title": "easy-c-code-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& v, int k, int x) {\\n        int n=v.size();\\n        vector<int>count(50,0),ans(n-k+1,0);\\n        for(int i=0;i<k;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n        }\\n        int u=0;\\n        for(int j=0;j<50;j++){\\n            if(u+count[j]<x) u+=count[j];\\n            else{\\n                ans[0]=j-50;\\n                break;\\n            }\\n        }\\n\\n        for(int i=k;i<n;i++){\\n            if(v[i]<0) count[v[i]+50]++;\\n            if(i-k>=0 and v[i-k]<0) count[v[i-k]+50]--;\\n            int u=0;\\n            for(int j=0;j<50;j++){\\n                if(u+count[j]<x) u+=count[j];\\n                else{\\n                    ans[i-k+1]=j-50;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3747861,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        negatives = [0]*50\\n        final = []\\n\\n        for i in range(k):\\n            if nums[i]<0:\\n                negatives[nums[i]] += 1\\n\\n        for i in range(k-1, len(nums)):\\n            if i>=k:\\n                if nums[i-k]<0: negatives[nums[i-k]] -= 1\\n                if nums[i]<0: negatives[nums[i]] += 1\\n\\n            remaining = x\\n            for i in range(len(negatives)):\\n                remaining -= negatives[i]\\n                if remaining<=0:\\n                    final.append(-50+i)\\n                    break\\n            \\n            if remaining>0:\\n                final.append(0)\\n        \\n        return final\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683403,
                "title": "striver-sliding-window-approach-easy-to-understand-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        //approaches\\n        //1. naive -- O(n^3nlogn)\\n        //2.using sliding window :\\n        // use freq array (-50 to 50)\\n        //update the frequencies for window size \\n\\n        vector<int> freq(101, 0), ans;\\n        int i=0, j=0, n = nums.size();\\n\\n        while(j<n){\\n            // 1. find out the calculations\\n            freq[nums[j]+50]++;\\n            \\n            if(j-i+1 < k) j++;\\n\\n            else if(j-i+1 == k){\\n                //2. ans <- calculations\\n                int cnt = 0, val = 0;\\n                while(cnt!=x){\\n                    for(int i=0; i<101; i++){\\n                        if(freq[i]!=0 && cnt+freq[i] > x){\\n                            cnt = x;\\n                        }\\n                        else if(freq[i]!=0 && cnt+freq[i] <= x){\\n                                cnt = cnt + freq[i];\\n                        }\\n\\n                        if(cnt==x){\\n                            val = i-50;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(val < 0) ans.push_back(val);\\n                else ans.push_back(0);\\n\\n                //3. sliding the window\\n                freq[nums[i]+50]--;\\n                i++, j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673489,
                "title": "sliding-window-map-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mpp;\\n        vector<int> ans;\\n        int left = 0; int right = k - 1;\\n        for(int i=0;i<k-1;i++) mpp[nums[i]]++;\\n        while( right < nums.size()){\\n            mpp[nums[right]]++;\\n            int xtracker=0;\\n            for(auto it: mpp){\\n               xtracker += it.second;\\n               if(xtracker>=x){\\n                   if(it.first > 0) ans.push_back(0);\\n                   else ans.push_back(it.first);\\n                   break;\\n               }\\n            }\\n            mpp[nums[left]]--;\\n            if(mpp[nums[left]]<=0) mpp.erase(nums[left]);\\n            left++; right++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3644670,
                "title": "golang-sliding-window-counting-sort",
                "content": "Use sliding window and counting sort to get the xth smallest negative number.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- Space complexity: O(1) since the we only need to store 101 elements\\n\\n# Code\\n```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Two Pointers",
                    "Sliding Window",
                    "Counting",
                    "Counting Sort"
                ],
                "code": "```\\nfunc getSubarrayBeauty(nums []int, k int, x int) []int {\\n  // nums[i] is [-50...50] so we can easily do counting sort\\n  // Using an array with an offset so we don\\'t have to use a map\\n  var counts [101]int\\n  left := 0\\n  offset := 50\\n  var res []int\\n  for right := 0; right < len(nums); right++ {\\n    counts[nums[right]+offset]++\\n    if right - left + 1 == k { // subarray with size k is found\\n      // Let\\'s find if ser have xth smallest negative integer\\n      var pos int\\n      var elem int\\n      for i := 0; i < offset; i++ { // only iterate the negative numbers\\n        pos += counts[i]\\n        if pos >= x {\\n          elem = i-offset\\n          break\\n        }\\n      }\\n      // If we can\\'t find a negative element, elem will be 0 which is what we want\\n      res = append(res, elem)\\n      counts[nums[left]+offset]--\\n      left++\\n    }\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642345,
                "title": "simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr = new int[101];\\n        int j=0;\\n        int[] ans = new int[nums.length-k+1];\\n        int ind=0;\\n        for(int i=0;i<nums.length;i++){\\n            arr[nums[i]+50]++;\\n            if(i<k-1){\\n                continue;\\n            }\\n\\n// this if is to optimize the code further, code will run without this if also. \\n            if(ind >0 && ans[ind-1]<nums[i] && ans[ind-1] <nums[j-1]){\\n                arr[nums[j++]+50]--;\\n                ans[ind] = ans[ind-1];\\n                ind++;\\n                continue;\\n            }\\n            int count =0;\\n            int si=-1;\\n            while(count<x){\\n                si++;\\n                if(arr[si]!=0){\\n                    count +=arr[si];\\n                }\\n\\n            }\\n            arr[nums[j++]+50]--;\\n            ans[ind++] = (si-50<1)?si-50:0;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3592646,
                "title": "simple-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] arr= new int[101];\\n        int[] ans=new int[nums.length-k+1];\\n        int l=0;\\n        for(int i=0;i<k;i++){\\n            arr[nums[i]+50]+=1;   \\n        }\\n        int n=x;\\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n             continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                 if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        int j=k;\\n        int s=0;\\n        while(j<nums.length){\\n            \\n            arr[nums[s++]+50]-=1;\\n            arr[nums[j++]+50]+=1;\\n           \\n            \\n            n=x;\\n            \\n        for(int i=0;i<101 && n>0;i++){\\n            if(arr[i]==0)\\n            continue;\\n            n-=arr[i];\\n            if(n<=0){\\n                if(i-50>0)\\n                    ans[l++]=0;\\n                else\\n                    ans[l++]=i-50;\\n            }\\n            \\n        }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578713,
                "title": "c-ac-using-maxheap-and-minheap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n         vector<int>ans;\\n        int n=nums.size();\\n        priority_queue<pair<int,int>>maxHeap;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>minHeap;\\n        for(int i=0;i<k;i++)\\n        {\\n            \\n                if(maxHeap.size()<x)\\n                maxHeap.push({nums[i],i});\\n                else\\n                {\\n                    if(maxHeap.top().first>nums[i])\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                        maxHeap.push({nums[i],i});\\n                    }\\n                    else minHeap.push({nums[i],i});\\n                }\\n\\n        }\\n        if(maxHeap.top().first>=0)\\n        ans.push_back(0);\\n        else\\n        {\\n            ans.push_back(maxHeap.top().first);\\n        }\\n   //     cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n        int i=1,j=k,size=x;\\n        while(j<n)\\n        {\\n            // cout<<\"i=\"<<i<<\" j=\"<<j<<\\'\\\\n\\';\\n            // cout<<maxHeap.top().first<<\" \"<<minHeap.top().first<<\\'\\\\n\\';\\n            if(nums[i-1]<=maxHeap.top().first)\\n            {\\n                 //maxHeap.push({nums[j],j});\\n                 size++;\\n            }\\n                   if(nums[j]<maxHeap.top().first)\\n                {\\n                    maxHeap.push({nums[j],j});\\n                    if(maxHeap.size()>size)\\n                    {\\n                        minHeap.push(maxHeap.top());\\n                        maxHeap.pop();\\n                    }\\n                    \\n                }\\n                else\\n                {\\n                    minHeap.push({nums[j],j});\\n                }\\n            while(!maxHeap.empty()&&maxHeap.top().second<i)\\n            {\\n                maxHeap.pop();\\n                size--;\\n            }\\n            while(!minHeap.empty()&&minHeap.top().second<i)\\n            {\\n                minHeap.pop();\\n            }\\n            if(maxHeap.size()<size)\\n            {\\n                maxHeap.push(minHeap.top());\\n                minHeap.pop();\\n            }\\n             if(maxHeap.top().first>=0)\\n             ans.push_back(0);\\n            else\\n            {\\n            ans.push_back(maxHeap.top().first);\\n            }\\n            i++;\\n            j++;\\n        }\\n       return ans; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3554007,
                "title": "java-frequency-counter-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n\\tpublic int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n\\t\\tint[] freqCounter = new int[50];\\n\\t\\tint index = 0;\\n\\t\\tint[] results = new int[nums.length - k + 1];\\n\\t\\t\\n\\t\\tfor(int i = 0; i < k; i++) {\\n\\t\\t\\tif(nums[i] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[i] + 50]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\n\\t\\t\\n\\t\\twhile (index < results.length) {\\n\\t\\t\\tif(nums[index-1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index - 1] + 50]--;\\n\\t\\t\\t}\\n\\t\\t\\tif(nums[index + k -1] < 0) {\\n\\t\\t\\t\\tfreqCounter[nums[index + k -1] + 50]++;\\n\\t\\t\\t}\\n\\t\\t\\tresults[index++] = getXthSmallest(freqCounter, x);\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn results;\\n\\t}\\n\\t\\n\\tprivate int getXthSmallest(int[] freqCounter, int x) {\\n\\t\\tint count = 0;\\n\\t\\tfor(int i = 0; i < 50; i++) {\\n\\t\\t\\tcount += freqCounter[i];\\n\\t\\t\\tif(count >= x) {\\n\\t\\t\\t\\treturn i - 50;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn 0;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539749,
                "title": "slow-python-sliding-window",
                "content": "# Intuition\\nThe numbers are in the range -50, 50.\\nWe can keep track of the frequency of numbers in a sliding window of length k.\\nThen we can loop over values (in increasing order) to see which is the x-th smallest element. Since the possible values are in [-50, 50], we can just loop over the whole range.\\n\\n# Approach\\nCount frequency for the first k elements. Then, for the remaining elements, add one by one and update the frequency. \\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ -- ~100x n, but still O(n). \\n\\n- Space complexity:\\n$$O(1)$$ - we keep frequency for unique elements -- this can be at most 101 values.\\n\\n# Improvements\\nCan replace the `defaultdict` with an `OrderedDict` or use an ordered set to keep track of elements present in the range.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        from collections import defaultdict\\n        counts = defaultdict(int)\\n        res = []\\n\\n        for i in range(k):\\n            counts[nums[i]] += 1\\n        \\n        crt_cnt = 0\\n        \\n        for j in range(-50, 51):\\n            if counts[j] > 0:\\n                if crt_cnt < x:\\n                    crt_cnt += counts[j]\\n                if crt_cnt >= x:\\n                    res.append(min(0, j))\\n                    break\\n        \\n        for i in range(k, len(nums)):\\n            counts[nums[i - k]] -= 1\\n            counts[nums[i]] += 1\\n            crt_cnt = 0\\n            for j in range(-50, 51):\\n                if counts[j] > 0:\\n                    if crt_cnt < x:\\n                        crt_cnt += counts[j]\\n                    if crt_cnt >= x:\\n                        res.append(min(0, j))\\n                        break\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538695,
                "title": "java-treemap-slow-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        for (int i = 0; i < k; i++) {\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n        }\\n        int count = 0, c = 0;\\n        int[] res = new int[nums.length - k + 1];\\n        for (int key : map.keySet()) {\\n            count += map.get(key);\\n            if (count >= x) {\\n                res[c] = Math.min(key, 0);\\n                break;\\n            }\\n        }\\n        for (int i = k; i < nums.length; i++) {\\n            int kk = map.get(nums[c]);\\n            if (kk == 0) map.remove(nums[c]);\\n            else map.put(nums[c], kk - 1);\\n            c++;\\n            if (map.containsKey(nums[i])) map.put(nums[i], map.get(nums[i]) + 1);\\n            else map.put(nums[i], 1);\\n            count = 0;\\n            for (int key : map.keySet()) {\\n                count += map.get(key);\\n                if (count >= x) {\\n                    res[c] = Math.min(key, 0);\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535654,
                "title": "java-c-python-just-a-solution-explained",
                "content": "# TL;DR\\n``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```\\n---\\n#### \\u26A0\\uFE0F Please upvote if you like this solution. \\uD83D\\uDE43\\n---\\n\\n# Intuition\\n\\nThe problem asks us to find the beauty of each subarray of size k in the input array. The beauty of a subarray is defined as the xth smallest negative integer in the subarray if there are at least x negative integers, or 0 otherwise. \\n\\nA straightforward approach to this problem would be to sort each subarray and select the xth smallest negative integer. However, this approach is not efficient due to the repeated sorting operation, which would result in a time complexity of O(n*k*log(k)), where n is the length of the array and k is the size of the subarray.\\n\\nTo optimize this, we can use a sliding window approach and maintain a frequency count of the integers in the current subarray. We also keep track of the minimum and maximum values in the current subarray. \\n\\n# Approach\\n\\nThe optimized approach is to use a sliding window of size `k`. As we slide the window, we keep track of the frequency of numbers in the current window using a frequency array `counts`. For each new window, we add the new number to the frequency array and remove the number that is no longer in the window.\\n\\nWe keep track of the minimum and maximum numbers in the current window. This helps in searching for the xth smallest negative number in the frequency array. \\n\\nAs we slide the window, we keep adding the xth smallest negative number in the window to our result array `res`.\\n\\n# Complexity Analysis\\n\\n- Time complexity: The time complexity of this approach is $$O(n)$$, where $$n$$ is the number of elements in the array. We iterate over the array once, and for each iteration, we perform constant time operations such as updating the frequency array, searching for the xth smallest negative number, and updating the result array.\\n\\n- Space complexity: The space complexity is $$O(n)$$ for the `res` array, and $$O(1)$$ for the `counts` array as it has a fixed size based on the problem constraints (range of the numbers in the array). Therefore, the total space complexity is $$O(n)$$.\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "``` java []\\nclass Solution {\\n    private static final int MAX_VAL = 50;\\n    private static final int MIN_VAL = -50;\\n    private static final int OFFSET = -MIN_VAL;\\n\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        var res = new int[nums.length - k + 1];\\n        var counts = new int[MAX_VAL - MIN_VAL + 2];\\n\\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = Math.min(min, nums[i]);\\n            max = Math.max(max, nums[i]);\\n        }\\n\\n        for (int i = 0; i < nums.length - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = Math.max(max, next);\\n            min = Math.min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = Math.min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n``` cpp []\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        const int MAX_VAL = 50;\\n        const int MIN_VAL = -50;\\n        const int OFFSET = -MIN_VAL;\\n        int n = nums.size();\\n        vector<int> res(n - k + 1);\\n        vector<int> counts(MAX_VAL - MIN_VAL + 2, 0);\\n        \\n        int min = MAX_VAL;\\n        int max = MIN_VAL;\\n        for (int i = 0; i < k - 1; i++) {\\n            counts[nums[i] + OFFSET]++;\\n            min = std::min(min, nums[i]);\\n            max = std::max(max, nums[i]);\\n        }\\n        \\n        for (int i = 0; i < n - k + 1; i++) {\\n            int next = nums[i + k - 1];\\n            counts[next + OFFSET]++;\\n            max = std::max(max, next);\\n            min = std::min(min, next);\\n            int xMin = 0;\\n            int count = 0;\\n            for (int j = min - MIN_VAL; j <= max + OFFSET; j++) {\\n                count += counts[j];\\n                if (count >= x) {\\n                    xMin = j - OFFSET;\\n                    break;\\n                }\\n            }\\n            res[i] = std::min(xMin, 0);\\n            counts[nums[i] + OFFSET]--;\\n            if (counts[nums[i] + OFFSET] == 0) {\\n                if (nums[i] == max) {\\n                    max = MAX_VAL;\\n                }\\n                if (nums[i] == min) {\\n                    min = MIN_VAL;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\n``` python []\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        MAX_VAL = 50\\n        MIN_VAL = -50\\n        OFFSET = -MIN_VAL\\n        n = len(nums)\\n        res = [0] * (n - k + 1)\\n        counts = [0] * (MAX_VAL - MIN_VAL + 2)\\n        \\n        min_val = MAX_VAL\\n        max_val = MIN_VAL\\n        for i in range(k - 1):\\n            counts[nums[i] + OFFSET] += 1\\n            min_val = min(min_val, nums[i])\\n            max_val = max(max_val, nums[i])\\n        \\n        for i in range(n - k + 1):\\n            next_val = nums[i + k - 1]\\n            counts[next_val + OFFSET] += 1\\n            max_val = max(max_val, next_val)\\n            min_val = min(min_val, next_val)\\n            xMin = 0\\n            count = 0\\n            for j in range(min_val - MIN_VAL, max_val + OFFSET + 1):\\n                count += counts[j]\\n                if count >= x:\\n                    xMin = j - OFFSET\\n                    break\\n            res[i] = min(xMin, 0)\\n            counts[nums[i] + OFFSET] -= 1\\n            if counts[nums[i] + OFFSET] == 0:\\n                if nums[i] == max_val:\\n                    max_val = MAX_VAL\\n                if nums[i] == min_val:\\n                    min_val = MIN_VAL\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3517791,
                "title": "python-counting-sort-o-n-50",
                "content": "As the value range is only `[-50, 50]`, or to be more specific actual range that we work with only `[-50, -1]` we can use instead of `nlogn` sorting `counting sort` with `O(50)`.\\n\\nInstead of counting every time `k-size window` we can use `sliding window of fixed size k`.\\n\\n2641ms ~99.4%\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        res = []\\n        freq = [0] * 51\\n        neg_nums_count = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            if nums[end] < 0:\\n                neg_nums_count += 1\\n                freq[nums[end]] += 1\\n\\n            if end >= k - 1:\\n                pos = 0\\n                current = x\\n                if x > neg_nums_count:\\n                    pos = 51\\n                else:\\n                    while freq[pos] < current:\\n                        current -= freq[pos]\\n                        pos += 1\\n                res.append(pos - 51)\\n\\n                if nums[start] < 0:\\n                    neg_nums_count -= 1\\n                    freq[nums[start]] -= 1\\n                start += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3506204,
                "title": "easy-cpp-solution-time-complexity-explained-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->the value for nums are given from -50 to 50 think upon this and write a code for their count\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->The function aims to find subarrays of length k in nums that have a \"beauty\" value of at least x. A subarray\\'s beauty is defined as the absolute difference between its maximum and minimum elements.\\n\\nThe implementation uses a sliding window approach to iterate over all subarrays of length k in nums. At each iteration, it maintains a map mp that tracks the frequency of each element in the current subarray.\\n\\nThe while loop iterates from j=0 to j=nums.size()-1. At each iteration, if the subarray length is less than k, the frequency of the element at index j is incremented in the map mp, and j is incremented. If the subarray length is equal to k, the function checks the beauty value of the current subarray by iterating over all elements in the map mp and calculating their contribution to the beauty value. The iteration continues until the sum of the frequencies of the elements encountered so far is greater than or equal to x. If the beauty value of the subarray is greater than or equal to x, the minimum element in the subarray is added to the vector v.\\n\\nAfter checking the beauty value of the subarray, the implementation removes the first element of the current subarray by decrementing its frequency in the map mp. If the frequency of the element becomes zero, it is removed from the map. The indices i and j are incremented to move the sliding window forward.\\n\\nFinally, when the while loop completes, the function returns the vector v containing the minimum elements of all subarrays of length k with a beauty value of at least x.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The while loop in the implementation iterates over each element in the input vector nums exactly once, so the time complexity of the loop is O(n).\\n\\nInside the while loop, the implementation uses a map to keep track of the frequency of each element in the current subarray. The map operations, such as insertion, deletion, and finding an element, have a time complexity of O(log(n)) on average. In the worst case, when the map is unbalanced, the time complexity of these operations can be O(n). Since the map operations are performed for each element in nums, the overall time complexity of the map operations is O(n*log(n)) on average and O(n^2) in the worst case.\\n\\nTherefore, the overall time complexity of the implementation is dominated by the time complexity of the while loop, which is O(n). Thus, the time complexity of the implementation is O(n*log(n)).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The implementation uses a map to keep track of the frequency of each element in the current subarray, so the space complexity of the map is at most O(k). This is because the map will store at most k distinct elements, one for each position in the sliding window.\\n\\nIn addition to the map, the implementation uses a vector to store the minimum elements of the subarrays with beauty value at least x. The length of this vector is at most n/k, since there can be at most n/k subarrays of length k in the input vector nums that the function checks. Therefore, the space complexity of the vector is O(n/k).\\n\\nSince O(k) is less than or equal to O(n/k), the overall space complexity of the implementation is O(n/k).\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        ios_base::sync_with_stdio(false);\\n        map<int,int>mp;\\n        int i=0; int j=0;\\n        vector<int>v;\\n        while(j<nums.size()){\\n            if(j-i+1<k){\\n                mp[nums[j]]++;\\n                j++;\\n            }\\n            else{\\n                mp[nums[j]]++;\\n                int count=0;\\n               for(auto it:mp){\\n                   count+=it.second;\\n                   if(count>=x){\\n                       if(it.first<=0){\\n                          v.push_back(it.first);  \\n                       }\\n                      else{\\n                          v.push_back(0);\\n                      }\\n                       break;\\n                   }\\n               } \\n               mp[nums[i]]--;\\n               if(mp[nums[i]]==0) {\\n                   mp.erase(nums[i]);\\n               }\\n               i++;\\n               j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497251,
                "title": "easy-to-understand-sliding-window-ordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nk) \\n-  n-> for iterating over nums array\\n-  k-> for iterating over map\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int,int> mp;\\n        int i=0;\\n        for(;i<k-1;i++)\\n          mp[nums[i]]++;\\n\\n            vector<int> ans;\\n          for(;i<nums.size();i++){\\n              mp[nums[i]]++;\\n              int count=0,beauty=0;\\n              for(auto [ele,f]:mp){\\n                  count+=f;\\n                  if(count>=x){ beauty=ele; break;}\\n              }\\n              if(beauty<0)\\n              ans.push_back(beauty);\\n              else \\n              ans.push_back(0);\\n\\n              mp[nums[i-k+1]]--;\\n              if(mp[nums[i-k+1]]==0) mp.erase(nums[i-k+1]);\\n          }\\n          return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3488084,
                "title": "c-easy-solution-frequency-vector",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> ans;\\n        vector<int> fre(101);\\n        int i=0,j=0,n = nums.size();\\n        while(j<n)\\n        {\\n            if(nums[j]<0)\\n            {\\n                fre[nums[j]+50]++;\\n            }\\n            if(j-i+1==k)\\n            {\\n                int cnt = 0;\\n                for(int s=0;s<101;s++)\\n                {\\n                    cnt+=fre[s];\\n                    if(cnt>=x)\\n                    {\\n                        ans.push_back(s-50);\\n                        break;\\n                    }\\n                }\\n                if(cnt<x)\\n                ans.push_back(0);\\n                fre[nums[i]+50]--;\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486317,
                "title": "99-84-tc-easy-python-solution-using-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        def solve(negative):\\n            if(negative < x):\\n                return 0\\n            temp = x\\n            for i in range(50):\\n                if(temp <= count[i]):\\n                    return i-50\\n                temp -= count[i]\\n                \\n        neg = 0\\n        count = [0] * 50\\n        for i in range(k):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n        ans = [solve(neg)]\\n        for i in range(k, len(nums)):\\n            if(nums[i] < 0):\\n                count[nums[i]] += 1\\n                neg += 1\\n            if(nums[i-k] < 0):\\n                count[nums[i-k]] -= 1\\n                neg -= 1\\n            ans.append(solve(neg))\\n        return ans\\n            \\n        \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3485287,
                "title": "easy-java-solution-array-sliding-window",
                "content": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC = O(N*101)~= O(N)\\nSC = O(101) ~= O(1)\\n\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          \\n        int freq[] = new int[101];\\n        int N = nums.length;\\n        int len = N - k + 1;\\n        int ans[] = new int[len];\\n        \\n        for(int i=0; i<k; i++) {\\n            freq[nums[i]+50]++;\\n        }\\n        int index =0; \\n\\n        int count = 0;\\n        for(int i=0; i<101; i++) {\\n            count += freq[i];\\n            if(count>=x) {\\n                ans[index++] = i-50 < 0 ? i-50 : 0;\\n                break;\\n            }\\n        }\\n        for(int i=k; i<N; i++) {\\n            freq[nums[i-k]+50]--;\\n            freq[nums[i]+50]++;\\n            count = 0;\\n            for(int j=0; j<101; j++) {\\n                count += freq[j];\\n                if(count>=x) {\\n                    ans[index++] = j-50 < 0 ? j-50 : 0;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3480168,
                "title": "java-only-array-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  int t[] = new int[101];\\n  int X;\\n\\n  private int findX(){\\n    for(int i = 0, c = 0; i != 50; ++i)\\n      if( (c+=t[i]) >= X) return i - 50;\\n    return 0;\\n  }\\n\\n  public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n    int ans[] = new int[nums.length - k + 1];\\n    X = x;\\n    \\n    for(int i = 0; i != k; ++i) ++t[nums[i]+50];\\n    ans[0] = findX();\\n\\n    for(int i = k, j = 1; i != nums.length; ++i, ++j){\\n      ++t[nums[i]+50];\\n      --t[nums[j-1]+50];\\n      ans[j] = findX();\\n    }\\n\\n    return ans;  \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478045,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn get_subarray_beauty(nums: Vec<i32>, k: i32, x: i32) -> Vec<i32> {\\n        let mut ans = vec![];\\n        let mut mp = std::collections::BTreeMap::new();\\n        for i in 0..nums.len() {\\n            *mp.entry(nums[i]).or_insert(0) += 1;\\n            if i >= k as usize - 1 {\\n                if i >= k as usize {\\n                    *mp.get_mut(&nums[i - k as usize]).unwrap() -= 1;\\n                }\\n                let mut sum = 0;\\n                let mut t = 0;\\n                for (key, value) in mp.iter() {\\n                    sum += value;\\n                    if sum >= x {\\n                        t = if *key < 0 { *key } else { 0 };\\n                        break;\\n                    }\\n                }\\n                ans.push(t);\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477265,
                "title": "c-solution-using-multiset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use multisets to store the elements in sorted order. One multiset(here m1) will store the first x elements and the other(here m2) will store the next k-x elements.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs we slide the window, we will check if the element to be removed is present in the first multiset or the second and remove it from there.\\nThe new element will be added to the other multiset. Suppose we are removing the element from the first multiset then the new element will be added to the second multiset and vice-versa.\\nNow we will adjust the multisets accordingly such that the first multiset contains x elements and the other contains k-x elements.\\nNow, we check if the last element of first multiset is negative or positive and push it to the answer vector accordingly.\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int>m1,m2;\\n        int i=0,j=0;\\n        for(;i<k;i++)\\n            m1.insert(nums[i]);\\n        while(m1.size()>x)\\n        {\\n            m2.insert(*m1.rbegin());\\n            m1.erase(m1.find(*m1.rbegin()));\\n        }\\n        vector<int>res;\\n        if(*m1.rbegin()>=0)\\n            res.push_back(0);\\n        else\\n            res.push_back(*m1.rbegin());\\n        for(;i<nums.size();i++,j++)\\n        {\\n            if(m1.find(nums[j])!=m1.end())\\n            {\\n                m1.erase(m1.find(nums[j]));\\n                m2.insert(nums[i]);\\n                m1.insert(*m2.begin());\\n                m2.erase(m2.begin());\\n            }\\n            else\\n            {\\n                m2.erase(m2.find(nums[j]));\\n                m1.insert(nums[i]);\\n                m2.insert(*m1.rbegin());\\n                m1.erase(m1.find(*m1.rbegin()));\\n            }\\n            if(*m1.rbegin()>=0)\\n                res.push_back(0);\\n            else\\n                res.push_back(*m1.rbegin());\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471955,
                "title": "c-o-n-log-k-using-ordered-multiset-but-code-is-awful-to-read",
                "content": "I didn\\'t notice the constraint of the range of values, so I didn\\'t think to use counting sort. By the time I noticed the constraint, I had already most of the code for this solution, which is O(n log k) and uses a multiset to store the window. \\n\\nWe insert and delete elements from the window as it slides through the input, and store an iterator to the xth element of the multiset. When processing the next element, we may need to shift the iterator for the xth element left or right based on its relation to the inserted and deleted element. That\\'s why there\\'s so many cases to check. Although this took me a while to do, I learned a lot about the std::multiset which I hadn\\'t known prior.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> res(n-k+1);\\n        multiset<int> s;\\n        for (int i = 0; i < k; i ++){\\n            s.insert(nums[i]);\\n        }\\n        \\n        auto it = s.begin();\\n        for (int i = 1; i < x; i++){  \\n            it++;\\n        }\\n        \\n        int xth = *it;\\n        res[0] = (xth < 0 ) ? xth : 0;\\n\\n        for (int i = k; i < n; i++){\\n            int ins = nums[i];\\n            int del = nums[i-k];\\n\\n            if (ins == del){\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n            }else if (xth > ins && xth > del || xth < ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth > ins && xth < del){\\n                s.insert(ins);\\n                it = prev(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth > del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth < ins && xth == del){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }  \\n            }else if (xth > ins && xth == del){\\n                //hardest part\\n                s.insert(ins);\\n                auto itr = s.lower_bound(del);\\n                if (itr == it){\\n                    it = prev(it);\\n                    s.erase(itr);\\n                }else{\\n                    s.erase(itr);\\n                }\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;         \\n            }else if (xth == ins && xth > del ){\\n                s.insert(ins);\\n                it = next(it);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.find(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }else if (xth == ins && xth < del){\\n                s.insert(ins);\\n                xth = *it;\\n                res[i-k+1] = (xth < 0 ) ? xth : 0;\\n                auto itr = s.lower_bound(del);\\n                if (itr != s.end()){\\n                    s.erase(itr);\\n                }\\n            }\\n\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471317,
                "title": "java",
                "content": "The main trick is to understand that -50 <= nums[i] <= 50, before wasting time on any creative ideas.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int negs=0,n=nums.length;\\n        int [] sol = new int [n-k+1], frqs = new int[101]; //-50 - +50\\n        for (int i=0;i<k;i++){\\n            frqs[nums[i]+50]++;\\n            if (nums[i]<0) negs++;\\n        }\\n        for (int i=0;i<n-k+1;i++){\\n            sol[i] = (negs<x)?0:findXth(frqs,x);\\n            if (i==n-k) break;\\n            frqs[nums[i]+50]--;\\n            if (nums[i]<0) negs--;\\n            frqs[nums[i+k]+50]++;\\n            if (nums[i+k]<0) negs++;\\n        }\\n        return sol;\\n    }\\n\\n    public int findXth(int frqs[],int x){\\n        int counter=0;\\n        for (int i=0;i<51;i++){\\n            counter+=frqs[i];\\n            if (counter>=x) return i-50;\\n        }\\n        return 777;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467658,
                "title": "max-heap-min-heap",
                "content": "# Intuition\\nIf we remove the ridiculous -50..50 condition from the task (or just didn\\'t notice it, haha), we would not be able to use the counting-based solutions, so we need something smarter.\\nThe idea is to use max heap for the x smaller numbers, and min heap for the larger numbers and \"transfuse\" numbers between them. When we remove the 1st element from the sliding array, we will either remove it from the maxHeap (and put there the smallest of the larger numbers from the minHeap); or we just remove it from the maxHeap.\\n\\n# Approach\\nI tried to explain everything in details in comments in the code\\n\\n# Complexity\\n- Time complexity:\\nO(n*log(n))\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        // we will store x smallest numbers in the maxHeap, so that the element on teh top is the x-th smallest\\n        val maxHeap = PriorityQueue<Int>(reverseOrder())\\n        // we will store the rest of the elements (the bigger ones) in the minHeap\\n        val minHeap = PriorityQueue<Int>()\\n        for (i in 0 until k) {\\n            maxHeap.offer(nums[i])\\n        }\\n        var result  = IntArray(nums.size - k + 1)\\n        for (i in 0 .. nums.size-k) {\\n            // remove the bigger elements from the maxHeap and put them in the minHeap\\n            while (maxHeap.size > x) {\\n                minHeap.offer(maxHeap.poll())\\n            }\\n            // get the x-th smallest element from the top of the maxHeap\\n            result[i] = Math.min(0, maxHeap.peek())\\n            // now we need to remove the 1st element of our sliding array from the heaps\\n            // if this element is less or equal than the top of the maxHeap - it means it participates in the x-size set of minimum elements\\n            // this means we need to remove it from the maxHeap, and put there the smallest number from the remaining elements (which we store in the minHeap)\\n            // otherwise this 1st element is one of the bigger elements, so we just remove it from the minHeap\\n            if (nums[i] <= maxHeap.peek()) {\\n                maxHeap.remove(nums[i])\\n                // if x == k, the minHeap will always be empty\\n                if (minHeap.size > 0) maxHeap.offer(minHeap.poll())\\n            } else minHeap.remove(nums[i])\\n            \\n            // and finally we are adding the next element to the maxHeap\\n            if (k+i < nums.size) maxHeap.offer(nums[k+i])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466590,
                "title": "java-26ms-96-and-clean-code",
                "content": "# Approach\\n1. Use an int[101] window to mark & count the nums[-50..50]. Just add 50 to the num (-50 + 50) -> 0, (4 +50) -> 54\\n2. Create the initial window with the nums[0..k-1].\\n3. While adding them, keep track of the negative count. If num < 0, increase negative count.\\nWhen quering a given interval, if negativeCount < x, then return 0 immediately.\\n4. Finding the xth negative. \\n    - As mentioned on #3, if negativeCount < x, return 0\\n    - Else loop from 0 to < 50 (representing the nums -50, -1) and do a prefix sum.\\n    - Stop when prefixSum >= x. Return index - 50 (an index 4 will represent the number -46 becuase -46+50 = 4;\\n5. When moving to next element, just remove the left number of the window (nums[i - k]). Also, adjust the negative count. (decrease if the eliminated number is negative). \\n\\n# Complexity\\n- Time complexity:$$O((n-k) * 50)$$ - worst case\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(102)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] negativeCount = {0};\\n        int[] window = createWindow(nums, k, negativeCount);\\n        int[] beauty = new int[nums.length - k + 1];\\n        for (int i = k; i < nums.length; i++) {\\n            beauty[i - k] = findXthSmallestInteger(window, x, negativeCount);\\n            removePreviousElement(window, nums, i - k, negativeCount);\\n            addNextElement(window, nums, i, negativeCount);\\n        }\\n        beauty[nums.length - k] = findXthSmallestInteger(window, x, negativeCount);\\n        return beauty;\\n    }\\n\\n    private void removePreviousElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]--;\\n        }\\n        window[nums[index] + 50]--;\\n    }\\n\\n    private void addNextElement(int[] window, int[] nums, int index, int[] negativeCount) {\\n        if (nums[index] < 0) {\\n            negativeCount[0]++;\\n        }\\n        window[nums[index] + 50]++;\\n    }\\n\\n    private int findXthSmallestInteger(int[] window, int x, int[] negativeCount) {\\n        if (negativeCount[0] < x) {\\n            return 0;\\n        }\\n        int count = 0;\\n        for (int i = 0; i < 50; i++) {\\n            if (window[i] > 0) {\\n                count += window[i];\\n                if (count >= x) {\\n                   return index - 50;\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    private int[] createWindow(int[] nums, int size, int[] negativeCount) {\\n        int[] window = new int[101];\\n        while(--size >= 0) {\\n            window[nums[size] + 50]++;\\n            if (nums[size] < 0) {\\n                negativeCount[0]++;\\n            }\\n        }\\n        return window;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466479,
                "title": "java-93-faster-simple-counting-array",
                "content": "**Approach:**\\n* We are provided with a range of `-50 <= nums[i] <= 50 ` , so we can create a count array of size 50 to store only negative number as we only need negative numbers.\\n* Now as we have a fix range of 50, we iterate we iterate over 50 elements to calculate xth negative number with TC: `O(50)` for each operation we do this using frequency by adding frequency to a local variable and checking if it becomes greator or equals to x.\\n* In each iteration we slide over array and increase the frequency of each negative no and remove the element from start if negative.\\n\\n\\n**Tme Complexity:**\\n```\\nTC: O(N)\\nSC: O(1)\\n```\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nTC: O(N)\\nSC: O(1)\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n          int[] count = new int[50];\\n          int[] sol = new int[nums.length-k+1];\\n          int i=0;\\n          for(;i<k;i++){\\n              if(nums[i]<0)count[nums[i]+50]++;\\n          }\\n          int l=0,val=0;\\n          for(int q=0;q<50;q++){\\n                  l+=count[q];\\n                  if(l>=x){\\n                      val=q-50;\\n                      break;\\n                  }\\n          }\\n          sol[0]=val;\\n          int idx=1;\\n          for(;i<nums.length;i++){\\n              if(nums[idx-1]<0)count[nums[idx-1]+50]--;\\n              if(nums[i]<0)count[nums[i]+50]++;\\n              int loc=0,v=0;\\n              for(int q=0;q<50;q++){\\n                  loc+=count[q];\\n                  if(loc>=x){\\n                      v=q-50;\\n                      break;\\n                  }\\n              }\\n              sol[idx++]=v;\\n          }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465886,
                "title": "very-easy-solution-c-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nused set and map \\nset is used because in it searching insertion and deletion is done in O(logN) time\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int i=0 , j=0;\\n        int n = nums.size();\\n        map<int , int>mpp;\\n        set<int>st;\\n        vector<int>ans;\\n        \\n        while(j<n)\\n        {\\n            mpp[nums[j]]++;\\n            st.insert(nums[j]);\\n            \\n            if(j-i+1<k)j++;\\n            \\n            else if(j-i+1==k)\\n            {\\n                int cnt=0;\\n\\n                for(auto ele : st)\\n                {\\n                    cnt+=mpp[ele];\\n                    if(cnt>=x)\\n                    {\\n                        if(ele<0)ans.push_back(ele);\\n                        else ans.push_back(0);\\n                        break;\\n                    }\\n                }\\n\\n                if(mpp[nums[i]]==1)\\n                {\\n                    st.erase(nums[i]);\\n                }\\n                mpp[nums[i]]--;\\n                i++;\\n                j++;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3463444,
                "title": "python3-hashtable-and-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def find_x_smallest(self, count_map, x):\\n        count = 0\\n        for num in range(-50, 0, 1):\\n            if count_map.get(num, 0) != 0:\\n                count += count_map[num]\\n                if count >= x:\\n                    return num\\n                \\n        return 0\\n\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        start = 0\\n        neg = 0\\n        count_map = {}\\n    \\n        ans = []\\n            \\n        for end in range(len(nums)):\\n            # Remove contribution of start element if its negative.\\n            if start > len(nums)-k+1:\\n                break\\n            if nums[end] < 0:\\n                neg += 1\\n                count_map[nums[end]] = count_map.get(nums[end], 0) + 1\\n            \\n            window_size = end - start + 1\\n            if window_size == k:\\n                temp = 0\\n                if neg > 0 and neg >= x: \\n                    temp = self.find_x_smallest(count_map, x)\\n                if nums[start] < 0:\\n                    neg -= 1\\n                    count_map[nums[start]] -= 1\\n                start += 1\\n                ans.append(temp)\\n            \\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3462116,
                "title": "sliding-window-treemap",
                "content": "# Code\\n```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int getXthSmallest(Map<Integer, Integer> map, int x) {\\n        int count = 0;\\n\\n        for (var entry: map.entrySet()) {\\n            count += entry.getValue();\\n\\n            if (count >= x) {\\n                return entry.getKey();\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n     public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int j = 0;\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        var frequency = new TreeMap<Integer, Integer>();\\n\\n        for (int i = 0; i < k; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n        }\\n\\n        ans[j++] = getXthSmallest(frequency, x);\\n\\n        for (int i = k; i < nums.length; i++) {\\n            if (nums[i] < 0) {\\n                frequency.merge(nums[i], 1, Integer::sum);\\n            }\\n\\n            if (nums[i - k] < 0) {\\n                frequency.merge(nums[i - k], -1, Integer::sum);\\n            }\\n\\n            ans[j++] = getXthSmallest(frequency, x);\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461681,
                "title": "easy-beginner-friendly-fixed-sized-sliding-window-problem-well-commented-cpp",
                "content": "# Intuition + Approach\\n1. Converted the problem into Fixed Size Sliding Window Problem. \\n2. Used a Map to store the negative numbers, such that we can easily extract the xth smallest element at any point of time.\\n3. At any point the map would only contain the negative numbers present in the window\\n4. Once window size K is reached the challeneging point is to get into the xth position in the map.\\n5. However, while travelling to xth position in map, we need to take into account of the frequency.\\n6. Ran a for loop to take into the number of times we are iterating. \\n\\n# Complexity\\n- Time complexity:\\nO(n*x)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  vector<int> getSubarrayBeauty(vector<int> &nums, int k, int x)\\n  {\\n    // to store -ve numbers in order for quick extraction of xth smallest element\\n    map<int, int> umap;\\n    vector<int> ans;\\n    int i = 0, j = 0, flag = 1, c = 0, no = 0;\\n    // sliding window starts\\n    while (j < nums.size())\\n    {\\n      // calculation - insert only negative numbers in map [contains]\\n      if (nums[j] < 0)\\n        umap[nums[j]]++;\\n      // if window size k isn\\'t reached\\n      if (j - i + 1 < k)\\n        j++;\\n      // if window size k is reached\\n      else if (j - i + 1 == k)\\n      {\\n        // this loop is run to get into xth smallest element in map\\n        for (auto it = umap.begin(); it != umap.end(); it++)\\n        {\\n          c += it->second; // to take into account of the number of times it apperared, as if it\\'s present in map means the window has this element of these many occurences\\n          if (c >= x)\\n          { // while adding to it->second, c might exceed x , so if c!=x && c>x doesn\\'t mean xth smallest element isn\\'t present.\\n            no = it->first;\\n            flag = 0;\\n            break;\\n          }\\n        }\\n        c = 0;\\n        if (flag == 0)\\n          ans.push_back(no);\\n        else\\n          ans.push_back(0); // flag!=0 indicates xth smallest element wasn\\'t found so return 0.\\n        flag = 1;\\n        // slide the window\\n        // as k is reached, so delete 1 element from start and update in map accordingly\\n        auto index = umap.find(nums[i]);\\n        if (index != umap.end())\\n        {\\n          if (umap[nums[i]] == 1)\\n            umap.erase(nums[i]);\\n          else\\n            umap[nums[i]]--;\\n        }\\n        i++;\\n        j++;\\n      }\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460988,
                "title": "a-few-solutions",
                "content": "Let `cnt` be \"buckets\" which store the count of values `1..50` inclusive which represent each corresponding negative value `x` of the input array `A`.\\n\\nUse a sliding window `i..j` inclusive of size `K` along with the function `f()` to perform a linear scan of the \"buckets\" to find and return the target `T`<sup>th</sup> smallest negative value (if it exists).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(A: IntArray, K: Int, T: Int): IntArray {\\n        var ans = mutableListOf<Int>()\\n        var cnt = IntArray(50 + 1) { 0 }\\n        fun f(): Int {\\n            var t = 0\\n            for (x in 50 downTo 1) {\\n                t += cnt[x]\\n                if (T <= t)\\n                    return -x\\n            }\\n            return 0\\n        }\\n        for (j in 0 until A.size) {\\n            if (A[j] < 0) ++cnt[-A[j]]\\n            var i = j - K + 1\\n            if (0 <= i) {\\n                ans.add(f())\\n                if (A[i] < 0) --cnt[-A[i]]\\n            }\\n        }\\n        return ans.toIntArray()\\n    }\\n}\\n```\n```\\nlet getSubarrayBeauty = (A, K, T, cnt = Array(50 + 1).fill(0), ans = []) => {\\n    let f = () => {\\n        let t = 0;\\n        for (let x = 50; 0 < x; --x) {\\n            t += cnt[x];\\n            if (T <= t)\\n                return -x;\\n        }\\n        return 0;\\n    };\\n    for (let j = 0; j < A.length; ++j) {\\n        if (A[j] < 0) ++cnt[-A[j]];\\n        let i = j - K + 1;\\n        if (0 <= i) {\\n            ans.push(f());\\n            if (A[i] < 0) --cnt[-A[i]];\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, A: List[int], K: int, T: int) -> List[int]:\\n        ans = []\\n        cnt = [0] * (50 + 1)\\n        def f():\\n            t = 0\\n            for x in range(50, 0, -1):\\n                t += cnt[x]\\n                if T <= t:\\n                    return -x\\n            return 0\\n        for j in range(len(A)):\\n            if A[j] < 0: cnt[-A[j]] += 1\\n            i = j - K + 1\\n            if 0 <= i:\\n                ans.append(f())\\n                if A[i] < 0: cnt[-A[i]] -= 1\\n        return ans\\n```\n```\\ntype VI = Vec<i32>;\\nimpl Solution {\\n    pub fn get_subarray_beauty(A: VI, K: i32, T: i32) -> VI {\\n        let mut ans = vec![];\\n        let mut cnt = vec![0; 50 + 1];\\n        fn f(A: &VI, T: i32, cnt: &VI) -> i32 {\\n            let mut t = 0;\\n            for x in (1..=50).rev() {\\n                t += cnt[x];\\n                if T <= t {\\n                    return -(x as i32);\\n                }\\n            }\\n            0\\n        }\\n        for j in 0..A.len() {\\n            if A[j] < 0 { cnt[-A[j] as usize] += 1; }\\n            let i = j as i32 - K + 1;\\n            if 0 <= i {\\n                ans.push(f(&A, T, &cnt));\\n                let i = i as usize;\\n                if A[i] < 0 { cnt[-A[i] as usize] -= 1; }\\n            }\\n        }\\n        ans\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI getSubarrayBeauty(VI& A, int K, int T, VI ans = {}) {\\n        VI cnt(50 + 1);\\n        auto f = [&]() {\\n            auto t = 0;\\n            for (auto x{ 50 }; 0 < x; --x) {\\n                t += cnt[x];\\n                if (T <= t)\\n                    return -x;\\n            }\\n            return 0;\\n        };\\n        for (auto j{ 0 }; j < A.size(); ++j) {\\n            if (A[j] < 0) ++cnt[-A[j]];\\n            auto i = j - K + 1;\\n            if (0 <= i) {\\n                ans.push_back(f());\\n                if (A[i] < 0) --cnt[-A[i]];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460189,
                "title": "a-short-and-general-multiset-solution",
                "content": "# Intuition\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n\\n# Approach\\nMultiset with pointer to xth largest element in the sliding window set maintained\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlog(k)) which is independent of nums[i]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        x = x-1;\\n        \\n        vector<int> temp(nums.begin(), nums.begin()+k);\\n        sort(temp.begin(), temp.end());\\n        vector<int> ans = {temp[x]};\\n        int prev = temp[x];\\n        \\n        multiset<int> s;\\n        for(int i = 0; i<k; i++) s.insert(nums[i]);\\n        auto ptr = s.begin();\\n        for(int i = 0; i<x; i++) ptr++;\\n        \\n        \\n        for(int i = k; i<n; i++){\\n            s.insert(nums[i]);\\n            if(nums[i] < prev) ptr--;\\n            prev = *ptr;\\n            if(nums[i-k] <= prev) ptr++;\\n            s.erase(s.find(nums[i-k]));\\n            prev = *ptr;\\n            ans.push_back(prev);\\n        }\\n        for(auto &x : ans) if(x>0) x = 0;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459761,
                "title": "java-simple-solution-greedy-sliding-window-tc-o-n-sc-o-1",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        int cnt = 0;\\n        int[] freq = new int[60];\\n        for(int i = 0;i < k;i++){\\n            if(nums[i] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[i])]++;\\n            }\\n        }\\n        if(cnt >= x){\\n            int csf = 0;\\n            for(int i = 50;i >= 0;i--){\\n                if(freq[i] + csf >= x){\\n                    ans[0] = -i;\\n                    break;\\n                }\\n                csf += freq[i];\\n            }\\n        }\\n        int start = 0;\\n        int end = k;\\n\\n        while(end < n){\\n            if(nums[end] < 0){\\n                cnt++;\\n                freq[Math.abs(nums[end])]++;\\n            }\\n\\n            if(nums[start] < 0){\\n                cnt--;\\n                freq[Math.abs(nums[start])]--;\\n            }\\n\\n            if(cnt >= x){\\n                int csf = 0;\\n                for(int i = 50;i >= 0;i--){\\n                    if(freq[i] + csf >= x){\\n                        ans[start + 1] = -i;\\n                        break;\\n                    }\\n                    csf += freq[i];\\n                }\\n            }\\n            start++;\\n            end++;\\n        }    \\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3459566,
                "title": "sliding-window-concept-done-with-treemap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        TreeMap<Integer, Integer> tmap = new TreeMap<>();\\n        int n = nums.length;\\n        int[] ans = new int[n - k + 1];\\n        \\n        for(int i = 0; i < k; i++)\\n          tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n        ans[0] = getMin(tmap, x);\\n\\n        for(int i = k; i < n; i++){\\n            tmap.put(nums[i], tmap.getOrDefault(nums[i], 0) + 1);\\n            tmap.put(nums[i - k], tmap.getOrDefault(nums[i - k], 0) - 1);\\n\\n            if(tmap.get(nums[i - k]) == 0)\\n               tmap.remove(nums[i - k]);\\n\\n            ans[i - k + 1] = getMin(tmap, x);\\n        }\\n        \\n        return ans;\\n    }\\n\\n    public int getMin(TreeMap<Integer, Integer> tmap, int x){\\n        int sma = 0;\\n        for(Integer val : tmap.keySet()){\\n            if(val < 0) \\n               sma += tmap.get(val);\\n            else return 0;\\n\\n            if(sma >= x) \\n               return val;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458923,
                "title": "java-freq-count-o-n-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution is based on constraints where we violate the nums[i] >= -50 and <= 50\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse frequency of numbers and traverse the constant 50-100 numbers and find the xth number from the freq array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(N*100)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n            \\n            int i = 0;\\n            int n = nums.length;\\n            int[] ans = new int[n-k+1];\\n            int st = 0;\\n\\n\\n            int[] map = new int[200];\\n\\n\\n            while(i<k-1)\\n                map[nums[i++]+50]++;\\n            int j = 0;\\n            while(i<n){\\n                map[nums[i++]+50]++;\\n                ans[j++] = getRes(map, x);\\n                map[nums[st++]+50]--;\\n\\n            }\\n            return ans;\\n    }\\n\\n    public int getRes(int[] m, int x){\\n        int i = 0;\\n        while(x>0 & i < 101){\\n            int j = m[i];\\n            x = Math.max(0, x-j);\\n            if(x > 0)\\n            i++;\\n        }\\n        // System.out.println(i);\\n        return i-50 < 0 ? i-50 : 0; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458671,
                "title": "easy-to-understand-using-sliding-window-and-map-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each window search the xth min by maintaining a map and running a\\nloop from -50 to 0 as the num value is mentioned in constraints\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i = -50; i <= 50; i++)\\n        map.put(i, 0);\\n\\n        int start = 0;\\n        int end = 0;\\n        int [] res = new int[nums.length - k + 1];\\n        int idx = 0;\\n        while(end < nums.length)\\n        {\\n            if(nums[end] < 0)\\n            map.put(nums[end], map.getOrDefault(nums[end], 0) + 1);\\n            end++;\\n            if(end - start == k)\\n            {\\n               res[idx++] = findXMin(map, x);\\n               map.put(nums[start], map.get(nums[start]) - 1);\\n               start++;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findXMin(HashMap<Integer,Integer> map, int x)\\n    {\\n        int xthMin = 0;\\n        for(int i = -50; i <= 0; i++)\\n        {\\n            if(map.get(i) > 0)\\n            xthMin+= map.get(i);\\n\\n            if(xthMin >= x)\\n            return i;\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458670,
                "title": "c-solution-simple-counting-simple-and-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    vector<int>getSubarrayBeauty(vector<int>&nums,int k,int x){\\n        vector<int>dp(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k;i++)\\n            dp[nums[i]+50]+=1;\\n        int cnt=0;\\n        for(int j=0;j<=50;j++){\\n            cnt+=dp[j];\\n            if(cnt>=x){\\n                res.push_back(j-50);\\n                break;\\n            }\\n        }\\n        if(cnt<x)\\n            res.push_back(0);\\n        \\n        for(int i=k;i<nums.size();i++){\\n            cnt=0;\\n            dp[nums[i]+50]+=1;\\n            dp[nums[i-k]+50]-=1;\\n            for(int j=0;j<=50;j++){\\n                cnt+=dp[j];\\n                if(cnt>=x){\\n                    res.push_back(j-50);\\n                    break;\\n                }\\n            }\\n            if(cnt<x)\\n                res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3458438,
                "title": "faster-than-99-97-maintain-a-histogram-of-seen-negative-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKeep `cnt[i]` number of times `-i` is in the window\\n`n` number of negatives in the window\\nfirst init the window, `cnt` and `n` wih the first loop over k elements. Then keep updating the window by removing the leftmost element `nums[i-k]` and adding an element to the ritht: `nums[i]`.\\n\\nThe x^th element is found each time by going over the histogram and accounting for up to `x` first elements found.\\nThis could be improved, by maintaining the x^th element and checking if the new element is lower or higher-or-equel than it, but since my solution is the fastest, no one did so.\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        cnt = [0] * 51\\n        n = 0\\n        for i in range(k):\\n            if nums[i] < 0:\\n                n += 1\\n                cnt[-nums[i]] += 1\\n        if n < x:\\n            ret = [0]\\n        else:\\n            j = x\\n            for i in range(50,0,-1):\\n                j -= cnt[i]\\n                if j <= 0:\\n                    ret = [-i]\\n                    break\\n        for i in range(k, len(nums)):\\n            if nums[i-k] < 0:\\n                cnt[-nums[i-k]] -= 1\\n                n -= 1\\n            if nums[i] < 0:\\n                cnt[-nums[i]] += 1\\n                n += 1\\n            if n < x:\\n                ret.append(0)\\n            else:\\n                j = x\\n                for i in range(50,0,-1):\\n                    j -= cnt[i]\\n                    if j <= 0:\\n                        ret.append(-i)\\n                        break\\n        return ret\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457425,
                "title": "c-ordered-set-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#include <ext/pb_ds/assoc_container.hpp>\\n#include <ext/pb_ds/tree_policy.hpp>\\nusing namespace __gnu_pbds;\\n\\n\\n#define ordered_set tree<int, null_type,less_equal<int>, rb_tree_tag,tree_order_statistics_node_update>\\n\\nclass Solution {\\npublic:\\n    void myerase(ordered_set &t, int v){\\n        int rank = t.order_of_key(v);\\n        ordered_set::iterator it = t.find_by_order(rank);\\n        t.erase(it);\\n        }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        vector<int> v;\\n        ordered_set o_set;\\n        for (int i = 0; i < k; i++)\\n        {\\n            o_set.insert(nums[i]);\\n        }\\n        int tp = *(o_set.find_by_order(x-1));\\n        if(tp<0) v.push_back(tp);\\n        else v.push_back(0);\\n        int ct = 0;\\n        for (int i = k; i < nums.size(); i++)\\n        {\\n            // auto it1 = o_set.find(nums[ct]);\\n            myerase(o_set, nums[ct]);\\n            o_set.insert(nums[i]);\\n            int tp1 = *(o_set.find_by_order(x-1));\\n            if(tp1<0) v.push_back(tp1);\\n            else v.push_back(0);\\n            ct++;\\n\\n        }\\n        \\n        \\n        return v;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3457215,
                "title": "easy-c-solution-using-two-array-with-0-n-time-ans-constant-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntwo array for sort using hashing and sliding window\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int neg[51]={0},pos[51]={0};\\n        int i=0,j=0;\\n        while(i<k-1)\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n        }\\n          vector<int>  ans;\\n      \\n        while(i<nums.size())\\n        {\\n            if(nums[i]<0)\\n            neg[-nums[i]]++;\\n            else\\n            pos[nums[i]]++;\\n            i++;\\n                int cnt=x;\\n          bool no=true;\\n           for(int l=50;l>0;l--)\\n           {\\n             if(neg[l]>0)\\n             {\\n                 cnt-=neg[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(-l);\\n                 no=false;\\n                 break;\\n             }\\n           }\\n           if(no==true)\\n              {\\n                    for(int l=0;l<=50;l++)\\n           {\\n             if(pos[l]>0)\\n             {\\n                 cnt-=pos[l];\\n             }\\n             if(cnt<=0)\\n             {\\n                 ans.push_back(0);\\n                 break;\\n             }\\n           }\\n              }\\n              else\\n              no= false;\\n               if(nums[j]<0)\\n            neg[-nums[j]]--;\\n            else\\n            pos[nums[j]]--;\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457062,
                "title": "brute-force-c-solution-without-using-stl-with-93-memory-beats",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> v1(101,0);\\n        vector<int> v2(nums.size()-k+1);\\n        int idx=0,c=0,t=0;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            v1[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            v1[nums[i]+50]++;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c+=v1[j];\\n                if(x<=c)\\n                {\\n                    t=j-50;\\n                    if(t>0)\\n                    {\\n                        v2[idx++]=0;\\n                        break;\\n                    }\\n                    else\\n                    {\\n                        v2[idx++]=t;\\n                        break;\\n                    }\\n                \\n                }\\n            }\\n            c=0;\\n            v1[nums[i-k+1]+50]--;\\n        }\\n        return v2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456713,
                "title": "c-ordered-map-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(map<int,int> mp,int x){\\n        int smallest=0;\\n        for(auto it : mp){\\n        \\n            if(it.first<0){\\n                smallest+=it.second;\\n            }\\n            else return 0;\\n            \\n            if(smallest>=x){\\n            \\n                return it.first;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        long long int n=nums.size();\\n       \\n        map<int,int> mp;\\n        vector<int> ans;\\n       \\n        for(int i=0;i<k-1;i++) mp[nums[i]]++;\\n        \\n        for(int j=k-1;j<n;j++){\\n             \\n                mp[nums[j]]++;\\n             \\n               ans.push_back(findMin(mp,x));\\n           \\n            \\n               mp[nums[j-k+1]]--;\\n        \\n                \\n            }\\n      return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456282,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int getXthSmallest(unordered_map<int, int>& freq, int x) {\\n    int tot = 0;\\n    for (int i = -50; i < 0; ++i) {\\n      tot += freq[i];\\n      if (tot >= x) return i;\\n    }\\n    return 0;\\n  }\\n  \\n  vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n    int n = nums.size();\\n    vector<int> ans;\\n    unordered_map<int, int> freq;\\n    for (int i = 0; i < k; ++i) {\\n      freq[nums[i]]++;\\n    }\\n    ans.push_back(getXthSmallest(freq, x));\\n    for (int i = 1; i <= (n - k); ++i) {\\n      freq[nums[i - 1]]--;\\n      freq[nums[i + k - 1]]++;\\n      ans.push_back(getXthSmallest(freq, x));\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456059,
                "title": "short-easy-c-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        vector<int> cnt(51, 0), res(n - k + 1);\\n        for(int i = 0; i < n; i++) {\\n            if(nums[i] <= 0) cnt[-nums[i]]++;\\n            if(i - k >= 0 && nums[i - k] < 0) cnt[-nums[i - k]]--;\\n            int t = 0;\\n            for(int j = 50; j >= 0 && i >= k - 1; j--) {\\n                t += cnt[j];\\n                if(t >= x) {\\n                    res[i - k + 1] = -j;\\n                    break;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455999,
                "title": "c-solution-count-negative-numbers-sliding-window-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        SortedDictionary<int, int> negFreqMap = new();\\n        int[] res = new int[nums.Length - k + 1];\\n\\n        for(int i=-50; i<0; i++){\\n            negFreqMap.Add(i, 0);\\n        }\\n\\n        for(int i=0; i<k; i++){\\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        for(int i=k; i<nums.Length; i++){\\n            res[i-k] = GetXthSmallest(negFreqMap, x);\\n\\n            if(nums[i-k] < 0){\\n                negFreqMap[nums[i-k]]--;\\n            }\\n            \\n            if(nums[i] < 0){\\n                negFreqMap[nums[i]]++;\\n            }\\n        }\\n\\n        res[nums.Length - k] = GetXthSmallest(negFreqMap, x);\\n\\n        return res;\\n    }\\n\\n    private int GetXthSmallest(SortedDictionary<int, int> negFreqMap, int x){\\n        foreach(var kvp in negFreqMap){\\n            x -= kvp.Value;\\n\\n            if(x<=0){\\n                return kvp.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455753,
                "title": "sliding-window-map-commented",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        map<int, int> mapp;\\n        vector<int> out;\\n        int ws=0;\\n        for(int we=ws; we<n; we++) {\\n            // we can use the freq of elements in ordered-map to find xth smallest element\\n            mapp[nums[we]]++;\\n            if(we >= k-1) { //if window size(k) hits\\n                int elements=0;\\n                for(auto i: mapp) {\\n                    elements+=i.second;\\n                    if(elements >= x) { // we are at xth smallest\\n                        out.push_back(min(0, i.first)); //if xth element is positive, push 0\\n                        break;\\n                    }\\n                }\\n                mapp[nums[ws]]--;\\n                ws++;\\n            }\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455665,
                "title": "c-using-sorteddictionary-as-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMaintain sliding windows with **SortedDictionary** data structure. \\nDictionary:\\n* Key = num\\n* Value = count of occurence. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAlso has *GetValueForXth* helper function to identify Xth pos of negative numbers in **SortedDictionary**\\n\\n# Complexity\\n- Time complexity:$$O(nlog(k))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(k)$$, SortedDictionary size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 2165 ms\\n- Memory: 65 MB\\n\\n# Code\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\\n\\n# Aproach #2 with array counter much faster\\n# Complexity\\n- Time complexity:$$O(n*50))$$, where N = nums size\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: additional $$O(50)$$, counter size\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n- Runtime: 487 ms\\n- Memory: 57.6 MB\\n\\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        var sorted = new SortedDictionary<int, int>();\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0) {\\n                int prev = nums[i - k];\\n                sorted[prev]--;\\n                if (sorted[prev] == 0) {\\n                    sorted.Remove(prev);\\n                }\\n            }\\n\\n            sorted.TryAdd(nums[i], 0);\\n            sorted[nums[i]]++;\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            res[i - k + 1] = Math.Min(0, GetValueForXth(sorted, x));\\n        }\\n\\n        return res;\\n    }\\n\\n    public int GetValueForXth(SortedDictionary<int, int> sortedMap, int x) {\\n        int count = 0;\\n\\n        foreach (var kv in sortedMap) {\\n            count += kv.Value;\\n            if (count >= x) {\\n\\n                return kv.Key;\\n            }\\n        }\\n\\n        return 0;\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x) {\\n        int N = nums.Length;\\n        var res = new int[N - k + 1];\\n        int[] counter = new int[50];\\n\\n        for (int i = 0; i < N; i++) {\\n            if (i - k >= 0 && nums[i - k] < 0) {\\n                counter[nums[i - k] + 50]--;\\n            }\\n\\n            if (nums[i] < 0) {\\n                counter[nums[i] + 50]++;\\n            }\\n\\n            if (i - k + 1 < 0) continue;\\n\\n            for (int j = 0, count = 0; j < 50; j++) {\\n                count += counter[j];\\n                if (count >= x) {\\n                    res[i - k + 1] = j - 50;\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455222,
                "title": "o-n-50",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        c= [0]*51\\n        temp = nums[:k]\\n        l=len(nums)\\n        \\n        for neg in temp:\\n            if neg<0:\\n                c[-neg]+=1\\n        ans=[]\\n        sum_=0\\n        for j in range(50,-1,-1):\\n            sum_+=c[j]\\n            if sum_>=x:\\n                ans.append(-j)\\n                break\\n        if sum_ < x:\\n            ans.append(0)\\n        t=0\\n        for i in range(k,l):\\n            sum_=0\\n            if nums[t]<0:\\n                c[-nums[t]]-=1\\n            t+=1\\n            if nums[i]<0:\\n                c[-nums[i]]+=1\\n            for j in range(50,-1,-1):\\n                sum_+=c[j]\\n                if sum_>=x:\\n                    ans.append(-j)\\n                    break\\n            if sum_<x:\\n                ans.append(0)\\n        return ans\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454911,
                "title": "segment-tree-with-sliding-window",
                "content": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\n    ll offset=52;\\n    vector<ll> st;\\npublic:\\n    void update(ll tind,ll tl,ll tr,ll ind,ll val){\\n        if(tl>tr)\\n            return;\\n        if(tl==tr){\\n            st[tind]+=val;\\n            return;\\n        }\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        if(tm>=ind)\\n            update(left,tl,tm,ind,val);\\n        else\\n            update(left+1,tm+1,tr,ind,val);\\n        st[tind]=st[left]+st[left|1];\\n    }\\n    \\n    ll findSum(ll tind,ll tl,ll tr,ll ql,ll qr){\\n        if(tl>tr or ql>tr or qr<ql or qr<tl)\\n            return 0;\\n        if(tl>=ql and tr<=qr)\\n            return st[tind];\\n        ll tm=tl+((tr-tl)>>1),left=tind<<1;\\n        return findSum(left,tl,tm,ql,qr)+findSum(left|1,tm+1,tr,ql,qr);\\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) {\\n        ll n=a.size();\\n        vector<int> f;\\n        st.resize(550,0);\\n        \\n        for(ll i=0;i<n;i++){\\n            update(1,1,110,a[i]+offset,1);\\n            if(i>=k)\\n                update(1,1,110,a[i-k]+offset,-1);\\n            if(i>=(k-1)){\\n                int l=1,r=110,ans=0;\\n                while(l<=r){\\n                    ll m=l+((r-l)>>1);\\n                    ll s=findSum(1,1,110,1,m);\\n                    if(s>=x){\\n                        if(m<offset)\\n                            ans=m-offset;\\n                        r=m-1;\\n                    }\\n                    else\\n                        l=m+1;\\n                }\\n                f.push_back(ans);\\n            }\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454308,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& a, int k, int x) \\n    {\\n        int len = a.size()-k+1;\\n        map <int,int> mp;\\n        vector <int> v;\\n        for (int i = 0, j = 0; i < a.size(); i++) \\n        {\\n            mp[a[i]]++;\\n            int sm = 0;\\n            if (i-j+1 == k)\\n            {\\n                for (auto it : mp)\\n                {\\n                    sm += it.second;\\n                    if (sm >= x) \\n                    {\\n                        v.push_back(min(0,it.first));\\n                        break;\\n                    }\\n                }\\n                mp[a[j]]--;\\n                j++;\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454152,
                "title": "cpp-code-without-using-stl-s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n=nums.size();\\n        vector<int>ans(n-k+1,0),counter(51, 0);\\n    \\n\\n        for(int i=0;i<k-1;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++;\\n        }\\n        int index=0;\\n        for(int i=k-1;i<n;i++)\\n        {\\n            if(nums[i]<0) \\n            counter[abs(nums[i])]++; \\n            int count=0;\\n            for(int j=50;j>0;j--)\\n            {\\n                count+=counter[j];\\n                if(count>=x)\\n                {\\n                    ans[index]=-1*(j); \\n                    break;\\n                }\\n            }\\n            if(nums[i-k+1]<0)\\n            {\\n                counter[abs(nums[i-k+1])]--;\\n            }\\n            index++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453989,
                "title": "easy-c-solution-without-stl",
                "content": "\\n# Complexity\\n- Time complexity :O(n*100)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int>a(101,0);\\n        vector<int>res;\\n        for(int i=0;i<k-1;i++)\\n        {\\n            a[nums[i]+50]++;\\n        }\\n        for(int i=k-1;i<nums.size();i++)\\n        {\\n            a[nums[i]+50]++;\\n            int c=0,mi;\\n            for(int j=0;j<=100;j++)\\n            {\\n                c=c+a[j];\\n                if(c>=x)\\n                {\\n                    mi=min(0,j-50);\\n                    res.push_back(mi);\\n                    break;\\n                }\\n            }\\n            a[nums[i-k+1]+50]--;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453978,
                "title": "using-sortedlist",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        final=[0]*(len(nums)-k+1)\\n        j=0\\n        n=len(nums)\\n        ans=SortedList()\\n        print(ans)\\n        for i,a in enumerate(nums):\\n            ans.add(a)\\n            if(i>=k):\\n                ans.remove(nums[i-k])\\n            if(i>=k-1):\\n                if(ans[x-1]<0):\\n                    final[j]=ans[x-1]\\n                j+=1\\n        return final\\n    \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453254,
                "title": "c-map-sliding-window-easy-to-understand-clean-code-tc-sc-explained",
                "content": "# Intuition\\nSimple case of sliding window.\\n\\n# Complexity\\n- Time complexity:\\nO(10^5 * 100 * log 100) ~= O(2 * 10^7) at worst case because there can be 100 different numbers in the hashmap\\n\\n- Space complexity:\\nO(100) for the hashmap that we have used in this solution because numbers can range from -50 to 50.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int func(map<int,int>&mp, int x){\\n        for(auto e: mp){\\n            if(e.second<x){\\n                x-=e.second;\\n            }\\n            else{\\n                if(e.first>0){\\n                    return 0;\\n                }\\n\\n                else{\\n                    return e.first;\\n                }\\n            }\\n        }\\n\\n        return 0;\\n    }\\n\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int>ans(nums.size()-k+1);\\n        map<int,int>mp;\\n        int i =0, j = 0;\\n\\n        while(j<nums.size()){\\n            mp[nums[j]]++;\\n\\n            if(j-i+1==k){\\n                ans[j-k+1] = func(mp,x);\\n                mp[nums[i]]--;\\n                if(mp[nums[i]]==0){\\n                    mp.erase(nums[i]);\\n                }\\n                i++;\\n            }\\n\\n            j++;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451879,
                "title": "c-simple-sliding-window-counting-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSliding Window + Counting\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int n = nums.size();\\n        int left = 0;\\n        int right = 0;\\n        map<int,int> freq;\\n        vector<int> res; \\n        while(right<n){\\n            freq[nums[right]]++;\\n            if(right>=k-1){\\n                //maintain window\\n                if(right-left+1>k){\\n                    freq[nums[left]]--;\\n                    if(freq[nums[left]]==0){\\n                        freq.erase(nums[left]);\\n                    }\\n                    left++;\\n                }\\n                int ret = helper(freq, x);\\n                res.push_back(ret);\\n            }\\n            right++;\\n        }\\n        return res;\\n    }\\n\\n\\n    int helper(map<int,int>& freq, int x){\\n        int count = 0;\\n\\n        for(auto iter:freq){\\n            if(iter.first>=0){\\n                break;\\n            }\\n            count+=iter.second;\\n            if(count>=x){\\n                return iter.first;\\n            }\\n        }\\n        return 0;\\n\\n\\n    }\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451755,
                "title": "java-treemap-ordered-map",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans= new int[nums.length-k+1];\\n        TreeMap<Integer, Integer> map= new TreeMap<>();\\n        int count=0;\\n        int ind=0;\\n        int si=0;\\n        int i=0;\\n        for(;i<nums.length;i++)\\n        {\\n             if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {   ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                si++;\\n                count--;\\n            }\\n            if(count<k)\\n            {\\n                if(nums[i]<=0)\\n                {\\n                if(!map.containsKey(nums[i]))\\n                {\\n                    map.put(nums[i],1);\\n                }\\n                else{\\n                    map.put(nums[i],map.get(nums[i])+1);\\n                }\\n                }\\n                count++;\\n            }\\n           \\n        }\\n        if(count==k)\\n            {\\n                int sum=0;\\n                for (Map.Entry<Integer, Integer> entry : map.entrySet())\\n                {\\n                    sum=sum+entry.getValue();\\n                    if(sum>=x)\\n                    {\\n                        ans[ind]=entry.getKey();\\n                        ind++;\\n                        break;\\n                    }\\n                }\\n                if(sum<x) \\n                {\\n                    ans[ind]=0;\\n                    ind++;\\n                }\\n\\n                if(nums[si]<=0)\\n                {\\n                    if(map.get(nums[si])==1) map.remove(nums[si]);\\n                    else map.put(nums[si],map.get(nums[si])-1);\\n                }\\n                \\n                si++;\\n                count--;\\n            }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451678,
                "title": "using-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int st = 0;\\n        int n = nums.length;\\n        int []res = new int[n - k + 1];\\n        int freq[] = new int[51];\\n        int itr = 0;\\n        for(int i = 0; i < n ;i++){\\n            int ele = -1 * nums[i];\\n            if(ele > 0){\\n                freq[ele]++;\\n            }\\n            if(i >= k - 1){\\n                int cnt = x;\\n                boolean flag = false;\\n                for(int j = 50; j >= 1; j--){\\n                    if(freq[j] > 0){\\n                        cnt -= freq[j];\\n                        if(cnt <= 0){\\n                            flag = true;\\n                            res[itr++] = -j;\\n                            int stEle = -1 * nums[st];\\n                            if(stEle > 0){\\n                                freq[stEle]--;\\n                            }\\n                            st++;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if(flag == false){\\n                    res[itr++] = 0;\\n                    int stEle = -1 * nums[st];\\n                    if(stEle > 0){\\n                        freq[stEle]--;\\n                    }\\n                    st++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451198,
                "title": "intuitive-simulation-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    int smallx(const vector<int>& sub, int x) {\\n        int acc = 0;\\n        for (int i = 0; i <= 50; ++i) {\\n            acc += sub[i];\\n            if (acc >= x) return i - 50;\\n        }\\n        return 0;\\n    }\\n\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> sub(101);\\n        for (int i = 0; i < k - 1; ++i) {\\n            sub[nums[i] + 50]++;\\n        }\\n\\n        vector<int> res;\\n        for (int i = k - 1; i < nums.size(); ++i) {\\n            sub[nums[i] + 50]++;\\n            res.push_back(smallx(sub, x));\\n            sub[nums[i - k + 1] + 50]--;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451161,
                "title": "100-faster-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[]res = new int[n-k+1];\\n        int[]arr = new int[101];\\n        for(int i = 0;i<n;i++){\\n            arr[nums[i]+50]++;\\n            if(i>=(k-1)){\\n                int t = x;\\n                for(int j = 0;j<=100;j++){ // just created an array of\\n                // 100 numbers and each index storing frq of ith number (offset is 50 because nums\\n                // can be negetive also) . now just iterate and find x largest in each window \\n                    if(t-arr[j] <=0){\\n                        res[i-(k-1)] = j-50;\\n                        if(j>=50) res[i-(k-1)] = 0;\\n                        break;\\n                    }\\n                    t-=arr[j];\\n                }\\n                arr[nums[i-(k-1)]+50]--;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451056,
                "title": "c-use-two-multiset-set",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBorrow the idea from finding the median of the stream, we use the two muliset to store the sliding window, and make sure the begin of the second multiset is the xth smallest value.\\n\\nIn order to handle the multiple value, we use the multiset instead of the set.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe key point is that we need to make sure the size of the s1 is equal or less than x - 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        multiset<int> s1, s2; \\n        int n = nums.size(), j = 0;\\n        vector<int> ans;\\n        for(int i=0; i<n; i++) {\\n            s1.insert(nums[i]);\\n            if(s1.size() >= x) {\\n                auto tmp = (--s1.end());\\n                s2.insert(*tmp);\\n                s1.erase(tmp);\\n            }\\n            if(s1.size() + s2.size() > k) {\\n                if(s1.find(nums[j]) != s1.end()) {\\n                    s1.erase(s1.find(nums[j++]));\\n                    auto tmp = s2.begin();\\n                    s1.insert(*tmp);\\n                    s2.erase(tmp);\\n                } else \\n                    s2.erase(s2.find(nums[j++]));\\n            }\\n            \\n            if(i >= k - 1) {\\n                int be = *(s2.begin());\\n                ans.push_back(be >= 0 ? 0 : be);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n\\n\\n/*\\n[-3,1,2,-3,0,-3]\\n2\\n1\\n\\ns1 -3\\n\\n\\n\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450916,
                "title": "simple-c-counting",
                "content": "# Intuition\\nThe big hint in this problem is in the bounds  ```-50 <= nums[i] <= 50```. Here we know that we can simply hold an array of length 101 that represents the possible numbers seen in the array nums (-50, -49, ... , -1, 0, 1, ... 49, 50). \\n# Approach\\nSimilarly to how some sorting functions can achieve O(n) time given some bounds on the values to be sorted (ie. our ```-50 <= nums[i] <= 50```) we can simply hold the counts of numbers seen and find the x^th smallest number as we go. \\n\\nNote: helper functions were used to keep code concise\\n\\n# getSubarrayBeauty Algorithm:\\n- First initialize an array (in my code arr) that simple holds the values seen so far in nums. Its size is 101 since there are only 101 unique values in nums. This array holds the counts of each unique number seen. \\n\\n- Initialize a vector (in my code list), this is where we will house our solutions. \\n\\n- Loop through nums\\n    - add the number to arr\\n    - if we have seen k numbers then we can find the xth smallest\\n    - add the xth smallest to the list\\n    - remove the number at the back of the sliding window\\n- Make sure to set all positive x^th smallest numbers to 0\\n- Return list\\n\\n# getXthSmallest Algorithm:\\n- Loop through arr\\n    - if there is an element seen at the index i\\n    - Check if x - arr[i] is negative, if so then we have found x^th smallest\\n    - else, update x and continue to the next number in arr\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int arr[101] = {0};\\n        vector<int> list;\\n        for(int i=0; i<nums.size(); i++) {\\n            addNum(nums[i], arr);\\n            if(i + 1 - k >= 0) {\\n                list.push_back(getXthSmallest(x, arr));\\n                removeNum(nums[i - k + 1], arr);\\n            }\\n        }\\n        for(int i=0; i<list.size(); i++) {\\n            if(list[i] > 0) {\\n                list[i] = 0;\\n            }\\n        }\\n        return list;\\n    }\\n    \\n    private:\\n        void addNum(int num, int arr[101]) {\\n            arr[num + 50]++;\\n        }\\n    \\n    private: \\n        void removeNum(int num, int arr[101]) {\\n            arr[num + 50]--;\\n        }\\n    \\n    private: \\n        int getXthSmallest(int x, int arr[101]) {\\n            for(int i=0; i<101; i++) {\\n                if(arr[i] != 0) {\\n                    int temp = x - arr[i];\\n                    if(temp <= 0) {\\n                        return i - 50;\\n                    } else {\\n                        x = x - arr[i];\\n                    }\\n                }\\n            }\\n            return 0;\\n        }  \\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "```-50 <= nums[i] <= 50```\n```-50 <= nums[i] <= 50```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450842,
                "title": "java-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) \\n    {\\n        int n = nums.length;\\n        int[] count = new int[50];\\n        for(int i = 0; i<k; i++)\\n        {\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]++;\\n            }\\n        }\\n        int[] ans = new int[n-k+1];\\n        int j = k;\\n        for(int i = 0; i<n && j<=n; i++, j++)\\n        {\\n            int sum = 0;\\n            boolean flag = false;\\n            for(int m = 0; m < 50; m++)\\n            {\\n                sum += count[m];\\n                if(sum >= x)\\n                {\\n                    ans[i] = m - 50;\\n                    flag = true;\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                ans[i] = 0;\\n            }\\n            if(nums[i] < 0)\\n            {\\n                count[nums[i] + 50]--;\\n            }\\n            if(j<n && nums[j] < 0)\\n            {\\n                count[nums[j] + 50]++;\\n            }\\n        }    \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450771,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n      var map=new TreeMap<Integer,Integer>();\\n      int n=nums.length,res=0;\\n      var result=new int[n-k+1];\\n      for(int i=0;i<n;i++){\\n          map.put(nums[i],map.getOrDefault(nums[i],0)+1);\\n          int out=i-k<0?Integer.MAX_VALUE:nums[i-k];\\n          map.put(out,map.getOrDefault(out,0)-1);\\n          if(i>=k-1){\\n              result[res++]=getsnum(map,x);\\n          }\\n      }return result;\\n    } \\n    private int getsnum(TreeMap<Integer,Integer>map,int x){\\n        int run=0;\\n        for(var entry:map.entrySet()){\\n            int key=entry.getKey();\\n            int val=entry.getValue();\\n            if(key<0){\\n                run+=val;\\n            }\\n            if(run>=x)return key;\\n\\n        }return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450680,
                "title": "very-easy-optimized-solution-using-frequency-array",
                "content": "# Complexity\\n- Time complexity: O(n*50)\\n\\n# Code\\n```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nO(n*50)\\n  int getElement(vector<int>& neg, int x){\\n        int i;\\n        int count=0;\\n        for(int i=50; i>=0; i--){\\n            count+=neg[i];\\n            if(count>=x)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        vector<int> neg(51,0);\\n        int i=0, j=0;\\n        int n=nums.size();\\n        vector<int> ans;\\n        while(j<n){\\n            //Calculation\\n            if(nums[j]<0)   neg[abs(nums[j])]++;\\n\\n\\n            //if window size is less than k\\n            if(j-i+1<k){\\n                j++;\\n\\n\\n            //else if window size==k\\n            }else if(j-i+1==k){\\n                int res = getElement(neg, x);\\n                ans.push_back(res);\\n                if(nums[i]<0){\\n                    neg[abs(nums[i])]--;\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3450622,
                "title": "beats-100-runtime-as-of-24mar2023-38ms-sliding-windows-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince normal approach even using the priority queue it was giving TLE, finally tried sliding window. Keep sliding the windows of k array. And find the xth smallest for the current windows of k element. We do not need to keep all elements of k windows instead just keep/manage negative elements. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. create windows queueu of all negative element in the first k index.\\n2. begin the loop of sliding windows.\\n3. in the loop first find the xth smallest as in the current window queue.\\n4. as a logical slide check if the left most element which is outgoing is a negative or not. If it is negative then decrease the frequency counter. This basically means that the number is removed from our calculations. Also similarly check the right most incoming number and if this is negative increment its frequency.\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(k*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] res = new int[nums.length-k+1];\\n\\t\\tint[] q = new int[50]; \\n        for(int i=0;i<k;i++) // for all the negative values of k windows count up the frequency: first window\\n            if(nums[i]<0)\\n                q[50+nums[i]]++;\\n        \\n       \\t\\t\\n\\t    for(int i=0;i<nums.length - k+1;i++){ // keep sliding the window\\n\\t    \\tres[i] = getXthSmallest(q,x); // in the current windows find the smallest xth value.\\n\\t    \\tif(i+k>nums.length-1) break; // as windows are sliding in next step check the over-run.\\n            //below is logical shift of window to right. \\n            if (nums[i]<0) //if the left most number is negative then it is being removed so update its frequency.\\n                q[50+nums[i]]--;\\n            if(nums[i+k]<0) // the new number coming in and if it is negative update its frequency.\\n                q[50+nums[i+k]]++;\\n        }\\n\\t    \\n        return res;\\n        \\n    }\\n    \\n    // to find the xth smallest by just going through the each index and adding its frequency.\\n    public int getXthSmallest(int[]q, int x){\\n        int count =0; \\n        int res = 0;\\n\\t\\tfor(int j=0;j<50;j++){\\n\\t\\t    count+=q[j];\\n\\t\\t\\tif(count>=x) {\\n                res = j - 50;\\n                break;\\n            }\\n        }\\n        return res;     \\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450606,
                "title": "commented-solution-with-time-complexityma",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\nstore the ele in map as in sorted form count the freq , calling the fun in order to find the xth smallest val nd now moving the window size by itrating from k\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:NlogN\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint funCall(map<int, int>&mp, int x){\\n    int cnt=0;\\n    for(auto it:mp){\\n        int val = it.first;\\n        if(val<0){\\n            cnt+=it.second;\\n        }\\n        else{\\n            return 0; //map is already sorted slo if not find return 0\\n        }\\n        if(cnt>=x){\\n            return val;\\n        }\\n    }\\n    return 0;\\n}\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        map<int, int>mp;\\n        int n = nums.size();\\n        vector<int>ans(n-k+1);//storing the ans req of size k \\n        for(int i= 0 ; i<k; i++){\\n            mp[nums[i]]++;//storing the freq \\n        }\\n        ans[0]= funCall(mp, x);//findng the x smallest val\\n        for(int i = k ; i <n ; i++){\\n            mp[nums[i]]++;\\n            mp[nums[i-k]]--;//revoing the first ele from window\\n            if(mp[nums[i-k]]==0){\\n                mp.erase(nums[i-k]);\\n            }\\n            ans[i-k+1]= funCall(mp,x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450541,
                "title": "c-tc-0-n-50-frequency-array-fixed-size-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findMin(int a[],int n,int k){\\n        int i;\\n        int count=0;\\n        for(int i=50;i>=0;i--){\\n            count+=a[i];\\n            if(count>=k)\\n                return i*-1;\\n        }\\n        return 0;\\n    }\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        int a[51];\\n        memset(a,0,sizeof(a));\\n        vector<int>ans;\\n        for(int i=0;i<k;i++){\\n            if(nums[i]<0)a[nums[i]*-1]++;\\n        }\\n        ans.push_back(findMin(a,51,x));\\n        int n=nums.size();\\n        int start=0,end=k;\\n        while(end<n){\\n            if(nums[start]<0){\\n                if(a[nums[start]*-1]>0)\\n                    a[nums[start]*-1]--;\\n            }\\n            start++;\\n            if(nums[end]<0)\\n                a[nums[end]*-1]++;\\n            end++;\\n            ans.push_back(findMin(a,51,x));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450416,
                "title": "kotlin-accepted",
                "content": "# Intuition\\nIt turns out that limits on the size of array elements are important. A completely different approach to subarray analysis.\\n\\n# Approach\\nWindow shift + frequency.\\n\\n# Complexity\\n- Time complexity:\\nO(n(101))\\n\\n- Space complexity:\\nO(n(101))\\n\\n# Code\\n```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun getSubarrayBeauty(nums: IntArray, k: Int, x: Int): IntArray {\\n        val Counts: Array<Int> = Array(101, {0})\\n        var nn_zam = 0\\n        var sum = 0\\n        var len = nums.size\\n        var rez: Array<Int> = Array(len-k+1, {0})\\n\\n        nn_zam = nums[0]\\n        for (j in 0..k-1) {\\n            Counts[nums[j]+50] +=1\\n        }\\n        \\n        sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n        for (i in 0..49) {\\n            if (Counts[i] == 0) continue\\n            sum += Counts[i] \\n            if (sum>=x) {\\n                rez[0] = i-50\\n                break\\n            }\\n        }\\n        if (k == len) return rez.toIntArray()\\n        for (j in 1..len-k) {\\n            Counts[nn_zam+50] -=1\\n            Counts[nums[j+k-1]+50] +=1\\n            sum = 0\\n        // \\u043F\\u043E\\u043A\\u0430 sum < x\\n            for (i in 0..49) {\\n                if (Counts[i] == 0) continue\\n                sum += Counts[i] \\n                if (sum>=x) {\\n                    rez[j] = i-50\\n                    break\\n                }\\n            }\\n            nn_zam = nums[j]\\n        }\\n        return rez.toIntArray()\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450151,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhash negative elements\\n\\n# Complexity\\n- Time complexity:`O(n * 50) = O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:`O(n)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) {\\n        \\n        // size of input array\\n        int n = nums.size();\\n\\n        vector<int>freq(51,0); // store frequecies of negative elements\\n        vector<int>result;     // resultant vector\\n\\n        // some variables\\n        int i = 0 , j = 0;\\n        \\n        // traverse input array\\n        while(j < n){\\n            \\n            // hash only negatives\\n            if(nums[j] < 0) freq[nums[j]*(-1)]++; \\n\\n            // subarray size is less than k\\n            if(j - i + 1 < k) j++;\\n            else if(j - i + 1 == k){  // k size subarray is fixed\\n\\n                // for counting negatives & store possible candidate\\n                int cnt = 0 , negative = 0;\\n\\n                // traverse from back to get xth smallest negative\\n                for(int i=50;i>=1;i--){\\n                    \\n                    // if we have x negatives in subarray it will automatically update negative.. otherwise it will remain 0\\n                    if(freq[i] && cnt < x){\\n                        cnt += freq[i];\\n                        if(cnt >= x) negative = i * (-1); \\n                    }\\n\\n                }\\n\\n                // add negative or 0 in result\\n                result.push_back(negative);\\n\\n                // if first element of subarray is negative then remove it from subarray & hash it\\'s value\\n                if(nums[i] < 0) freq[nums[i]*(-1)]--;\\n\\n                // update the subarray\\n                i++; j++;\\n            }\\n        }\\n        // result \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450069,
                "title": "o-n-solution",
                "content": "<!-- Describe your first thoughts on how to solve this problem. -->\\n<!-- Describe your approach to solving the problem. -->\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n        public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n         int[] res = new int[nums.length - k + 1];\\n        int[] track = new int[150];\\n        for (int i = 0; i < k; i++) {\\n            track[nums[i] + 50]++;\\n        }\\n        int xClone = x;\\n        for (int i = 0; i < 50; i++) {\\n            if (track[i] > 0) {\\n                if (xClone - track[i] <= 0) {\\n                    res[0] = i - 50;\\n                    xClone -= track[i];\\n                    break;\\n                } else {\\n                    xClone -= track[i];\\n                }\\n            }\\n        }\\n        if (xClone > 0)\\n            res[0] = 0;\\n        for (int i = 0; i < nums.length - k; i++) {\\n            track[nums[i] + 50]--;\\n            track[nums[i + k] + 50]++;\\n            int xClone2 = x;\\n            for (int j = 0; j < 50; j++) {\\n                if (track[j] > 0) {\\n                    if (xClone2 - track[j] <= 0) {\\n                        res[i + 1] = j - 50;\\n                        xClone2 -= track[j];\\n                        break;\\n                    } else {\\n                        xClone2 -= track[j];\\n                    }\\n                }\\n            }\\n            if (xClone2 > 0)\\n                res[i + 1] = 0;\\n        }\\n        return res;\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449950,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int[] GetSubarrayBeauty(int[] nums, int k, int x)\\n    {\\n        var n = nums.Length;\\n        var result = new int[n - k + 1];\\n        var negatives = new List<int>();\\n\\n        InitNegatives(negatives, nums, k);\\n\\n        negatives.Sort();\\n        result[0] = negatives.Count >= x ? negatives[x - 1] : 0;\\n\\n        for (var i = k; i < n; i++)\\n        {\\n            if (nums[i - k] < 0)\\n                negatives.Remove(nums[i - k]);\\n\\n            if (nums[i] < 0)\\n            {\\n                var index = negatives.BinarySearch(nums[i]);\\n\\n                if (index < 0)\\n                    index = ~index;\\n\\n                negatives.Insert(index, nums[i]);\\n            }\\n\\n            result[i - k + 1] = negatives.Count >= x ? negatives[x - 1] : 0;\\n        }\\n\\n        return result;\\n    }\\n\\n    private static void InitNegatives(List<int> negatives, int[] nums, int k)\\n    {\\n        for (var i = 0; i < k; i++)\\n            if (nums[i] < 0)\\n                negatives.Add(nums[i]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449712,
                "title": "java-javascript-sliding-window-with-counting-table-counting-sort",
                "content": "### Brute Force, O(n^2), TLE\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\\n\\n---\\n\\nIf you have done a similar problem before, you might immediately think of using maxHeap to maintain size == x to find the xth smallest integer.\\nHere is the list of problems that I have done before. \\n\\n(Medium)\\n[215. Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\\n[378.\\xA0Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\\n[2583.\\xA0Kth Largest Sum in a Binary Tree (Weekly Contest 335)](https://leetcode.com/problems/kth-largest-sum-in-a-binary-tree/)\\n\\n(Hard)\\n[295.\\xA0Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\\n\\nOf course, if you have more question lists about it, down below your question list is welcome.\\n\\n---\\n\\nOK, come back to the problem.\\n\\nIf we use the sliding window method together when we need to remove the left pointer of the window, we cannot efficiently find a specific number in the heap, which need O(n) time to find, we also get TLE result.\\n\\nHow can we solve this? We can discover the constraints and conditions, `-50 <= nums[i] <= 50`, the range of value is too small, then we can try to use the counting table to calculate the frequency of number in the current window.\\n\\n\\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\\n\\nThen, we don\\'t need to consider the positive number. So, just open the 51 sizes.\\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\\n\\nNow we can add and remove the number really efficiently, we only traverse the counting table to calculate xth smallest integer.\\n\\n---\\n### **Solution**\\n\\n#### Javascript\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n#### Java\\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n* Time : O(51n) --> O(n)\\n* Space : O(51)  --> O(1)",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Counting"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    const res = [];\\n    for(let i = 0; i <= n - k; i++){\\n        const list = [];\\n        for(let j = i; j - i + 1 <= k; j++){\\n            list.push(nums[j]);\\n        }\\n        list.sort((a, b) => a - b);\\n        res.push(list[x - 1] > 0 ? 0 : list[x - 1]);\\n    }\\n    return res;\\n};\\n\\n// 0 1 2 3 4 5\\n// X X X X X X\\n//   i     j\\n```\n```\\nindex   =      0   1   2 ... 49  50  51  52\\ncnt     =    [ 0,  0,  0,     0,  0,  0,  0 ]  => size == 101\\nnums[i] =>   -50 -49 -48 ... -1   0   1   2\\n```\n```\\nindex   =      0   1   2 ... 49  50\\ncnt     =    [ 0,  0,  0,     0,  0 ]  => size == 51\\nnums[i] =>   -50 -49 -48 ... -1   0\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} x\\n * @return {number[]}\\n */\\nvar getSubarrayBeauty = function(nums, k, x) {\\n    const n = nums.length;\\n    // Build counting table, we don\\'t need to consider the positive number.\\n    // So, just open the 51 sizes.\\n    const cnt = new Array(51).fill(0);  \\n    const res = [];\\n    let j = 0;\\n    for(let i = 0; i <= n - k; i++){\\n        // window size of k\\n        while(j < n && j - i + 1 <= k){\\n            if(nums[j] <= 0){\\n                cnt[nums[j] + 50]++;\\n            }\\n            j++;\\n        }\\n        \\n        // Search and calculate the number of xth smallest in the counting table, \\n        // If we found, add the current index key into the result.\\n        let numberOf = 0;\\n        for(let key = 0; key < 51; key++){\\n            numberOf += cnt[key];\\n            if(numberOf >= x || key === 50){\\n                res.push(key - 50); // Restore to the original number.\\n                break;\\n            }\\n        }\\n        \\n        // remove the left side\\'s number of the window.\\n        if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n    }\\n    return res;\\n};\\n```\n```\\nclass Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int n = nums.length;\\n        int[] cnt = new int[51];\\n        int[] res = new int[n - k + 1];\\n        int index = 0, j = 0;\\n        \\n        for(int i = 0; i <= n - k; i++){\\n            while(j < n && j - i + 1 <= k){\\n                if(nums[j] <= 0){\\n                    cnt[nums[j] + 50]++;\\n                }\\n                j++;\\n            }\\n            \\n            int numberOf = 0;\\n            for(int key = 0; key < 51; key++){\\n                numberOf += cnt[key];\\n                if(numberOf >= x || key == 50){\\n                    res[index++] = key - 50;\\n                    break;\\n                }\\n            }\\n            \\n            if(nums[i] <= 0) cnt[nums[i] + 50]--;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449690,
                "title": "python3-sliding-window-and-sorted-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        ans = []\\n        from sortedcontainers import SortedList\\n        # created a sorted list , with first k elements from nums\\n        s=SortedList()\\n        for i in range(k):\\n            s.add(nums[i])\\n\\n        # append xth smallest number to ans if it is negative, else append 0\\n        # using x-1 since zero based index\\n        if s[x-1] < 0:\\n            ans.append(s[x-1])\\n        else:\\n            ans.append(0)\\n        \\n        # right shift our sliding window by,\\n        # 1. remove nums[i-k] \\n        # 2. add nums[i]\\n        for i in range(k, len(nums)):\\n            s.remove(nums[i-k])\\n            s.add(nums[i])\\n            # append xth smallest number to ans if it is negative, else append 0\\n            if s[x-1] < 0:\\n                ans.append(s[x-1])\\n            else:\\n                ans.append(0)\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871468,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872730,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872389,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872061,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872592,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1872035,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871801,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1871441,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 2018090,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1972216,
                "content": [
                    {
                        "username": "Lee_fan_Ak_The_Boss",
                        "content": "how , How does the Time Limit come.\n704/715 testcases passed."
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "[@_BREEZE_](/_BREEZE_)  same here 703/717"
                    },
                    {
                        "username": "_BREEZE_",
                        "content": "me too 703/717"
                    },
                    {
                        "username": "rajitkumarchauhan99",
                        "content": "I also got TLE at 704/715.\\nhere  is my code\\n\\n```\\nclass Solution:\\n    def find(self , curr , x):\\n        sorted_arr = sorted(curr)\\n        return sorted_arr[x-1]\\n    def getSubarrayBeauty(self, nums: List[int], k: int, x: int) -> List[int]:\\n        curr = []\\n        res = []\\n        start = 0\\n        end = 0\\n        for end in range(len(nums)):\\n            curr.append(nums[end])\\n\\n            if(len(curr) >= k):\\n                ele = self.find(curr , x)\\n                if(ele < 0):\\n                    res.append(ele)\\n                else:\\n                    res.append(0)\\n                curr.pop(0)\\n        return res\\n        \\n```"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "Exactly, I we need to find way to get the xth smallest item in O(n) time, instead of nlogn"
                    },
                    {
                        "username": "palak-agg",
                        "content": "Can someone tell how can we solve it using a heap since we are talking about xth smallest element? Also, will this be an efficient approach?"
                    },
                    {
                        "username": "Dev_Juneja_23",
                        "content": "Yes it can be done using heap but I don\\'t think it will be an efficient approach if you will use only heap. Try using map with heap it might help. Although counting the frequencies will be the most intuitive and easiest approach here according to me."
                    },
                    {
                        "username": "saichandra004",
                        "content": "Hint - Slide the window and use a dict/map to count the number of occurrences of each number. (While sliding, remove the left most element).\n\nAs the elements in nums can only be between -50 and 50, use a loop to count from -50 upto 50 and the counter that exceeds x is the xth smallest element. \n\nOverall - This is a regular sliding window problem and because the range is [-50,50] (We can also optimise this range from -50 to 0), the operations are linear.\n\nI think this will be O(n) time and O(n) complexity.\n"
                    },
                    {
                        "username": "Silver_Dime",
                        "content": "TLE at 707/717 hurts............."
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "Hint: They should really mention it in the body of the question: THE VALUES OF NUMS ONLY RANGE FROM -50 TO 50!\nYou can solve it without that knowledge using some fancier data structures(that's the way I did it because I didn't check all the constraints), but the neat (and probably expected) solution relies on -50<nums[i]<50"
                    },
                    {
                        "username": "atom2s",
                        "content": "707/717 sadness."
                    },
                    {
                        "username": "ManojKumarPatnaik",
                        "content": "\\nWe need to find the beauty of each subarray of size  k in the given array nums . The beauty of a subarray is the x -th smallest negative integer in the subarray, or 0 if there are fewer than  x negative integers. We can use a sliding window of size k to keep track of the current subarray. We can then use a frequency array to efficiently calculate the beauty of this subarray. By iterating over the first 100 elements of the frequency array, we can find the x -th smallest negative integer in the subarray. If there are fewer than x negative integers in the subarray, we set the beauty to 0. We repeat this process for each subarray of size k in the input array nums Finally, we return an array containing the beauty of each subarray in order from the first index in the array.\\n\\n"
                    },
                    {
                        "username": "saguaro",
                        "content": "Is using SortedList legit in an interview (in Python)?\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I\\'m not sure either, but it\\'s totally possible they ask you to implement it in another way. \\nOr that they ask you how sortedList works under the hood"
                    },
                    {
                        "username": "amitpant14",
                        "content": "depends on the interviewer but in my opinion it would be too powerful to use here. Some interviewers may ask for a way without using it."
                    },
                    {
                        "username": "ChasingX",
                        "content": "Why not?"
                    },
                    {
                        "username": "reassurance",
                        "content": "TLE at ```703/717``` hurts more than a breakup"
                    },
                    {
                        "username": "nitissssh",
                        "content": "using of multiset will just give you tle , try something related to frequency of repeated characters this way u can avoid tle using maps\\n"
                    }
                ]
            },
            {
                "id": 1963849,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1873927,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1872141,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871938,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871711,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871650,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871617,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871587,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871576,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            },
            {
                "id": 1871563,
                "content": [
                    {
                        "username": "khushiii07",
                        "content": "703/717 :("
                    },
                    {
                        "username": "Moneswar27",
                        "content": " `   int fun(unordered_map<int,int>mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[i];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<k;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            mp[nums[i-k]]--;\\n            mp[nums[i]]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n  then above code got TLE but if i do with vectors the same code pass any guess why?\\n\\n//Accepted code:\\n` int fun(vector<int>& mp,int k)\\n    {\\n        int count=0;\\n        for(int i=-50;i<0;i++)\\n        {\\n            count+=mp[abs(i)];\\n            if(count>=k)\\n                return i;\\n        }\\n        return 0;\\n        \\n    }\\n    \\n    vector<int> getSubarrayBeauty(vector<int>& nums, int k, int x) \\n    {\\n        vector<int> ans;\\n        vector<int> mp(51,0);\\n        for(int i=0;i<k;i++)\\n        {\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n        }\\n        ans.push_back(fun(mp,x));\\n        for(int i=k;i<nums.size();i++)\\n        {\\n            if(nums[i-k]<0)\\n                mp[abs(nums[i-k])]--;\\n            if(nums[i]<0)\\n                mp[abs(nums[i])]++;\\n            ans.push_back(fun(mp,x));\\n        }\\n        return ans;\\n    }`\\n Time complexity remains same\\n"
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "What if the array is [-1,-1,-1,-1,-1] , k = 3 and x = 2 then there is no xth smallest integer in a subarray of size k as all elements are same, am I missing out on something?"
                    },
                    {
                        "username": "amitpant14",
                        "content": "[@Harsha Devarakonda](/code_blooded_39) Generally if the question does not mention distinct numbers, it shouldn\\'t be assumed so. But yeah maybe providing an example with such a case would have helped in better understanding."
                    },
                    {
                        "username": "code_blooded_39",
                        "content": "[@amitpant14](/amitpant14)  thanks, but it would be better understood if the problem statement explicitly mentions the same."
                    },
                    {
                        "username": "amitpant14",
                        "content": "The question does not means Xth distinct smallest integer, so -1 is the 1st to 5th smallest integers."
                    },
                    {
                        "username": "akshat_ag",
                        "content": "Can anyone tell me how to correct this? I am not able to figure out though it looks there are some issues related to map.\\n\\nIt is failing for input\\nnums = [0,-28,-8]\\nk = 1\\nx = 1\\nOutput [0,-28,-28]\\nExpected [0,-28,-8]\\n\\n```class Solution {\\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\\n        int[] ans=new int[nums.length-k+1];\\n        int i=0;\\n        int j=0;\\n        Map<Integer,Integer> map=new TreeMap<>((a,b)->a-b);\\n        while(j<nums.length) {\\n            map.put(nums[j],map.getOrDefault(nums[j],0)+1);\\n            if(j-i+1<k) {\\n                j++;\\n            }\\n            else if(j-i+1==k) {\\n                int y=x;\\n                int tmp=0;\\n                int flag=0;\\n                //System.out.println(map);\\n                for(Map.Entry<Integer,Integer> entry : map.entrySet()) {  \\n                    tmp = entry.getKey();\\n                    //System.out.println(tmp);\\n                    if(tmp<0) {\\n                        flag+=entry.getValue();   \\n                    }         \\n                    y--;\\n                    if(y==0)\\n                        break;\\n                }\\n                //System.out.println(flag);\\n                if(flag>=x) {\\n                    ans[i] = tmp; \\n                }\\n                else  {\\n                    ans[i]=0;\\n                }\\n                //System.out.println(ans[i]);\\n                j++;\\n            }\\n            else if(j-i+1>k) {\\n                map.put(nums[i],map.get(nums[i])-1);\\n                if(map.get(nums[i])==0)\\n                    map.remove(nums[i]);\\n                i++; \\n                System.out.println(map);\\n            }       \\n        }    \\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "saurabh09700",
                        "content": "Passed 715 / 717 test cases :\\'("
                    },
                    {
                        "username": "onekokun",
                        "content": "nlogk isnt working"
                    },
                    {
                        "username": "jayanth_26_01",
                        "content": "Can be solved in n using hashmap"
                    },
                    {
                        "username": "gurpreetsingh8",
                        "content": "I guess they expected us to find the xth smallest item for kth size array using the sliding approach. "
                    },
                    {
                        "username": "arghyadas",
                        "content": "703/717 \\uD83E\\uDD72"
                    },
                    {
                        "username": "sergei-durkin",
                        "content": "Oh god, time limit.. 703/715 \\uD83D\\uDE13"
                    },
                    {
                        "username": "mo_ali7379",
                        "content": "my multiset solution in c++ tled. do we have to implement better than nlogn?"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "ig no !! my multiset soln got tle too. then i used a map (frequency map). \\n\\nfor an eg. take the tc: [0,0,0,0,0,.....,0,0,0] (all 0\\'s)\\n\\nusing a map we dont need to traverse over all 0\\'s as we have their frequency !! this is not in the case of a multiset"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Latest Salaries",
        "question_content": null,
        "solutions": [],
        "discussions": [
            {
                "id": 1983461,
                "content": [
                    {
                        "username": "manpreetsarao",
                        "content": "select a.emp_id, a.firstname, a.lastname, a.salary,\\na.department_id from salary a\\njoin salary b on b.salary <=a.salary\\ngroup by emp_id\\norder by emp_id\\n\\ncan anyone help me with this code it worked well for all other test cases but failed the 21-test case without any reason, it gives the same output but still failed"
                    }
                ]
            }
        ]
    },
    {
        "title": "Number of Senior Citizens",
        "question_content": "<p>You are given a <strong>0-indexed</strong> array of strings <code>details</code>. Each element of <code>details</code> provides information about a given passenger compressed into a string of length <code>15</code>. The system is such that:</p>\n\n<ul>\n\t<li>The first ten characters consist of the phone number of passengers.</li>\n\t<li>The next character denotes the gender of the person.</li>\n\t<li>The following two characters are used to indicate the age of the person.</li>\n\t<li>The last two characters determine the seat allotted to that person.</li>\n</ul>\n\n<p>Return <em>the number of passengers who are <strong>strictly </strong><strong>more than 60 years old</strong>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> details = [&quot;7868190130M7522&quot;,&quot;5303914400F9211&quot;,&quot;9273338290F4010&quot;]\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> details = [&quot;1313579440F2036&quot;,&quot;2921522980M5644&quot;]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> None of the passengers are older than 60.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= details.length &lt;= 100</code></li>\n\t<li><code>details[i].length == 15</code></li>\n\t<li><code>details[i] consists of digits from &#39;0&#39; to &#39;9&#39;.</code></li>\n\t<li><code>details[i][10] is either &#39;M&#39; or &#39;F&#39; or &#39;O&#39;.</code></li>\n\t<li>The phone numbers and seat numbers of the passengers are distinct.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 3520270,
                "title": "very-simple-easy-to-understand-solution",
                "content": "\\n# Code\\n```\\n\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(auto d: details){\\n            int age = (d[11] - \\'0\\') * 10 + (d[12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n\\n```\\n\\n<b> Here is an article of my last interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(auto d: details){\\n            int age = (d[11] - \\'0\\') * 10 + (d[12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520201,
                "title": "python-elegant-short-just-slice",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum(int(p[-4:-2]) > 60 for p in details)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum(int(p[-4:-2]) > 60 for p in details)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3715837,
                "title": "99-memory-beats-a-very-good-solution-for-early-users-as-a-knive-way-and-easily-understandable",
                "content": "# Intuition\\nPLEASE \"UPVOTE\" ME\\n\\n# Approach\\nBRUTE FORCE \\n\\n# Complexity\\n- Time complexity:\\n- n-times\\n\\n- Space complexity:\\n16.2 MB\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        e=[]\\n        d=[]\\n        count=0\\n        for i in range(len(details)):\\n           e.append(details[i][-4]+details[i][-3])\\n        for j in range(len(e)):\\n            x=int(e[j])\\n            d.append(x)\\n        for k in range(len(d)):\\n            if d[k]>60:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        e=[]\\n        d=[]\\n        count=0\\n        for i in range(len(details)):\\n           e.append(details[i][-4]+details[i][-3])\\n        for j in range(len(e)):\\n            x=int(e[j])\\n            d.append(x)\\n        for k in range(len(d)):\\n            if d[k]>60:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525994,
                "title": "python-go-100-faster-easy-solution",
                "content": "# Python\\u2705\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count\\n\\n```\\n# Go\\u2705\\n```\\nfunc countSeniors(details []string) int {\\n    count := 0\\n    for _, item := range details {\\n        firstDigit := string(item[11])\\n        if firstDigit == \"7\" || firstDigit == \"8\" || firstDigit == \"9\" {\\n            count++\\n        } else if firstDigit == \"6\" && string(item[12]) != \"0\"{\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Go"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for item in details:\\n            age = int(item[11]+item[12])\\n            if age > 60:\\n                count +=1\\n        return count\\n\\n```\n```\\nfunc countSeniors(details []string) int {\\n    count := 0\\n    for _, item := range details {\\n        firstDigit := string(item[11])\\n        if firstDigit == \"7\" || firstDigit == \"8\" || firstDigit == \"9\" {\\n            count++\\n        } else if firstDigit == \"6\" && string(item[12]) != \"0\"{\\n            count++\\n        }\\n    }\\n    return count\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520297,
                "title": "easy-java-solution-0-ms",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String s:details){\\n            int age=((s.charAt(11)-\\'0\\')*10)+s.charAt(12)-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String s:details){\\n            int age=((s.charAt(11)-\\'0\\')*10)+s.charAt(12)-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520240,
                "title": "day-408-one-liner-100-python-java-c-explained",
                "content": "# Please Upvote as it really motivates me \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIterates over each string in the input array, and extracts the age of the person from the string using the \\nsubstring method and the  parseInt method. If the age is greater than 60, the function increments the count. Finally, the function returns the count.\\n\\n# Complexity\\nThe time complexity of this function is O(n), where n is the number of strings in the input array, since we need to iterate over each string in the array. The space complexity is O(1), since we only need to store the count of seniors in memory.\\n\\n\\n\\n# Code\\n```java []\\n    public int countSeniors(String[] details) {\\n        int cnt=0;\\n        for(String tem:details){\\n            int age = Integer.parseInt(tem.substring(11,13));\\n            if(age>60)cnt++;\\n        }return cnt;\\n        \\n    }\\n```\\n```c++ []\\nint countSeniors(vector<string>& details) {\\n    int cnt = 0;\\n    for (string tem : details) {\\n        int age = stoi(tem.substr(11, 2));\\n        if (age > 60) {\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n}\\n```\\n```python []\\ndef countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\\n# ONE LINER\\n\\n```PYTHON  []\\ndef countSeniors(details: List[str]) -> int:\\n    return sum(int(detail[11:13]) > 60 for detail in details)\\n```\\n```C++ []\\nint countSeniors(vector<string>& details) {\\n    return count_if(details.begin(), details.end(), [](string detail) {\\n        int age = stoi(detail.substr(11, 2));\\n        return age > 60;\\n    });\\n}\\n```\\n```JAVA []\\npublic int countSeniors(String[] details) {\\n        return (int) Arrays.stream(details)\\n                .mapToInt(detail -> Integer.parseInt(detail.substring(11, 13)))\\n                .filter(age -> age > 60)\\n                .count();\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```java []\\n    public int countSeniors(String[] details) {\\n        int cnt=0;\\n        for(String tem:details){\\n            int age = Integer.parseInt(tem.substring(11,13));\\n            if(age>60)cnt++;\\n        }return cnt;\\n        \\n    }\\n```\n```c++ []\\nint countSeniors(vector<string>& details) {\\n    int cnt = 0;\\n    for (string tem : details) {\\n        int age = stoi(tem.substr(11, 2));\\n        if (age > 60) {\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n}\\n```\n```python []\\ndef countSeniors(details: List[str]) -> int:\\n    cnt = 0\\n    for tem in details:\\n        age = int(tem[11:13])\\n        if age > 60:\\n            cnt += 1\\n    return cnt\\n```\n```PYTHON  []\\ndef countSeniors(details: List[str]) -> int:\\n    return sum(int(detail[11:13]) > 60 for detail in details)\\n```\n```C++ []\\nint countSeniors(vector<string>& details) {\\n    return count_if(details.begin(), details.end(), [](string detail) {\\n        int age = stoi(detail.substr(11, 2));\\n        return age > 60;\\n    });\\n}\\n```\n```JAVA []\\npublic int countSeniors(String[] details) {\\n        return (int) Arrays.stream(details)\\n                .mapToInt(detail -> Integer.parseInt(detail.substring(11, 13)))\\n                .filter(age -> age > 60)\\n                .count();\\n    }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3520864,
                "title": "simple-easy-to-understand-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int x = 0;\\n        for(auto &i: details){\\n            // cout<<i[11]<<\" \"<<i[12]<<endl;\\n            if(i[11]>\\'6\\'){\\n                x++;\\n            }else if(i[11]==\\'6\\'&&i[12]>\\'0\\')x++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int x = 0;\\n        for(auto &i: details){\\n            // cout<<i[11]<<\" \"<<i[12]<<endl;\\n            if(i[11]>\\'6\\'){\\n                x++;\\n            }else if(i[11]==\\'6\\'&&i[12]>\\'0\\')x++;\\n        }\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3520283,
                "title": "brute-force-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(auto str:details){\\n            int age=(str[11]-\\'0\\')*10+str[12]-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(auto str:details){\\n            int age=(str[11]-\\'0\\')*10+str[12]-\\'0\\';\\n            if(age>60) count++;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521469,
                "title": "python-3-1-line-string-comparison-t-m-89-87",
                "content": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n\\n        return sum(d[11:13] > \\'60\\' for d in details)\\n\\n```\\n[https://leetcode.com/problems/number-of-senior-citizens/submissions/985081922/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(1).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n\\n        return sum(d[11:13] > \\'60\\' for d in details)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520726,
                "title": "well-explained-easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs it given that the 12th and the 13th position of each string is denoting the age of the passenger so we can get the age of each passenger from that position and then we can find out total number of passengers who are older than 60. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Loop through the given string type vector and get the char at index 11 and 12 . Store char of 11th index in a variable (dec) and store char of 12th index in a variable (uni).\\n- Convert them into integer (char-\\'0\\')\\n- Find out the age (age = (dec*10)+uni)\\n- Store age of each passenger in a integer type vector(ageList)\\n- Then find out count of the passengers who are strictly older than 60.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nAt first it is looping through the given vector to find out their age, which will take O(n)\\nThen it is looping through the created vector (ageList) to find out the count of people who are older than 60, it will also take O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nIf the size of the given vector is \\'n\\', then size of the vector which we have created (ageList), will also be n.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n=details.size();\\n        vector<int>age;\\n        for(int i=0;i<n;i++){\\n            string given=details[i];\\n            char char11=given.at(11);\\n            char char12=given.at(12);\\n            \\n            int dec=char11-\\'0\\';\\n            int uni=char12-\\'0\\';\\n            int num=(dec*10)+uni;\\n            age.push_back(num);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<age.size();i++){\\n            if(age[i]>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# One like can be really encouraging\\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n=details.size();\\n        vector<int>age;\\n        for(int i=0;i<n;i++){\\n            string given=details[i];\\n            char char11=given.at(11);\\n            char char12=given.at(12);\\n            \\n            int dec=char11-\\'0\\';\\n            int uni=char12-\\'0\\';\\n            int num=(dec*10)+uni;\\n            age.push_back(num);\\n        }\\n        int cnt=0;\\n        for(int i=0;i<age.size();i++){\\n            if(age[i]>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520296,
                "title": "easy-approach-in-java-detailed-explained",
                "content": "# Intuition\\nTake a substring and convert to Integer.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1) Iterate through all the strings in details and take a substring(startIndex, endIndex)(11, 13).\\n2) Convert that string into Integer to get age.\\n3) Comapre if greater than 60.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n = details.length, a = 0, count = 0;\\n        for(int i = 0; i < n; i++){\\n            String s = details[i].substring(11, 13);\\n            a = Integer.parseInt(s);\\n            if(a > 60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n = details.length, a = 0, count = 0;\\n        for(int i = 0; i < n; i++){\\n            String s = details[i].substring(11, 13);\\n            a = Integer.parseInt(s);\\n            if(a > 60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3968858,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp=details[i];\\n            if(((temp.charAt(11)-\\'0\\')*10)+(temp.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp=details[i];\\n            if(((temp.charAt(11)-\\'0\\')*10)+(temp.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688200,
                "title": "c-simple-straight-forward-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        vector<int> ages;\\n        int ans = 0;\\n        for(auto it:details){\\n            string s = it.substr(11,2);\\n            cout<<s<<\" \";\\n            int temp = stoi(s);\\n            ages.push_back(temp);\\n        }\\n        for(auto it:ages){\\n            if(it > 60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        vector<int> ages;\\n        int ans = 0;\\n        for(auto it:details){\\n            string s = it.substr(11,2);\\n            cout<<s<<\" \";\\n            int temp = stoi(s);\\n            ages.push_back(temp);\\n        }\\n        for(auto it:ages){\\n            if(it > 60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3600476,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countSeniors(vector<string>& details) {\\n      \\n\\t  int count = 0 ; \\n        for(int i=0 ;i<details.size();i++){\\n           int a = (details[i][11]-\\'0\\')*10 + (details[i][12]-\\'0\\');\\n            if(a>60) count++ ; }\\n        return count ;  \\n    }\\n    \\n};",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countSeniors(vector<string>& details) {\\n      \\n\\t  int count = 0 ; \\n        for(int i=0 ;i<details.size();i++){\\n           int a = (details[i][11]-\\'0\\')*10 + (details[i][12]-\\'0\\');\\n            if(a>60) count++ ; }",
                "codeTag": "Java"
            },
            {
                "id": 3561065,
                "title": "simple-solution-runtime-0-ms-100-beats-memory-41-3-mb-99-5-beats",
                "content": "# Approach\\nApproach:\\n1. Initialize a variable `count` to 0.\\n2. Iterate over each string `s` in the `details` array.\\n3. Extract the age information from `s` by converting the characters at indices 11 and 12 to an integer.\\n4. If the extracted age is greater than 60, increment the `count` variable.\\n5. After iterating over all strings, return the final `count` value, which represents the number of passengers who are strictly more than 60 years old.\\n\\nAlgorithm:\\n1. Initialize `count` to 0.\\n2. For each `s` in `details`, do steps 3-4.\\n   - Extract the age from `s` using `(s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\')`.\\n   - If the age is greater than 60, increment `count`.\\n3. Return `count` as the result.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s : details){\\n            int age = (s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\');\\n            if(age > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s : details){\\n            int age = (s.charAt(11) - \\'0\\') * 10 + (s.charAt(12) - \\'0\\');\\n            if(age > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3557401,
                "title": "number-of-senior-citizens-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int i, count=0;\\n        for(i=0 ; i<details.size() ; i++)\\n        {\\n            if((int)details[i][11]>54 || (int)details[i][11]==54 && (int)details[i][12]>=49)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/6888ef7d-dc4b-4298-8f1b-4d3f4848d9ad_1684899245.7077143.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int i, count=0;\\n        for(i=0 ; i<details.size() ; i++)\\n        {\\n            if((int)details[i][11]>54 || (int)details[i][11]==54 && (int)details[i][12]>=49)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520885,
                "title": "c-python-easy-o-n-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto i : details) {\\n            if(i[11] - \\'0\\' > 6) count++;\\n            else if (i[11] - \\'0\\' == 6 && i[12] - \\'0\\' > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n# Python / Python3\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11]) > 6:\\n                count += 1\\n            elif int(i[11]) == 6 and int(i[12]) > 0:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto i : details) {\\n            if(i[11] - \\'0\\' > 6) count++;\\n            else if (i[11] - \\'0\\' == 6 && i[12] - \\'0\\' > 0) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11]) > 6:\\n                count += 1\\n            elif int(i[11]) == 6 and int(i[12]) > 0:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520256,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] s) {\\n        int ans=0;\\n        for(String ss:s){\\n            int a1=ss.charAt(11)-\\'0\\';\\n            int a2=ss.charAt(12)-\\'0\\'; \\n            if((a1*10)+a2>60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] s) {\\n        int ans=0;\\n        for(String ss:s){\\n            int a1=ss.charAt(11)-\\'0\\';\\n            int a2=ss.charAt(12)-\\'0\\'; \\n            if((a1*10)+a2>60)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072941,
                "title": "beats-93-of-users-in-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(stoi(nums[i].substr(11,2)) > 60)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& nums) {\\n        int ans = 0;\\n\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(stoi(nums[i].substr(11,2)) > 60)ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793211,
                "title": "java-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n,c=0;\\n        for (n=0;n<details.length;n++){\\n            int i=Integer.parseInt(details[n].substring(11,13));\\n            if(i>60) {\\n                 c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int n,c=0;\\n        for (n=0;n<details.length;n++){\\n            int i=Integer.parseInt(details[n].substring(11,13));\\n            if(i>60) {\\n                 c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786738,
                "title": "java-easy-solution-0ms",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n      int count = 0;\\n      for(String s : details) {\\n          int age = Integer.parseInt(s.substring(11, 13));\\n          if(age > 60) count ++;\\n      }  \\n      return count;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n      int count = 0;\\n      for(String s : details) {\\n          int age = Integer.parseInt(s.substring(11, 13));\\n          if(age > 60) count ++;\\n      }  \\n      return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3751961,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String i : details)\\n        {\\n           if( check(i)==true) // check for separete word\\n           {\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n    public Boolean check(String s)\\n    {\\n        char ch1=s.charAt(s.length()-4);\\n        char ch2=s.charAt(s.length()-3);\\nif(ch1==54 && ch2==48)\\n{\\n    return false;\\n}\\n      if(ch1>=54 && ch2>=48)\\n      {\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String i : details)\\n        {\\n           if( check(i)==true) // check for separete word\\n           {\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n    public Boolean check(String s)\\n    {\\n        char ch1=s.charAt(s.length()-4);\\n        char ch2=s.charAt(s.length()-3);\\nif(ch1==54 && ch2==48)\\n{\\n    return false;\\n}\\n      if(ch1>=54 && ch2>=48)\\n      {\\n          return true;\\n      }\\n      return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714030,
                "title": "js-one-liner-beats-94",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => parseInt(detail.substring(11,13)) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => parseInt(detail.substring(11,13)) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670082,
                "title": "2678-number-of-senior-citizens-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            String d = details[i].substring(11,13);\\n            int s = Integer.parseInt(d);\\n            if(s>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            String d = details[i].substring(11,13);\\n            int s = Integer.parseInt(d);\\n            if(s>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666867,
                "title": "easy-c-solution-beginner-friendly",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(int i=0; i<details.size(); i++)\\n        {\\n            int l = details[i][11], r=details[i][12];\\n            if(l>=\\'6\\')\\n            {\\n                if(l==\\'6\\' && r==\\'0\\')\\n                    continue;\\n                else \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for(int i=0; i<details.size(); i++)\\n        {\\n            int l = details[i][11], r=details[i][12];\\n            if(l>=\\'6\\')\\n            {\\n                if(l==\\'6\\' && r==\\'0\\')\\n                    continue;\\n                else \\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3653835,
                "title": "simplest-way",
                "content": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto info: details)\\n            if (stoi(info.substr(11, 2)) > 60) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto info: details)\\n            if (stoi(info.substr(11, 2)) > 60) res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578685,
                "title": "100-efficient-solution-java-with-t-n-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3563889,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(el => el.slice(-4, -2) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(el => el.slice(-4, -2) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558388,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n        details\\n            .map { Int(String($0.suffix(4).prefix(2)))! }\\n            .filter { $0 > 60 }\\n            .count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n        details\\n            .map { Int(String($0.suffix(4).prefix(2)))! }\\n            .filter { $0 > 60 }\\n            .count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3543268,
                "title": "beginners-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String data: details){\\n            // System.out.println(data.substring(11,13));\\n            int age= Integer.parseInt(data.substring(11,13));\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String data: details){\\n            // System.out.println(data.substring(11,13));\\n            int age= Integer.parseInt(data.substring(11,13));\\n            if(age>60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537834,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += ((x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\') > 60 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += ((x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\') > 60 ? 1 : 0;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537822,
                "title": "simple-java-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += Integer.parseInt(x.substring(11, 13)) > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String x : details) {\\n            count += Integer.parseInt(x.substring(11, 13)) > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537811,
                "title": "simple-java-solution-for-beginners-1ms-beats-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            String s = x.substring(11, 13);\\n            age = Integer.parseInt(s);\\n            count += age > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            String s = x.substring(11, 13);\\n            age = Integer.parseInt(s);\\n            count += age > 60 ? 1 : 0;            \\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3537787,
                "title": "simple-java-solution-for-beginners-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526089,
                "title": "substring-and-parseint",
                "content": "# Code\\n```\\npublic int countSeniors(String[] details) {\\n    int res = 0;\\n    for (String d : details) {\\n        int age = Integer.parseInt(d.substring(11, 13));\\n        if (age > 60) res++;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countSeniors(String[] details) {\\n    int res = 0;\\n    for (String d : details) {\\n        int age = Integer.parseInt(d.substring(11, 13));\\n        if (age > 60) res++;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524881,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let counter = 0;\\n    for(let i = 0;i < details.length;i++){\\n        if(details[i][11].concat(details[i][12]) > 60){\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let counter = 0;\\n    for(let i = 0;i < details.length;i++){\\n        if(details[i][11].concat(details[i][12]) > 60){\\n            counter++\\n        }\\n    }\\n    return counter\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524223,
                "title": "java-very-easy-beats-100-time-and-space",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : d) {\\n            sb.append(s.charAt(s.length() - 4));\\n            sb.append(s.charAt(s.length() - 3));\\n            sb.append(\" \");\\n        }\\n        String str =  sb.toString();\\n        String res[] = str.split(\" \");\\n        for(String i : res) {\\n            if(Integer.valueOf(i) > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        int count = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(String s : d) {\\n            sb.append(s.charAt(s.length() - 4));\\n            sb.append(s.charAt(s.length() - 3));\\n            sb.append(\" \");\\n        }\\n        String str =  sb.toString();\\n        String res[] = str.split(\" \");\\n        for(String i : res) {\\n            if(Integer.valueOf(i) > 60) count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523009,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(auto it: details){\\n            int num=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n            cout<<num<<endl;\\n            if(num>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(auto it: details){\\n            int num=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n            cout<<num<<endl;\\n            if(num>60){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3523007,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int countSeniors(vector<string>& details) \\n    {\\n        int ans=0;\\n        for(auto p: details)\\n        {\\n            string op1(1,p[11]);\\n            string op2(1,p[12]);\\n            string age=op1+op2;\\n            int a=stoi(age);\\n            if(a>60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countSeniors(vector<string>& details) \\n    {\\n        int ans=0;\\n        for(auto p: details)\\n        {\\n            string op1(1,p[11]);\\n            string op2(1,p[12]);\\n            string age=op1+op2;\\n            int a=stoi(age);\\n            if(a>60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521937,
                "title": "c-easy-to-understand-brute-force",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for (int i=0; i<details.size(); i++){\\n            string s= details[i];\\n            int age= s[11]-\\'0\\';\\n            age*=10;\\n            age+= (s[12]-\\'0\\');\\n            if (age>60)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for (int i=0; i<details.size(); i++){\\n            string s= details[i];\\n            int age= s[11]-\\'0\\';\\n            age*=10;\\n            age+= (s[12]-\\'0\\');\\n            if (age>60)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521856,
                "title": "simple-typescript-solution-o-n-time-o-1-space",
                "content": "# Intuition\\nWe need to get the age from the string positions, convert it to number and compare\\n\\n# Approach\\nSince the position of the age digits is always fixed at **11 and 12**,\\n \\n## Step 1: Take out the substring of age from the given string,\\n\\n## Step 2: Use the unary + operator to directly convert the string to a number and then compare it. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Simple String, Indexes, to Number Solution \\nfunction countSeniors(details: string[]): number {\\n    let result:number = 0;\\n    for (let person of details){\\n        if(+person.substring(11,13) > 60){\\n            result+=1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\n// Simple String, Indexes, to Number Solution \\nfunction countSeniors(details: string[]): number {\\n    let result:number = 0;\\n    for (let person of details){\\n        if(+person.substring(11,13) > 60){\\n            result+=1;\\n        }\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3521222,
                "title": "c-simple-parse-no-built-in-string-number-conversion-0ms-13-4mb",
                "content": "Pretty plain problem in which we basically just need to code what we are told to code:\\n* reading the age \"hidden\" in the personal details of each user;\\n* check if said age is above the required threshold and if so increase a counter;\\n* finally, `return` the counter.\\n\\nOur support variables are going to be:\\n* `res`, our counter initially set to `0`;\\n* `age`, that we will use when parsing each user.\\n\\nFor each `code` in `details`, we will:\\n* extract the digits at indexes `11` and `12`;\\n* subtract `0` from both of them to get their value in numbers;\\n* multiply the first by `10` and add the second, to get their value in numbers to get the `age`;\\n* check if `age > 60` and if so increase `res` by `1`.\\n\\nOnce done, we can `return` `res`.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        // support variables\\n        int res = 0, age;\\n        // parsing details\\n        for (auto &code: details) {\\n            age = (code[11] - \\'0\\') * 10 + (code[12] - \\'0\\');\\n            if (age > 60) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        // support variables\\n        int res = 0, age;\\n        // parsing details\\n        for (auto &code: details) {\\n            age = (code[11] - \\'0\\') * 10 + (code[12] - \\'0\\');\\n            if (age > 60) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520805,
                "title": "easy-java-solution-100-faster-0ms",
                "content": "\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n     int count=0;\\n     for(int i=0;i<details.length;i++)\\n     {\\n         int a=details[i].charAt(11)-\\'0\\';\\n         a*=10;\\n         a+=details[i].charAt(12)-\\'0\\';\\n         if(a>60)\\n         {\\n             count++;\\n         }\\n     }\\n     return count;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n     int count=0;\\n     for(int i=0;i<details.length;i++)\\n     {\\n         int a=details[i].charAt(11)-\\'0\\';\\n         a*=10;\\n         a+=details[i].charAt(12)-\\'0\\';\\n         if(a>60)\\n         {\\n             count++;\\n         }\\n     }\\n     return count;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520729,
                "title": "easy-solution-with-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint countSeniors(char ** details, int detailsSize){\\n    int a=0,ind=0;\\n    \\n    for(int i=0;i<detailsSize;i++)\\n    { \\n        a=10*(details[i][11]-\\'0\\')+details[i][12]-\\'0\\';\\n        if(a>60)\\n        {\\n            ind++;\\n        }\\n    }\\n    return ind;\\n}\\n            \\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nint countSeniors(char ** details, int detailsSize){\\n    int a=0,ind=0;\\n    \\n    for(int i=0;i<detailsSize;i++)\\n    { \\n        a=10*(details[i][11]-\\'0\\')+details[i][12]-\\'0\\';\\n        if(a>60)\\n        {\\n            ind++;\\n        }\\n    }\\n    return ind;\\n}\\n            \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520715,
                "title": "full-explanation-in-steps-simplest-approach",
                "content": "# Intuition\\n- The solution follows a simple and straightforward approach to count the number of passengers who are more than 60 years old.\\n- By iterating through each string in the `details` array, we extract the age of each passenger.\\n- The age is obtained by extracting the relevant substring from each string and converting it into an integer.\\n- If the extracted age is greater than 60, it means the passenger is a senior citizen, so we increment the `count` variable.\\n- Finally, we return the total count of senior passengers as the result.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize a variable, `count`, to keep track of the number of passengers who are strictly more than 60 years old.\\n2. Iterate through each string, `str`, in the `details` array.\\n3. Extract the age of the passenger from the substring `str.substring(11, 13)`.\\n4. Convert the extracted age from a string to an integer using `Integer.parseInt()`.\\n5. If the age is greater than 60, increment the `count` variable.\\n6. Return the final value of `count` as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String str : details) {\\n            int age = Integer.parseInt(str.substring(11, 13));\\n            if (age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```\\n![images.jpeg](https://assets.leetcode.com/users/images/2f224d46-b7c5-4a7a-add2-fbfa74226820_1683998207.5152655.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String str : details) {\\n            int age = Integer.parseInt(str.substring(11, 13));\\n            if (age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520691,
                "title": "count-if",
                "content": "**C++**\\n```cpp\\nint countSeniors(vector<string>& details) {\\n    return count_if(begin(details), end(details), [](const auto &d){\\n        return d.substr(11, 2) > \"60\";\\n    });\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countSeniors(vector<string>& details) {\\n    return count_if(begin(details), end(details), [](const auto &d){\\n        return d.substr(11, 2) > \"60\";\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3520634,
                "title": "c-easy-o-n",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        string x;\\n        int cnt=0;\\n        for(int i=0;i<d.size();i++){\\n            string cand = d[i]; \\n            string ans;\\n            ans.push_back(cand[11]);\\n            ans.push_back(cand[12]); \\n            int num=0;\\n            num=num*10+ans[0]-\\'0\\';\\n            num = num*10+ans[1]-\\'0\\'; \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        string x;\\n        int cnt=0;\\n        for(int i=0;i<d.size();i++){\\n            string cand = d[i]; \\n            string ans;\\n            ans.push_back(cand[11]);\\n            ans.push_back(cand[12]); \\n            int num=0;\\n            num=num*10+ans[0]-\\'0\\';\\n            num = num*10+ans[1]-\\'0\\'; \\n        } \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520526,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        senior_citizen=0\\n        for detail in details:\\n            age=int(detail[11:13])\\n            if age>60:\\n                senior_citizen+=1\\n\\n\\n        return senior_citizen       \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        senior_citizen=0\\n        for detail in details:\\n            age=int(detail[11:13])\\n            if age>60:\\n                senior_citizen+=1\\n\\n\\n        return senior_citizen       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520470,
                "title": "the-best-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  int countSeniors(vector<string>& details) {\\n    int res = 0;\\n    for(string& st: details){\\n      res += (st[11] > \\'6\\' || st[11] == \\'6\\' && st[12] > \\'0\\');\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countSeniors(vector<string>& details) {\\n    int res = 0;\\n    for(string& st: details){\\n      res += (st[11] > \\'6\\' || st[11] == \\'6\\' && st[12] > \\'0\\');\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520432,
                "title": "implementation",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        int ans = 0;\\n        for(string&e: d){\\n            string s = e.substr(11,2);\\n            int age = stoi(s);\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& d) {\\n        int ans = 0;\\n        for(string&e: d){\\n            string s = e.substr(11,2);\\n            int age = stoi(s);\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520379,
                "title": "c-1-line",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public int CountSeniors(string[] details) \\n    {\\n        return details.Count(d => int.Parse(d.Substring(11, 2)) > 60);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int CountSeniors(string[] details) \\n    {\\n        return details.Count(d => int.Parse(d.Substring(11, 2)) > 60);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520322,
                "title": "java-beats-100-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < details.length; i++) {\\n            int age = (details[i].charAt(11) - \\'0\\') * 10 + (details[i].charAt(12) - \\'0\\');\\n            \\n            if(age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for(int i = 0; i < details.length; i++) {\\n            int age = (details[i].charAt(11) - \\'0\\') * 10 + (details[i].charAt(12) - \\'0\\');\\n            \\n            if(age > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520317,
                "title": "very-easy-java-code-with-explaination",
                "content": "# Algorithm steps\\n\\nAlgorithm for countSeniors method in the Solution class:\\n\\n1. Create a method called \"countSeniors\" that takes a String array called \"details\" as input and returns an integer.\\n2. Initialize an integer variable called \"res\" to 0.\\n3. For each String \"s\" in the \"details\" array, do the following:\\n   a. Extract the age of the person from the String \"s\" by getting the substring that starts at index 11 and ends at index 13 (exclusive).\\n   b. Convert the extracted substring to an integer using the \"Integer.parseInt\" method.\\n   c. If the age is greater than 60, increment the \"res\" variable by 1.\\n4. After processing all the elements in the \"details\" array, return the value of \"res\" as the count of seniors.\\n\\nOverall, this algorithm counts the number of seniors in an array of Strings by iterating through each String, extracting the age of the person, and incrementing the count if the age is greater than 60.\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int res = 0;\\n        for (String s : details) {\\n            if (Integer.parseInt(s.substring(11, 13)) > 60) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int res = 0;\\n        for (String s : details) {\\n            if (Integer.parseInt(s.substring(11, 13)) > 60) res++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520300,
                "title": "simple-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if(possible(details[i].substring(11,13))){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean possible(String age){\\n        int a=Integer.parseInt(age);\\n        if(a>60){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if(possible(details[i].substring(11,13))){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    boolean possible(String age){\\n        int a=Integer.parseInt(age);\\n        if(a>60){\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520252,
                "title": "using-java-substring",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int countaccepted = 0;\\n        for(int i = 0; i < details.length; i++){\\n            String passen = details[i];\\n            String AgeOfPerson = passen.substring(11, 13);\\n            int Age = Integer.parseInt(AgeOfPerson);\\n            if(Age > 60){\\n                countaccepted++;\\n            }\\n        }\\n        return countaccepted;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int countaccepted = 0;\\n        for(int i = 0; i < details.length; i++){\\n            String passen = details[i];\\n            String AgeOfPerson = passen.substring(11, 13);\\n            int Age = Integer.parseInt(AgeOfPerson);\\n            if(Age > 60){\\n                countaccepted++;\\n            }\\n        }\\n        return countaccepted;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520229,
                "title": "c-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(auto ele: details){\\n            int num = (ele[11]-\\'0\\')*10 + (ele[12]-\\'0\\');\\n            if(num > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(auto ele: details){\\n            int num = (ele[11]-\\'0\\')*10 + (ele[12]-\\'0\\');\\n            if(num > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520216,
                "title": "easiest-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n         int count = 0;\\n\\n        for (const string& info : details) {\\n        int age = stoi(info.substr(11, 2));\\n\\n        if (age > 60) {\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n         int count = 0;\\n\\n        for (const string& info : details) {\\n        int age = stoi(info.substr(11, 2));\\n\\n        if (age > 60) {\\n            count++;\\n        }\\n    }\\n\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100480,
                "title": "pyhton3-easy-solution",
                "content": "# Intuition\\n![Screenshot from 2023-09-28 16-26-13.png](https://assets.leetcode.com/users/images/cf2dbe13-5f16-4b4c-bf9f-6bf3dc6d7d63_1695900383.1126714.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: list[str]) -> int:\\n        return sum(1 for x in details if int(x[11:13]) > 60)\\n\\n\\nobj = Solution()\\nprint(obj.countSeniors(details=[\"7868190130M7522\", \"5303914400F9211\", \"9273338290F4010\"]))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: list[str]) -> int:\\n        return sum(1 for x in details if int(x[11:13]) > 60)\\n\\n\\nobj = Solution()\\nprint(obj.countSeniors(details=[\"7868190130M7522\", \"5303914400F9211\", \"9273338290F4010\"]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097530,
                "title": "easiest-solution-that-can-exist-0ms-best-solution-java-anyone-can-do-leetcode",
                "content": "\\n\\n# Complexity\\n- Time complexity: 0ms\\nBeats 100.00%of users with Java\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 40.42MB\\nBeats 99.83%of users with Java\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String d: details)\\n        {\\n            if(d.charAt(11)==\\'6\\' && d.charAt(12)==\\'0\\')\\n            continue;\\n            else if(d.charAt(11)>=\\'6\\' && d.charAt(12)>=\\'0\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String d: details)\\n        {\\n            if(d.charAt(11)==\\'6\\' && d.charAt(12)==\\'0\\')\\n            continue;\\n            else if(d.charAt(11)>=\\'6\\' && d.charAt(12)>=\\'0\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4096639,
                "title": "task-solution-number-of-senior-citizens-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count = 0\\n        for I in details:\\n          if int(I[11:-2]) > 60:\\n              count += 1\\n        return count\\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n\\n        count = 0\\n        for I in details:\\n          if int(I[11:-2]) > 60:\\n              count += 1\\n        return count\\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4093688,
                "title": "1ms-o-n-simple-java-solution-number-of-senior-citizens",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String person: details) {\\n            int age = Integer.valueOf(person.substring(11,13));\\n            if (age>60) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String person: details) {\\n            int age = Integer.valueOf(person.substring(11,13));\\n            if (age>60) {\\n                count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4092812,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String str=details[i];\\n            int a=(str.charAt(11)-\\'0\\')*10+(str.charAt(12)-\\'0\\');\\n            if(a>60)\\n            {\\n                c+=1;\\n            }\\n            \\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String str=details[i];\\n            int a=(str.charAt(11)-\\'0\\')*10+(str.charAt(12)-\\'0\\');\\n            if(a>60)\\n            {\\n                c+=1;\\n            }\\n            \\n        }\\n        return c;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086189,
                "title": "python-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11:13]) > 60:\\n                count += 1\\n        return count\\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for i in details:\\n            if int(i[11:13]) > 60:\\n                count += 1\\n        return count\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085861,
                "title": "best-method-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n               // please upvote if it help you\\uD83D\\uDE0A\\uD83D\\uDE0A\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(int i=0;i<details.size();i++){\\n            if(details[i][11]>=\\'6\\' && details[i][12]>\\'0\\') ans++;\\n            else if(details[i][11]>\\'6\\' && details[i][12]>=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n               // please upvote if it help you\\uD83D\\uDE0A\\uD83D\\uDE0A\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(int i=0;i<details.size();i++){\\n            if(details[i][11]>=\\'6\\' && details[i][12]>\\'0\\') ans++;\\n            else if(details[i][11]>\\'6\\' && details[i][12]>=\\'0\\') ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085666,
                "title": "220103011",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans = 0;\\n        for (var x : details) {\\n            int age = Integer.parseInt(x.substring(11, 13));\\n            if (age > 60) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans = 0;\\n        for (var x : details) {\\n            int age = Integer.parseInt(x.substring(11, 13));\\n            if (age > 60) {\\n                ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083839,
                "title": "java-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\nint age=((details[i].charAt(11)-\\'0\\'))*10+(details[i].charAt(12))-\\'0\\';\\n    if(age>60)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\nint age=((details[i].charAt(11)-\\'0\\'))*10+(details[i].charAt(12))-\\'0\\';\\n    if(age>60)count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4082724,
                "title": "java-solution-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0 ;\\n\\n        for(String detail : details){\\n            int age = detail.charAt(12) - \\'0\\' ;\\n            age = 10 * (detail.charAt(11) - \\'0\\') + age ;\\n            if(age > 60){\\n                count++ ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0 ;\\n\\n        for(String detail : details){\\n            int age = detail.charAt(12) - \\'0\\' ;\\n            age = 10 * (detail.charAt(11) - \\'0\\') + age ;\\n            if(age > 60){\\n                count++ ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080968,
                "title": "my-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        suj=0\\n        for i in range(len(details)):\\n            if int(details[i][11]+details[i][12])>60:\\n                suj+=1\\n        return suj\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        suj=0\\n        for i in range(len(details)):\\n            if int(details[i][11]+details[i][12])>60:\\n                suj+=1\\n        return suj\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4080778,
                "title": "java-oms-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n            int count=0;\\n\\n        for (int i=0;i<details.length;i++)\\n        {\\n//checking if the passenger is 60 if not then then increse the count++\\n            if (details[i].charAt(11)==\\'6\\')\\n            {\\n                if (details[i].charAt(12)>\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                if (details[i].charAt(11)>\\'6\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n            int count=0;\\n\\n        for (int i=0;i<details.length;i++)\\n        {\\n//checking if the passenger is 60 if not then then increse the count++\\n            if (details[i].charAt(11)==\\'6\\')\\n            {\\n                if (details[i].charAt(12)>\\'0\\')\\n                {\\n                    count++;\\n                }\\n            }\\n            else\\n            {\\n                if (details[i].charAt(11)>\\'6\\')\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074837,
                "title": "java-easy-3-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i < details.length; i++) {\\n            if(Integer.parseInt(details[i].substring(11, 13)) > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i < details.length; i++) {\\n            if(Integer.parseInt(details[i].substring(11, 13)) > 60) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072872,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\n//  0-9 - phone \\n//  10 - gender\\n//  11-12 - age\\nvar countSeniors = function(details) {\\n    let count = 0\\n    details.forEach(passenger => {\\n        if(parseInt(passenger[11]+passenger[12]) > 60){\\n            count++;\\n        }\\n    })\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\n//  0-9 - phone \\n//  10 - gender\\n//  11-12 - age\\nvar countSeniors = function(details) {\\n    let count = 0\\n    details.forEach(passenger => {\\n        if(parseInt(passenger[11]+passenger[12]) > 60){\\n            count++;\\n        }\\n    })\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4071544,
                "title": "easy-java-solution-100-beats-5-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int answer =0;\\n        for(String detail:details){\\n            int age = detail.charAt(11)-\\'0\\';\\n            age = age*10 + detail.charAt(12)-\\'0\\';\\n            if(age > 60) answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int answer =0;\\n        for(String detail:details){\\n            int age = detail.charAt(11)-\\'0\\';\\n            age = age*10 + detail.charAt(12)-\\'0\\';\\n            if(age > 60) answer++;\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070795,
                "title": "solution-by-latif-problem-no-2678-number-of-senior-citizens",
                "content": "# Approach\\n1) First, we need to slice the age from all the given string in array\\n2) Then we need to store all the sliced string into another new string array (here I used store[])\\n3) Now, convert all the sliced string into integer by using parseInt technique\\n4) After converting string to integer, count those integers which is greater than 60 (here I used \\'result\\' to count)\\n5) Return the result\\n\\n# Runtime - 1ms\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int result = 0;\\n        String[] store = new String[details.length];\\n        for(int i=0;i<store.length;i++){\\n            store[i] = details[i].substring(11,13);\\n        }\\n        int[] arr = convert(store);\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] > 60){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int[] convert(String[] store){\\n        int[] arr = new int[store.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = Integer.parseInt(store[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int result = 0;\\n        String[] store = new String[details.length];\\n        for(int i=0;i<store.length;i++){\\n            store[i] = details[i].substring(11,13);\\n        }\\n        int[] arr = convert(store);\\n        for(int i=0;i<arr.length;i++){\\n            if(arr[i] > 60){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n    \\n    public int[] convert(String[] store){\\n        int[] arr = new int[store.length];\\n        for(int i=0;i<arr.length;i++){\\n            arr[i] = Integer.parseInt(store[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4068712,
                "title": "very-simple-code-dead-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        String s;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            s=details[i].substring(11,13);\\n            if(Integer.valueOf(s)>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        String s;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            s=details[i].substring(11,13);\\n            if(Integer.valueOf(s)>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067997,
                "title": "java-0-ms-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe know that the age digits are at the 11th and 12th index of the string so compare the ascii values for >60.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n       for(int i=0;i<details.length;i++){\\n\\n       if((details[i].charAt(11)>54)){\\n           c++;\\n       }\\n       if((details[i].charAt(11)==54)&&(details[i].charAt(12)>48))\\n        c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n       for(int i=0;i<details.length;i++){\\n\\n       if((details[i].charAt(11)>54)){\\n           c++;\\n       }\\n       if((details[i].charAt(11)==54)&&(details[i].charAt(12)>48))\\n        c++;\\n       }\\n       return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067604,
                "title": "python-simple-approach-beats-96-17-ms-13-4-mb-string-slicing",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4067531,
                "title": "python-simple-approach-beats-96-17ms-13-36-mb",
                "content": "# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        \"\"\"\\n        :type details: List[str]\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for passenger in details:\\n            if int(passenger[-4:-2]) > 60:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4066002,
                "title": "python3-simple-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for val in details:\\n            if int(val[11:13]) > 60:  # [11: 13-1] \\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for val in details:\\n            if int(val[11:13]) > 60:  # [11: 13-1] \\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065367,
                "title": "python3-solution-with-using-position-calculating",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        res = 0\\n        for detail in details:\\n            if int(detail[11:len(detail) - 2]) > 60: res += 1\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        res = 0\\n        for detail in details:\\n            if int(detail[11:len(detail) - 2]) > 60: res += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055914,
                "title": "java-easy-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n        int count = 0;\\n        int age;\\n        for(String x : details) {\\n            age = (x.charAt(11) - \\'0\\') * 10 + x.charAt(12) - \\'0\\';\\n            count += age > 60 ? 1 : 0;\\n            \\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055231,
                "title": "beats-96-in-memory-python3-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        c=0\\n        for ele in details:\\n            if int(ele[-4:-2])>60:\\n                c+=1\\n        return c\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        c=0\\n        for ele in details:\\n            if int(ele[-4:-2])>60:\\n                c+=1\\n        return c\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055077,
                "title": "simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n   func countSeniors(_ details: [String]) -> Int {\\n    var str = details\\n    \\n    for i in 0..<details.count {\\n        str[i].removeFirst(11)\\n        str[i].removeLast(2)\\n    }\\n    \\n    let result = str.filter { Int($0)! > 60 }.count\\n    \\n    return result\\n}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n   func countSeniors(_ details: [String]) -> Int {\\n    var str = details\\n    \\n    for i in 0..<details.count {\\n        str[i].removeFirst(11)\\n        str[i].removeLast(2)\\n    }\\n    \\n    let result = str.filter { Int($0)! > 60 }.count\\n    \\n    return result\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4053108,
                "title": "easy-solution",
                "content": "# 1ms\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int noOfSeniorCitizens = 0;\\n        for(String  detail: details){\\n            if(Integer.parseInt(detail.substring(11,13)) > 60)\\n               noOfSeniorCitizens++; \\n        }\\n        return noOfSeniorCitizens;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int noOfSeniorCitizens = 0;\\n        for(String  detail: details){\\n            if(Integer.parseInt(detail.substring(11,13)) > 60)\\n               noOfSeniorCitizens++; \\n        }\\n        return noOfSeniorCitizens;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4049260,
                "title": "java-straightforward",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String s : details) {\\n            int age = Integer.parseInt(s.substring(11, 13));\\n            if (age > 60) count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for (String s : details) {\\n            int age = Integer.parseInt(s.substring(11, 13));\\n            if (age > 60) count++;\\n        }\\n        return count;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048585,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count=0\\n        for i in details:\\n            a=i[11:13]\\n            \\n            if a>\\'60\\':\\n                count+=1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count=0\\n        for i in details:\\n            a=i[11:13]\\n            \\n            if a>\\'60\\':\\n                count+=1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4048431,
                "title": "const-js-ts-single-line-solution-great-explanation",
                "content": "This code defines a TypeScript function `countSeniors` that takes an array of strings called `details` as its input. Each string in the `details` array is assumed to represent some kind of information. The goal of this function is to count the number of seniors in the given `details` array based on some criteria.\\n\\nHere\\'s a breakdown of the code and an analysis of its time and space complexity:\\n\\n```typescript\\nfunction countSeniors(details: string[]): number {\\n    return details.reduce((acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc, 0);\\n};\\n```\\n\\n1. `details.reduce(...)`: This line uses the `reduce` method to iterate through the `details` array, accumulating a count of seniors. The `reduce` method applies a given function to each element of the array and maintains an accumulator (`acc`) to keep track of the count.\\n\\n2. `(acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc`: This is the function that is called for each element in the `details` array during the reduction process. It takes two parameters: `acc` (the accumulator) and `curr` (the current element being processed).\\n\\n   - `curr.slice(11, 13)`: This extracts a substring of `curr` from index 11 to 12 (inclusive). This assumes that the format of each string in the `details` array is such that characters at index 11 and 12 represent the age of the person.\\n   \\n   - `+curr.slice(11, 13) > 60`: This converts the extracted substring to a number and checks if it\\'s greater than 60, indicating that the person is a senior.\\n\\n   - If the condition is true (`+curr.slice(11, 13) > 60`), it increments the accumulator (`acc + 1`); otherwise, it leaves the accumulator unchanged (`acc`).\\n\\n3. The `reduce` method starts with an initial accumulator value of `0` (`0` is the second argument to `reduce`).\\n\\nTime Complexity:\\n- The `reduce` method iterates through each element in the `details` array exactly once. For each element, it performs some constant-time operations, including slicing the string and comparing the age to 60. Therefore, the time complexity of this function is O(n), where n is the number of elements in the `details` array.\\n\\nSpace Complexity:\\n- The space complexity is O(1) because the function uses a constant amount of memory regardless of the size of the `details` array. It doesn\\'t create any additional data structures that grow with the input size.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction countSeniors(details: string[]): number {\\n    return details.reduce((acc, curr) => +curr.slice(11, 13) > 60 ? acc + 1 : acc, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4047622,
                "title": "220103354",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int index = 0;\\n        for(String str: details){\\n            String s = str.substring(11, 13);\\n            int age = Integer.parseInt(s);\\n            if (age>60){index++;}\\n        }\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int index = 0;\\n        for(String str: details){\\n            String s = str.substring(11, 13);\\n            int age = Integer.parseInt(s);\\n            if (age>60){index++;}\\n        }\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047503,
                "title": "220103341",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n         int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n         int count = 0;\\n        for(String i : details){\\n        int age_of_passengers = Integer.parseInt(i.substring(11,13));\\n        \\n            if(age_of_passengers > 60) \\n                count++;\\n        \\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4047462,
                "title": "220103086",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for (String detail : details) {\\n            int jas = Integer.parseInt(detail.substring(11, 13));\\n            if (jas > 60) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        \\n        for (String detail : details) {\\n            int jas = Integer.parseInt(detail.substring(11, 13));\\n            if (jas > 60) {\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4044156,
                "title": "simple-and-easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n  Using wrapper classes converting string into integer and thus finding the solution\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp = details[i];\\n            int age = Integer.parseInt(temp.substring(11,13));\\n            if(age>60)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c=0;\\n        for(int i=0;i<details.length;i++)\\n        {\\n            String temp = details[i];\\n            int age = Integer.parseInt(temp.substring(11,13));\\n            if(age>60)\\n            {\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041383,
                "title": "java-simple-python-solution-for-beginners-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            int val1=Integer.valueOf(details[i].substring(11,13));\\n            if(val1>60){\\n                ans=ans+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            int val1=Integer.valueOf(details[i].substring(11,13));\\n            if(val1>60){\\n                ans=ans+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4039864,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if( ((10*(details[i].charAt(11)-\\'0\\'))+details[i].charAt(12)-\\'0\\')>60){\\n                ans+=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            if( ((10*(details[i].charAt(11)-\\'0\\'))+details[i].charAt(12)-\\'0\\')>60){\\n                ans+=1;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4036012,
                "title": "sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nQuestion itself is very clear no need to think any thing\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt was straigth forward to convert the substring into int and check the condition and return the result\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int r=0;\\n        int x=0;\\n        for(String s : details){\\n            x = Integer.parseInt(s.substring(11,13));\\n            if(x>60){\\n                r++;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int r=0;\\n        int x=0;\\n        for(String s : details){\\n            x = Integer.parseInt(s.substring(11,13));\\n            if(x>60){\\n                r++;\\n            }\\n        }\\n        return r;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035266,
                "title": "very-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int seniors = 0;\\n        for(String s : details){\\n            int age = Integer.parseInt(s.substring(11,13));\\n            if(age > 60)\\n            seniors++;\\n        }\\n        return seniors;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int seniors = 0;\\n        for(String s : details){\\n            int age = Integer.parseInt(s.substring(11,13));\\n            if(age > 60)\\n            seniors++;\\n        }\\n        return seniors;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4030940,
                "title": "easy-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String e:details)\\n        {\\n            int num1=Integer.parseInt(String.valueOf(e.charAt(11)));\\n            int num2=Integer.parseInt(String.valueOf(e.charAt(12)));\\n            int age=num1*10+num2;\\n            if(age>60)\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(String e:details)\\n        {\\n            int num1=Integer.parseInt(String.valueOf(e.charAt(11)));\\n            int num2=Integer.parseInt(String.valueOf(e.charAt(12)));\\n            int age=num1*10+num2;\\n            if(age>60)\\n            count++;\\n        }\\n        return count;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028536,
                "title": "python-one-line",
                "content": "# Approach\\nThis is not difficult. It was first try. I am open for a better suggestions.\\n\\n# Stats\\n- Runtime: 47ms, beats 85.59% of users with Python3\\n\\n- Memory: 16.34MB, beats 40.75% of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return len([int(age[11:13]) for age in details if int(age[11:13]) > 60])\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return len([int(age[11:13]) for age in details if int(age[11:13]) > 60])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022884,
                "title": "java-simple-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            \\n         if(((details[i].charAt(11) - \\'0\\' == 6) && \\n         (details[i].charAt(12) - \\'0\\' > 0) )  || \\n         (details[i].charAt(11) - \\'0\\' > 6) )  {\\n                count++;\\n         }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n\\n        for(int i=0; i<details.length; i++){\\n            \\n         if(((details[i].charAt(11) - \\'0\\' == 6) && \\n         (details[i].charAt(12) - \\'0\\' > 0) )  || \\n         (details[i].charAt(11) - \\'0\\' > 6) )  {\\n                count++;\\n         }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021461,
                "title": "c-foreach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let res = 0;\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13);\\n        if(age > 60){\\n            res++;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let res = 0;\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13);\\n        if(age > 60){\\n            res++;\\n        }\\n    });\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4019391,
                "title": "very-very-easy-solution-in-c-using-substr",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> string problem so think all parameter about string \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto it: details)\\n            if (stoi(it.substr(11, 2)) > 60) \\n            res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int res = 0;\\n        for (auto it: details)\\n            if (stoi(it.substr(11, 2)) > 60) \\n            res++;\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018400,
                "title": "beats-100-very-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for( int i = 0; i < details.length; i++ ){\\n            if(details[i].charAt(11) >= \\'6\\'  ){\\n                if(details[i].charAt(11) == \\'6\\' && details[i].charAt(12) < \\'1\\' )\\n                continue;\\n                else\\n                count++;\\n            }\\n            \\n        } \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for( int i = 0; i < details.length; i++ ){\\n            if(details[i].charAt(11) >= \\'6\\'  ){\\n                if(details[i].charAt(11) == \\'6\\' && details[i].charAt(12) < \\'1\\' )\\n                continue;\\n                else\\n                count++;\\n            }\\n            \\n        } \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017451,
                "title": "one-liner-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {int a=0;\\n        for(int i=0;i<details.length;i++){\\n            if(((details[i].charAt(11)-\\'0\\')*10+details[i].charAt(12)-\\'0\\')>60)a++;\\n        }\\n                return a;                        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {int a=0;\\n        for(int i=0;i<details.length;i++){\\n            if(((details[i].charAt(11)-\\'0\\')*10+details[i].charAt(12)-\\'0\\')>60)a++;\\n        }\\n                return a;                        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016636,
                "title": "easy-way-to-understanding-the-program-beginners-friendly-2-ms",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] a) {\\n\\n\\n        int count=0;\\n\\t\\t//String []a={\"1313579440F2036\",\"2921522980M5644\"};\\n\\t\\tfor(int i=0;i<a.length;i++)\\n\\t\\t{\\n\\t\\t\\tString c=\"\";\\n\\t\\t\\tc=c+a[i].charAt(11);\\n\\t\\t\\tc=c+a[i].charAt(12);\\n\\t\\t\\tint d=Integer.parseInt(c);\\n\\t\\t\\tif(d>60)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] a) {\\n\\n\\n        int count=0;\\n\\t\\t//String []a={\"1313579440F2036\",\"2921522980M5644\"};\\n\\t\\tfor(int i=0;i<a.length;i++)\\n\\t\\t{\\n\\t\\t\\tString c=\"\";\\n\\t\\t\\tc=c+a[i].charAt(11);\\n\\t\\t\\tc=c+a[i].charAt(12);\\n\\t\\t\\tint d=Integer.parseInt(c);\\n\\t\\t\\tif(d>60)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4014570,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count = 0\\n\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13)\\n        if(+age > 60) count++\\n    })\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count = 0\\n\\n    details.forEach((detail) => {\\n        let age = detail.slice(11, 13)\\n        if(+age > 60) count++\\n    })\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011615,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countSeniors(List<String> details) {\\n  int result = 0;\\n  for (int i = 0; i < details.length; i++) {\\n    if (int.parse(details[i][11]) >= 6 && int.parse(details[i][12]) > 0||\\n        int.parse(details[i][11]) > 6) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countSeniors(List<String> details) {\\n  int result = 0;\\n  for (int i = 0; i < details.length; i++) {\\n    if (int.parse(details[i][11]) >= 6 && int.parse(details[i][12]) > 0||\\n        int.parse(details[i][11]) > 6) {\\n      result++;\\n    }\\n  }\\n  return result;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010237,
                "title": "90-easy-js-solution",
                "content": "# Code\\n```\\nfor: \\nvar countSeniors = function (details) {\\n  let count = 0;\\n\\n  for (let i = 0; i < details.length; i++) {\\n    let age = details[i].slice(11, 13);\\n    if (age > 60) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n\\nreduce: \\nconst countSeniors = (details) => {\\n  return details.reduce((count, detail) => {\\n    const age = Number(detail.slice(11, 13));\\n    return age > 60 ? count + 1 : count;\\n  }, 0);\\n};\\n\\n\\nforEach: \\nconst countSeniors = (details) => {\\n  let count = 0;\\n\\n  details.forEach((person) => {\\n    let age = person.slice(11, 13);\\n    return age > 60 ? count++ : count;\\n  });\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfor: \\nvar countSeniors = function (details) {\\n  let count = 0;\\n\\n  for (let i = 0; i < details.length; i++) {\\n    let age = details[i].slice(11, 13);\\n    if (age > 60) {\\n      count++;\\n    }\\n  }\\n  return count;\\n};\\n\\n\\nreduce: \\nconst countSeniors = (details) => {\\n  return details.reduce((count, detail) => {\\n    const age = Number(detail.slice(11, 13));\\n    return age > 60 ? count + 1 : count;\\n  }, 0);\\n};\\n\\n\\nforEach: \\nconst countSeniors = (details) => {\\n  let count = 0;\\n\\n  details.forEach((person) => {\\n    let age = person.slice(11, 13);\\n    return age > 60 ? count++ : count;\\n  });\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4008719,
                "title": "typescript-javascript-solution",
                "content": "```\\nfunction countSeniors(details: string[]): number {\\n    const ages: string[] = details.filter(id => +id.slice(-4, -2) > 60);\\n    return ages.length;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction countSeniors(details: string[]): number {\\n    const ages: string[] = details.filter(id => +id.slice(-4, -2) > 60);\\n    return ages.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007036,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++)\\n        {\\n            string s=details[i];\\n            if ((s[11]>=\\'6\\' && s[12]>\\'0\\') || s[11]>\\'6\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++)\\n        {\\n            string s=details[i];\\n            if ((s[11]>=\\'6\\' && s[12]>\\'0\\') || s[11]>\\'6\\')\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005503,
                "title": "world-easy-solution-in-js-anyone-can-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let number = 0;\\n    for (let i = 0; i<details.length ; i++){\\n        let x = checkage(details[i]);\\n        if(x){\\n            number++;\\n        }\\n    }\\n    return number;\\n};\\nfunction checkage(detail)\\n{\\n    // console.log(detail[12]);\\n    if(detail[11]==6){\\n        if(detail[12]>0){\\n            return true;\\n        }\\n        // return true;\\n    }else if(detail[11]>6){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let number = 0;\\n    for (let i = 0; i<details.length ; i++){\\n        let x = checkage(details[i]);\\n        if(x){\\n            number++;\\n        }\\n    }\\n    return number;\\n};\\nfunction checkage(detail)\\n{\\n    // console.log(detail[12]);\\n    if(detail[11]==6){\\n        if(detail[12]>0){\\n            return true;\\n        }\\n        // return true;\\n    }else if(detail[11]>6){\\n        return true;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4003470,
                "title": "elixir-simple-solution",
                "content": "```\\ndefmodule Solution do\\n  @spec count_seniors(details :: [String.t()]) :: integer\\n  def count_seniors(details) do\\n    details\\n    |> Enum.reduce(0, fn d, acc ->\\n      age = d |> String.slice(11..12) |> String.to_integer()\\n\\n      if age > 60 do\\n        acc + 1\\n      else\\n        acc\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\ndefmodule Solution do\\n  @spec count_seniors(details :: [String.t()]) :: integer\\n  def count_seniors(details) do\\n    details\\n    |> Enum.reduce(0, fn d, acc ->\\n      age = d |> String.slice(11..12) |> String.to_integer()\\n\\n      if age > 60 do\\n        acc + 1\\n      else\\n        acc\\n      end\\n    end)\\n  end\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4000912,
                "title": "4ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++){\\n            if (details[i].substr(11,2)>\"60\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count=0;\\n        for (int i=0;i<details.size();i++){\\n            if (details[i].substr(11,2)>\"60\"){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999519,
                "title": "easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        a = 0\\n        for i in details:\\n            b = int(i[11:13])\\n            if b > 60:\\n                a+=1\\n        return a\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        a = 0\\n        for i in details:\\n            b = int(i[11:13])\\n            if b > 60:\\n                a+=1\\n        return a\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3992134,
                "title": "easy-solution-in-java-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i<details.length; i++){\\n            String s = details[i];\\n            if(((s.charAt(11)-\\'0\\')*10) + (s.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(int i = 0; i<details.length; i++){\\n            String s = details[i];\\n            if(((s.charAt(11)-\\'0\\')*10) + (s.charAt(12)-\\'0\\')>60)\\n                count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984916,
                "title": "c-solution-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(string& st:details){\\n            cnt+=(st[11]> \\'6\\' || st[11]==\\'6\\' && st[12]>\\'0\\');\\n        }\\n        return   cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt=0;\\n        for(string& st:details){\\n            cnt+=(st[11]> \\'6\\' || st[11]==\\'6\\' && st[12]>\\'0\\');\\n        }\\n        return   cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984009,
                "title": "java-easy-solution-optimised",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        String s=\"\";\\n        int count=0;\\n        for(int i=0;i<d.length;i++){\\n             String a=d[i];\\n             s=a.substring(11,13);\\n             int n=Integer.parseInt(s);\\n              if(n>60){\\n                  count++;\\n              }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] d) {\\n        String s=\"\";\\n        int count=0;\\n        for(int i=0;i<d.length;i++){\\n             String a=d[i];\\n             s=a.substring(11,13);\\n             int n=Integer.parseInt(s);\\n              if(n>60){\\n                  count++;\\n              }\\n        }\\n       return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982087,
                "title": "javascript-simple-filter",
                "content": "# Code\\n```\\nvar countSeniors = function(details) {\\n    return details.filter(d => +d.substr(11, 2) > 60).length;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar countSeniors = function(details) {\\n    return details.filter(d => +d.substr(11, 2) > 60).length;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3981769,
                "title": "solution-for-number-of-senior-citizens",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        {\\n            for(int i=0;i<details.length;i++)\\n            {\\n                int greater=Integer.parseInt(details[i].substring(11,13));\\n                if(greater>60)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        {\\n            for(int i=0;i<details.length;i++)\\n            {\\n                int greater=Integer.parseInt(details[i].substring(11,13));\\n                if(greater>60)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981337,
                "title": "fastest-34ms-runtime-python-easy-to-understand-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBrute Force Approach\\n\\n# Complexity\\n- Time  complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for citizen in details:\\n            age = citizen[11:13]\\n            if int(age) > 60:\\n                count += 1\\n        return count\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for citizen in details:\\n            age = citizen[11:13]\\n            if int(age) > 60:\\n                count += 1\\n        return count\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977496,
                "title": "c-beats-94-86-in-time-complexity-and-80-89-in-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(string s: details)\\n        {\\n            if(s[11]>\\'6\\' || (s[11]==\\'6\\' && s[12]>\\'0\\')){ans++;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans=0;\\n        for(string s: details)\\n        {\\n            if(s[11]>\\'6\\' || (s[11]==\\'6\\' && s[12]>\\'0\\')){ans++;}\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977325,
                "title": "c-beats-100-using-std-string-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(std::string &str : details) { \\n            int temp = std::stoi(str.substr(11, 2));\\n            if(temp > 60) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(std::string &str : details) { \\n            int temp = std::stoi(str.substr(11, 2));\\n            if(temp > 60) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3975290,
                "title": "java-1-ms-beats-96-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c = 0;\\n        for(int i=0; i<details.length; i++){\\n            if((details[i].charAt(11)-\\'0\\')*10+(details[i].charAt(12)-\\'0\\') > 60)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int c = 0;\\n        for(int i=0; i<details.length; i++){\\n            if((details[i].charAt(11)-\\'0\\')*10+(details[i].charAt(12)-\\'0\\') > 60)\\n                c++;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3972473,
                "title": "age-checking-easy-to-understand-intuition-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    boolean ageC(String s){\\n        int i=0;\\n        int len = s.length();\\n        String st=\"\";\\n        for(i=0; i<len-1; i++){\\n            if(s.charAt(i)==\\'M\\' || s.charAt(i)==\\'F\\' || s.charAt(i)==\\'O\\'){\\n                st = Character.toString(s.charAt(i+1))+Character.toString(s.charAt(i+2));\\n                break; \\n            }\\n        }\\n        if(st==\"\"){\\n            return false;\\n        }\\n        return Integer.parseInt(st)>60;\\n    }\\n\\n    public int countSeniors(String[] d) {/*\\n        int count=0;\\n        for(int i=0; i<details.length; i++){\\n            int c;\\n            for(int j=0; j<details[i].length(); j++){\\n                if(details[i].charAt(j)==\\'M\\'){\\n                    String s1 = Character.toString(details.charAt(j+1));\\n                    String s2 = Character.toString(details.charAt(j+2));\\n                    break;\\n                }\\n            }\\n            if(Integer.parseInt(s1)+ Integer.parseInt(s2) > 60){\\n                count++;\\n            }\\n        }\\n        return count;*/\\n\\n        int count=0;\\n        for(int i=0; i<d.length; i++){\\n            if(ageC(d[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    boolean ageC(String s){\\n        int i=0;\\n        int len = s.length();\\n        String st=\"\";\\n        for(i=0; i<len-1; i++){\\n            if(s.charAt(i)==\\'M\\' || s.charAt(i)==\\'F\\' || s.charAt(i)==\\'O\\'){\\n                st = Character.toString(s.charAt(i+1))+Character.toString(s.charAt(i+2));\\n                break; \\n            }\\n        }\\n        if(st==\"\"){\\n            return false;\\n        }\\n        return Integer.parseInt(st)>60;\\n    }\\n\\n    public int countSeniors(String[] d) {/*\\n        int count=0;\\n        for(int i=0; i<details.length; i++){\\n            int c;\\n            for(int j=0; j<details[i].length(); j++){\\n                if(details[i].charAt(j)==\\'M\\'){\\n                    String s1 = Character.toString(details.charAt(j+1));\\n                    String s2 = Character.toString(details.charAt(j+2));\\n                    break;\\n                }\\n            }\\n            if(Integer.parseInt(s1)+ Integer.parseInt(s2) > 60){\\n                count++;\\n            }\\n        }\\n        return count;*/\\n\\n        int count=0;\\n        for(int i=0; i<d.length; i++){\\n            if(ageC(d[i])){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970930,
                "title": "easy-c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        unsigned int ret = 0;\\n        for (const auto& detail : details)\\n        {\\n            ret += std::stoi(detail.substr(11,2)) > 60;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        unsigned int ret = 0;\\n        for (const auto& detail : details)\\n        {\\n            ret += std::stoi(detail.substr(11,2)) > 60;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963287,
                "title": "c-easy-and-readable-solution-less-than-88",
                "content": "![image.png](https://assets.leetcode.com/users/images/2bdc6c1f-0c16-45dc-864f-a5c0e540e4a1_1693061554.2383866.png)\\n\\n**Don\\'t hesitate to suggest or ask bellow about something that you don\\'t understand**\\n\\n```\\npublic class Solution {\\n    public int CountSeniors(string[] details) {\\n        int counter = 0;\\n        foreach (string d in details)\\n            if (Convert.ToInt32(d.Substring(11, 2)) > 60)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```\\n\\nIf you like it don\\'t forget to **upvote!**",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountSeniors(string[] details) {\\n        int counter = 0;\\n        foreach (string d in details)\\n            if (Convert.ToInt32(d.Substring(11, 2)) > 60)\\n                counter++;\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961404,
                "title": "c-very-simple-solution-runtime-3-ms-beats-95-34-memory-13-5-mb-beats-32-91",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            int age = (details[i][11] - \\'0\\')*10 + (details[i][12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int ans = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            int age = (details[i][11] - \\'0\\')*10 + (details[i][12] - \\'0\\');\\n            if(age > 60) ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960949,
                "title": "by-using-ascii-value-without-typecasting-and-one-more-thing-all-beginners-in-a-easy-way-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n        if((details[i].charAt(11)>=54) && details[i].charAt(12)>=48){\\n            //System.out.print(details[i].charAt(11)+\"\"+count);\\n            count++;\\n        }if(details[i].charAt(11)==54&& (details[i].charAt(12)==48)){\\n            count--;\\n        }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n        if((details[i].charAt(11)>=54) && details[i].charAt(12)>=48){\\n            //System.out.print(details[i].charAt(11)+\"\"+count);\\n            count++;\\n        }if(details[i].charAt(11)==54&& (details[i].charAt(12)==48)){\\n            count--;\\n        }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3959879,
                "title": "java-easy-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n      int count=0;\\n\\n       for(int i=0;i<details.length;i++){\\n    \\n     char a=details[i].charAt(11);\\n      char b=details[i].charAt(12);\\n\\n      int a1=a-\\'0\\';\\n      int b1=b-\\'0\\';\\n\\n      int c=a1*10+b1;\\n\\n      if(c>60){\\n          count++;\\n      }\\n\\n       } return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n\\n      int count=0;\\n\\n       for(int i=0;i<details.length;i++){\\n    \\n     char a=details[i].charAt(11);\\n      char b=details[i].charAt(12);\\n\\n      int a1=a-\\'0\\';\\n      int b1=b-\\'0\\';\\n\\n      int c=a1*10+b1;\\n\\n      if(c>60){\\n          count++;\\n      }\\n\\n       } return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3954187,
                "title": "very-clear-and-easy-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for detail in details:\\n            if detail[11:13] > \"60\":\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        count = 0\\n        for detail in details:\\n            if detail[11:13] > \"60\":\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953765,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int x = 0;\\n        String s = \"\";\\n        String str = \"\";\\n        for(String i:details){\\n            s = s + i;\\n        }\\n        int count = 0;\\n        int p = 1;\\n        int q = 2;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'M\\'|| s.charAt(i)==\\'F\\'||s.charAt(i)==\\'O\\'){\\n                str = str+ s.charAt(i+1) + s.charAt(i+2);\\n                x = Integer.parseInt(str);\\n                System.out.println(x);\\n                if(x>60){\\n                    count = count+1;\\n                }\\n            }\\n            str = \"\";\\n            p++;\\n            q++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int x = 0;\\n        String s = \"\";\\n        String str = \"\";\\n        for(String i:details){\\n            s = s + i;\\n        }\\n        int count = 0;\\n        int p = 1;\\n        int q = 2;\\n        for(int i=0;i<s.length();i++){\\n            \\n            if(s.charAt(i)==\\'M\\'|| s.charAt(i)==\\'F\\'||s.charAt(i)==\\'O\\'){\\n                str = str+ s.charAt(i+1) + s.charAt(i+2);\\n                x = Integer.parseInt(str);\\n                System.out.println(x);\\n                if(x>60){\\n                    count = count+1;\\n                }\\n            }\\n            str = \"\";\\n            p++;\\n            q++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953533,
                "title": "countseniors-brute-force-beginner-friendly",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(1) - constant space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto it:details){\\n            int num = (it[11]-\\'0\\')*10 + (it[12]-\\'0\\');\\n            if(num>60)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int count = 0;\\n        for(auto it:details){\\n            int num = (it[11]-\\'0\\')*10 + (it[12]-\\'0\\');\\n            if(num>60)  count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952955,
                "title": "java-solution-faster-than-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity : O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=details[i];\\n            int num=((s.charAt(11)-\\'0\\')*10)+(s.charAt(12)-\\'0\\');\\n            if(num>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=details[i];\\n            int num=((s.charAt(11)-\\'0\\')*10)+(s.charAt(12)-\\'0\\');\\n            if(num>60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952379,
                "title": "python-one-liner",
                "content": "# Code\\n```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum([1 for detail in details if int(detail[11:13])>60])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countSeniors(self, details: List[str]) -> int:\\n        return sum([1 for detail in details if int(detail[11:13])>60])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948609,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n*Simply we store 11th and 12th element into one variable and check it greater than 60 or not if greater then count increases. \\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n     int ans=0;\\n     int count=0;\\n     for(auto it:details){\\n        ans=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n         if(ans>60){\\n             count++;\\n         }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n     int ans=0;\\n     int count=0;\\n     for(auto it:details){\\n        ans=(it[11]-\\'0\\')*10+(it[12]-\\'0\\');\\n         if(ans>60){\\n             count++;\\n         }\\n    }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948332,
                "title": "most-easy-approach",
                "content": "# Intuition\\nNorth East University Bangladesh\\n\\n# Approach\\nBrute force\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt = 0;\\n        for(int i=0;i<details.size();i++)\\n        {\\n            string s = details[i];\\n            string str = \"\";\\n            str+=s[11];\\n            str+=s[12];\\n            int temp = stoi(str);\\n            if(temp>60)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int cnt = 0;\\n        for(int i=0;i<details.size();i++)\\n        {\\n            string s = details[i];\\n            string str = \"\";\\n            str+=s[11];\\n            str+=s[12];\\n            int temp = stoi(str);\\n            if(temp>60)\\n            {\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3947571,
                "title": "java-solution-substring-runtime-1ms",
                "content": "# Intuition\\nfetch age using substring()\\nconvert it into integer\\ncheck if it is >60\\nreturn the count of senior passenger\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details){\\n           if(Integer.parseInt(s.substring(11,13))>60){\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details){\\n           if(Integer.parseInt(s.substring(11,13))>60){\\n               count++;\\n           }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945080,
                "title": "1ms-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n    \\n        int count=0;\\n      for(int i=0;i<details.length;i++){\\n        int a=Integer.parseInt(details[i].substring(11,13));\\n          if(a>60){\\n              count++;\\n          }\\n      }  \\n      return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n    \\n        int count=0;\\n      for(int i=0;i<details.length;i++){\\n        int a=Integer.parseInt(details[i].substring(11,13));\\n          if(a>60){\\n              count++;\\n          }\\n      }  \\n      return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3935054,
                "title": "javascript-single-line-declarative-and-functionaly-solution-beats-99-58",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => +detail.slice(11, -2) > 60).length\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    return details.filter(detail => +detail.slice(11, -2) > 60).length\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931301,
                "title": "substring-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n            int ct=0;\\n        for(auto it:details)\\n         {\\n             //first 10 ignore\\n             //next denote gender\\n             //age\\n             int ind=11;\\n             int age=stoi(it.substr(ind,2));\\n             cout<<age<<\" \";\\n             if(age>60)\\n             ct++;\\n\\n         }\\n         return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n            int ct=0;\\n        for(auto it:details)\\n         {\\n             //first 10 ignore\\n             //next denote gender\\n             //age\\n             int ind=11;\\n             int age=stoi(it.substr(ind,2));\\n             cout<<age<<\" \";\\n             if(age>60)\\n             ct++;\\n\\n         }\\n         return ct;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3922531,
                "title": "easy-solution-using-java",
                "content": "\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s:details){\\n            int a = (s.charAt(11) - \\'0\\') * 10 + s.charAt(12) - \\'0\\';\\n            if(a > 60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count = 0;\\n        for(String s:details){\\n            int a = (s.charAt(11) - \\'0\\') * 10 + s.charAt(12) - \\'0\\';\\n            if(a > 60){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919334,
                "title": "easy-python",
                "content": "# Intuition\\nGet the age out of the string and count\\n\\n# Approach\\nNothing to explain\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count=0\\n        for item in details:\\n            age = int(item[11:13])\\n            if age > 60:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count=0\\n        for item in details:\\n            age = int(item[11:13])\\n            if age > 60:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3919283,
                "title": "python-beats-98-runtime-99-memory-coded-on-mobile",
                "content": "![image](https://assets.leetcode.com/users/images/0c60d744-f23d-4692-971a-a8f6b1cd6ea2_1692209121.3218896.jpeg)\\n![image](https://assets.leetcode.com/users/images/51973d5e-2448-4517-bd35-27f30f70ae27_1692209121.2971199.jpeg)\\n\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/0c60d744-f23d-4692-971a-a8f6b1cd6ea2_1692209121.3218896.jpeg)\\n![image](https://assets.leetcode.com/users/images/51973d5e-2448-4517-bd35-27f30f70ae27_1692209121.2971199.jpeg)\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3919246,
                "title": "easiest-solution-in-java",
                "content": ">\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        \\n        int sc = 0;\\n        for(int i =0;i<details.length;i++)\\n        {\\n            String str = details[i];\\n            int age = Integer.parseInt(str.substring(11,13));\\n            if(age>60)\\n            sc++;\\n        }\\n\\n        return sc;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        \\n        int sc = 0;\\n        for(int i =0;i<details.length;i++)\\n        {\\n            String str = details[i];\\n            int age = Integer.parseInt(str.substring(11,13));\\n            if(age>60)\\n            sc++;\\n        }\\n\\n        return sc;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917656,
                "title": "javascript-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Dev Bhayani\\n//16/08/2023\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count=0;\\n    for(let i=0;i<details.length;i++){\\n        let age=details[i].substring(11,13)\\n        if(parseInt(age)>60){\\n            count++;\\n        }\\n        console.log(age)\\n        // if(parseInt(,10)>60){\\n        //     count++;\\n        // }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//Dev Bhayani\\n//16/08/2023\\n/**\\n * @param {string[]} details\\n * @return {number}\\n */\\nvar countSeniors = function(details) {\\n    let count=0;\\n    for(let i=0;i<details.length;i++){\\n        let age=details[i].substring(11,13)\\n        if(parseInt(age)>60){\\n            count++;\\n        }\\n        console.log(age)\\n        // if(parseInt(,10)>60){\\n        //     count++;\\n        // }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3917550,
                "title": "java-2-solution-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int max = 0 , ans = 0;\\n        for(String i : details){\\n            max = (i.charAt(11)-\\'0\\')*10 + (i.charAt(12)-\\'0\\');\\n            if(max > 60) ans++;          \\n        }\\n        return ans;\\n    }\\n}          \\n//                 Another solution\\n        // int ans = 0;\\n        // for(String i : details){\\n        //     String d = i.substring(11,13);\\n        //     int s = Integer.parseInt(d);\\n        //     if(s>60) ans++;\\n        // }\\n        // return ans;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int max = 0 , ans = 0;\\n        for(String i : details){\\n            max = (i.charAt(11)-\\'0\\')*10 + (i.charAt(12)-\\'0\\');\\n            if(max > 60) ans++;          \\n        }\\n        return ans;\\n    }\\n}          \\n//                 Another solution\\n        // int ans = 0;\\n        // for(String i : details){\\n        //     String d = i.substring(11,13);\\n        //     int s = Integer.parseInt(d);\\n        //     if(s>60) ans++;\\n        // }\\n        // return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3917517,
                "title": "simple-solution-with-filter",
                "content": "# Code\\n```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n       return details.filter { detail in\\n            let ageStartIndex = detail.index(detail.startIndex, offsetBy: 11)\\n            let ageEndIndex = detail.index(ageStartIndex, offsetBy: 2)\\n            let ageString = detail[ageStartIndex..<ageEndIndex]\\n            return Int(ageString) ?? 0 > 60\\n        }.count \\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countSeniors(_ details: [String]) -> Int {\\n       return details.filter { detail in\\n            let ageStartIndex = detail.index(detail.startIndex, offsetBy: 11)\\n            let ageEndIndex = detail.index(ageStartIndex, offsetBy: 2)\\n            let ageString = detail[ageStartIndex..<ageEndIndex]\\n            return Int(ageString) ?? 0 > 60\\n        }.count \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916559,
                "title": "python-rust-solution",
                "content": "\\n# Code\\n\\nThe code block has solutions in both Python and Rust.\\n\\n```python []\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count = 0\\n        for detail in details:\\n            if int(detail[11:13]) > 60:\\n                count += 1\\n\\n        return count\\n```\\n```rust []\\nimpl Solution {\\n    pub fn count_seniors(details: Vec<String>) -> i32 {\\n        let mut count = 0;\\n        for detail in details.iter() {\\n            if detail.get(11..=12).unwrap().parse::<i32>().unwrap() > 60 {\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Rust"
                ],
                "code": "```python []\\nclass Solution(object):\\n    def countSeniors(self, details):\\n        count = 0\\n        for detail in details:\\n            if int(detail[11:13]) > 60:\\n                count += 1\\n\\n        return count\\n```\n```rust []\\nimpl Solution {\\n    pub fn count_seniors(details: Vec<String>) -> i32 {\\n        let mut count = 0;\\n        for detail in details.iter() {\\n            if detail.get(11..=12).unwrap().parse::<i32>().unwrap() > 60 {\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916292,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\niterate over each element and create a astring of that after that check combination of character is >60 if true add in ans else do nothing ..... .... ... .. .\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=\"\"+details[i];\\n            int a=s.charAt(s.length()-4)-\\'0\\';\\n                        int b=s.charAt(s.length()-3)-\\'0\\';\\n                        if((a*10)+b>60)\\n                        ans++;\\n\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int ans=0;\\n        for(int i=0;i<details.length;i++){\\n            String s=\"\"+details[i];\\n            int a=s.charAt(s.length()-4)-\\'0\\';\\n                        int b=s.charAt(s.length()-3)-\\'0\\';\\n                        if((a*10)+b>60)\\n                        ans++;\\n\\n        }\\n        return ans;\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910474,
                "title": "simple-dart",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n  int countSeniors(List<String> details) {\\n   int count=0;\\n   for(String s in details){\\n       if(int.parse(s[11])>=6&&int.parse(s[12])>0)\\n       {\\n           count++;\\n       }\\n       else if(int.parse(s[11])>6)\\n       count++;\\n   }\\n   return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int countSeniors(List<String> details) {\\n   int count=0;\\n   for(String s in details){\\n       if(int.parse(s[11])>=6&&int.parse(s[12])>0)\\n       {\\n           count++;\\n       }\\n       else if(int.parse(s[11])>6)\\n       count++;\\n   }\\n   return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3907788,
                "title": "the-native-solution-is-explained-in-detail-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code aims to count the number of senior passengers based on their ages from a vector of passenger details.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.The code defines a function countSeniors that takes a vector of strings (details) as input.\\n2.It initializes a counter variable (counter) to keep track of the number of senior passengers.\\n3.It iterates through each element (string) in the details vector using a loop.\\n4.For each passenger\\'s details, it extracts the age information from the string.\\n5.The age is extracted by converting the characters representing tens and units of age to integer values and combining them.\\n6.If the calculated age is greater than 60, the counter is incremented.\\n7.After iterating through all passenger details, the function returns the final count of senior passengers.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this code is determined by the loop that iterates through the details vector. Let n be the number of passenger details in the vector.\\n\\nThe loop runs n times, and for each iteration, a constant amount of work is done (extracting age and checking the condition). Therefore, the overall time complexity is O(n).\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this code is relatively low, as it only uses a few integer variables (counter, i, age) and a string (passenger) to temporarily store data.\\n\\nThe integer variables (counter, i, age) take constant space.\\nThe passenger string takes space proportional to the length of the longest passenger detail string.\\nTherefore, the space complexity of this code can be considered O(1) (constant space), given that the length of the longest passenger detail string is not significantly large compared to the number of passenger details.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        int counter = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            string passenger = details[i];\\n\\n            int age = (((passenger[11] - \\'0\\') * 10) + (passenger[12] - \\'0\\'));\\n\\n            if(age > 60) ++counter;\\n        }\\n\\n        return counter; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        \\n        int counter = 0;\\n        for(int i = 0; i < details.size(); ++i){\\n            string passenger = details[i];\\n\\n            int age = (((passenger[11] - \\'0\\') * 10) + (passenger[12] - \\'0\\'));\\n\\n            if(age > 60) ++counter;\\n        }\\n\\n        return counter; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905078,
                "title": "easy-using-substring",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details)\\n        {\\n            int val = Integer.valueOf(s.substring(11,13));\\n            if(val>60)\\n            {\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countSeniors(String[] details) {\\n        int count =0;\\n        for(String s : details)\\n        {\\n            int val = Integer.valueOf(s.substring(11,13));\\n            if(val>60)\\n            {\\n                count++;\\n            }\\n\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3902873,
                "title": "simple-approach-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n = details.size(), c=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            string age = details[i].substr(11,2);\\n            if(stoi(age,0,10)>60) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countSeniors(vector<string>& details) {\\n        int n = details.size(), c=0;\\n        for(int i=0; i<n; i++)\\n        {\\n            string age = details[i].substr(11,2);\\n            if(stoi(age,0,10)>60) c++;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1892585,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892719,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1893030,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2024304,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1974369,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1895358,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2026552,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2013093,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1941609,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1919220,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892585,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1892719,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1893030,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2024304,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1974369,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1895358,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2026552,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 2013093,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1941609,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            },
            {
                "id": 1919220,
                "content": [
                    {
                        "username": "Movsar",
                        "content": "I hope no one will need hint for this question :)"
                    },
                    {
                        "username": "hector_21",
                        "content": "Be smart...look for 11th and 12th index..that will be sufficient"
                    },
                    {
                        "username": "adiraj04",
                        "content": "But 11th character denotes gender?"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "It\\'s okay to start your morning with this question"
                    },
                    {
                        "username": "Aditya1647",
                        "content": "easy good one leetcode"
                    },
                    {
                        "username": "shreya2070",
                        "content": "num = s[11]+s[12];\\n            if(stoi(num)>60){\\n                count++;\\n            }\\nterminate called after throwing an instance of \\'std::invalid_argument\\'\\n  what():  stoi\\nWhy stoi is throwing this error?"
                    },
                    {
                        "username": "Msey",
                        "content": "\"Number of Leetcoders who is still trying to climb up to medium questions\""
                    },
                    {
                        "username": "Sushil_pramanik",
                        "content": "Simple solution in c++\\nhttps://leetcode.com/problems/number-of-senior-citizens/solutions/3948609/easy-solution-in-c/\\n"
                    },
                    {
                        "username": "nitinbisht438",
                        "content": "please check this input\\ndetails =\\n[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "output : 2 ..."
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "Hey folks, does anyone know why is this not working for the TC?  \nCode:\nif(((s.charAt(11)-'0')>=6) && ((s.charAt(12)-'0')>0)){\n                total++;\n}\nTC:[\"5612624052M0130\",\"5378802576M6424\",\"5447619845F0171\",\"2941701174O9078\"]\n"
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@sahilparekh1212](/sahilparekh1212) yeah ! No problem"
                    },
                    {
                        "username": "sahilparekh1212",
                        "content": "[@SoNiceCoder](/SoNiceCoder) I see. My condition is making 60,70,80,90... Invalid. Thanks a lot. "
                    },
                    {
                        "username": "SoNiceCoder",
                        "content": "[@Sahil ](/sahilparekh1212) hi , you have missing one point in ur if condition...that is\\nyour if condition says => 11th char should be num>6 and 12th char should be greater than zero but never can be zero...but according to question => 70(or any number >60 and ending with 0) is also valid age (>60) but your if condition will not approve it. HOPE U UNDRSTAND !"
                    },
                    {
                        "username": "overchenkoag",
                        "content": "One-line solution in Python."
                    }
                ]
            }
        ]
    },
    {
        "title": "Array Wrapper",
        "question_content": "<p>Create a class&nbsp;<code>ArrayWrapper</code> that accepts&nbsp;an array of integers in its constructor. This class should have two features:</p>\n\n<ul>\n\t<li>When two instances of this class are added together with the&nbsp;<code>+</code>&nbsp;operator, the resulting value is the sum of all the elements in&nbsp;both arrays.</li>\n\t<li>When the&nbsp;<code>String()</code>&nbsp;function is called on the instance, it will return a comma separated string surrounded by brackets. For example, <code>[1,2,3]</code>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[1,2],[3,4]], operation = &quot;Add&quot;\n<strong>Output:</strong> 10\n<strong>Explanation:</strong>\nconst obj1 = new ArrayWrapper([1,2]);\nconst obj2 = new ArrayWrapper([3,4]);\nobj1 + obj2; // 10\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[23,98,42,70]], operation = &quot;String&quot;\n<strong>Output:</strong> &quot;[23,98,42,70]&quot;\n<strong>Explanation:</strong>\nconst obj = new ArrayWrapper([23,98,42,70]);\nString(obj); // &quot;[23,98,42,70]&quot;\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [[],[]], operation = &quot;Add&quot;\n<strong>Output:</strong> 0\n<strong>Explanation:</strong>\nconst obj1 = new ArrayWrapper([]);\nconst obj2 = new ArrayWrapper([]);\nobj1 + obj2; // 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>0 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i]&nbsp;&lt;= 1000</code></li>\n\t<li><code>Note: nums is the array passed to the constructor</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3584650,
                "title": "2695-array-wrapper-level-up-your-js-skills-with-these-intuitive-implementations-day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> The `ArrayWrapper` class is designed to encapsulate an array of integers and provide two features: computing the sum of all elements when two instances are added together, and returning a string representation of the array surrounded by brackets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n>1. The `ArrayWrapper` class is defined as a function constructor that takes an array of numbers (`nums`) as an argument and assigns it to the instance property `this.nums`.\\n\\n>2. The `valueOf` method is defined on the prototype of the `ArrayWrapper` class. This method is automatically called when the instance is used in a context where a primitive value is expected, such as addition with the `+` operator. It uses the `reduce` method to calculate the sum of all the numbers in the `this.nums` array.\\n\\n>3. The `toString` method is also defined on the prototype of the `ArrayWrapper` class. This method is automatically called when the instance is converted to a string, such as when using `String(obj)` or implicitly during string concatenation. It uses the `join` method to convert the `this.nums` array into a comma-separated string, and surrounds it with square brackets to represent an array.\\n# Code\\n```JS []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n## Here are alternative implementations of the `ArrayWrapper` class:\\n## Implementation 1: \\n>Using the spread operator and Array.prototype.reduce\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return [...this.nums].reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n```\\n## Implementation 2:\\n> Using a for loop\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n      sum += this.nums[i];\\n    }\\n    return sum;\\n  }\\n\\n  toString() {\\n    let str = \\'[\\';\\n    for (let i = 0; i < this.nums.length; i++) {\\n      str += this.nums[i];\\n      if (i !== this.nums.length - 1) {\\n        str += \\',\\';\\n      }\\n    }\\n    str += \\']\\';\\n    return str;\\n  }\\n}\\n\\n```\\n## Implementation 3:\\n>Using Array.prototype.reduce and template literals\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.map(num => String(num)).join(\\',\\')}]`;\\n  }\\n}\\n\\n```\\n## Implementation 4:\\n>Using Array.prototype.reduceRight\\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduceRight((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.reduceRight((str, num, index) => {\\n      if (index === this.nums.length - 1) {\\n        return String(num) + str;\\n      } else {\\n        return String(num) + \\',\\' + str;\\n      }\\n    }, \\'\\')}]`;\\n  }\\n}\\n\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n>The `valueOf` method computes the sum of the elements in the array, which requires iterating over all elements once. Thus, its time complexity is O(n), where n is the number of elements in the array.\\n\\n>The `toString` method uses the `join` function, which concatenates allelements of the array into a string. Its time complexity is also O(n).\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n>The space complexity of the `ArrayWrapper` class is O(1) as it only stores the array as an instance variable and does not use any additional space that grows with the input size.\\n\\n\\n\\n# Important topic to Learn \\n\\n| Sr No. | Topic | Sr No. | Topic |\\n|-----|-----|-----|-----|\\n1.|Arrays , Array methods() * |2.|Function programming *|\\n3.|Higher-order function|4.|Memoization|\\n5.|Currying|6.|Promises, async/await|\\n7.|Compare Objects|8.|Prototypes, inheritance|\\n\\n>[ Note:- * marked is related to today\\'s problem ]\\n\\n\\n<img src=\"https://media.giphy.com/media/Xd6WrGsyh1su7X0ZGF/giphy.gif\" width=\"40\">\\n\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D \\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JS []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return [...this.nums].reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n      sum += this.nums[i];\\n    }\\n    return sum;\\n  }\\n\\n  toString() {\\n    let str = \\'[\\';\\n    for (let i = 0; i < this.nums.length; i++) {\\n      str += this.nums[i];\\n      if (i !== this.nums.length - 1) {\\n        str += \\',\\';\\n      }\\n    }\\n    str += \\']\\';\\n    return str;\\n  }\\n}\\n\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.map(num => String(num)).join(\\',\\')}]`;\\n  }\\n}\\n\\n```\n```JS []\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduceRight((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.reduceRight((str, num, index) => {\\n      if (index === this.nums.length - 1) {\\n        return String(num) + str;\\n      } else {\\n        return String(num) + \\',\\' + str;\\n      }\\n    }, \\'\\')}]`;\\n  }\\n}\\n\\n```\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3550702,
                "title": "easy-js-implementation-beats-100-constructor-building-js-40-mb",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.array.join(\",\") + \"]\";\\n};\\n\\n\\n\\n```\\n\\n# Overview\\n\\n1. The `ArrayWrapper` function is defined with `nums` as a parameter. This function serves as the constructor for the `ArrayWrapper` class.\\n\\n2. Inside the `ArrayWrapper` constructor, `this.array = nums` assigns the `nums` array passed to the constructor to the `array` property of the instance. This ensures that each instance of `ArrayWrapper` has its own array.\\n\\n3. The `valueOf` method is added to the `ArrayWrapper.prototype`. This method is used to override the default behavior of the `valueOf` function and define how the instance should be evaluated in a numeric context.\\n\\n4. Inside the `valueOf` method, the `reduce` function is used on `this.array` to calculate the sum of all the numbers in the array. The initial value of the sum is set to `0`. The `reduce` function iterates over each element of the array, adding it to the running sum.\\n\\n5. The `toString` method is added to the `ArrayWrapper.prototype`. This method is used to override the default behavior of the `toString` function and define how the instance should be represented as a string.\\n\\n6. Inside the `toString` method, the `join` function is used on `this.array` to concatenate all the elements of the array into a single string, separated by commas. The resulting string is then enclosed in square brackets to match the desired format.\\n\\n# Approach\\n\\nThe approach for solving this problem is as follows:\\n\\n1. Create an instance of `ArrayWrapper` using the `new` keyword and pass an array of numbers to the constructor.\\n   ```javascript\\n   const obj1 = new ArrayWrapper([1, 2]);\\n\\n2. When you use the `+` operator between two `ArrayWrapper` instances (`obj1 + obj2`), JavaScript implicitly calls the `valueOf` method for both instances.\\n   - In the `valueOf` method, the `reduce` function sums all the elements in the `array` property of the instance.\\n   - The sum of the elements is then returned.\\n\\n3. The result of `obj1 + obj2` will be the sum of all the elements in both `obj1.array` and `obj2.array`.\\n\\n4. When you call `String(obj1)` or `obj1.toString()`, JavaScript implicitly calls the `toString` method for the `ArrayWrapper` instance.\\n   - In the `toString` method, the `join` function is used to concatenate all the elements in the `array` property of the instance with commas.\\n   - The resulting string is returned, enclosed in square brackets.\\n\\n5. The output of `String(obj1)` will be the string representation of the `obj1.array` enclosed in square brackets.\\n\\nThe code provides a convenient way to handle the sum of arrays and obtain their string representation in a specific format using the `ArrayWrapper` class.\\n\\n# PLEASE UPVOTE IF THIS HELPED YOU IN ANY MANNER \\u2705\\n![image.png](https://assets.leetcode.com/users/images/c2a9ee75-9d19-4742-89f2-482ec48d148e_1684732245.0597358.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Design"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.array.join(\",\") + \"]\";\\n};\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584189,
                "title": "easy-javascript-solution-detailed-explanation-o-n-t-n-and-s-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n - For the valueof method, we will access the array which basically contains elements of an array of both objects and simply return its sum.\\n - For the toString method, we will modify the array into a string using the stringify method of JSON.\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n**Please consider liking my post if you found it usefull.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584730,
                "title": "arraywrapper-easy-self-explanatory",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569540,
                "title": "full-thorough-explanation-o-1-time-for-valueof-and-tostring-funcs",
                "content": "\\n# Code\\n```\\n// Store sum and string in ArrayWrapper\\n// That way, if we call sum or string multiple times, it\\'s only calculated once!\\nvar ArrayWrapper = function(nums) {\\n    this.sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    this.string = JSON.stringify(nums);\\n};\\n\\n// Since sum is stored in the object, O(1) time\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.sum;\\n}\\n\\n// Since string is stored in the object, O(1) time\\nArrayWrapper.prototype.toString = function() {\\n    return this.string;\\n}\\n```\\n# Overview\\n- In general, it is good practice to store a value that might be accessed multiple times. We wouldn\\'t want to calculate the value of the array every time we need its value. It is better to simply store it in our ArrayWrapper. And so, we define ```this.sum``` and ```this.string```.\\n- ```this.sum``` will be the sum of all the integers in the array. We do this with the reduce function. The reduce function I wrote here is ```nums.reduce((acc, cur) => acc + cur, 0)```.\\n    - What this does is it iterates throughout the array, sets cur to the current element it iterated to, and uses the specified function (in this, the function does ```acc + cur```), and stores the value in ```acc```. And so, if our array is [1, 2, 3, 4], the reduce function will set cur to 1, add acc + 1 = 1 (acc was initialized to 0), then go to the next element, which is 2, sets cur to 2, then does acc + 2 = 3, and so on.\\n- Next, we set ```this.string```. We can do this with ```JSON.stringify(nums)```. This stores the array as a string.\\n- And so, our ArrayWrapper variable is now storing all the values we\\'ll need. So in the ```ArrayWrapper.prototype.valueOf``` function, we simply return ```this.sum```, and for the ```ArrayWrapper.prototype.toString``` function, we return ```this.string```.\\n- NOTE: We only use the ```this``` keyword if we are accessing variables in the ArrayWrapper object. For example, when we access the sum variable stored in the ArrayWrapper, we need to use ```this.sum```. Simply returning ```sum``` does not work, as there is no parameter or local variable named ```sum```. However, when creating the ArrayWrapper, we do not write ```this.nums``` when trying to access ```nums```. It is not defined as part of the ArrayWrapper variable, it is simply a parameter being passed. So any time we use ```nums```, we simply write ```nums```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ to build ArrayWrapper, $$O(1)$$ to access the value of array or string of array.\\n\\n- Space complexity: $$O(n)$$, due to storing the string.\\n\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "String",
                    "Design"
                ],
                "code": "```\\n// Store sum and string in ArrayWrapper\\n// That way, if we call sum or string multiple times, it\\'s only calculated once!\\nvar ArrayWrapper = function(nums) {\\n    this.sum = nums.reduce((acc, cur) => acc + cur, 0);\\n    this.string = JSON.stringify(nums);\\n};\\n\\n// Since sum is stored in the object, O(1) time\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.sum;\\n}\\n\\n// Since string is stored in the object, O(1) time\\nArrayWrapper.prototype.toString = function() {\\n    return this.string;\\n}\\n```\n```this.sum```\n```this.string```\n```this.sum```\n```nums.reduce((acc, cur) => acc + cur, 0)```\n```acc + cur```\n```acc```\n```this.string```\n```JSON.stringify(nums)```\n```ArrayWrapper.prototype.valueOf```\n```this.sum```\n```ArrayWrapper.prototype.toString```\n```this.string```\n```this```\n```this.sum```\n```sum```\n```sum```\n```this.nums```\n```nums```\n```nums```\n```nums```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584341,
                "title": "3-lines-easy-commented",
                "content": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n```\\n\\nThis code defines a constructor function called `ArrayWrapper`, which creates an object that wraps an array of numbers. The constructor function takes an argument `nums`, which represents the array of numbers.\\n\\nThe `valueOf` method is defined on the `ArrayWrapper.prototype`. This method is used to provide a primitive representation of the object. In this case, `valueOf` returns the sum of all the numbers in the `nums` array using the `reduce` method. The `reduce` method iterates over each element of the array, accumulating the sum in the variable `a`. The initial value of `a` is set to 0.\\n\\nThe `toString` method is also defined on the `ArrayWrapper.prototype`. This method is used to convert the object to a string representation. In this case, `toString` returns a string that represents the `nums` array enclosed in square brackets. It uses the `toString` method of the `nums` array to convert each element to a string and then concatenates them together with commas.\\n\\nHere\\'s an example usage of the code:\\n\\n```javascript\\nvar wrapper = new ArrayWrapper([1, 2, 3, 4, 5]);\\n\\nconsole.log(wrapper.valueOf());  // Output: 15\\nconsole.log(wrapper.toString()); // Output: [1,2,3,4,5]\\n```\\n\\nIn this example, a new `ArrayWrapper` object is created with the array `[1, 2, 3, 4, 5]`. When `wrapper.valueOf()` is called, it returns the sum of all the numbers in the array, which is 15. When `wrapper.toString()` is called, it returns the string representation of the array, `[1,2,3,4,5]`.",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n```\n```javascript\\nvar wrapper = new ArrayWrapper([1, 2, 3, 4, 5]);\\n\\nconsole.log(wrapper.valueOf());  // Output: 15\\nconsole.log(wrapper.toString()); // Output: [1,2,3,4,5]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3546591,
                "title": "easiest-detailed-explanation-reduce-string-interpolation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n<img src=\"https://assets.leetcode.com/users/images/b93dcc50-7e19-44d3-80ec-c41558d719ba_1684043630.2104852.png\" width=\"50%\">\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf (){\\n        return this.nums.reduce((acc, val) => acc += val, 0)\\n    }\\n\\n    toString(){\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf (){\\n        return this.nums.reduce((acc, val) => acc += val, 0)\\n    }\\n\\n    toString(){\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584277,
                "title": "java-script-solution-for-array-wrapper-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- The ArrayWrapper constructor initializes the instance with the provided array of integers.\\n- The valueOf() method calculates the sum of all integers in the array.\\n- The toString() method converts the array to a string representation in the format of a comma-separated list surrounded by square brackets.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The ArrayWrapper class is defined with a constructor that takes an array nums as input and assigns it to the instance variable this.nums.\\n1. The valueOf() method is overridden to calculate the sum of all elements in the nums array using the reduce() function. It returns the sum.\\n1. The toString() method is overridden to convert the nums array to a string representation in the format of a comma-separated list surrounded by square brackets. It uses the join() method to join the elements with commas. It returns the formatted string.\\n1. Example usage demonstrates the addition of two ArrayWrapper instances using the + operator and the conversion of an ArrayWrapper instance to a string using the String() function.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- The valueOf() method has a time complexity of O(n), where n is the length of the input array. This is because it iterates over all elements of the array once to calculate the sum.\\n- The toString() method also has a time complexity of O(n), as it iterates over all elements of the array to join them into a string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- The space complexity of the ArrayWrapper class is O(1) because it only stores the input array and does not use any additional space that grows with the input size.\\n- The valueOf() and toString() methods do not allocate any significant additional space. The space used by these methods is negligible compared to the input size.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n      this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.join(\\',\\') + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n      this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.join(\\',\\') + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3540218,
                "title": "javascript-solution",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3539856,
                "title": "100-typescript-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass ArrayWrapper {\\n  private nums: number[];\\n\\n  constructor(nums: number[]) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf(): number {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// console.log(obj1 + obj2); // 10\\n// console.log(String(obj1)); // \"[1,2]\"\\n// console.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  private nums: number[];\\n\\n  constructor(nums: number[]) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf(): number {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// console.log(obj1 + obj2); // 10\\n// console.log(String(obj1)); // \"[1,2]\"\\n// console.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3539852,
                "title": "best-js-solution-for-beginners",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584222,
                "title": "best-javascript-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688655,
                "title": "reduce-json-stringify",
                "content": "```js\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584408,
                "title": "easy-1-1-1-line-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,num) => acc + num,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,num) => acc + num,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581477,
                "title": "java-style",
                "content": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var res = 0;\\n    for (var i=0;i<this.nums.length;i++) res+=this.nums[i];\\n    return res;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\\',\\')+\"]\";\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var res = 0;\\n    for (var i=0;i<this.nums.length;i++) res+=this.nums[i];\\n    return res;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\\',\\')+\"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565190,
                "title": "simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((pre, cur)=>pre+cur,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((pre, cur)=>pre+cur,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */",
                "codeTag": "Unknown"
            },
            {
                "id": 3546378,
                "title": "ts-just-store-two-values-59ms-45mb",
                "content": "Another super plain one, with the best thing to do here being to create both our results (that will never change) in the `constructor`:\\n* `str` will bhe the stringified version of `nums` that we can quickly get using a simple template literal and a `.join` operation;\\n* `tot` will store the total of the values contained in `nums`, easily obtained by calling `.reduce` on it.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nclass ArrayWrapper {\\n    str: string;\\n    tot: number;\\n\\tconstructor(nums: number[]) {\\n        this.str = `[${nums.join(\",\")}]`;\\n        this.tot = nums.reduce((acc, iter) => acc + iter, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.tot;\\n    }\\n\\n\\ttoString(): string {\\n        return this.str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array"
                ],
                "code": "```ts\\nclass ArrayWrapper {\\n    str: string;\\n    tot: number;\\n\\tconstructor(nums: number[]) {\\n        this.str = `[${nums.join(\",\")}]`;\\n        this.tot = nums.reduce((acc, iter) => acc + iter, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.tot;\\n    }\\n\\n\\ttoString(): string {\\n        return this.str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540093,
                "title": "array-wrapper-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.nums.reduce((subSum, subNum) => subSum + subNum, 0)\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.nums.flat().join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.nums.reduce((subSum, subNum) => subSum + subNum, 0)\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.nums.flat().join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4100707,
                "title": "my-solution",
                "content": "class ArrayWrapper {\\n  arrays = [];\\n  constructor(nums: number[]) {\\n    this.arrays.push(nums);\\n  }\\n  valueOf(): number {\\n    let result = 0;\\n    let [arr1, arr2] = this.arrays;\\n    if (arr1) {\\n      arr1.forEach((element: number) => {\\n         result+= element;\\n      });\\n    }\\n    if (arr2) {\\n      arr2.forEach((element: number) => {\\n         result += element;\\n      });\\n    }\\n    return result;\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.arrays[0]);\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "class ArrayWrapper {\\n  arrays = [];\\n  constructor(nums: number[]) {\\n    this.arrays.push(nums);\\n  }\\n  valueOf(): number {\\n    let result = 0;\\n    let [arr1, arr2] = this.arrays;\\n    if (arr1) {\\n      arr1.forEach((element: number) => {\\n         result+= element;\\n      });\\n    }\\n    if (arr2) {\\n      arr2.forEach((element: number) => {\\n         result += element;\\n      });\\n    }\\n    return result;\\n  }\\n\\n  toString(): string {\\n    return JSON.stringify(this.arrays[0]);\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4100042,
                "title": "simple-js-ts-solution-1-1-line",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    private arr: number[];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf = (): number => this.arr.reduce((acc, arr) => acc+arr, 0);\\n\\n\\ttoString = (): string => `[${this.arr.toString()}]`;\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private arr: number[];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf = (): number => this.arr.reduce((acc, arr) => acc+arr, 0);\\n\\n\\ttoString = (): string => `[${this.arr.toString()}]`;\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097555,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0)\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0)\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4096695,
                "title": "step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Constructor function for ArrayWrapper.\\n *\\n * @param {number[]} nums - An array of numbers to be wrapped.\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * Custom valueOf method to calculate the sum of wrapped numbers.\\n *\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, num) => acc + num, 0);\\n};\\n\\n/**\\n * Custom toString method to convert the wrapped array to a string.\\n *\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Create instances of ArrayWrapper\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// Using the custom methods and demonstrating their behavior\\nobj1 + obj2; // When used in an addition context, it calculates the sum of both arrays, resulting in 10.\\nString(obj1); // Converts obj1 to a string, resulting in \"[1,2]\".\\nString(obj2); // Converts obj2 to a string, resulting in \"[3,4]\".\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Constructor function for ArrayWrapper.\\n *\\n * @param {number[]} nums - An array of numbers to be wrapped.\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * Custom valueOf method to calculate the sum of wrapped numbers.\\n *\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, num) => acc + num, 0);\\n};\\n\\n/**\\n * Custom toString method to convert the wrapped array to a string.\\n *\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Create instances of ArrayWrapper\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\n// Using the custom methods and demonstrating their behavior\\nobj1 + obj2; // When used in an addition context, it calculates the sum of both arrays, resulting in 10.\\nString(obj1); // Converts obj1 to a string, resulting in \"[1,2]\".\\nString(obj2); // Converts obj2 to a string, resulting in \"[3,4]\".\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4095722,
                "title": "2695-array-wrapper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {void}\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n/**\\n * @return {number}\\n */\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((accumulator, currentValue) => accumulator + currentValue, 0);\\n}\\n\\n/**\\n * @return {string}\\n */\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085116,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return \"[\" + this.nums.join(\",\") + \"]\";\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4077441,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function (nums) {\\n  this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.arr.reduce((acc, next) => acc + next, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return JSON.stringify(this.arr);\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function (nums) {\\n  this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.arr.reduce((acc, next) => acc + next, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return JSON.stringify(this.arr);\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4070058,
                "title": "s",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4065488,
                "title": "const-js-ts-single-line-solution",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    private nums: number [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private nums: number [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\",\")}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063300,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+String(this.nums) + \"]\";    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+String(this.nums) + \"]\";    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4060816,
                "title": "very-simple-use-reduce-and-json-stringify",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = [...nums]\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num) => num + sum, 0)\\n    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = [...nums]\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num) => num + sum, 0)\\n    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046290,
                "title": "beats-97-87-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, curr) => acc+=curr,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, curr) => acc+=curr,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034492,
                "title": "solution-using-reduce",
                "content": "# Intuition\\nThis can be handled by Array.reduce\\n\\n# Approach\\nStore the array as a member by spreading nums. Use Array.reduce for the sum with the + operator. Use reduce for the string add conditionals to apend the \"[],\" characters depending on index of the array element.\\n\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if (!this.nums.length) \\n        return \\'[]\\';\\n    return this.nums.reduce((str,n,i) => {\\n        if(i == 0) \\n            str += \\'[\\';\\n        str += n;\\n        if (i == this.nums.length-1)\\n            str += \\']\\'\\n        else\\n            str += \\',\\';\\n        return str\\n    },\"\");\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if (!this.nums.length) \\n        return \\'[]\\';\\n    return this.nums.reduce((str,n,i) => {\\n        if(i == 0) \\n            str += \\'[\\';\\n        str += n;\\n        if (i == this.nums.length-1)\\n            str += \\']\\'\\n        else\\n            str += \\',\\';\\n        return str\\n    },\"\");\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4034457,
                "title": "easy-solution",
                "content": "# Intuition\\nThis is easy\\n\\n# Approach\\nStore the array as a member. Iterate over the elements and add to a string. Use Array.reduce for the sum\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \"[\";\\n    this.nums.forEach((n) => { \\n        str += n;\\n        str += \\',\\';\\n    });\\n    if (this.nums.length)\\n        str = str.substring(0,str.length - 1);\\n    str += \\']\\';\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=[...nums];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((total,n) => total + n,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \"[\";\\n    this.nums.forEach((n) => { \\n        str += n;\\n        str += \\',\\';\\n    });\\n    if (this.nums.length)\\n        str = str.substring(0,str.length - 1);\\n    str += \\']\\';\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020561,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n               sum+=this.nums[i];\\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n               sum+=this.nums[i];\\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4020556,
                "title": "easy-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n           \\n               sum+=this.nums[i];\\n           \\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum=0;\\n    for(let i=0;i<this.nums.length;i++){\\n           \\n               sum+=this.nums[i];\\n           \\n    }\\n    return sum;\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4011731,
                "title": "implementation-with-nested-array-and-recursive-ts",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(private nums: number[] | number[][]) {}\\n  calcSum(array: number[] | number[][], index: number, sum: number): number {\\n    if (index === array.length) {\\n      return sum;\\n    }\\n    const item = array[index];\\n    if (Array.isArray(item)) {\\n      return this.calcSum(array, index + 1, sum + this.calcSum(item, 0, 0));\\n    }\\n    return this.calcSum(array, index + 1, sum + item);\\n  }\\n  valueOf() {\\n    return this.calcSum(this.nums, 0, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(private nums: number[] | number[][]) {}\\n  calcSum(array: number[] | number[][], index: number, sum: number): number {\\n    if (index === array.length) {\\n      return sum;\\n    }\\n    const item = array[index];\\n    if (Array.isArray(item)) {\\n      return this.calcSum(array, index + 1, sum + this.calcSum(item, 0, 0));\\n    }\\n    return this.calcSum(array, index + 1, sum + item);\\n  }\\n  valueOf() {\\n    return this.calcSum(this.nums, 0, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4009418,
                "title": "the-10x-approach-don-t-forget-about-the-redooocer",
                "content": "# Intuition\\nWhen given an array of numbers, we often want to perform certain operations on it. The `ArrayWrapper` class seems to be a way to encapsulate an array and provide additional methods to operate on it. The methods provided are:\\n- `valueOf()`: Returns the sum of all numbers in the array.\\n- `toString()`: Returns a string representation of the array.\\n\\n# Approach\\n1. **Constructor**: The class takes an array of numbers as its argument and initializes its `nums` property with this array.\\n2. **valueOf()**: This method uses the `reduce` function to sum up all the numbers in the array and return the result.\\n3. **toString()**: This method returns a stringified version of the array using `JSON.stringify`.\\n\\n# Complexity\\n- **Time complexity**:\\n  - Constructor: \\\\(O(1)\\\\) (Assigning a reference)\\n  - valueOf(): \\\\(O(n)\\\\) (Iterating over the array to sum up)\\n  - toString(): \\\\(O(n)\\\\) (Stringifying the array)\\n\\n- **Space complexity**:\\n  - Constructor: \\\\(O(n)\\\\) (Storing the array)\\n  - valueOf(): \\\\(O(1)\\\\) (Just returning a single number)\\n  - toString(): \\\\(O(n)\\\\) (Returning a string representation of the array)\\n\\n# Code\\n```typescript\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, n) => acc+n, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Intuition\\nWhen given an array of numbers, we often want to perform certain operations on it. The `ArrayWrapper` class seems to be a way to encapsulate an array and provide additional methods to operate on it. The methods provided are:\\n- `valueOf()`: Returns the sum of all numbers in the array.\\n- `toString()`: Returns a string representation of the array.\\n\\n# Approach\\n1. **Constructor**: The class takes an array of numbers as its argument and initializes its `nums` property with this array.\\n2. **valueOf()**: This method uses the `reduce` function to sum up all the numbers in the array and return the result.\\n3. **toString()**: This method returns a stringified version of the array using `JSON.stringify`.\\n\\n# Complexity\\n- **Time complexity**:\\n  - Constructor: \\\\(O(1)\\\\) (Assigning a reference)\\n  - valueOf(): \\\\(O(n)\\\\) (Iterating over the array to sum up)\\n  - toString(): \\\\(O(n)\\\\) (Stringifying the array)\\n\\n- **Space complexity**:\\n  - Constructor: \\\\(O(n)\\\\) (Storing the array)\\n  - valueOf(): \\\\(O(1)\\\\) (Just returning a single number)\\n  - toString(): \\\\(O(n)\\\\) (Returning a string representation of the array)\\n\\n# Code\\n```typescript\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, n) => acc+n, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 4008929,
                "title": "typescript-javascript-solution",
                "content": "```ts\\nclass ArrayWrapper {\\n    private nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((total, num) => total += num, 0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```ts\\nclass ArrayWrapper {\\n    private nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((total, num) => total += num, 0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4008030,
                "title": "self-explanatory-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.nums)\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.nums)\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4006079,
                "title": "array-wrapper",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce((a, c) => a + c, initialValue);\\n    return sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join()}]`;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce((a, c) => a + c, initialValue);\\n    return sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join()}]`;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3987186,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985517,
                "title": "simple-js-solution-reduce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.numbers=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    \\n    return this.numbers.reduce((prev,curr)=>prev+=curr,0)\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.numbers.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.numbers=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    \\n    return this.numbers.reduce((prev,curr)=>prev+=curr,0)\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.numbers.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974708,
                "title": "one-liner-solution-no-confusion",
                "content": "\\n```\\nclass ArrayWrapper {\\n    private nums: number[]\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((acc, item) => acc += item,0)\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.nums)\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    private nums: number[]\\n    constructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((acc, item) => acc += item,0)\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.nums)\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969364,
                "title": "javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums =nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums =nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3962529,
                "title": "constructor-function-with-prototype",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957490,
                "title": "simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n, acc) => n + acc, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n, acc) => n + acc, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3955652,
                "title": "js-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var sum=0;\\n    for(let i=0;i<this.arr.length;i++){\\n        sum+=this.arr[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var sum=0;\\n    for(let i=0;i<this.arr.length;i++){\\n        sum+=this.arr[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3941660,
                "title": "single-line-solutions-beats-100-users",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, item) => sum + item, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, item) => sum + item, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925399,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924471,
                "title": "typescript-simple-solution",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n\\tconstructor(private nums: number[]) {}\\n\\tvalueOf(): number { return this.nums.reduce( ( acc, val ) => acc += val, 0 ) }\\n\\ttoString() { return \\'[\\' + this.nums.toString() + \\']\\'; }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n\\tconstructor(private nums: number[]) {}\\n\\tvalueOf(): number { return this.nums.reduce( ( acc, val ) => acc += val, 0 ) }\\n\\ttoString() { return \\'[\\' + this.nums.toString() + \\']\\'; }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3910769,
                "title": "easy-to-understand-javascript-solution-with-explanation",
                "content": "# Intuition\\nI had a really hard time figuring out how to solve this problem initially because there were a few concepts I had to learn in order to solve the problem. \\n\\nI needed to understand a few things:\\n\\n- When we perform operations like obj1 + obj2 or String(obj1), we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for valueOf() (which is a method on Object.prototype)\\n- If the primitive that\\'s expected is a string, then JS engine looks for toString() (which is a method on Object.prototype)\\n\\n# Approach\\nWith an understanding now of the concepts the problem expects us to know, I designed my solution as follows:\\n\\n- create a variable in the class that takes in `nums`\\n- `valueOf` is expected to return an integer, so we need to reduce our class variable in this method\\n- `toString` is expected to return a string, so we need to turn our class variable into a string\\n\\n# Complexity\\n- Time complexity:\\n`valueOf` is O(n)\\n`toString` is O(n)\\n\\n- Space complexity:\\n`valueOf` is O(1)\\n`toString` is O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3900649,
                "title": "easy-wrapper-with-class-json-stringify",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.array = nums;\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.array);\\n    }\\n    valueOf() {\\n        return this.array.reduce((acc, value) => {\\n        return acc + value;\\n    }, 0);\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.array = nums;\\n    }\\n\\n    toString() {\\n        return JSON.stringify(this.array);\\n    }\\n    valueOf() {\\n        return this.array.reduce((acc, value) => {\\n        return acc + value;\\n    }, 0);\\n    }\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3889935,
                "title": "2695-array-wrapper",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((accomulation, value) => accomulation + value, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.toString() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((accomulation, value) => accomulation + value, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.toString() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3877221,
                "title": "best-solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- In constructor we can initialize the stringfiedArray and valueof that array.\\n- When the functions will be called for that object then it will directly return the saved value and no need of calculating again and again.\\n\\n# Code\\n```js\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.value = this.nums.reduce((acc, curr) => acc+curr, 0);\\n    this.stringifiedArray = JSON.stringify(this.nums);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.value;\\n}\\n\\nArrayWrapper.prototype.toString = function() {  \\n    return this.stringifiedArray;\\n}\\n\\n// creating object\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\n\\n// testing \\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.value = this.nums.reduce((acc, curr) => acc+curr, 0);\\n    this.stringifiedArray = JSON.stringify(this.nums);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.value;\\n}\\n\\nArrayWrapper.prototype.toString = function() {  \\n    return this.stringifiedArray;\\n}\\n\\n// creating object\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\n\\n// testing \\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876603,
                "title": "simple-solution-faster-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0\\n    ? this.nums.reduce((a, b) => a + b)\\n    : 0\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString(\\'\\') + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0\\n    ? this.nums.reduce((a, b) => a + b)\\n    : 0\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString(\\'\\') + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867415,
                "title": "easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for ( let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    for ( let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861426,
                "title": "check-it-guys",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Test cases\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // Output: 10\\nconsole.log(String(obj1)); // Output: \"[1,2]\"\\nconsole.log(String(obj2)); // Output: \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n};\\n\\n// Test cases\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // Output: 10\\nconsole.log(String(obj1)); // Output: \"[1,2]\"\\nconsole.log(String(obj2)); // Output: \"[3,4]\"\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837970,
                "title": "very-simple-solution",
                "content": "\\n```\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nconst ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3820660,
                "title": "array-wrapper-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>{\\n        return a + b\\n    },0)    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>{\\n        return a + b\\n    },0)    \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816785,
                "title": "most-easy-and-simple-solution",
                "content": "# Approach\\n- For first method,use reduce function of arrays to add two elements of array at a time till end of array which will give us sum.\\n- For second method,use join() to join each element of array with \\',\\'.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num)=>sum+num,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum,num)=>sum+num,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816368,
                "title": "basic-approach-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return  this.nums.reduce((accum,item) => accum + item,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return  this.nums.reduce((accum,item) => accum + item,0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806918,
                "title": "easy-to-understand-login-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums=nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const nums=this.nums;\\n    const sum=nums.reduce((accumalator,currentvalues)=>accumalator+currentvalues,0);\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if(this.nums.length==0)\\n    {\\n        return \"[]\";\\n    }\\n    else\\n    {\\n         var result=\"[\";\\n    const arra=this.nums;\\n    for(var i=0;i<arra.length;i++)\\n    {\\n        \\n        if(i==arra.length-1)\\n        {\\n            result=result+arra[i]+\"]\";\\n        \\n        }\\n        else\\n        {\\n            result=result+arra[i].toString()+\\',\\';\\n\\n        }\\n    }\\n    return result;\\n\\n    }\\n\\n   \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums=nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const nums=this.nums;\\n    const sum=nums.reduce((accumalator,currentvalues)=>accumalator+currentvalues,0);\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    if(this.nums.length==0)\\n    {\\n        return \"[]\";\\n    }\\n    else\\n    {\\n         var result=\"[\";\\n    const arra=this.nums;\\n    for(var i=0;i<arra.length;i++)\\n    {\\n        \\n        if(i==arra.length-1)\\n        {\\n            result=result+arra[i]+\"]\";\\n        \\n        }\\n        else\\n        {\\n            result=result+arra[i].toString()+\\',\\';\\n\\n        }\\n    }\\n    return result;\\n\\n    }\\n\\n   \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3806547,
                "title": "javascript-this-valueof-tostring-explained-with-space-time-complexity",
                "content": "# Intuition\\nThe special keyword \\'this\\'. We can bind it to any value and that is automatically available to prototype object\\n\\n# Approach\\n1. Assing the passed \\'nums\\' to a variable of your choice inside \\'this\\'\\n2. For valueOf, use Array.reduce() to sum up all the nums\\n3. For toString, use concatination and Array.join() for desired output as asked in the question\\n4. Please note that both \\'valeuOf\\' and \\'toString\\' are recogonised by javascript. Name it anything else and your logic will fail. These are reserved keywords (proto functions) in javascript. The use of operator \\'+\\' between two or more object of ArrayWrapper \"type\" invokes the \\'valueOf\\' function automatically to get their respective values. The only thing we have modified here is the logic of that \\'valueOf\\' function. Same goes for \\'toString\\', we have only modified the underlying logic.\\n\\n# Complexity\\n- Time complexity:\\nConstructor: O(1)\\nvalueOf method: O(n)\\ntoString method: O(n)\\n\\n- Space complexity:\\nConstructor: O(1)\\nvalueOf method: O(1)\\ntoString method: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arrOfNums = nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arrOfNums.reduce((t,n)=>t+n,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.arrOfNums.join()+\\']\\'\\n}\\n\\n\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\nobj1 + obj2; // 10\\nString(obj1); // \"[1,2]\"\\nString(obj2); // \"[3,4]\"\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arrOfNums = nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arrOfNums.reduce((t,n)=>t+n,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.arrOfNums.join()+\\']\\'\\n}\\n\\n\\nconst obj1 = new ArrayWrapper([1,2]);\\nconst obj2 = new ArrayWrapper([3,4]);\\nobj1 + obj2; // 10\\nString(obj1); // \"[1,2]\"\\nString(obj2); // \"[3,4]\"\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3786722,
                "title": "solution-with-simple-foreach-beats-91-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums = nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let result = 0;\\n    this.nums.forEach(v=>{\\n        result += v;\\n    })\\n    return result;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[` + this.nums.join(\\',\\') + `]`;\\n}   \\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    constructor(nums)\\n    {\\n        this.nums = nums;\\n    }\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let result = 0;\\n    this.nums.forEach(v=>{\\n        result += v;\\n    })\\n    return result;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[` + this.nums.join(\\',\\') + `]`;\\n}   \\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770544,
                "title": "array-wrapper",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum1=0\\n    for(var num of this.nums){\\n        sum1+=num\\n    }\\n    return sum1\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str1=\"\"\\n    for(var i=0;i<this.nums.length;i++)\\n    {\\n        if(i===this.nums.length-1){\\n            str1+=this.nums[i]\\n        }\\n        else{\\n            str1+=this.nums[i]+\",\"\\n        }\\n    }\\n    return \"[\"+str1+\"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum1=0\\n    for(var num of this.nums){\\n        sum1+=num\\n    }\\n    return sum1\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str1=\"\"\\n    for(var i=0;i<this.nums.length;i++)\\n    {\\n        if(i===this.nums.length-1){\\n            str1+=this.nums[i]\\n        }\\n        else{\\n            str1+=this.nums[i]+\",\"\\n        }\\n    }\\n    return \"[\"+str1+\"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764843,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758001,
                "title": "2695-array-wrapper-umarbek-s-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738296,
                "title": "the-most-obvious-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst thought: implement `valueOf` with reducer and `toString` with (the most obvious for me) `JSON.stringify`.\\n\\n# Code (TS)\\n```\\nclass ArrayWrapper {\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    nums = []\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, num) => acc + num, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    nums = []\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((acc, num) => acc + num, 0);\\n    }\\n\\n\\ttoString() {\\n        return JSON.stringify(this.nums);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731976,
                "title": "easy-js-solution",
                "content": "\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  if(this.nums.length === 0) return 0;\\n  return  this.nums.reduce((acc, cur) => acc + cur)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  if(this.nums.length === 0) return 0;\\n  return  this.nums.reduce((acc, cur) => acc + cur)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3730153,
                "title": "js-easy-solition-enjoy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum +num, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum +num, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3719270,
                "title": "what-you-were-looking-for-3-lines-easy",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, val) => acc + val, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, val) => acc + val, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3696629,
                "title": "easy-3-lines-solution-uses-array-reduce-for-sum",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694771,
                "title": "simple-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.length ? this.arr.reduce((a, b) => a + b) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.length ? this.arr.reduce((a, b) => a + b) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3691009,
                "title": "js",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    sum = 0;\\n    for (i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    ans = \"[\";\\n    for (i = 0; i < this.nums.length; i++){\\n        ans += this.nums[i];\\n        if (i+1 != this.nums.length) {\\n            ans += \\',\\';\\n        }\\n    }\\n    ans += \"]\";\\n    return ans;\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    sum = 0;\\n    for (i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    ans = \"[\";\\n    for (i = 0; i < this.nums.length; i++){\\n        ans += this.nums[i];\\n        if (i+1 != this.nums.length) {\\n            ans += \\',\\';\\n        }\\n    }\\n    ans += \"]\";\\n    return ans;\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3690749,
                "title": "array-wrapper",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let sum = 0;\\n    for (let i = 0; i < this.nums.length; i++) {\\n        sum += this.nums[i];\\n    }\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3661479,
                "title": "one-line-simple-solutions",
                "content": "- #### *Intuition*\\n\\n---\\n\\n- <!-- Describe your first thoughts on how to solve this problem. -->\\n\\n---\\n\\n- \\n\\n---\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.nums.length != 0 ? this.nums.reduce((a, b) => a + b) : 0;\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return \"[\" + this.nums.join(\",\") + \"]\"\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n  return this.nums.length != 0 ? this.nums.reduce((a, b) => a + b) : 0;\\n};\\n\\nArrayWrapper.prototype.toString = function () {\\n  return \"[\" + this.nums.join(\",\") + \"]\"\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3648159,
                "title": "solution-using-symbol-obj",
                "content": "# Description\\nThis article will help you understand my solution much better than I could explain to you. [link](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums\\n    }\\n    [Symbol.toPrimitive](hint) {\\n        if (hint === \"string\") {\\n            return \"[\" + this.nums + \"]\"\\n        } else {\\n            let sum = 0\\n            for (const num of this.nums) {\\n                sum += num\\n            }\\n            return sum\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums\\n    }\\n    [Symbol.toPrimitive](hint) {\\n        if (hint === \"string\") {\\n            return \"[\" + this.nums + \"]\"\\n        } else {\\n            let sum = 0\\n            for (const num of this.nums) {\\n                sum += num\\n            }\\n            return sum\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3630525,
                "title": "array-wrapper-javascript-this-in-a-method",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() { \\n    return this.arr.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {    \\n    return \\'[\\' + this.arr + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() { \\n    return this.arr.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {    \\n    return \\'[\\' + this.arr + \\']\\'\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3627046,
                "title": "js-arraywrapper-noodkhan-navin",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\n```\\n```\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${String(this.nums)}]`;\\n}\\n```\\n```\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n```\n```\\nvar ArrayWrapper = function (nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function () {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function () {\\n    return `[${String(this.nums)}]`;\\n}\\n```\n```\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3623557,
                "title": "javascript-typeof",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    nums: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((n, a) => n + a, 0);\\n    }\\n\\n    toString() {\\n        return \\'[\\' + this.nums.join(\\',\\') + \\']\\'\\n    }\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.reduce((n, a) => n + a, 0);\\n    }\\n\\n    toString() {\\n        return \\'[\\' + this.nums.join(\\',\\') + \\']\\'\\n    }\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619648,
                "title": "simple-o-n-solution-with-explanation",
                "content": "# Intuition\\n- add this.nums property to ArrayWrapper constructor\\n- - (nums is already passed as an arg just add prop this.nums = nums)\\n\\n- update ArrayWrapper.valueOf to sum all values of array\\n- - use .flat method on this.nums to flatten nested arrays\\n- - use .reduce callback function to sum values of flattenedd array\\n- - return summedArray \\n\\n- update ArrayWrapper.toString to convert nums to a string\\n- - use JSON.stringify on this.nums to produce desired output format (.toString method removes brackets)\\n- - return stringified array\\n\\n# Approach\\nObject Oriented / Functional Approach\\n\\n# Complexity\\n- Time complexity:\\nO(n) / linear\\n\\n- Space complexity:\\nO(n) / linear\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let flattenedArr = this.nums.flat(Infinity);\\n    let sumArr = flattenedArr.reduce(function(acc, curr) {\\n        return acc + curr;\\n    }, 0);\\n    return sumArr;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let arrayStr = JSON.stringify(this.nums);\\n    return arrayStr;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let flattenedArr = this.nums.flat(Infinity);\\n    let sumArr = flattenedArr.reduce(function(acc, curr) {\\n        return acc + curr;\\n    }, 0);\\n    return sumArr;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let arrayStr = JSON.stringify(this.nums);\\n    return arrayStr;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612053,
                "title": "javascript-reduce-tostring-2-solutions",
                "content": "# Code\\n##### Solution 1\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```\\n##### Solution 2\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.valueOf = () => this.nums.reduce((acc, cur) => acc + cur, 0);\\n    this.toString = () => \"[\" + this.nums.toString() + \"]\";\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n    this.valueOf = () => this.nums.reduce((acc, cur) => acc + cur, 0);\\n    this.toString = () => \"[\" + this.nums.toString() + \"]\";\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3612038,
                "title": "javascript-reduce-tostring",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.toString() + \"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3601757,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594495,
                "title": "javascript-faster-than-95",
                "content": "# Intuition\\nJust keep an array in a class\\'s field.\\n\\n# Approach\\nIn the constructor just keep an array in a class\\'s field.\\n```\\nthis.nums = nums;\\n```\\nThen in both methods use cycle to iterate through all the items of array:\\n```\\nfor (let i = 0; i < this.nums.length; i++){\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, where n is the number of items in array.\\n\\n- Space complexity:\\n$$O(n)$$, where n is the number of items in array.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var rs = 0;\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n    }\\n    return rs;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    var rs = \"[\";\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n        if (i < this.nums.length - 1) rs+= \",\";\\n    }\\n    rs += \"]\";\\n    return rs;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nthis.nums = nums;\\n```\n```\\nfor (let i = 0; i < this.nums.length; i++){\\n```\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    var rs = 0;\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n    }\\n    return rs;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    var rs = \"[\";\\n    for (let i = 0; i < this.nums.length; i++){\\n        rs += this.nums[i];\\n        if (i < this.nums.length - 1) rs+= \",\";\\n    }\\n    rs += \"]\";\\n    return rs;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594481,
                "title": "easy-self-explainary-day-28",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n,a) => n + a, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((n,a) => n + a, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593241,
                "title": "day-28-javascript-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((accumulator, item) => accumulator += item, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((accumulator, item) => accumulator += item, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593089,
                "title": "3-line-easy-solution-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, n) => sum + n, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, n) => sum + n, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591971,
                "title": "beginner-friendly-js-solution",
                "content": "> **DISCLAIMER: ** I am not a Pro, Just sharing my solution here to start a healthy discussion, if you feel it could have been better, please feel free to share your solution and thoughts \\uD83D\\uDE4F below\\n\\n# Intuition\\nArray `reduce()` method and String Interpolation might be useful \\uD83E\\uDD14\\uD83D\\uDE00\\n\\n# Approach\\nWhile creating an object we are passing an array of integers and the value of instance we are expecting it to be the sum of all the integers to achieve this we have `Array.prototype.reduce()`.\\n\\nAnd for showing the instance in form of a string, we can use string interpolation to retain those `[Square brackets]`\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/7cde9949-6770-4d4c-b6c3-d8506c56a0ee_1685775711.1795843.png)\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0 ? this.nums.reduce( (acc,e) => acc+e) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return String(`[${this.nums}]`);\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.length > 0 ? this.nums.reduce( (acc,e) => acc+e) : 0;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return String(`[${this.nums}]`);\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590939,
                "title": "easy-ts-solution-reduce",
                "content": "Ja# Code\\n```\\nclass ArrayWrapper {\\n    arr: Array<number>;\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((accumulated, curr) => {\\n            accumulated += curr;\\n            return accumulated;\\n        },0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.arr.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    arr: Array<number>;\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((accumulated, curr) => {\\n            accumulated += curr;\\n            return accumulated;\\n        },0);\\n    }\\n\\n\\ttoString() {\\n        return `[${this.arr.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590825,
                "title": "my-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this._nums = nums ? nums : [];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this._nums.reduce( (sum,cur) => {return sum + cur}, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this._nums.join()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this._nums = nums ? nums : [];\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this._nums.reduce( (sum,cur) => {return sum + cur}, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this._nums.join()}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590686,
                "title": "javascript-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy assigning the numbers array to the this.numbers property, we make the array accessible within the instance. This allows other methods or functions defined on the instance, such as the sum() prototype function, to access and work with the numbers array.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let total = 0;\\n    for(let i = 0; i < this.nums.length; ++i) {\\n        total += this.nums[i];\\n    }\\n    return total;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = JSON.stringify(this.nums);\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let total = 0;\\n    for(let i = 0; i < this.nums.length; ++i) {\\n        total += this.nums[i];\\n    }\\n    return total;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = JSON.stringify(this.nums);\\n    return str;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3588447,
                "title": "easy-solution",
                "content": "Kindly upvote if you like my solution\\n\\n```\\n/**\\n * @param {number[]} nums\\n */\\n let nums;\\nvar ArrayWrapper = function(nums) {\\n    this.nums= nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce(\\n  (accumulator, currentValue) => accumulator + currentValue,\\n  initialValue\\n);\\nreturn sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n let nums;\\nvar ArrayWrapper = function(nums) {\\n    this.nums= nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    const initialValue = 0;\\n    const sumWithInitial = this.nums.reduce(\\n  (accumulator, currentValue) => accumulator + currentValue,\\n  initialValue\\n);\\nreturn sumWithInitial;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587699,
                "title": "js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => {\\n        return a+b\\n    }, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => {\\n        return a+b\\n    }, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n    \\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587321,
                "title": "one-line-code-for-each-method",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587279,
                "title": "if-you-don-t-know-now-you-know",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHonestly, I just felt something inside of me and just cracked this bad boy out\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsed my fingers to press buttons on my keyboard then finally clicking submit with my mousepad\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.storage = nums\\n    this.added = this.storage.reduce((accum, curr) => accum + curr, 0)\\n    this.stringy = `[${this.storage.join(\",\")}]`\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.added\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.stringy\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.storage = nums\\n    this.added = this.storage.reduce((accum, curr) => accum + curr, 0)\\n    this.stringy = `[${this.storage.join(\",\")}]`\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.added\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.stringy\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587198,
                "title": "simple-typescript-solution",
                "content": "\\n# Code\\n```\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.length > 0 \\n            ? this.nums.reduce((acc, value) => acc + value)\\n            : 0;\\n    }\\n    toString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[] = [];\\n\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n    valueOf() {\\n        return this.nums.length > 0 \\n            ? this.nums.reduce((acc, value) => acc + value)\\n            : 0;\\n    }\\n    toString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586864,
                "title": "3-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,total)=>acc+total, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,total)=>acc+total, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586789,
                "title": "easiest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- **reduce method:**\\n    - Syntax: `reduce(callbackFn, initialValue)`\\n    - callbackFn (in this Case):\\n        - `(accumulator, currentValue) => accumulator + currentValue, initialValue)`\\n        - accumulator:\\n            - Holds resulting value from the previous call to callbackFn.\\n            - Initially holds initialValue (if specified).\\n            - Otherwise holds the value of array[0].\\n        - currentValue:\\n            - It is the current element\\'s value.\\n            - On first call:\\n                - If initial value was specified:\\n                    - It has value of array[0]\\n                - Otherwise:\\n                    - it has the value of array[1].\\n\\n\\n# Code\\n``` javaScript []\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, currentValue) => sum + currentValue, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join(\",\") + \"]\";\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` javaScript []\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((sum, currentValue) => sum + currentValue, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join(\",\") + \"]\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586768,
                "title": "array-wrapper-easy-solution-es6",
                "content": "# Code 1\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n```\\n# Code 2\\n```\\nclass ArrayWrapper{\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf(){\\n        return this.nums.reduce((a,b)=>a+b, 0);\\n    }\\n\\n    toString(){\\n        return `[${this.nums}]`;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr)=>acc+curr,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n```\n```\\nclass ArrayWrapper{\\n    constructor(nums){\\n        this.nums = nums;\\n    }\\n\\n    valueOf(){\\n        return this.nums.reduce((a,b)=>a+b, 0);\\n    }\\n\\n    toString(){\\n        return `[${this.nums}]`;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586699,
                "title": "simple-javascript-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586595,
                "title": "simple-solution-typescript-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe `ArrayWrapper` class is designed to provide custom behavior when used in arithmetic operations and when converted to a string. In this case, the `ArrayWrapper` objects are expected to behave like arrays when added together and should return the sum of their elements. When converted to a string, they should return a formatted string representation of the wrapped array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a constructor function `ArrayWrapper` that takes an array `nums` as its parameter ans store in it\\'s instance.\\n\\n2. Implement the `valueOf()` method for the `ArrayWrapper` prototype. This method calculates the sum of nums and return the calculated sum.\\n\\n3. Implement the `toString()` method for the `ArrayWrapper` prototype. This method concatenate the array elements to a string representation, separated by commas. Wrap the resulting string with square brackets (`[]`) to match the desired format. Return the formatted string.\\n\\n# Code\\n``` javascript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((prev, cur) => cur + prev, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n``` typescript []\\nclass ArrayWrapper {\\n    nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n       return this.nums.reduce((prev, cur) => cur + prev, 0) \\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Design"
                ],
                "code": "``` javascript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((prev, cur) => cur + prev, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\n``` typescript []\\nclass ArrayWrapper {\\n    nums: number[];\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n    }\\n\\n\\tvalueOf() {\\n       return this.nums.reduce((prev, cur) => cur + prev, 0) \\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.join(\\',\\')}]`\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586575,
                "title": "solution-typescript-javascript",
                "content": "# Code\\n``` typescript []\\ninterface ArrayWrapper {\\n    nums: number[];\\n    valueOf: () => number;\\n    toString: () => string;\\n}\\n\\nfunction ArrayWrapper(this: ArrayWrapper, nums: number[]) {\\n    this.nums = nums;\\n}\\n\\nArrayWrapper.prototype.valueOf = function(this: ArrayWrapper): number {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function(this: ArrayWrapper): string {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```\\n``` javascript []\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` typescript []\\ninterface ArrayWrapper {\\n    nums: number[];\\n    valueOf: () => number;\\n    toString: () => string;\\n}\\n\\nfunction ArrayWrapper(this: ArrayWrapper, nums: number[]) {\\n    this.nums = nums;\\n}\\n\\nArrayWrapper.prototype.valueOf = function(this: ArrayWrapper): number {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function(this: ArrayWrapper): string {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```\n``` javascript []\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586351,
                "title": "js-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=> a+b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=> a+b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3586232,
                "title": "new-syntax-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntbh, at first thought I didn\\'t know what to do. I\\'m not too familiar with classes in javascrpt.\\n\\nI learned a lot with this exercise.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n  valueOf() {\\n    const a = this.nums.reduce((sum, current) => {\\n      return sum + current;\\n    }, 0);\\n    return a;\\n  }\\n  toString() {\\n    return `[${this.nums}]`;\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n  valueOf() {\\n    const a = this.nums.reduce((sum, current) => {\\n      return sum + current;\\n    }, 0);\\n    return a;\\n  }\\n  toString() {\\n    return `[${this.nums}]`;\\n  }\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586127,
                "title": "easy-ts-implementation",
                "content": "\\n```\\nclass ArrayWrapper {\\n    array: number[]\\n\\tconstructor(nums: number[]) {\\n        this.array = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.array.reduce((sum, item) => sum+item,0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.array.join(\\',\\')}]`\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    array: number[]\\n\\tconstructor(nums: number[]) {\\n        this.array = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.array.reduce((sum, item) => sum+item,0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.array.join(\\',\\')}]`\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585898,
                "title": "day-28-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585850,
                "title": "3-lines-easy-and-clean-solution",
                "content": "# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b) => a+b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585816,
                "title": "easy-to-read",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, currentValue) => acc + currentValue, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, currentValue) => acc + currentValue, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.arr.join() + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585776,
                "title": "day28-simple-beginner-friendly-js-solution",
                "content": "# Intuition\\n**The given  question have 3 parts**\\n\\n\\n1. **ArrayWrapper constructor** : this just takes an array as parameter and assign it to nums of arrayWrapper.\\n2. **valueOf** : this function just returns the sum of each element of the array in ArrayWrapper class.\\n3. **toString** : this method just converts the array : [1,2,3] to string \"[1,2,3]\" form .\\n\\n# Approach\\n**Step 1**: \\n```\\n this.array = nums;\\n\\n    here the parameterized array is now stored as array element\\n    of ArrayWrapper Class.\\n```\\n\\n\\n**Step 2** :\\n```\\nlet sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n\\nHere a sum var will store the value of sum of each element of \\nthe array of arrayWrapper classes obj.\\n\\nthis can be accessed by : this.array\\n\\n\\nLater on sum is returned.\\n```\\n\\n**Step 3** : \\n```\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\nHere we just need to convert the array into string \\nSo we will use join method .\\nhere the returning string will \\n\\'[\\'  + string returned  by the this.array.join(\\',\\') + \\']\\'\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(N)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n this.array = nums;\\n\\n    here the parameterized array is now stored as array element\\n    of ArrayWrapper Class.\\n```\n```\\nlet sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n\\nHere a sum var will store the value of sum of each element of \\nthe array of arrayWrapper classes obj.\\n\\nthis can be accessed by : this.array\\n\\n\\nLater on sum is returned.\\n```\n```\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\nHere we just need to convert the array into string \\nSo we will use join method .\\nhere the returning string will \\n\\'[\\'  + string returned  by the this.array.join(\\',\\') + \\']\\'\\n```\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let sum = 0;\\n    this.array.forEach((val)=>{\\n        sum += val;\\n    })\\n    return sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585765,
                "title": "simple-typescript-solution-using-array-reduce-and-string-function",
                "content": "# Code\\n```\\nclass ArrayWrapper {\\n    protected arr: number[];\\n\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\tvalueOf() {\\n        return this.arr.reduce((acc, val) => acc + val, 0);\\n    }\\n\\ttoString() {\\n        return \"[\" + String(this.arr) + \"]\";\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    protected arr: number[];\\n\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\tvalueOf() {\\n        return this.arr.reduce((acc, val) => acc + val, 0);\\n    }\\n\\ttoString() {\\n        return \"[\" + String(this.arr) + \"]\";\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585663,
                "title": "easy-typescript-solution",
                "content": "\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n    arr: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\ttoString() {\\n        return \\'[\\' + this.arr.toString() + \\']\\';\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    arr: number[] = [];\\n\\tconstructor(nums: number[]) {\\n        this.arr = nums;\\n    }\\n\\n\\tvalueOf() {\\n        return this.arr.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\ttoString() {\\n        return \\'[\\' + this.arr.toString() + \\']\\';\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585620,
                "title": "chatgpt-code-snippet",
                "content": "**Intuition:**\\n\\nThe goal of the problem is to create a class called `ArrayWrapper` that performs addition and string conversion operations on arrays. The `ArrayWrapper` class accepts an array of integers as input.\\n\\nTo achieve this, we can implement the `ArrayWrapper` class with two methods: `valueOf()` and `toString()`. \\n\\nThe `valueOf()` method calculates the sum of all the elements in the array by iterating over the array and adding each element to a running sum. This method is invoked when the instances of `ArrayWrapper` are added together using the `+` operator.\\n\\nThe `toString()` method converts the array to a string representation surrounded by brackets. It uses the `join()` method to concatenate the elements of the array with a comma as the separator. This method is invoked when the `String()` function is called on an instance of `ArrayWrapper`.\\n\\n**Approach:**\\n\\n1. Define the `ArrayWrapper` class that accepts an array of integers as the constructor parameter. Store the array as an instance variable (`this.nums`).\\n2. Implement the `valueOf()` method:\\n   - Initialize a variable `sum` to 0.\\n   - Iterate over each element `num` in `this.nums`.\\n   - Add `num` to `sum` in each iteration.\\n   - Return the final `sum`.\\n3. Implement the `toString()` method:\\n   - Convert the array to a comma-separated string using the `join()` method.\\n   - Prepend `\\'[\\'` and append `\\']\\'` to the resulting string.\\n   - Return the final string representation.\\n4. Test the `ArrayWrapper` class by creating instances and performing the required operations.\\n\\n**Complexity Analysis:**\\n\\nLet\\'s analyze the time and space complexity of the solution:\\n\\n- Time Complexity: The `valueOf()` method iterates over each element of the array, resulting in a time complexity of O(N), where N is the number of elements in the array. The `toString()` method also has a time complexity of O(N) due to the `join()` operation. Therefore, the overall time complexity is O(N), where N is the size of the input array.\\n- Space Complexity: The space complexity is O(1) since the additional space used by the class does not depend on the input size.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "**Intuition:**\\n\\nThe goal of the problem is to create a class called `ArrayWrapper` that performs addition and string conversion operations on arrays. The `ArrayWrapper` class accepts an array of integers as input.\\n\\nTo achieve this, we can implement the `ArrayWrapper` class with two methods: `valueOf()` and `toString()`. \\n\\nThe `valueOf()` method calculates the sum of all the elements in the array by iterating over the array and adding each element to a running sum. This method is invoked when the instances of `ArrayWrapper` are added together using the `+` operator.\\n\\nThe `toString()` method converts the array to a string representation surrounded by brackets. It uses the `join()` method to concatenate the elements of the array with a comma as the separator. This method is invoked when the `String()` function is called on an instance of `ArrayWrapper`.\\n\\n**Approach:**\\n\\n1. Define the `ArrayWrapper` class that accepts an array of integers as the constructor parameter. Store the array as an instance variable (`this.nums`).\\n2. Implement the `valueOf()` method:\\n   - Initialize a variable `sum` to 0.\\n   - Iterate over each element `num` in `this.nums`.\\n   - Add `num` to `sum` in each iteration.\\n   - Return the final `sum`.\\n3. Implement the `toString()` method:\\n   - Convert the array to a comma-separated string using the `join()` method.\\n   - Prepend `\\'[\\'` and append `\\']\\'` to the resulting string.\\n   - Return the final string representation.\\n4. Test the `ArrayWrapper` class by creating instances and performing the required operations.\\n\\n**Complexity Analysis:**\\n\\nLet\\'s analyze the time and space complexity of the solution:\\n\\n- Time Complexity: The `valueOf()` method iterates over each element of the array, resulting in a time complexity of O(N), where N is the number of elements in the array. The `toString()` method also has a time complexity of O(N) due to the `join()` operation. Therefore, the overall time complexity is O(N), where N is the size of the input array.\\n- Space Complexity: The space complexity is O(1) since the additional space used by the class does not depend on the input size.",
                "codeTag": "Java"
            },
            {
                "id": 3585574,
                "title": "javascript-simple-javascript-typescript-solution-basic-coding-technique",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 57.14% of JavaScript online submissions for Array Wrapper.\\n# Memory Usage: 44.7 MB, less than 10.28% of JavaScript online submissions for Array Wrapper.\\n\\n\\t\\tvar ArrayWrapper = function(nums) {\\n\\t\\t\\tthis.nums = nums;\\n\\t\\t};\\n\\n\\t\\tArrayWrapper.prototype.valueOf = function() {\\n\\n\\t\\t\\tlet result = 0;\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tArrayWrapper.prototype.toString = function() {\\n\\n\\t\\t\\tlet result = \"[\";\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\n\\t\\t\\t\\tif(index === this.nums.length - 1){\\n\\t\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tresult = result + this.nums[index] + \",\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = result + \"]\";\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 60 ms, faster than 57.14% of JavaScript online submissions for Array Wrapper.\\n# Memory Usage: 44.7 MB, less than 10.28% of JavaScript online submissions for Array Wrapper.\\n\\n\\t\\tvar ArrayWrapper = function(nums) {\\n\\t\\t\\tthis.nums = nums;\\n\\t\\t};\\n\\n\\t\\tArrayWrapper.prototype.valueOf = function() {\\n\\n\\t\\t\\tlet result = 0;\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\n\\t\\tArrayWrapper.prototype.toString = function() {\\n\\n\\t\\t\\tlet result = \"[\";\\n\\n\\t\\t\\tfor(let index = 0; index < this.nums.length ; index++){\\n\\n\\t\\t\\t\\tif(index === this.nums.length - 1){\\n\\t\\t\\t\\t\\tresult = result + this.nums[index];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tresult = result + this.nums[index] + \",\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tresult = result + \"]\";\\n\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Unknown"
            },
            {
                "id": 3585468,
                "title": "js-inbuilt-operators-time-61ms-49-space-44mb-57",
                "content": "# Approach\\nWe\\'ll store the arrays of integers and overload the inbuilt ValueOf and String operator as requested by the function.\\n\\n# Complexity\\n- Time complexity:\\nO(n) *, where n is the lenght of the array*\\n\\n- Space complexity:\\nO(n) *, where n is the lenght of the array*\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585369,
                "title": "easy-javascript-solution-using-reduce",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```\\n![UpvoteLeetcode.jpeg](https://assets.leetcode.com/users/images/7a315f9e-9e80-4c59-a572-c32556614966_1685610772.228738.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.nums.join(\\',\\') + \"]\";\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585344,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, v)=>acc+v,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, v)=>acc+v,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\"+this.nums.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585316,
                "title": "use-reduce-and-string",
                "content": "# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, elem) => acc + elem, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, elem) => acc + elem, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585123,
                "title": "typescript-solution",
                "content": "```\\nclass ArrayWrapper {\\n    nums: number[]\\n\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((sum, value) => sum + value, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n    nums: number[]\\n\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums\\n    }\\n\\n\\tvalueOf() {\\n        return this.nums.reduce((sum, value) => sum + value, 0)\\n    }\\n\\n\\ttoString() {\\n        return `[${this.nums.toString()}]`\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585077,
                "title": "beats-93-easy-javascript-solution-2695-array-wrapper-javascript-day-28",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce(\\n        (n,a) => n+a,0\\n    );\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce(\\n        (n,a) => n+a,0\\n    );\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${String(this.nums)}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3585010,
                "title": "simple-solution-using-prototype-and-class-2-solutions",
                "content": "# Code Using Prototype\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n```\\n\\n# Code Using Class\\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    valueOf() {\\n        return this.nums.reduce((acc, cur) => acc + cur, 0);\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    toString() {\\n        return `[${this.nums.join(\",\")}]`;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\n//Time complexity: O(n) - where n is the length of the nums array\\n//Space complexity: O(1)\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\",\")}]`;\\n}\\n```\n```\\nclass ArrayWrapper {\\n    constructor(nums) {\\n        this.nums = nums;\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    valueOf() {\\n        return this.nums.reduce((acc, cur) => acc + cur, 0);\\n    }\\n\\n    //Time complexity: O(n) - where n is the length of the nums array\\n    //Space complexity: O(1)\\n    toString() {\\n        return `[${this.nums.join(\",\")}]`;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584977,
                "title": "typescript-using-reduce-method-and-storing-the-sum-runtime-70-memory-60",
                "content": "\\n# Complexity\\n- Time complexity: $$O(1)$$ for adding and $$O(n)$$ for reduce() and toString()\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```TypeScript\\nclass ArrayWrapper {\\n    nums: number[];\\n    sum: number;\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n        this.sum = nums.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.sum;\\n    }\\n\\n\\ttoString(): string {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```TypeScript\\nclass ArrayWrapper {\\n    nums: number[];\\n    sum: number;\\n\\tconstructor(nums: number[]) {\\n        this.nums = nums;\\n        this.sum = nums.reduce((a, b) => a + b, 0);\\n    }\\n\\n\\tvalueOf(): number {\\n        return this.sum;\\n    }\\n\\n\\ttoString(): string {\\n        return `[${this.nums.toString()}]`;\\n    }\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584905,
                "title": "easy-one-line-solutions-with-respectible-space-and-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSum the values and turn them into strings\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\nsimple one line solutions \\n\\n# Complexity\\n- Time complexity: 0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1), O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) { \\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((acc,curr)=>acc+curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) { \\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.nums.reduce((acc,curr)=>acc+curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.nums)\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584745,
                "title": "javascript-class-for-arraywrapper-with-sum-and-string-representation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, we can create a class called `ArrayWrapper` that accepts an array of integers in its constructor. The class should have two methods: `valueOf` and `toString`. The `valueOf` method will be called when two instances of the class are added together with the `+` operator, and the `toString` method will be called when the `String()` function is used on the instance.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Create a class `ArrayWrapper` with a constructor that accepts an array of integers(`nums`) and assigns it to the class instance.\\n2. Implement the `valueOf` method that calculates the sum of all the elements in the `nums` array using the `reduce` method.\\n3. Implement the `toString` method that converts the `nums` array to a string representation using the `join` method to join the elements with commas, and surround the resulting string with brackets.\\n4. Test the class by creating instances of `ArrayWrapper` and performing the required operations.\\n\\n# Complexity\\n- Time complexity: The `valueOf` method has a time complexity of O(n) as it uses the `reduce` method to iterate over the array and calculate the sum. The `toString` method has a time complexity of O(n) as it uses the `join` method to concatenate the elements of the array into a string.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity is O(n), where n is the length of the `nums` array. The `ArrayWrapper` class stores the `nums` array as an instance variable, which requires space proportional to the length of the array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Math",
                    "String",
                    "Design"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n  }\\n\\n  toString() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584735,
                "title": "easy-solution-javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr) => acc+ curr, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + String(this.nums) + \"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc,curr) => acc+ curr, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + String(this.nums) + \"]\"\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584703,
                "title": "easy-solution-o-n-one-liner",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc, cur) => acc + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584698,
                "title": "create-arraywrapper-class-in-javascript",
                "content": "1. The ArrayWrapper class is defined with a constructor that takes an array of integers as input and assigns it to the nums property of the instance.\\n\\n2. The valueOf() method is implemented to calculate the sum of all the elements in the array (nums) using the reduce() method with an initial value of 0.\\n\\n3. The toString() method is implemented to return a string representation of the array (nums) by joining its elements with commas and surrounding them with brackets.\\n\\n4. Since JavaScript automatically converts objects to their primitive values when the + operator is used, we don\\'t need to explicitly define the + operator behavior for ArrayWrapper. Instead, we leverage the valueOf() method, which returns the sum of all the elements in the array, allowing us to use the + operator on two ArrayWrapper instances to get the desired result.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584657,
                "title": "easy-js-solution-for-beginners",
                "content": "\\nvar ArrayWrapper = function(nums) {\\n     this.nums = nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n   return this.nums.reduce((sum, num) => sum + num, 0); \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\nvar ArrayWrapper = function(nums) {\\n     this.nums = nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n   return this.nums.reduce((sum, num) => sum + num, 0); \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3584630,
                "title": "fastest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.array);\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((sum, num) => sum + num, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return JSON.stringify(this.array);\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584600,
                "title": "day-28-easy-solution-in-js",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.nums.toString()+\\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a,b)=>a+b,0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\'+this.nums.toString()+\\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584522,
                "title": "best-solution-for-array-wrappes-99-99-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum, num) => sum + num, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \"[\" + this.array.join(\",\") + \"]\";\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584504,
                "title": "array-wrapper-easy-solution-o-n-complexity",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr=nums; \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n     let Sum=0;  \\n     let arr1=this.arr;   \\n     for(v of arr1)\\n     {\\n         Sum+=v;\\n     }\\n     return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n     return JSON.stringify(this.arr);\\n}\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584497,
                "title": "simple-arraywrapper-using-function-declaration",
                "content": "# Intuition\\n- for converting any object to string (`toString()`) should be overridden\\n- for taking out value we have another method `valueof()`\\n\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nfunction ArrayWrapper(nums) {\\n  this.values = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.values.reduce((acc, item) => acc+item, 0)   \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.values.join(\\',\\')}]`\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nfunction ArrayWrapper(nums) {\\n  this.values = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n return this.values.reduce((acc, item) => acc+item, 0)   \\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n  return `[${this.values.join(\\',\\')}]`\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584466,
                "title": "simple-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.data = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this?.data?.reduce((prev, cur) => prev + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.data.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.data = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this?.data?.reduce((prev, cur) => prev + cur, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.data.join(\",\")}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584413,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\nlet Sum=0;\\n    let arr1=this.arr;\\n    for(v of arr1){\\n        Sum+=v;\\n    }\\n    return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.arr=nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\nlet Sum=0;\\n    let arr1=this.arr;\\n    for(v of arr1){\\n        Sum+=v;\\n    }\\n    return Sum;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.arr);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584386,
                "title": "array-wrapper",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\n\\n\\n// constructor funfor ArrayWrapper\\nvar ArrayWrapper = function(nums) {\\n  this.arr = nums;\\n};\\n\\n//  calculate the sum of all elements \\nArrayWrapper.prototype.valueOf = function() {\\n  return this.arr.reduce(function(sum, num) {\\n    return sum + num;\\n  }, 0);\\n};\\n\\n//  converting the array to a string \\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.arr.join(\",\") + \"]\";\\n};\\n\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\n\\n\\n// constructor funfor ArrayWrapper\\nvar ArrayWrapper = function(nums) {\\n  this.arr = nums;\\n};\\n\\n//  calculate the sum of all elements \\nArrayWrapper.prototype.valueOf = function() {\\n  return this.arr.reduce(function(sum, num) {\\n    return sum + num;\\n  }, 0);\\n};\\n\\n//  converting the array to a string \\nArrayWrapper.prototype.toString = function() {\\n  return \"[\" + this.arr.join(\",\") + \"]\";\\n};\\n\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584377,
                "title": "easy-solution-daily-lc-javascript-challenge-june-day-28-30",
                "content": "\\n# Approach\\nThe approach of the code is to use the reduce method of arrays to calculate the sum of the numbers in the nums property of the ArrayWrapper instance. The toString method uses the JSON.stringify function to convert the nums property to a JSON string.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the valueOf method is O(n), where n is the length of the nums array, because it iterates over all elements of the array to compute the sum. The time complexity of the toString method is also O(n), because JSON.stringify iterates over all elements of the array to create a JSON string.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0);\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n        return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n        this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n        return this.nums.reduce((acc, curr) => acc + curr, 0);\\n\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n        return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584357,
                "title": "javascript-easy-to-understand-solution-97",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.toString()}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584339,
                "title": "using-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum,val)=>{\\n        return sum+val;\\n    },0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.array.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce((sum,val)=>{\\n        return sum+val;\\n    },0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.array.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584239,
                "title": "java-script-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass ArrayWrapper {\\n  constructor(nums) {\\n    this.nums = nums;\\n  }\\n\\n  valueOf() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n  }\\n\\n  toString() {\\n    return JSON.stringify(this.nums);\\n  }\\n}\\n\\nconst obj1 = new ArrayWrapper([1, 2]);\\nconst obj2 = new ArrayWrapper([3, 4]);\\n\\nconsole.log(obj1 + obj2); // 10\\nconsole.log(String(obj1)); // \"[1,2]\"\\nconsole.log(String(obj2)); // \"[3,4]\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584216,
                "title": "javascript-add-string-nums",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let tot = 0\\n    for (let i =0; i< this.arr.length; i ++){\\n        tot += this.arr[i]\\n    }\\n    return tot\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \\'[\\'\\n    for (let i =0; i< this.arr.length; i ++){\\n        if (i == this.arr.length - 1){\\n            str += String(this.arr[i])\\n        }\\n        else{\\n            str += String(this.arr[i]) + \\',\\'\\n        }\\n    }\\n    str += \\']\\'\\n    \\n    return str\\n}",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    let tot = 0\\n    for (let i =0; i< this.arr.length; i ++){\\n        tot += this.arr[i]\\n    }\\n    return tot\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    let str = \\'[\\'\\n    for (let i =0; i< this.arr.length; i ++){\\n        if (i == this.arr.length - 1){\\n            str += String(this.arr[i])\\n        }\\n        else{\\n            str += String(this.arr[i]) + \\',\\'\\n        }\\n    }\\n    str += \\']\\'\\n    \\n    return str\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3584199,
                "title": "easy-solution-with-this-array-reduce-and-array-join",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc,cur) => acc + cur, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.arr = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.arr.reduce((acc,cur) => acc + cur, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.arr.join(\\',\\')}]`\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584146,
                "title": "javascript-typescript-1-line-each-time-space-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n}\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce( ( s, v ) => s + v, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "String"
                ],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.array = nums\\n}\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.array.reduce( ( s, v ) => s + v, 0 )\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return JSON.stringify(this.array)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584133,
                "title": "day-28-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584069,
                "title": "solution-in-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n    \\n}\\n\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((acc, curr) => acc + curr, 0);\\n    \\n}\\n\\n\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.nums.join(\\',\\')}]`;\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584028,
                "title": "easy-javascript-solution",
                "content": "# Approach\\n\\n1. The `ArrayWrapper` constructor accepts an array of numbers (`nums`) as input and assigns it to the `array` property of the instance.\\n\\n2. The `valueOf` method is overridden to provide a custom behavior when the object is used in a numerical context (such as addition). It uses the `reduce` method on the `array` property to calculate the sum of all elements and returns the result.\\n\\n3. The `toString` method is overridden to provide a custom behavior when the object is converted to a string. It uses the `join` method on the `array` property to concatenate all elements with commas, and surrounds the resulting string with brackets.\\n\\nBy implementing these methods, we ensure that the `ArrayWrapper` instances can be added together using the `+` operator and that they produce the expected string representation when converted to a string using `String(obj)` or `obj.toString()`.\\n\\nThe usage examples demonstrate how to create instances of `ArrayWrapper`, perform addition between them (`obj1 + obj2`), and convert them to strings (`String(obj1)`).\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((acc, curr) => acc + curr, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n  this.array = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n  return this.array.reduce((acc, curr) => acc + curr, 0);\\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\' + this.array.join(\\',\\') + \\']\\';\\n};\\n\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3584012,
                "title": "day-28",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums=nums;\\n    \\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((subSum,subNum)=>subSum+subNum,0)\\n    \\n};\\n\\nArrayWrapper.prototype.toString = function() {\\n  return \\'[\\'+this.nums.flat().join(\\',\\')+\\']\\'  \\n};\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3583579,
                "title": "javascript-good-enough",
                "content": "``` JavaScript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((x,y) => x+y, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "``` JavaScript []\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums;\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((x,y) => x+y, 0);\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return \\'[\\' + this.nums.toString() + \\']\\';\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3581502,
                "title": "immutable-array-snapshot",
                "content": "Creates string and numerical representation right away, doesn\\'t process array afterwards:\\n```\\nvar ArrayWrapper = function(nums) {\\n    this.str = \"[\" + nums.join(\\',\\') + \"]\";\\n    this.val = nums.reduce((a,b)=>a+b,0);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.val;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.str;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar ArrayWrapper = function(nums) {\\n    this.str = \"[\" + nums.join(\\',\\') + \"]\";\\n    this.val = nums.reduce((a,b)=>a+b,0);\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.val;\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n    return this.str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3580455,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.nums = nums\\n};\\n\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.nums.reduce((a, b) => a + b, 0)\\n}\\n\\nArrayWrapper.prototype.toString = function() {\\n   return JSON.stringify(this.nums);\\n}\\n\\n/**\\n * const obj1 = new ArrayWrapper([1,2]);\\n * const obj2 = new ArrayWrapper([3,4]);\\n * obj1 + obj2; // 10\\n * String(obj1); // \"[1,2]\"\\n * String(obj2); // \"[3,4]\"\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3578786,
                "title": "js",
                "content": "\\n```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.list=nums\\n}\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.list.reduce((t,e)=>t+e,0) \\n}\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.list}]`\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar ArrayWrapper = function(nums) {\\n    this.list=nums\\n}\\nArrayWrapper.prototype.valueOf = function() {\\n    return this.list.reduce((t,e)=>t+e,0) \\n}\\nArrayWrapper.prototype.toString = function() {\\n    return `[${this.list}]`\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1899981,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1912728,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1912967,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2014522,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2074746,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 2028003,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1930339,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            },
            {
                "id": 1901472,
                "content": [
                    {
                        "username": "Mister_CK",
                        "content": "It is not immediately clear from the description that valueOf is what is being used for the \\'add\\' operation. Maybe you can explain that a bit more clearly Leetcode?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "[@rcomesan](/rcomesan) Thanks for your answer, I hadn\\'t read that, quite interesting! still feel that they could mention it in the description though. "
                    },
                    {
                        "username": "rcomesan",
                        "content": "[@Chris Kapinga](/Mister_CK) I understand the frustration but this has nothing to do with Leetcode, it's just how JavaScript works. When objects are used as operands they are coerced into primitives. The binary + operator uses the default hint, so JS will call methods in the following order:\n1) it calls System.toPrimitive method with \"default\" hint\n2) if System.toPrimitive method is undefined, it calls .valueOf()\n3) if .valueOf() is undefined or doesn't return a primitive, it calls .toString()\n\nCheck out the editorial for a thorough explanation."
                    },
                    {
                        "username": "Tribhuwan-Joshi",
                        "content": "The  feature explanation  is  vague respective to the code example"
                    },
                    {
                        "username": "Code_Sagar",
                        "content": "#Day28 : Done Solving Today\\'s Question \\n\\nvalue of : this function is just returns the sum of the all the elements of array\\ntoString : this function converts the aray [1,2,3] to string \"[1,2,3]\""
                    },
                    {
                        "username": "jessfeliciano",
                        "content": "At first I had no idea what valueOf() was supposed to do and I found it hard to understand the editorial, so I\\'m going to chime in here regarding what you need to understand in order to solve this problem correctly. \\n\\nYou need to understand a few things: \\n\\n- When we perform operations like `obj1 + obj2` or `String(obj1)`, we are using an object where a primitive is expected instead, so the JS engine will try to perform a type conversion to fulfill the operation (aka try to convert the type from object to a primitive type)\\n- If the primitive that\\'s expected is an integer, then JS engine looks for `valueOf()` (which is a method on `Object.prototype`)\\n- If the primitive that\\'s expected is a string, then JS engine looks for `toString()` (which is a method on `Object.prototype`)\\n\\n[link to documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#static_methods)\\n\\nWithout giving too much away, knowing what we know now, the above should give you a hint as to how you should write `valueOf` and `toString`. \\n\\nPlease chime in if there\\'s anything that needs additional clarification or correction."
                    },
                    {
                        "username": "baahu_01",
                        "content": "Are kehna kya chahte ho"
                    },
                    {
                        "username": "codewithelvin",
                        "content": "Definitely not for Juniors. Or probably for very strong Juniors."
                    },
                    {
                        "username": "FouadKazem",
                        "content": "I would know if they actually modified the JavaScript\\'s environment for this problem to make it accepts operator overloading, or they wrote it like that just to provide a simple explanation..."
                    },
                    {
                        "username": "rcomesan",
                        "content": "They didn\\'t. This is how JS works internally according to the specs. You can find a good summary of it in the MDN docs."
                    },
                    {
                        "username": "vadya-coder",
                        "content": "\nIncomprehensible condition. The `valueOf` method must return the sum of all array elements. And `toString` should return a string like this: \"[val1,val2,val3,val4,...]\""
                    }
                ]
            }
        ]
    },
    {
        "title": "Compact Object",
        "question_content": "<p>Given an object or array&nbsp;<code>obj</code>, return a <strong>compact object</strong>. A <strong>compact object</strong>&nbsp;is the same as the original object, except with keys containing <strong>falsy</strong> values removed. This operation applies to the object and any nested objects. Arrays are considered objects where&nbsp;the indices are&nbsp;keys. A value is&nbsp;considered <strong>falsy</strong>&nbsp;when <code>Boolean(value)</code> returns <code>false</code>.</p>\n\n<p>You may assume the&nbsp;<code>obj</code> is&nbsp;the output of&nbsp;<code>JSON.parse</code>. In other words, it is valid JSON.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, 0, false, 1]\n<strong>Output:</strong> [1]\n<strong>Explanation:</strong> All falsy values have been removed from the array.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = {&quot;a&quot;: null, &quot;b&quot;: [false, 1]}\n<strong>Output:</strong> {&quot;b&quot;: [1]}\n<strong>Explanation:</strong> obj[&quot;a&quot;] and obj[&quot;b&quot;][0] had falsy values and were removed.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> obj = [null, 0, 5, [0], [false, 16]]\n<strong>Output:</strong> [5, [], [16]]\n<strong>Explanation:</strong> obj[0], obj[1], obj[3][0], and obj[4][0] were falsy and removed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>obj</code> is a valid JSON object</li>\n\t<li><code>2 &lt;= JSON.stringify(obj).length &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3567296,
                "title": "simple-easy-full-thorough-explanation-beginner-friendly",
                "content": "# Intuition\\nSince the object can have subarrays and subobjects, recursion should be used. If the current recursive call is not an object, dealing with this is easy, and will be discussed below. If it is an object, then one should create a new object, let\\'s call this object ```compacted```. Then, iterate through each key in the object, and if the value is desireable (is not falsy), add the key and value to ```compacted```. When the entire object is iterated through, return ```comapcted```.\\n\\n# Approach\\n1. Check if ```obj``` is null. If so, return ```null```.\\n2. Check if ```obj``` is an array.\\n    - If so, we can first use the filter function. In this problem, one should use ```obj.filter(Boolean)```. Boolean is a function that returns true if the input value is truthy, and false if falsy. And so, the filter function will iterate through each element of the array and input it into the Boolean function (the filter function calls ```Boolean(obj[i])``` for all valid ```i```), and if the Boolean function returns true, filter will add the element into the return array, otherwise it will leave it out of the return array.\\n    - Next, we should call the map function on the array the filter function returns. The map function replaces each element in the array with the result of inputting the element in a specified function. In this problem, we want to make a recursive call on compactObject for each element, so that we can continue to remove falsy elements in any potential subobjects. So, we write ```obj.filter(Boolean).map(compactObject);``` so that the map function will call ```compactObject(obj[i])``` for all ```i``` in the array that the filter function returns. To make it clear, one can conceptualize this as: ```filterArr = obj.filter(Boolean);```, ```return filterArr.map(compactObject);```\\n3. Check if ```obj``` is not an object. If it isn\\'t return ```obj```.\\n4. If the past three steps have done nothing, that means ```obj``` is not null, an array, or not an object. So, it is an object, and we treat it as such.\\n    - Create empty variable. Here, it will be called ```compacted```.\\n    - Iterate through each key in ```obj```. For each key, we call compactObject on the key\\'s corresponding value, so we can remove any falsy values in any potential subarrays or subobjects in the value. If the result of this is truthy, we add the key and value to the ```compacted``` object. Else, do nothing, we do not want to add the key and falsy value.\\n5. After iterating through all of ```obj```, return ```compacted```.\\n\\n# Code\\n```\\nvar compactObject = function(obj) {\\n    // These three if statements deal with when obj is not an iterable object\\n    // Steps 1-3 as described above\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") return obj;\\n\\n    // This for loop deals with when obj is an iterable object\\n    // Steps 4-5 as described above\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n\\n    return compacted;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```compacted```\n```compacted```\n```comapcted```\n```obj```\n```null```\n```obj```\n```obj.filter(Boolean)```\n```Boolean(obj[i])```\n```i```\n```obj.filter(Boolean).map(compactObject);```\n```compactObject(obj[i])```\n```i```\n```filterArr = obj.filter(Boolean);```\n```return filterArr.map(compactObject);```\n```obj```\n```obj```\n```obj```\n```compacted```\n```obj```\n```compacted```\n```obj```\n```compacted```\n```\\nvar compactObject = function(obj) {\\n    // These three if statements deal with when obj is not an iterable object\\n    // Steps 1-3 as described above\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") return obj;\\n\\n    // This for loop deals with when obj is an iterable object\\n    // Steps 4-5 as described above\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n\\n    return compacted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595607,
                "title": "very-easy-to-understand-compact-object-by-removing-keys-with-falsy-values-recursive-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. **Check if the obj is not an object or is null. If so, return it as is.**\\n2. **If obj is an array:**\\n    - Create an empty compactArr.\\n    - Iterate through each element in the array, recursively compacting it.\\n    - If the compacted value is truthy, add it to compactArr.\\n    - Return \\n3. **If obj is an object**\\n    - Create an empty compactObj.\\n    - Iterate through each key in the object.\\n    - Recursively compact each value and add it to compactObj if it is truthy.\\n    - Return\\n# Complexity\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(d)** , where d represents the depth of the nesting.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n\\nvar compactObject = function(obj) {\\n    // Base case: if obj is not an object or is null, return it as is\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    // Case for arrays: recursively compact each element and remove falsy values\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val){\\n                compactArr.push(val)\\n            }\\n        }\\n\\n        return compactArr\\n    } \\n\\n    // Case for objects: create a new compacted object\\n    const compactObj = {};\\n\\n    for(let key in obj){\\n        // Iterate over each key in the object\\n        const val = compactObject(obj[key]);\\n        // If the value is truthy, add it to the compacted object\\n        if(val){\\n            compactObj[key] = val\\n        }\\n    }\\n\\n    return compactObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n\\nvar compactObject = function(obj) {\\n    // Base case: if obj is not an object or is null, return it as is\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    // Case for arrays: recursively compact each element and remove falsy values\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val){\\n                compactArr.push(val)\\n            }\\n        }\\n\\n        return compactArr\\n    } \\n\\n    // Case for objects: create a new compacted object\\n    const compactObj = {};\\n\\n    for(let key in obj){\\n        // Iterate over each key in the object\\n        const val = compactObject(obj[key]);\\n        // If the value is truthy, add it to the compacted object\\n        if(val){\\n            compactObj[key] = val\\n        }\\n    }\\n\\n    return compactObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3567111,
                "title": "javascript-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n  if (obj === null || typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n\\n  const result = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      result[key] = value;\\n    }\\n  }\\n  return result;   \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n  if (obj === null || typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n\\n  const result = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      result[key] = value;\\n    }\\n  }\\n  return result;   \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3789578,
                "title": "easy-solution-using-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n -Check for the object or array.\\n -If array: \\n 1.Iterate through it.\\n 2.Check for falsy of object type:\\na)*If falsy*, delete it. and remove index by one to check\\n again for same index.\\n        b)*If object* type than call compactObject() with iterated value as parameter.\\n\\n-If Object:\\nSame process as array just different iterating method i used.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n\\n   if(Array.isArray(obj)){\\n      for(let i = 0;i< obj.length;i++){\\n         if(obj[i] ===null|| obj[i] ===0 || obj[i]===false||obj[i]===\"\"){\\n            obj.splice(i,1);\\n            i--;\\n         }\\n         if(typeof obj[i]===\\'object\\'){\\n            compactObject(obj[i]);\\n         }\\n      }\\n   }\\n   else{\\n      for(const key in obj){\\n         if(obj[key]===null||obj[key]===0||obj[key]===false||obj[key]===\"\"){\\n            delete obj[key];\\n         }\\n         if(typeof obj[key]===\\'object\\'){\\n            compactObject(obj[key]);\\n         }\\n      }\\n\\n   }\\n   return obj;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n\\n   if(Array.isArray(obj)){\\n      for(let i = 0;i< obj.length;i++){\\n         if(obj[i] ===null|| obj[i] ===0 || obj[i]===false||obj[i]===\"\"){\\n            obj.splice(i,1);\\n            i--;\\n         }\\n         if(typeof obj[i]===\\'object\\'){\\n            compactObject(obj[i]);\\n         }\\n      }\\n   }\\n   else{\\n      for(const key in obj){\\n         if(obj[key]===null||obj[key]===0||obj[key]===false||obj[key]===\"\"){\\n            delete obj[key];\\n         }\\n         if(typeof obj[key]===\\'object\\'){\\n            compactObject(obj[key]);\\n         }\\n      }\\n\\n   }\\n   return obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3642392,
                "title": "easy-solution-o-n-time-and-space-complexity-javascript-typescript-versions",
                "content": "# Intuition\\nThe given solution aims to implement a function called **compactObject** that takes an object *obj* as input and returns a new object where all the falsy values (null, undefined, empty strings, etc.) are removed. This function uses recursion to traverse the object and its nested properties to solve this problem\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nFirst, we are checking if the input obj is an array. If it is, use the reduce method to iterate over each item in the array. For each item, recursively apply the **compactObject** function to obtain the compacted item. If the compacted item is truthy, adding it to the accumulator array. Finally, return the accumulated array.\\n\\nNext, we are checking if the input obj is an object (not an array) and not null. If it is, use the reduce method on the keys of the object. For each key, recursively apply the **compactObject** function to obtain the compacted value. If the compacted value is truthy, add it to the accumulator object with the same key. Finally, return the accumulated object.\\n\\nIf none of the above conditions are met, it means the input obj is a primitive value. Return the value if it is truthy or null if it is falsy.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Please Upwote this solution if it will be useful for you \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F\\n\\n# Javascript Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\\n\\n# Typescript Code\\nIn the TypeScript version, the code includes type annotations for the functions parameter and the return type of the **compactObject** function. \\n\\nIn the TypeScript version, the function **compactObject** is defined as a generic function using the type parameter **T**. This allows the function to maintain type safety by preserving the input type and returning the same type.\\n\\nThe logic and flow of the code remain the same as in the original JavaScript solution. The only difference is the addition of type annotations to make the code TypeScript-compliant.\\n\\n```\\nconst compactObject = <T>(obj: T): T => {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\\n# Please Upwote this solution if it was useful for you \\u2764\\uFE0F\\u2764\\uFE0F\\u2764\\uFE0F",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```\n```\\nconst compactObject = <T>(obj: T): T => {\\n    //check is it an array\\n    if (Array.isArray(obj)) {\\n        return obj.reduce((acc, cur) => {\\n            let value = compactObject(cur);\\n\\n            if (value) {\\n                acc.push(value);\\n            }\\n            \\n            return acc;\\n        }, [])\\n    }\\n\\n    //check is it an object\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj).reduce((acc, key) => {\\n            let value = compactObject(obj[key]);\\n\\n            if (value) {\\n                acc[key] = value;\\n            }\\n            \\n            return acc\\n        }, {});\\n    }\\n\\n    // If it is neither an array, nor an object, nor null, return the value (which can be a string, number, or boolean)\\n    return obj || null;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582761,
                "title": "straight-forward-recursive-solution-with-comments",
                "content": "# Intuition\\nRecursive iteration thru the object keys and array elements.\\n\\n# Approach\\nCheck the type of given object. If the type is an array or object, loop thru each sub object inside the array/object rescursively. If the type a primitive element (not an array or object), keep it or ignore it based on whether it is a \\'truthy\\' value.\\n\\n# Complexity\\n- Time complexity:\\nO(n): Need to check every element and sub-element in the given object.\\n\\n- Space complexity:\\nO(n): Need to construct a new object that could be of same size as the given object.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet getCompact = (val) => {\\n    if (Array.isArray(val)) {\\n        let resultArray = [];\\n        // console.log(`Iterating thru array: ${JSON.stringify(val)}`);\\n        for (let subVal of val) {\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultArray.push(compactSub);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof val === \\'object\\' && val !== null) {\\n        let resultObject = {};\\n        // console.log(`Iterating thru object: ${JSON.stringify(val)}`);\\n        for (let [key, subVal] of Object.entries(val)) {\\n            // console.log(`Checking key ${key}: ${JSON.stringify(subVal)}`);\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultObject[key] = compactSub;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(val) === true) return val;\\n    return undefined;\\n}\\n\\nvar compactObject = function(obj) {\\n    // console.log(Object.entries(obj));\\n    return getCompact(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet getCompact = (val) => {\\n    if (Array.isArray(val)) {\\n        let resultArray = [];\\n        // console.log(`Iterating thru array: ${JSON.stringify(val)}`);\\n        for (let subVal of val) {\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultArray.push(compactSub);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof val === \\'object\\' && val !== null) {\\n        let resultObject = {};\\n        // console.log(`Iterating thru object: ${JSON.stringify(val)}`);\\n        for (let [key, subVal] of Object.entries(val)) {\\n            // console.log(`Checking key ${key}: ${JSON.stringify(subVal)}`);\\n            let compactSub = getCompact(subVal);\\n            if (Boolean(compactSub)) {\\n                resultObject[key] = compactSub;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(val) === true) return val;\\n    return undefined;\\n}\\n\\nvar compactObject = function(obj) {\\n    // console.log(Object.entries(obj));\\n    return getCompact(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3566156,
                "title": "simple-check",
                "content": "Simple check.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\nif (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  const compactedObj = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      compactedObj[key] = value;\\n    }\\n  }\\n  return compactedObj;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\nif (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  const compactedObj = {};\\n  for (const key in obj) {\\n    const value = compactObject(obj[key]);\\n    if (Boolean(value)) {\\n      compactedObj[key] = value;\\n    }\\n  }\\n  return compactedObj;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3579479,
                "title": "ts-dfs-like-traversal-90ms-53-5mb",
                "content": "Another one we can conveniently solve just by traversing our objects as we would traverse any other tree structure: with a BFS or, as I prefer since it tends to be more efficient, with a DFS.\\n\\nWe will split our logic by type so that our result value `Obj` can also be a boolean and act depending on the type of `obj`:\\n* if `obj` is not an object of if it is `null`, we will just `return` it;\\n* it is an array, we will `return` what we get if we `reduce` it with an accumulator `acc` initially set to be an empty array, going through all its properties as `iter` and:\\n    * `return` `acc` if `iter` is falsey;\\n    * `.push` into `acc` the result of calling `compactObject` on `iter`;\\n    * `return` `acc`;\\n* if it is any other kind of object, we will proceed in a fashion similar to the previous looping through the `[key, val]` pairs in `Object.entries(obj)` and:\\n* if `val` is truthy, we will add to `acc` a new property `key` and `compactObject(val)` as its value;\\n* `return` `acc`.\\n\\nCheck [json deep equal](https://leetcode.com/problems/check-if-object-instance-of-class/https://leetcode.com/problems/json-deep-equal/) ([cracked here](https://leetcode.com/problems/json-deep-equal/solutions/3530101/c-diffing-algo-with-dfs-traversal-68ms-50-5mb/)) if you want to practice more of this kind of problems.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc.push(compactObject(iter));\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc[key] = compactObject(val);\\n        return acc;\\n    }, {});\\n};\\n```\\n\\nMore functional programming way of doing the same, creating a new `acc` at each step:\\n\\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc = [... acc, compactObject(iter)];\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc = {...acc, [key]: compactObject(val)};\\n        return acc;\\n    }, {});\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Depth-First Search"
                ],
                "code": "```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc.push(compactObject(iter));\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc[key] = compactObject(val);\\n        return acc;\\n    }, {});\\n};\\n```\n```ts\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    // obj is not an object or is null\\n    if (typeof obj !== \\'object\\' || obj === null) return obj;\\n    // obj is an array\\n    if (Array.isArray(obj)) return obj.reduce((acc, iter) => {\\n        if (!iter) return acc;\\n        acc = [... acc, compactObject(iter)];\\n        return acc;\\n    }, []);\\n    // obj is an ordinary object\\n    return Object.entries(obj).reduce((acc, [key, val]) => {\\n        if (val) acc = {...acc, [key]: compactObject(val)};\\n        return acc;\\n    }, {});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085078,
                "title": "best-of-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") \\n    return obj;\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n    return compacted;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    if (obj === null) return null;\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n    if (typeof obj !== \"object\") \\n    return obj;\\n    const compacted = {};\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n        if (Boolean(value)) compacted[key] = value;\\n    }\\n    return compacted;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079891,
                "title": "recursion-approach",
                "content": "# Code\\n```\\nvar compactObject = function (obj) {\\n  if (typeof obj !== \"object\") {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  for (const key in obj) {\\n    if (!obj[key]) {\\n      delete obj[key];\\n      continue;\\n    }\\n\\n    obj[key] = compactObject(obj[key]);\\n  }\\n\\n  return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function (obj) {\\n  if (typeof obj !== \"object\") {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  for (const key in obj) {\\n    if (!obj[key]) {\\n      delete obj[key];\\n      continue;\\n    }\\n\\n    obj[key] = compactObject(obj[key]);\\n  }\\n\\n  return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4068437,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n if (obj === null) return null;\\n if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n if (typeof obj !== \"object\") return obj;\\n \\n const compacted = {};\\n for (const key in obj) {\\n let value = compactObject(obj[key]);\\n if (Boolean(value)) compacted[key] = value;\\n }\\n\\n return compacted;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n if (obj === null) return null;\\n if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n if (typeof obj !== \"object\") return obj;\\n \\n const compacted = {};\\n for (const key in obj) {\\n let value = compactObject(obj[key]);\\n if (Boolean(value)) compacted[key] = value;\\n }\\n\\n return compacted;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4058309,
                "title": "an-easy-and-readable-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar compactObject = function (obj) {\\n \\n\\n   \\n   if(Array.isArray(obj))\\n    obj = obj.reduce((acc,e)=>{\\n      if(typeof(e) == \"object\" && e != null)\\n       e =  compactObject(e)\\n      //  console.log(e, acc)\\n       if(Boolean(e)){\\n         acc.push(e)\\n        //  console.log(acc)\\n       } \\n     return acc\\n    },[])\\n    // console.log(obj)\\n\\n    if(typeof(obj) == \"object\" && !Array.isArray(obj)){\\n       for(let i in obj ){\\n        if(typeof(obj[i]) == \"object\" && obj[i] != null){\\n          obj[i] = compactObject(obj[i])\\n        }\\n\\n        \\n\\n        // console.log(obj[i])\\n        \\n        !Boolean(obj[i]) && delete obj[i]\\n      }\\n    }\\n\\n   return obj\\n   \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function (obj) {\\n \\n\\n   \\n   if(Array.isArray(obj))\\n    obj = obj.reduce((acc,e)=>{\\n      if(typeof(e) == \"object\" && e != null)\\n       e =  compactObject(e)\\n      //  console.log(e, acc)\\n       if(Boolean(e)){\\n         acc.push(e)\\n        //  console.log(acc)\\n       } \\n     return acc\\n    },[])\\n    // console.log(obj)\\n\\n    if(typeof(obj) == \"object\" && !Array.isArray(obj)){\\n       for(let i in obj ){\\n        if(typeof(obj[i]) == \"object\" && obj[i] != null){\\n          obj[i] = compactObject(obj[i])\\n        }\\n\\n        \\n\\n        // console.log(obj[i])\\n        \\n        !Boolean(obj[i]) && delete obj[i]\\n      }\\n    }\\n\\n   return obj\\n   \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4057752,
                "title": "use-of-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\n    let res = Array.isArray(obj)? [] : {}\\n    function compact(obj, result)\\n    { \\n        Object.keys(obj).map(key =>{\\n            if(obj[key])\\n            {\\n                if (obj[key] instanceof Object) {\\n                    const inter = compact(obj[key], Array.isArray(obj[key])? [] : {})\\n                    Array.isArray(obj) ? result.push(inter) : (result[key] = inter)\\n                    return \\n                }\\n                Array.isArray(obj) ? result.push(obj[key]) : (result[key] = obj[key])\\n                return\\n                \\n            }\\n        } )\\n        return result\\n    }\\n    obj = compact(obj, res)\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\n    let res = Array.isArray(obj)? [] : {}\\n    function compact(obj, result)\\n    { \\n        Object.keys(obj).map(key =>{\\n            if(obj[key])\\n            {\\n                if (obj[key] instanceof Object) {\\n                    const inter = compact(obj[key], Array.isArray(obj[key])? [] : {})\\n                    Array.isArray(obj) ? result.push(inter) : (result[key] = inter)\\n                    return \\n                }\\n                Array.isArray(obj) ? result.push(obj[key]) : (result[key] = obj[key])\\n                return\\n                \\n            }\\n        } )\\n        return result\\n    }\\n    obj = compact(obj, res)\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4050659,
                "title": "beats-96-34-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nfunction compactObject(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.reduce((acc, val) => {\\n      if (val) {\\n        if (Array.isArray(val)) {\\n          acc.push(compactObject(val));\\n        } else if (typeof val === \\'object\\') {\\n          acc.push(compactObject(val));\\n        } else {\\n          acc.push(val);\\n        }\\n      }\\n      return acc;\\n    }, []);\\n  }\\n\\n  if (typeof obj === \\'object\\') {\\n    const result = {};\\n    Object.entries(obj).forEach(([key, value]) => {\\n      if (value) {\\n        if (Array.isArray(value) || typeof value === \\'object\\') {\\n          result[key] = compactObject(value);\\n        } else {\\n          result[key] = value;\\n        }\\n      }\\n    });\\n\\n    return result\\n\\n    \\n  }\\n\\n  return obj;\\n}\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nfunction compactObject(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.reduce((acc, val) => {\\n      if (val) {\\n        if (Array.isArray(val)) {\\n          acc.push(compactObject(val));\\n        } else if (typeof val === \\'object\\') {\\n          acc.push(compactObject(val));\\n        } else {\\n          acc.push(val);\\n        }\\n      }\\n      return acc;\\n    }, []);\\n  }\\n\\n  if (typeof obj === \\'object\\') {\\n    const result = {};\\n    Object.entries(obj).forEach(([key, value]) => {\\n      if (value) {\\n        if (Array.isArray(value) || typeof value === \\'object\\') {\\n          result[key] = compactObject(value);\\n        } else {\\n          result[key] = value;\\n        }\\n      }\\n    });\\n\\n    return result\\n\\n    \\n  }\\n\\n  return obj;\\n}\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4024545,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    function dfs(obj){\\n        if(!obj) return false;\\n        if(typeof obj !== \\'object\\') return obj\\n\\n        if(Array.isArray(obj)){\\n            const newArr = []\\n            for(let i=0; i<obj.length; i++){\\n                const curr = obj[i]\\n                const subRes = dfs(curr)\\n                if(subRes){\\n                    newArr.push(subRes)\\n                }\\n            }\\n            return newArr\\n        }\\n        const newObj = {}\\n\\n        for(const key in obj){\\n            const subRes = dfs(obj[key])\\n            if(subRes){\\n                newObj[key] = subRes\\n            }\\n        }\\n        return newObj\\n    }\\n    return dfs(obj)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    function dfs(obj){\\n        if(!obj) return false;\\n        if(typeof obj !== \\'object\\') return obj\\n\\n        if(Array.isArray(obj)){\\n            const newArr = []\\n            for(let i=0; i<obj.length; i++){\\n                const curr = obj[i]\\n                const subRes = dfs(curr)\\n                if(subRes){\\n                    newArr.push(subRes)\\n                }\\n            }\\n            return newArr\\n        }\\n        const newObj = {}\\n\\n        for(const key in obj){\\n            const subRes = dfs(obj[key])\\n            if(subRes){\\n                newObj[key] = subRes\\n            }\\n        }\\n        return newObj\\n    }\\n    return dfs(obj)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4017369,
                "title": "recursive-inner-function-beat-2",
                "content": "# Intuition\\nThis can be solved using a recursive function\\n# Approach\\nCreate an inner function that identifies the argument as array or object and filter acordingly, the value of each element is processed by the recursive function before being added, if it is neither an array or object then return the value.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    function deFalsy(a){\\n        if (Array.isArray(a))\\n        {\\n            let r = [];\\n            a.forEach((e) => \\n            {\\n                if (e)\\n                {  \\n                    r.push(deFalsy(e))\\n                }    \\n            });\\n            return r;\\n        }\\n        else if(typeof a === \"object\" && a !== null)\\n        {\\n            let r = {};\\n            for(let key of Object.keys(a))\\n            {\\n                if (a[key])\\n                { \\n                    r[key] = deFalsy(a[key]);;\\n                }\\n            }\\n            return r;\\n        }\\n        return a;\\n    }\\n    return deFalsy(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    function deFalsy(a){\\n        if (Array.isArray(a))\\n        {\\n            let r = [];\\n            a.forEach((e) => \\n            {\\n                if (e)\\n                {  \\n                    r.push(deFalsy(e))\\n                }    \\n            });\\n            return r;\\n        }\\n        else if(typeof a === \"object\" && a !== null)\\n        {\\n            let r = {};\\n            for(let key of Object.keys(a))\\n            {\\n                if (a[key])\\n                { \\n                    r[key] = deFalsy(a[key]);;\\n                }\\n            }\\n            return r;\\n        }\\n        return a;\\n    }\\n    return deFalsy(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4016068,
                "title": "typescript-recursive",
                "content": "# Intuition\\nyou can use *undefined* or *null* to check the return value \\n \\n\\n# Code\\n```\\ntype Obj = Record<string, any> | Array<any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (!Boolean(obj)) return undefined;\\n    if (typeof obj !== \\'object\\' ) return obj;\\n    \\n    if (Array.isArray(obj)) {\\n        let result = obj.map(item => compactObject(item));\\n        return result.filter(item =>  item!==undefined) ;\\n    }\\n    let resultObj = {};\\n    for (let key in obj) {\\n        let result = compactObject(obj[key]);\\n        if (result!=undefined) {\\n            resultObj[key] = result;\\n        }\\n    }\\n    return resultObj;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<string, any> | Array<any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (!Boolean(obj)) return undefined;\\n    if (typeof obj !== \\'object\\' ) return obj;\\n    \\n    if (Array.isArray(obj)) {\\n        let result = obj.map(item => compactObject(item));\\n        return result.filter(item =>  item!==undefined) ;\\n    }\\n    let resultObj = {};\\n    for (let key in obj) {\\n        let result = compactObject(obj[key]);\\n        if (result!=undefined) {\\n            resultObj[key] = result;\\n        }\\n    }\\n    return resultObj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4013769,
                "title": "recursion-easy-to-understand",
                "content": "\\n```\\nfunction solve(obj){\\n    if(!obj)\\n        return false;\\n    \\n    let ans;\\n    if(Array.isArray(obj)){\\n        ans = [];\\n        for(let i=0;i<obj.length;i++){\\n            let b = solve(obj[i]);\\n            if(b)\\n                ans.push(b);\\n        }\\n    }else{\\n        if(typeof(obj)!=\"object\")\\n            return obj;\\n        ans = {};\\n        for(const ky in obj){\\n            let b = solve(obj[ky]);\\n            if(b)\\n                ans[ky] = b;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    return solve(obj);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction solve(obj){\\n    if(!obj)\\n        return false;\\n    \\n    let ans;\\n    if(Array.isArray(obj)){\\n        ans = [];\\n        for(let i=0;i<obj.length;i++){\\n            let b = solve(obj[i]);\\n            if(b)\\n                ans.push(b);\\n        }\\n    }else{\\n        if(typeof(obj)!=\"object\")\\n            return obj;\\n        ans = {};\\n        for(const ky in obj){\\n            let b = solve(obj[ky]);\\n            if(b)\\n                ans[ky] = b;\\n        }\\n    }\\n    return ans;\\n    \\n}\\n\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n    return solve(obj);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3985930,
                "title": "short-json-replacer-solution",
                "content": "\\n```\\n\\nconst compactObject = obj =>\\n  JSON.parse(\\n    JSON.stringify(obj, (_, val) => {\\n      if (Array.isArray(val)) return val.filter(Boolean);\\n      if (val) return val;\\n    }),\\n  );\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst compactObject = obj =>\\n  JSON.parse(\\n    JSON.stringify(obj, (_, val) => {\\n      if (Array.isArray(val)) return val.filter(Boolean);\\n      if (val) return val;\\n    }),\\n  );\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3983672,
                "title": "compact-object-using-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet compactObject = function(obj) {\\n    const compactedData = {};\\n\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n\\n    if (typeof obj !== \"object\") return obj;\\n\\n    if (obj === null) return null;\\n\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n\\n        if (Boolean(value)) compactedData[key] = value;\\n    }\\n\\n    return compactedData;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nlet compactObject = function(obj) {\\n    const compactedData = {};\\n\\n    if (Array.isArray(obj)) return obj.filter(Boolean).map(compactObject);\\n\\n    if (typeof obj !== \"object\") return obj;\\n\\n    if (obj === null) return null;\\n\\n    for (const key in obj) {\\n        let value = compactObject(obj[key]);\\n\\n        if (Boolean(value)) compactedData[key] = value;\\n    }\\n\\n    return compactedData;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3982167,
                "title": "my-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\tconst result = Array.isArray(obj) ? [] : {}\\n\\tconst addToResult = (i, obj) => {\\n\\t\\tif(Array.isArray(result)) {\\n\\t\\t\\tresult.push(obj)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = obj\\n\\t\\t}\\n\\t}\\n\\tfor (const i in obj) {\\n\\t\\t\\tif (i === null || !Boolean(obj[i])) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if (typeof obj[i] === \\'object\\') {\\n\\t\\t\\t\\taddToResult(i, compactObject(obj[i]))\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddToResult(i, obj[i])\\n\\t\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object|Array} obj\\n * @return {Object|Array}\\n */\\nvar compactObject = function(obj) {\\n\\tconst result = Array.isArray(obj) ? [] : {}\\n\\tconst addToResult = (i, obj) => {\\n\\t\\tif(Array.isArray(result)) {\\n\\t\\t\\tresult.push(obj)\\n\\t\\t} else {\\n\\t\\t\\tresult[i] = obj\\n\\t\\t}\\n\\t}\\n\\tfor (const i in obj) {\\n\\t\\t\\tif (i === null || !Boolean(obj[i])) {\\n\\t\\t\\t\\tcontinue\\n\\t\\t\\t} else if (typeof obj[i] === \\'object\\') {\\n\\t\\t\\t\\taddToResult(i, compactObject(obj[i]))\\n\\t\\t\\t} else {\\n\\t\\t\\t\\taddToResult(i, obj[i])\\n\\t\\t\\t}\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3957333,
                "title": "elegant-simple-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (typeof obj !== \\'object\\') return obj\\n\\n    if (Array.isArray(obj)) {\\n        return obj\\n                .reduce((acc, el) => {\\n                    if (el) acc.push(compactObject(el))\\n                    return acc\\n                }, [])\\n    } else if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj)\\n            .reduce((acc,key) => {\\n                if (obj[key]) acc[key] = compactObject(obj[key])\\n                return acc\\n            }, {})\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (typeof obj !== \\'object\\') return obj\\n\\n    if (Array.isArray(obj)) {\\n        return obj\\n                .reduce((acc, el) => {\\n                    if (el) acc.push(compactObject(el))\\n                    return acc\\n                }, [])\\n    } else if (typeof obj === \\'object\\' && obj !== null) {\\n        return Object.keys(obj)\\n            .reduce((acc,key) => {\\n                if (obj[key]) acc[key] = compactObject(obj[key])\\n                return acc\\n            }, {})\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938286,
                "title": "typescript-1-line-solution-84ms",
                "content": "# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    return Array.isArray( obj ) \\n        ? obj.filter( Boolean ).map( compactObject )\\n        : ( obj && typeof obj === \\'object\\' )\\n        ? Object.assign( {}, ...Object.keys( obj ).map( key => obj[ key ] ? { [key]: compactObject( obj[ key ] ) } : {} ) )\\n        : obj;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    return Array.isArray( obj ) \\n        ? obj.filter( Boolean ).map( compactObject )\\n        : ( obj && typeof obj === \\'object\\' )\\n        ? Object.assign( {}, ...Object.keys( obj ).map( key => obj[ key ] ? { [key]: compactObject( obj[ key ] ) } : {} ) )\\n        : obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3930265,
                "title": "simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return obj.map(compactObject).filter(Boolean);\\n    }else if(obj && typeof obj == \"object\"){\\n        let result = {};\\n        for(const k in obj){\\n            const compactValue = compactObject(obj[k]);\\n            if(Boolean(compactValue)) result[k] = compactValue;\\n        }\\n        return result;\\n    }else{\\n        return obj;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return obj.map(compactObject).filter(Boolean);\\n    }else if(obj && typeof obj == \"object\"){\\n        let result = {};\\n        for(const k in obj){\\n            const compactValue = compactObject(obj[k]);\\n            if(Boolean(compactValue)) result[k] = compactValue;\\n        }\\n        return result;\\n    }else{\\n        return obj;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3927268,
                "title": "2705-compact-object",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val)\\n                compactArr.push(val)\\n        }\\n\\n        return compactArr\\n    } \\n\\n    const compactObj = {};\\n    for(let key in obj){\\n        const val = compactObject(obj[key]);\\n        if(val)\\n            compactObj[key] = val\\n    }\\n\\n    return compactObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null){\\n        return obj\\n    }\\n\\n    if(Array.isArray(obj)){\\n        const compactArr = []\\n        for(let i = 0; i < obj.length; i++){\\n            let val = compactObject(obj[i]);\\n            if(val)\\n                compactArr.push(val)\\n        }\\n\\n        return compactArr\\n    } \\n\\n    const compactObj = {};\\n    for(let key in obj){\\n        const val = compactObject(obj[key]);\\n        if(val)\\n            compactObj[key] = val\\n    }\\n\\n    return compactObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3911310,
                "title": "simple-solution-beats-98-2-step-by-step-explanation",
                "content": "# Intuition/Thought Process\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thoughts on how to solve this problem involved creating an initial if else block to handle whether the JSON Object was an array of an Object with key-value pairs, and then to iterate through the values of the object, filtering out anything that is `falsy`.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy final solution is a recursive solution operating in two similar ways depending on whether `obj` is an array or an object. We can check that with this if else:\\n```javascript\\nif (Array.isArray(obj)) {\\n    // handle array\\n} else {\\n    // handle object\\n}\\n```\\n\\nIf it is an array we first filter out any element that evaluates as `falsy` with this:\\n```javascript\\n.filter(el => Boolean(el))\\n```\\nThis iterates through every element of `obj`, referring to the current element as `el`, and checks if `Boolean(el)` evalues to a true value. If it does, it is included in the resulting array. \\nAfter this, we map through all the remaining values and check if they are an object, indicating that there is nesting going on in `obj` and we need to recursively call `compactObject()` to deal with it. We do this like this:\\n```javascript\\n.map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n```\\nThis now iterates through every `el` in the resulting array from out `.filter()` call just a line earlier. It checks that the `typeof el === \\'object\\'` which means that `el` does not just contain a value, but is a nested object within `obj`. If it is, we implicitly return `compactObject(el)`, and if not we simply return `el`. This line could be rewritten without the implicit return like this, for more clarity:\\n```javascript\\n.map(el => {\\n    return typeof el === \\'object\\' ? compactObject(el) : el\\n}\\n```\\n\\nWe can take a very similar approach to filtering out `falsy` values from the object now.\\nFirst, we\\'ll define a resulting object to return:\\n```javascript\\nlet res = {}\\n```\\nNow, we can iterate through the keys of the object and check if the value associated with the key is `truthy` or `falsy`:\\n```javascript\\nfor (const key of Object.keys(obj)) {\\n    if (Boolean(obj[key])) {\\n        // ...\\n    }\\n}\\n```\\nThen, inside the if statement, we do something similar to earlier to check if we can to recursively handle any nested objects:\\n```javascript\\nres[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n```\\nNow, we just return res! :)\\n```javascript\\nreturn res\\n```\\n\\n\\n# Complexity\\n- Time complexity: $$O(n+d)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nwhere `n` is the total number of elements/properties across all objects/arrays in the structure, and `d` is the maximum depth of nested structures.\\n\\n- Space complexity: $$O(n+d)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .filter(el => Boolean(el))\\n            .map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n    } else {\\n        let res = {}\\n        for (const key of Object.keys(obj)) {\\n            if (Boolean(obj[key])) {\\n                res[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n            }\\n        }\\n        return res\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/5838a724-e2c3-4736-a11c-bc0a2c51d41f_1692073895.2148383.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nif (Array.isArray(obj)) {\\n    // handle array\\n} else {\\n    // handle object\\n}\\n```\n```javascript\\n.filter(el => Boolean(el))\\n```\n```javascript\\n.map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n```\n```javascript\\n.map(el => {\\n    return typeof el === \\'object\\' ? compactObject(el) : el\\n}\\n```\n```javascript\\nlet res = {}\\n```\n```javascript\\nfor (const key of Object.keys(obj)) {\\n    if (Boolean(obj[key])) {\\n        // ...\\n    }\\n}\\n```\n```javascript\\nres[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n```\n```javascript\\nreturn res\\n```\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .filter(el => Boolean(el))\\n            .map(el => typeof el === \\'object\\' ? compactObject(el) : el)\\n    } else {\\n        let res = {}\\n        for (const key of Object.keys(obj)) {\\n            if (Boolean(obj[key])) {\\n                res[key] = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key]\\n            }\\n        }\\n        return res\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909368,
                "title": "javascript-solution-recursive-approach-beats-90-79",
                "content": "```javascript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        const result = [];\\n        for (const elem of obj) {\\n            if (!elem) continue;\\n            result.push(typeof(elem) === \\'object\\' ? compactObject(elem) : elem);\\n        }\\n        return result;\\n    }\\n    \\n    const result = {};\\n    for (const key in obj) {\\n        const value = obj[key];\\n        if (!value) continue;\\n        result[key] = typeof(value) === \\'object\\' ? compactObject(value) : value;\\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        const result = [];\\n        for (const elem of obj) {\\n            if (!elem) continue;\\n            result.push(typeof(elem) === \\'object\\' ? compactObject(elem) : elem);\\n        }\\n        return result;\\n    }\\n    \\n    const result = {};\\n    for (const key in obj) {\\n        const value = obj[key];\\n        if (!value) continue;\\n        result[key] = typeof(value) === \\'object\\' ? compactObject(value) : value;\\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3906524,
                "title": "clear-solution-using-recursive",
                "content": "# Intuition\\nrecursive iteration to handle array items or object keys.\\n\\n# Approach\\nLoop over each item in array or key-value in object, if `Boolean(entry)` is false, then drop it; otherwise check its type via `typeof`: if `object` which means array or object, then recursively call the function to handle it, else for other primitives type, just push/add to result array or restult object.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where N is the total number of the entries including all elements and sub-elements inside.\\n\\n- Space complexity: $$O(n)$$, same as the above\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n    const res: any[] = [];\\n    obj.forEach((e) => {\\n      if (e) {\\n        res.push(typeof e === \\'object\\' ? compactObject(e) : e);\\n      }\\n    });\\n    return res;\\n  }\\n\\n  const res: Obj = {};\\n  for (const key in obj) {\\n    if (obj[key]) {\\n      res[key] =\\n        typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n    const res: any[] = [];\\n    obj.forEach((e) => {\\n      if (e) {\\n        res.push(typeof e === \\'object\\' ? compactObject(e) : e);\\n      }\\n    });\\n    return res;\\n  }\\n\\n  const res: Obj = {};\\n  for (const key in obj) {\\n    if (obj[key]) {\\n      res[key] =\\n        typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3901513,
                "title": "intuitive-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar compactObject = function(obj) {\\n  if (typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n  if (Array.isArray(obj)) {\\n    let result = [];\\n    for (let n of obj) {\\n      if (Boolean(n)) {\\n        result.push(compactObject(n));\\n      }\\n    }    \\n    return result;\\n  } else {\\n    let result = {};\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (Boolean(v)) {\\n        result[k] = compactObject(v);\\n      }\\n    }    \\n    return result;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {\\n  if (typeof obj !== \\'object\\') {\\n    return obj;\\n  }\\n  if (Array.isArray(obj)) {\\n    let result = [];\\n    for (let n of obj) {\\n      if (Boolean(n)) {\\n        result.push(compactObject(n));\\n      }\\n    }    \\n    return result;\\n  } else {\\n    let result = {};\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (Boolean(v)) {\\n        result[k] = compactObject(v);\\n      }\\n    }    \\n    return result;\\n  }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3896356,
                "title": "easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nfunction modifyArray(arr) {\\n  const result = [];\\n\\n  arr.forEach((value) => {\\n    if(Array.isArray(value)) {\\n      const res = modifyArray(value);\\n      result.push(res);\\n      return;\\n    }\\n\\n    const res = modifyObject(value);\\n    if(res)\\n      result.push(res);\\n  })\\n\\n  return result;\\n}\\n\\nfunction modifyObject(obj) {\\n  if(!obj) return null;\\n\\n  const result = {};\\n\\n  if(typeof obj === \\'object\\') {\\n    for(let key in obj) {\\n      const value = obj[key]\\n      if(Array.isArray(value)) {\\n        result[key] = modifyArray(value);\\n        continue;\\n      }\\n\\n      const res = modifyObject(value);\\n\\n      if(res) {\\n        result[key] = res;\\n      }\\n    }\\n\\n    return result;\\n  }  \\n\\n  return obj;\\n}\\n\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n      return modifyArray(obj);\\n    }\\n\\n    return modifyObject(obj)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\nfunction modifyArray(arr) {\\n  const result = [];\\n\\n  arr.forEach((value) => {\\n    if(Array.isArray(value)) {\\n      const res = modifyArray(value);\\n      result.push(res);\\n      return;\\n    }\\n\\n    const res = modifyObject(value);\\n    if(res)\\n      result.push(res);\\n  })\\n\\n  return result;\\n}\\n\\nfunction modifyObject(obj) {\\n  if(!obj) return null;\\n\\n  const result = {};\\n\\n  if(typeof obj === \\'object\\') {\\n    for(let key in obj) {\\n      const value = obj[key]\\n      if(Array.isArray(value)) {\\n        result[key] = modifyArray(value);\\n        continue;\\n      }\\n\\n      const res = modifyObject(value);\\n\\n      if(res) {\\n        result[key] = res;\\n      }\\n    }\\n\\n    return result;\\n  }  \\n\\n  return obj;\\n}\\n\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n      return modifyArray(obj);\\n    }\\n\\n    return modifyObject(obj)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3888842,
                "title": "recursive-falsy-key-removal-for-compact-objects",
                "content": "# Intuition\\nThe compactObject function aims to remove keys containing falsy values from an input object or array, while also recursively applying the same process to nested objects and arrays. The intuition behind the approach is to traverse the input structure, filtering out any keys with falsy values, and transforming the structure into a more compact form.\\n\\nThe function uses a combination of conditional statements, filtering, mapping, and recursion to achieve this compacting behavior.\\n\\n# Approach\\nThe compactObject function recursively processes an object or array and removes keys containing falsy values. Here\\'s how it works:\\n\\nThe function first checks if the input obj is not an object (including null) or if it\\'s an array. If so, it directly returns the object (or array) since no further processing is needed.\\n\\nIf the input obj is an array, it uses the filter method to remove falsy values from the array and then applies the compactObject function to each remaining item using the map method.\\n\\nIf the input obj is an object, it uses Object.entries to get an array of [key, value] pairs, filters out pairs where the value is falsy, and then uses reduce to build the compacted object. During the reduction, it recursively applies the compactObject function to each value.\\n\\n# Complexity\\n- Time complexity:\\na time complexity of O(n), where n is the length of the array.\\n\\n- Space complexity:\\nThe space complexity is determined by the memory usage of the recursive call stack and the auxiliary space used during object transformation.\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n     if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(item => Boolean(item)).map(compactObject);\\n  }\\n\\n  return Object.entries(obj)\\n    .filter(([key, value]) => Boolean(value))\\n    .reduce((result, [key, value]) => {\\n      result[key] = compactObject(value);\\n      return result;\\n    }, {});\\n};\\n```\\nThe compactObject function applies a recursive approach to traverse and compact an input object or array by removing keys with falsy values. The time complexity is influenced by the number of keys and the maximum number of elements within arrays, while the space complexity is determined by the recursive call stack depth and auxiliary space required for intermediate data structures.\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n     if (typeof obj !== \\'object\\' || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.filter(item => Boolean(item)).map(compactObject);\\n  }\\n\\n  return Object.entries(obj)\\n    .filter(([key, value]) => Boolean(value))\\n    .reduce((result, [key, value]) => {\\n      result[key] = compactObject(value);\\n      return result;\\n    }, {});\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3880795,
                "title": "accepted-javascript",
                "content": "```\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .map(i => compactObject(i))\\n            .filter(i => Boolean(i));\\n    }\\n    else if (obj != null && typeof(obj) == \"object\") {\\n        var entries = Object\\n            .entries(obj)\\n            .map(v => compactObject(v))\\n            .filter(([_, v]) => v != null)\\n        return Object.fromEntries(entries);\\n    }\\n    else {\\n        return obj;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        return obj\\n            .map(i => compactObject(i))\\n            .filter(i => Boolean(i));\\n    }\\n    else if (obj != null && typeof(obj) == \"object\") {\\n        var entries = Object\\n            .entries(obj)\\n            .map(v => compactObject(v))\\n            .filter(([_, v]) => v != null)\\n        return Object.fromEntries(entries);\\n    }\\n    else {\\n        return obj;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3867660,
                "title": "easy-peasy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    \\n    const isArray = Array.isArray(obj);\\n    const r =  isArray ? [] : {};\\n    \\n    for (let key in obj) {\\n        var el = obj[key];\\n        \\n        if(typeof el === \"object\" && el !== null){\\n            isArray ? r.push(compactObject(el)) : r[key] = compactObject(el)\\n        }\\n        else if(Boolean(el)){\\n            isArray ? r.push(el) : r[key] = el \\n        }\\n    }\\n    return r\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    \\n    const isArray = Array.isArray(obj);\\n    const r =  isArray ? [] : {};\\n    \\n    for (let key in obj) {\\n        var el = obj[key];\\n        \\n        if(typeof el === \"object\" && el !== null){\\n            isArray ? r.push(compactObject(el)) : r[key] = compactObject(el)\\n        }\\n        else if(Boolean(el)){\\n            isArray ? r.push(el) : r[key] = el \\n        }\\n    }\\n    return r\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3847083,
                "title": "easy-solution-js",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse Array.property.filter() and delete key object method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStep 1: Filter obj\\nStep 2: Obj key loop\\n    - If obj[key] is falsy, delete this key\\n    - If type of obj[key] is object (array also has type object), callback compactObject() function with obj[key] instead of obj\\n# Complexity\\n- Time complexity: 80ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 52.54mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) obj = obj.filter(val => val);\\n    for (const key in obj) {\\n        if (!obj[key]) {\\n            delete obj[key]\\n        } else if (typeof obj[key] === \\'object\\') {\\n            obj[key] = compactObject(obj[key]);\\n        }\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) obj = obj.filter(val => val);\\n    for (const key in obj) {\\n        if (!obj[key]) {\\n            delete obj[key]\\n        } else if (typeof obj[key] === \\'object\\') {\\n            obj[key] = compactObject(obj[key]);\\n        }\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845167,
                "title": "compact-js",
                "content": "# Code\\n```\\nvar compactObject = function(obj) {    \\n    const isFalsy = (v) => {\\n        return !v;\\n    }\\n\\n    const getObjType = (o) => {\\n        if(o === null) return null\\n        if(o === undefined) return undefined;\\n\\n        if(typeof o === \"number\") return \"number\";\\n        if(typeof o === \"string\") return \"string\";\\n        if(typeof o === \"boolean\") return \"boolean\";\\n        \\n        if(Array.isArray(o)) return \"array\";\\n        \\n        return \"object\";\\n    }\\n\\n    const compactArray = (o) => {\\n        const res = [];\\n\\n        for(let val of o) {\\n            const type = getObjType(val);\\n            if(type === \"array\") {\\n                res.push(compactArray(val));\\n            }else if(type === \"object\") {\\n                res.push(compactObj(val));\\n            }else if(!isFalsy(val)){\\n                res.push(val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    const compactObj = (o) => {\\n        const res = {};\\n\\n        for(let k in o) {\\n            const type = getObjType(o[k]);\\n            if(type === \"array\") {\\n                res[k] = compactArray(o[k]);\\n            }else if(type === \"object\") {\\n                res[k] = compactObj(o[k]);\\n            }else if(!isFalsy(o[k])){\\n                res[k] = o[k];\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    let res = null;\\n    \\n    const type = getObjType(obj);\\n    if(type === \"array\") {\\n        res = compactArray(obj);\\n    }else if(type === \"object\") {\\n        res = compactObj(obj);\\n    }else if(!isFalsy(obj)){\\n        res = obj;\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar compactObject = function(obj) {    \\n    const isFalsy = (v) => {\\n        return !v;\\n    }\\n\\n    const getObjType = (o) => {\\n        if(o === null) return null\\n        if(o === undefined) return undefined;\\n\\n        if(typeof o === \"number\") return \"number\";\\n        if(typeof o === \"string\") return \"string\";\\n        if(typeof o === \"boolean\") return \"boolean\";\\n        \\n        if(Array.isArray(o)) return \"array\";\\n        \\n        return \"object\";\\n    }\\n\\n    const compactArray = (o) => {\\n        const res = [];\\n\\n        for(let val of o) {\\n            const type = getObjType(val);\\n            if(type === \"array\") {\\n                res.push(compactArray(val));\\n            }else if(type === \"object\") {\\n                res.push(compactObj(val));\\n            }else if(!isFalsy(val)){\\n                res.push(val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    const compactObj = (o) => {\\n        const res = {};\\n\\n        for(let k in o) {\\n            const type = getObjType(o[k]);\\n            if(type === \"array\") {\\n                res[k] = compactArray(o[k]);\\n            }else if(type === \"object\") {\\n                res[k] = compactObj(o[k]);\\n            }else if(!isFalsy(o[k])){\\n                res[k] = o[k];\\n            }\\n        }\\n\\n        return res;\\n    }\\n\\n    let res = null;\\n    \\n    const type = getObjType(obj);\\n    if(type === \"array\") {\\n        res = compactArray(obj);\\n    }else if(type === \"object\") {\\n        res = compactObj(obj);\\n    }else if(!isFalsy(obj)){\\n        res = obj;\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840543,
                "title": "compact-object-beats-92-12-of-users-with-javascript",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nfunction isFalsy(value) {\\n  return !value; // Converts value to a boolean and negates it\\n}\\n\\nfunction compactObject(obj) {\\n  if (typeof obj !== \"object\" || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.map(compactObject).filter((value) => !isFalsy(value));\\n  }\\n\\n  return Object.entries(obj).reduce((acc, [key, value]) => {\\n    const compactValue = compactObject(value);\\n    if (!isFalsy(compactValue)) {\\n      acc[key] = compactValue;\\n    }\\n    return acc;\\n  }, {});\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nfunction isFalsy(value) {\\n  return !value; // Converts value to a boolean and negates it\\n}\\n\\nfunction compactObject(obj) {\\n  if (typeof obj !== \"object\" || obj === null) {\\n    return obj;\\n  }\\n\\n  if (Array.isArray(obj)) {\\n    return obj.map(compactObject).filter((value) => !isFalsy(value));\\n  }\\n\\n  return Object.entries(obj).reduce((acc, [key, value]) => {\\n    const compactValue = compactObject(value);\\n    if (!isFalsy(compactValue)) {\\n      acc[key] = compactValue;\\n    }\\n    return acc;\\n  }, {});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3840312,
                "title": "javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const newObj = new Object(obj);\\n    if (obj instanceof Array){\\n        for (let i = 0; i< obj.length; i++){\\n            if (obj[i] instanceof Object){\\n                const t = compactObject(obj[i]);\\n                if (t){\\n                    newObj[i] = t;\\n                } else{\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            } else{\\n                if (!obj[i]){\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n    } else {\\n        for (let key in obj){\\n            if (obj[key] instanceof Object){\\n                const t = compactObject(obj[key]);\\n                if (t){\\n                    newObj[key] = t;\\n                } else{\\n                    delete newObj[key];\\n                }\\n            } else{\\n                if (!obj[key]){\\n                    delete newObj[key];\\n                }\\n            }\\n        }\\n        return newObj;\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const newObj = new Object(obj);\\n    if (obj instanceof Array){\\n        for (let i = 0; i< obj.length; i++){\\n            if (obj[i] instanceof Object){\\n                const t = compactObject(obj[i]);\\n                if (t){\\n                    newObj[i] = t;\\n                } else{\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            } else{\\n                if (!obj[i]){\\n                    obj.splice(i, 1);\\n                    i--;\\n                }\\n            }\\n        }\\n    } else {\\n        for (let key in obj){\\n            if (obj[key] instanceof Object){\\n                const t = compactObject(obj[key]);\\n                if (t){\\n                    newObj[key] = t;\\n                } else{\\n                    delete newObj[key];\\n                }\\n            } else{\\n                if (!obj[key]){\\n                    delete newObj[key];\\n                }\\n            }\\n        }\\n        return newObj;\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3837956,
                "title": "100-run-time-enjoy-the-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const result = Array.isArray(obj);\\n\\n    if(result){\\n        let newArray = new Array();\\n        for(let item of obj){\\n            if(item && typeof item === \\'object\\'){\\n                const res = compactObject(item);\\n                if(res) newArray.push(res);\\n            }else{\\n                if(item) newArray.push(item);\\n            }\\n        }\\n        return newArray;\\n\\n    }\\n    \\n    else{\\n        let newObject = new Object();\\n        for(let item in obj){\\n            if(obj[item] &&  typeof obj[item] === \\'object\\'){\\n                const res = compactObject(obj[item]);\\n                if(res) newObject[item] = res;\\n            }\\n            else {\\n                if(obj[item]){\\n                    newObject[item] = obj[item];\\n                }\\n            }\\n        }\\n        return newObject;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const result = Array.isArray(obj);\\n\\n    if(result){\\n        let newArray = new Array();\\n        for(let item of obj){\\n            if(item && typeof item === \\'object\\'){\\n                const res = compactObject(item);\\n                if(res) newArray.push(res);\\n            }else{\\n                if(item) newArray.push(item);\\n            }\\n        }\\n        return newArray;\\n\\n    }\\n    \\n    else{\\n        let newObject = new Object();\\n        for(let item in obj){\\n            if(obj[item] &&  typeof obj[item] === \\'object\\'){\\n                const res = compactObject(obj[item]);\\n                if(res) newObject[item] = res;\\n            }\\n            else {\\n                if(obj[item]){\\n                    newObject[item] = obj[item];\\n                }\\n            }\\n        }\\n        return newObject;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3836985,
                "title": "ts-solution",
                "content": "\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(!obj) return obj;\\n\\n    if(Array.isArray(obj)) {\\n        return obj.reduce((acc, curr) => {\\n            if(!curr) return acc;\\n\\n            if(typeof curr === \\'object\\') {\\n                acc.push(compactObject(curr))\\n                return acc\\n            }\\n            \\n            acc.push(curr)\\n            return acc;\\n        }, []);\\n    }\\n\\n    const output: Obj = {}\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if(typeof value === \\'object\\') {\\n            const filteredValue = compactObject(value);\\n\\n            if(!!filteredValue) {\\n                output[key] = filteredValue;\\n            } \\n        } else {\\n            if(!!value) {\\n                output[key] = value;\\n            }\\n        }\\n    })\\n\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(!obj) return obj;\\n\\n    if(Array.isArray(obj)) {\\n        return obj.reduce((acc, curr) => {\\n            if(!curr) return acc;\\n\\n            if(typeof curr === \\'object\\') {\\n                acc.push(compactObject(curr))\\n                return acc\\n            }\\n            \\n            acc.push(curr)\\n            return acc;\\n        }, []);\\n    }\\n\\n    const output: Obj = {}\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if(typeof value === \\'object\\') {\\n            const filteredValue = compactObject(value);\\n\\n            if(!!filteredValue) {\\n                output[key] = filteredValue;\\n            } \\n        } else {\\n            if(!!value) {\\n                output[key] = value;\\n            }\\n        }\\n    })\\n\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3833881,
                "title": "javascript-reduce-to-reduce-compact-the-object-d",
                "content": "# Intuition\\nDo operations on object and use reduce for better efficiency on deeply nested objects with many falsy values ( edge over filter + map )\\n\\n# Approach\\n1. At parent level we have null checks in place and all the logic we\\'ve written only works if the object has some data in it ( be it an Array / Object, Object.keys length check works for both )\\n2. Inside our parent block, we have 2 things to check => if it is an array or an object.\\n3. If obj is an array, we use reduce function to iterate with accumulator (acc) initialized to an empty array []. We only push the items to the accumulator if those are truthy. A double !! does the trick for boolean typecasting. In addition it it, we also check that if the current item of iteration is an object or not, if yes, we send it for getting further compacted with the help of same function \\'compacObject\\' via recursion.\\n4. Assing the accumulator back to original object (obj) to update it with compacted nested data.\\n5. Now, for the else block, since we already have handled the array part in if block, we can start writing logic for if it is an Object.\\n6. For this, simply iterate over object keys via a loop of yuor choice.\\n7. During the iteration, we again have similar conditions that we handled for Array type, i.e. compacting the nested items further if it an object, using the value directly otherwise.\\n8. We can do all operations on obj itself to delete falsy keys, assign new values to keys etc.\\n9. Firstly, we assign the compacted data back to the original object which is nothing but obj.\\n10. Secondly we delete the key entirely from \\'obj\\' if in case it is falsy using \\'delete OBJECT.KEYNAME\\'\\n11. That\\'s all, now only thing left to do is return the object obj as last statement of our function. Since all operations happend in sequence directly on obj, it will have the end result by the time we reach this last line.\\n\\n# Complexity\\n- Time complexity:\\ncompactObject = O(n)\\n\\n- Space complexity:\\ncompactObject = O(1)\\nInput object = O(h) | h = number of inputs\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = function(obj) {\\n    if(!!obj && typeof obj === \\'object\\' && Object.keys(obj).length){\\n        if(Array.isArray(obj)){\\n            obj = obj.reduce((acc, item)=>{\\n                const compacted = typeof item === \\'object\\' ? compactObject(item) : item;\\n                !!compacted && acc.push(compacted);\\n                return acc;\\n            },[])\\n        }\\n        else{\\n            Object.keys(obj).forEach(key=>{\\n                const compacted = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n                if(!!compacted) obj[key] = compacted;\\n                !compacted && delete(obj[key]);\\n            })\\n        }\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = function(obj) {\\n    if(!!obj && typeof obj === \\'object\\' && Object.keys(obj).length){\\n        if(Array.isArray(obj)){\\n            obj = obj.reduce((acc, item)=>{\\n                const compacted = typeof item === \\'object\\' ? compactObject(item) : item;\\n                !!compacted && acc.push(compacted);\\n                return acc;\\n            },[])\\n        }\\n        else{\\n            Object.keys(obj).forEach(key=>{\\n                const compacted = typeof obj[key] === \\'object\\' ? compactObject(obj[key]) : obj[key];\\n                if(!!compacted) obj[key] = compacted;\\n                !compacted && delete(obj[key]);\\n            })\\n        }\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3829136,
                "title": "easy-solution-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n  // Scenario obj is array\\n  if (Array.isArray(obj)) {\\n    return obj\\n      .filter((val) => Boolean(val))\\n      .map((curr) => {\\n        if (typeof curr === \"object\") {\\n          return compactObject(curr);\\n        } else {\\n          return curr;\\n        }\\n      });\\n  } else {\\n    const compactObj = {} as any;\\n    for (const key in obj) {\\n      if (obj.hasOwnProperty(key) && Boolean(obj[key])) {\\n        // Only truthy keys\\nif (typeof obj[key] === \"object\")\\n          compactObj[key] = compactObject(obj[key]);\\n          else {\\n            compactObj[key] = obj[key]; \\n          }      }\\n    }\\n    return compactObj;\\n  }\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n  // Scenario obj is array\\n  if (Array.isArray(obj)) {\\n    return obj\\n      .filter((val) => Boolean(val))\\n      .map((curr) => {\\n        if (typeof curr === \"object\") {\\n          return compactObject(curr);\\n        } else {\\n          return curr;\\n        }\\n      });\\n  } else {\\n    const compactObj = {} as any;\\n    for (const key in obj) {\\n      if (obj.hasOwnProperty(key) && Boolean(obj[key])) {\\n        // Only truthy keys\\nif (typeof obj[key] === \"object\")\\n          compactObj[key] = compactObject(obj[key]);\\n          else {\\n            compactObj[key] = obj[key]; \\n          }      }\\n    }\\n    return compactObj;\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3815558,
                "title": "javascript-solution-easy-with-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return;\\n    if (typeof obj !== \\'object\\') return obj;\\n\\n    let output;\\n    let curr;\\n    \\n    if (Array.isArray(obj)) {\\n        output = [];\\n\\n        for (let i = 0; i < obj.length; i++) {\\n            curr = compactObject(obj[i]);\\n            if (curr) output.push(curr);\\n        }\\n\\n    } else if (typeof obj === \\'object\\') {\\n      output = {};\\n\\n      for (const key in obj) {\\n          curr = compactObject(obj[key]);\\n          if (curr) output[key] = curr;\\n      } \\n    } \\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return;\\n    if (typeof obj !== \\'object\\') return obj;\\n\\n    let output;\\n    let curr;\\n    \\n    if (Array.isArray(obj)) {\\n        output = [];\\n\\n        for (let i = 0; i < obj.length; i++) {\\n            curr = compactObject(obj[i]);\\n            if (curr) output.push(curr);\\n        }\\n\\n    } else if (typeof obj === \\'object\\') {\\n      output = {};\\n\\n      for (const key in obj) {\\n          curr = compactObject(obj[key]);\\n          if (curr) output[key] = curr;\\n      } \\n    } \\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3807198,
                "title": "typescript-straightforward-solution",
                "content": "# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) {\\n        let retArr = []\\n        obj.forEach((e, idx) => {\\n            if(e) {\\n                retArr.push(compactObject(e))\\n            }\\n        })\\n        return retArr\\n    } else if(obj !== null && typeof obj === \\'object\\') {\\n        let retObj = {}\\n        for(const key of Object.keys(obj)) {\\n            if(obj[key]) {\\n                retObj[key] = compactObject(obj[key])\\n            }\\n        }\\n        return retObj\\n    } \\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) {\\n        let retArr = []\\n        obj.forEach((e, idx) => {\\n            if(e) {\\n                retArr.push(compactObject(e))\\n            }\\n        })\\n        return retArr\\n    } else if(obj !== null && typeof obj === \\'object\\') {\\n        let retObj = {}\\n        for(const key of Object.keys(obj)) {\\n            if(obj[key]) {\\n                retObj[key] = compactObject(obj[key])\\n            }\\n        }\\n        return retObj\\n    } \\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3775024,
                "title": "dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(obj === null) return false;\\n    if(typeof obj !== \\'object\\' ) {\\n        return obj ? obj: false;\\n    }\\n\\n    if(Array.isArray(obj)) {\\n        return obj.map((val) => {\\n            if(compactObject(val)) return compactObject(val);\\n            return false\\n        }).filter(v => v !== false)\\n    }\\n    const res = {}\\n    const keys = Object.keys(obj);\\n    for(const key of keys) {\\n        if(compactObject(obj[key])) res[key] = compactObject(obj[key]);\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(obj === null) return false;\\n    if(typeof obj !== \\'object\\' ) {\\n        return obj ? obj: false;\\n    }\\n\\n    if(Array.isArray(obj)) {\\n        return obj.map((val) => {\\n            if(compactObject(val)) return compactObject(val);\\n            return false\\n        }).filter(v => v !== false)\\n    }\\n    const res = {}\\n    const keys = Object.keys(obj);\\n    for(const key of keys) {\\n        if(compactObject(obj[key])) res[key] = compactObject(obj[key]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3770456,
                "title": "simple-recursive-approach-for-both-array-and-object",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n##### If the input is an Array:\\n- Create a separate function to handle all the elements in it.\\n- Traverse the elements of the array\\n- If the value is falsy, ignore it and continue to the next element\\n- If value is truthy and is not an object or array, add it to the result\\n- If the value is object, then recursively call the compactObject function\\n\\n##### Otherwise\\n- Traverse the keys of the object\\n- If the value is falsy, ignore it and continue to the next key\\n- If value is truthy and is not an object or array, add it to the result\\n- If the value is object, then recursively call the compactObject function\\n\\n# Complexity\\n- Time complexity: \\n    $$O(n)$$ - We will be checking every element and sub element\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n    $$O(n)$$ - Used to store the result\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return compactArray(obj);\\n    } else {\\n        const result = {};\\n        for(const key in obj){\\n            const value = obj[key];\\n\\n            if(Boolean(value)){\\n                if(typeof value !== \\'object\\'){\\n                    result[key] = value;\\n                } else {\\n                    result[key] = compactObject(value);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nconst compactArray = (arr) => {\\n    const result = [];\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const element = arr[i];\\n\\n        if(!Boolean(element)){\\n            continue;\\n        }\\n\\n        if(typeof element !== \\'object\\'){\\n            result.push(element);\\n        } else {\\n            result.push(compactObject(element));\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        return compactArray(obj);\\n    } else {\\n        const result = {};\\n        for(const key in obj){\\n            const value = obj[key];\\n\\n            if(Boolean(value)){\\n                if(typeof value !== \\'object\\'){\\n                    result[key] = value;\\n                } else {\\n                    result[key] = compactObject(value);\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n};\\n\\nconst compactArray = (arr) => {\\n    const result = [];\\n\\n    for(let i = 0; i < arr.length; i++){\\n        const element = arr[i];\\n\\n        if(!Boolean(element)){\\n            continue;\\n        }\\n\\n        if(typeof element !== \\'object\\'){\\n            result.push(element);\\n        } else {\\n            result.push(compactObject(element));\\n        }\\n    }\\n\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3753218,
                "title": "javascript-naive-solution",
                "content": "# Intuition\\nTruthy False is a term to describe whether a value should be considered as invalid to an if statement. Simply putting the value into the if statement will coerce it to be a truthy boolean.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nKnowing that when an object is passed into a `for (x in o)` means for each `key x` in `object o` we can then store the truthy true values into a new object.\\n\\nAs for the `Array.isArray` which is a builtin function (but not for leetcode) it simply checks that when the object is coerced into a string, that it is `\"[object Array]\"` which all arrays do when coerced.\\n\\n# Complexity\\n- Time complexity: $$o(n)$$ $$&$$ $$ O(n)$$ where $$n = obj$$\\n\\n- Space complexity: $$o(n)$$ $$&$$ $$O(2n)$$ where $$n = obj$$\\n\\n# Code\\n```\\n/**\\n * @brief Returns whether the object is an Array\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nArray.IsArray = (obj) => {\\n    return (Object.prototype.toString.call(obj) === \\'[object Array]\\')\\n}\\n\\n/**\\n * @brief Deep removes all values that are truthy false\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    var nobj = {};\\n    if (Array.IsArray(obj)) {\\n        nobj = [];\\n        for (var entry in obj) {\\n            entry = obj[entry];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj.push(entry);\\n        }\\n    } else {\\n        for (var key in obj) {\\n            var entry = obj[key];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj[key] = entry;\\n        }\\n    }\\n    return nobj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @brief Returns whether the object is an Array\\n * @param {Object} obj\\n * @return {Boolean}\\n */\\nArray.IsArray = (obj) => {\\n    return (Object.prototype.toString.call(obj) === \\'[object Array]\\')\\n}\\n\\n/**\\n * @brief Deep removes all values that are truthy false\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function (obj) {\\n    var nobj = {};\\n    if (Array.IsArray(obj)) {\\n        nobj = [];\\n        for (var entry in obj) {\\n            entry = obj[entry];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj.push(entry);\\n        }\\n    } else {\\n        for (var key in obj) {\\n            var entry = obj[key];\\n            if (!entry) continue;\\n            if (typeof entry == \"object\")\\n                entry = compactObject(entry);\\n            nobj[key] = entry;\\n        }\\n    }\\n    return nobj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3751835,
                "title": "2705-compact-object-easy-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let array = []\\n        for (const element of obj) {\\n            if (element) {\\n                if (typeof element == \\'object\\') array.push(compactObject(element))\\n                else array.push(element)   \\n            }\\n        }\\n        return array;\\n    }\\n\\n    let newObj = {}\\n\\n    for (let element in obj) {\\n        if (obj[element]) {\\n            if (typeof obj[element] == \\'object\\') newObj[element] = compactObject(obj[element])\\n             else  newObj[element] = obj[element]\\n        }\\n    }\\n    return newObj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let array = []\\n        for (const element of obj) {\\n            if (element) {\\n                if (typeof element == \\'object\\') array.push(compactObject(element))\\n                else array.push(element)   \\n            }\\n        }\\n        return array;\\n    }\\n\\n    let newObj = {}\\n\\n    for (let element in obj) {\\n        if (obj[element]) {\\n            if (typeof obj[element] == \\'object\\') newObj[element] = compactObject(obj[element])\\n             else  newObj[element] = obj[element]\\n        }\\n    }\\n    return newObj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3743716,
                "title": "recursive-removal-of-falsy-values-in-nested-objects-an-approach-with-o-n-time-and-space-complexity",
                "content": "# Intuition\\nThe task here is to remove all \"falsy\" (false, null, 0, \"\", undefined, and NaN) values from a given object which can be either an array or a plain object (dictionary). The function compactObject does this by traversing the object. If it encounters an array or another object, it makes a recursive call to handle it. If it encounters a \"truthy\" value, it keeps that value. The isObject function is used to check if a value is a plain object.\\n\\n# Approach\\nWe make use of the recursion to traverse the input object. During traversal, if the current item is an array, we iterate over its elements, and for each element, we check its type. If the element is also an array or an object, we make a recursive call to **compactObject**. If the element is a \"truthy\" value, we include it in the results. The same process is applied for objects, but instead of iterating over indices, we iterate over keys.\\n\\nThe **isObject** function checks whether a given value is a plain object. It does this by checking whether the type of the value is \\'object\\', the value is not null, and the value is not an array.\\n\\n# Complexity\\n**- Time complexity:**\\nThe time complexity of this function is O(n), where n is the total number of elements or properties in the object. This is because we are traversing the entire object once.\\n\\n**- Space complexity:**\\nThe space complexity is also O(n), where n is the size of the input object. This is because in the worst-case scenario, we might end up creating a deep copy of the input object (if all values are \"truthy\"). In addition, due to the recursive calls, there will be n function calls placed onto the call stack.\\n\\nPlease note that \\'n\\' here refers to the total number of nested elements or properties in the object, not just the top-level ones.\\n\\n```\\nRuntime 95 ms\\nMemory 52.6 MB\\n```\\n\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        const res = []\\n        obj.forEach((value)=>{\\n            if(Array.isArray(value)){\\n               res.push(compactObject(value))\\n            } else if (isObject(value)){\\n               res.push(compactObject(value))\\n            } else if (Boolean(value)){\\n                res.push(value)\\n            } \\n        })\\n        return res\\n    } \\n    if (isObject(obj)){\\n        const res = {}\\n        Object.entries(obj).forEach(([key, value])=>{\\n            if (Array.isArray(value)){\\n               res[key] = compactObject(value)\\n            } else if (isObject(value)){\\n                res[key] = compactObject(value)\\n            } else if (Boolean(value)){\\n                res[key] = value\\n            }\\n        })\\n        return res\\n   }\\n};\\n\\nfunction isObject(val){\\n    if (typeof val === \\'object\\' \\n        && val !== null \\n        && !Array.isArray(val)) {\\n        return true\\n    }\\n    return false\\n }\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nRuntime 95 ms\\nMemory 52.6 MB\\n```\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)){\\n        const res = []\\n        obj.forEach((value)=>{\\n            if(Array.isArray(value)){\\n               res.push(compactObject(value))\\n            } else if (isObject(value)){\\n               res.push(compactObject(value))\\n            } else if (Boolean(value)){\\n                res.push(value)\\n            } \\n        })\\n        return res\\n    } \\n    if (isObject(obj)){\\n        const res = {}\\n        Object.entries(obj).forEach(([key, value])=>{\\n            if (Array.isArray(value)){\\n               res[key] = compactObject(value)\\n            } else if (isObject(value)){\\n                res[key] = compactObject(value)\\n            } else if (Boolean(value)){\\n                res[key] = value\\n            }\\n        })\\n        return res\\n   }\\n};\\n\\nfunction isObject(val){\\n    if (typeof val === \\'object\\' \\n        && val !== null \\n        && !Array.isArray(val)) {\\n        return true\\n    }\\n    return false\\n }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3734240,
                "title": "js-solution",
                "content": "Recursively prune the object `o`\\n\\n---\\n\\n```\\nlet compactObject = o => {\\n    if (_.isBoolean(o) || _.isInteger(o))\\n        return o;\\n    if (_.isArray(o))\\n        return o.filter(x => x).map(x => compactObject(x));\\n    if (_.isObject(o))\\n        for (let [k, v] of Object.entries(o))\\n            if (v)\\n                o[k] = compactObject(v);\\n            else\\n                delete o[k];\\n    return o;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet compactObject = o => {\\n    if (_.isBoolean(o) || _.isInteger(o))\\n        return o;\\n    if (_.isArray(o))\\n        return o.filter(x => x).map(x => compactObject(x));\\n    if (_.isObject(o))\\n        for (let [k, v] of Object.entries(o))\\n            if (v)\\n                o[k] = compactObject(v);\\n            else\\n                delete o[k];\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3718590,
                "title": "easy-recursive-approach-2-3-line-solution",
                "content": "# Intuition\\n<!-- two cases to think about either ob can be array or normal object and just write recursive logic -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null) return obj;\\n    if(Array.isArray(obj)){\\n        return obj.filter(item => Boolean(item)).map(element=> compactObject(element));\\n    }\\n    return Object.fromEntries(\\n        Object.entries(obj).filter(([key, value])=> Boolean(value)).map(([key, value])=> [key, compactObject(value)])\\n    );\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\' || obj === null) return obj;\\n    if(Array.isArray(obj)){\\n        return obj.filter(item => Boolean(item)).map(element=> compactObject(element));\\n    }\\n    return Object.fromEntries(\\n        Object.entries(obj).filter(([key, value])=> Boolean(value)).map(([key, value])=> [key, compactObject(value)])\\n    );\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3704279,
                "title": "javascript-solution",
                "content": "I mainly write in Python, I asked chatgpt to help me convert to JavaScript.\\n\\n```JavaScript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.map(n => compactObject(n)).filter(n => n)\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    const item = {}\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (v) {\\n        item[k] = compactObject(v)\\n      }\\n    }\\n    return item\\n  }\\n  return obj\\n}\\n```\\n\\n\\n```python\\nclass Solution:\\n    def compactObject(self, obj: Any):\\n        if isinstance(obj, list):\\n            return [self.compactObject(n) for n in obj if n]\\n        elif isinstance(obj, dict):\\n            item = {}\\n            for k, v in obj.items():\\n                if v:\\n                    item[k] = self.compactObject(v)\\n            return item\\n        return obj\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```JavaScript\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if (Array.isArray(obj)) {\\n    return obj.map(n => compactObject(n)).filter(n => n)\\n  } else if (typeof obj === \\'object\\' && obj !== null) {\\n    const item = {}\\n    for (let [k, v] of Object.entries(obj)) {\\n      if (v) {\\n        item[k] = compactObject(v)\\n      }\\n    }\\n    return item\\n  }\\n  return obj\\n}\\n```\n```python\\nclass Solution:\\n    def compactObject(self, obj: Any):\\n        if isinstance(obj, list):\\n            return [self.compactObject(n) for n in obj if n]\\n        elif isinstance(obj, dict):\\n            item = {}\\n            for k, v in obj.items():\\n                if v:\\n                    item[k] = self.compactObject(v)\\n            return item\\n        return obj\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703952,
                "title": "recursive-solution-beats-more-than-90",
                "content": "# Approach\\nWe check whether given object is array or not, than act accordingly. Take a note that null is an object, but it\\'s falsy.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O (n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        const temp = []\\n        for (const item of obj) {\\n            if (item) {\\n                if (typeof item === \\'object\\') temp.push(compactObject(item))\\n                else temp.push(item)\\n            }\\n        }\\n        return temp\\n    }\\n    for (const [key, value] of Object.entries(obj)) {\\n        if (!value) delete obj[key]\\n        else if (typeof value === \\'object\\') obj[key] = compactObject(value)\\n    }\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        const temp = []\\n        for (const item of obj) {\\n            if (item) {\\n                if (typeof item === \\'object\\') temp.push(compactObject(item))\\n                else temp.push(item)\\n            }\\n        }\\n        return temp\\n    }\\n    for (const [key, value] of Object.entries(obj)) {\\n        if (!value) delete obj[key]\\n        else if (typeof value === \\'object\\') obj[key] = compactObject(value)\\n    }\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3685264,
                "title": "javascript-clean-solution-with-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return obj;\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if (!value) {\\n            console.log(value);\\n            delete obj[key];\\n            return;\\n        }\\n\\n        if (typeof value === \"object\") {\\n            compactObject(value);\\n            obj[key] = Array.isArray(value) ? value.filter((item) => item) : value;\\n        }\\n    })\\n\\n\\n\\n    return Array.isArray(obj) ? obj.filter((item) => item) : obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (!obj) return obj;\\n    Object.entries(obj).forEach(([key, value]) => {\\n        if (!value) {\\n            console.log(value);\\n            delete obj[key];\\n            return;\\n        }\\n\\n        if (typeof value === \"object\") {\\n            compactObject(value);\\n            obj[key] = Array.isArray(value) ? value.filter((item) => item) : value;\\n        }\\n    })\\n\\n\\n\\n    return Array.isArray(obj) ? obj.filter((item) => item) : obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3684604,
                "title": "beats-95-javascript-solution",
                "content": "# Intuition\\nRECURSION BABY\\n\\n# Approach\\nJUST USE SIMPLE RECURSION\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)) {\\n        for(let i=0; i<obj.length; i++){\\n            if(obj[i] === null || obj[i] === 0 || obj[i] === false || obj[i] === undefined || obj[i] === \"\")    {\\n                obj[i] = \"YOURNAME\";\\n            }\\n            if(Array.isArray(obj[i])){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n            else if(typeof obj[i] === \\'object\\'){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n        }\\n        obj = obj.filter(item => item !== \"YOURNAME\");\\n    } else{\\n    Object.keys(obj).forEach((k) => {\\n        if(obj[k] === null || obj[k] === 0 || obj[k] === false || obj[k] === \"\")    {\\n            delete obj[k];\\n        }\\n        if(Array.isArray(obj[k])){\\n            obj[k] = compactObject(obj[k]);\\n            }\\n        \\n        else if(typeof obj[k] === \\'object\\'){\\n            obj[k] = compactObject(obj[k]);\\n        }\\n    });\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(Array.isArray(obj)) {\\n        for(let i=0; i<obj.length; i++){\\n            if(obj[i] === null || obj[i] === 0 || obj[i] === false || obj[i] === undefined || obj[i] === \"\")    {\\n                obj[i] = \"YOURNAME\";\\n            }\\n            if(Array.isArray(obj[i])){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n            else if(typeof obj[i] === \\'object\\'){\\n                obj[i] = compactObject(obj[i]);\\n            }\\n        }\\n        obj = obj.filter(item => item !== \"YOURNAME\");\\n    } else{\\n    Object.keys(obj).forEach((k) => {\\n        if(obj[k] === null || obj[k] === 0 || obj[k] === false || obj[k] === \"\")    {\\n            delete obj[k];\\n        }\\n        if(Array.isArray(obj[k])){\\n            obj[k] = compactObject(obj[k]);\\n            }\\n        \\n        else if(typeof obj[k] === \\'object\\'){\\n            obj[k] = compactObject(obj[k]);\\n        }\\n    });\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3681645,
                "title": "javascript-2-lines-d-this-is-bait-of-excellent-quality",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = val => {\\n  const data = Array.isArray(val) ? val.filter(Boolean) : val;\\n  \\n  return Object.keys(data).reduce(\\n    (acc, key) => {\\n      const value = data[key];\\n      if (Boolean(value))\\n        acc[key] = typeof value === \\'object\\' ? compactObject(value) : value;\\n      return acc;\\n    },\\n    Array.isArray(val) ? [] : {}\\n  );\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nconst compactObject = val => {\\n  const data = Array.isArray(val) ? val.filter(Boolean) : val;\\n  \\n  return Object.keys(data).reduce(\\n    (acc, key) => {\\n      const value = data[key];\\n      if (Boolean(value))\\n        acc[key] = typeof value === \\'object\\' ? compactObject(value) : value;\\n      return acc;\\n    },\\n    Array.isArray(val) ? [] : {}\\n  );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3679042,
                "title": "js-runtime-beats-99-91-memory-beats-99-26",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy original solution was with reduce, however it was not memory efficient\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirstly, since obj can be an Array or Object I wanted to treat these two types differently. The Array can easily be filtered through using forEach and appending to a new array. The object can be filtered through and keys can be deleted if they are falsy.\\n\\nSecondly, since we don\\'t know the depth of the object, this has to be a recursive solution. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n    \\nvar compactObject = function(obj) {\\n    if (!obj) return\\n    if (obj instanceof Array) {\\n        let filtered = []\\n        obj.forEach((element) => {\\n            if (!element) return\\n            if (typeof element === \\'object\\') {\\n                filtered.push(compactObject(element))\\n            } else {\\n                filtered.push(element)\\n            }\\n        }, [])\\n        return filtered\\n    } else {\\n        Object.keys(obj).forEach((id) => {\\n            if (!obj[id]) {\\n                delete obj[id]\\n            } else {\\n                if (typeof obj[id] === \\'object\\') {\\n                    obj[id] = compactObject(obj[id])\\n                }\\n            }\\n        })\\n    }\\n\\n    return obj\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n    \\nvar compactObject = function(obj) {\\n    if (!obj) return\\n    if (obj instanceof Array) {\\n        let filtered = []\\n        obj.forEach((element) => {\\n            if (!element) return\\n            if (typeof element === \\'object\\') {\\n                filtered.push(compactObject(element))\\n            } else {\\n                filtered.push(element)\\n            }\\n        }, [])\\n        return filtered\\n    } else {\\n        Object.keys(obj).forEach((id) => {\\n            if (!obj[id]) {\\n                delete obj[id]\\n            } else {\\n                if (typeof obj[id] === \\'object\\') {\\n                    obj[id] = compactObject(obj[id])\\n                }\\n            }\\n        })\\n    }\\n\\n    return obj\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670685,
                "title": "typescript-recursive-in-place-solution",
                "content": "# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj))\\n        obj = obj.filter(Boolean);\\n    else for (const prop in obj)\\n            if (!obj[prop]) delete obj[prop];\\n\\n    for (const prop in obj)\\n        if (typeof obj[prop] === \\'object\\')\\n            obj[prop] = compactObject(obj[prop]);\\n\\n    return obj;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj))\\n        obj = obj.filter(Boolean);\\n    else for (const prop in obj)\\n            if (!obj[prop]) delete obj[prop];\\n\\n    for (const prop in obj)\\n        if (typeof obj[prop] === \\'object\\')\\n            obj[prop] = compactObject(obj[prop]);\\n\\n    return obj;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666824,
                "title": "js-intuitive-solution-in-3-lines-with-recursion",
                "content": "# Code\\n```\\n/**\\n * @param {Object} o\\n * @return {Object}\\n */\\nvar compactObject = function(o) {\\n    // step 1 : filter array\\n    if (Array.isArray(o)) o = o.filter((v) => v);\\n    // or object\\n    else Object.keys(o).forEach((key, index) => { if (! o[key]) delete o[key]});\\n    // step 2 : recursive call for each element of type \\'object\\'\\n    for (key in o) if (typeof o[key] == \\'object\\') o[key] = compactObject(o[key]);\\n    return o;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} o\\n * @return {Object}\\n */\\nvar compactObject = function(o) {\\n    // step 1 : filter array\\n    if (Array.isArray(o)) o = o.filter((v) => v);\\n    // or object\\n    else Object.keys(o).forEach((key, index) => { if (! o[key]) delete o[key]});\\n    // step 2 : recursive call for each element of type \\'object\\'\\n    for (key in o) if (typeof o[key] == \\'object\\') o[key] = compactObject(o[key]);\\n    return o;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3666675,
                "title": "easy-solution-heavily-explained",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n \\nvar compactObject = function(obj) {\\n  // Step 1: Handle arrays\\n  if (Array.isArray(obj)) {\\n    // Filter out falsy values from the array and recursively compact each element\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  // Step 2: Handle non-object values\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    // Return the truthy value as it is\\n    return obj;\\n  }\\n\\n  // Step 3: Handle objects\\n  const compactedObj = {};\\n\\n  // Step 4: Iterate over each key in the object\\n  for (let key in obj) {\\n    // Step 5: Recursively compact the value of each key\\n    const compactedValue = compactObject(obj[key]);\\n\\n    // Step 6: Check if the compactedValue is truthy\\n    if (Boolean(compactedValue)) {\\n      // Step 7: Add the truthy value to the compactedObj with the same key\\n      compactedObj[key] = compactedValue;\\n    }\\n  }\\n\\n  // Step 8: Return the compacted object\\n  return compactedObj;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\n\\n \\nvar compactObject = function(obj) {\\n  // Step 1: Handle arrays\\n  if (Array.isArray(obj)) {\\n    // Filter out falsy values from the array and recursively compact each element\\n    return obj.filter(Boolean).map(compactObject);\\n  }\\n\\n  // Step 2: Handle non-object values\\n  if (typeof obj !== \\'object\\' || obj === null) {\\n    // Return the truthy value as it is\\n    return obj;\\n  }\\n\\n  // Step 3: Handle objects\\n  const compactedObj = {};\\n\\n  // Step 4: Iterate over each key in the object\\n  for (let key in obj) {\\n    // Step 5: Recursively compact the value of each key\\n    const compactedValue = compactObject(obj[key]);\\n\\n    // Step 6: Check if the compactedValue is truthy\\n    if (Boolean(compactedValue)) {\\n      // Step 7: Add the truthy value to the compactedObj with the same key\\n      compactedObj[key] = compactedValue;\\n    }\\n  }\\n\\n  // Step 8: Return the compacted object\\n  return compactedObj;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3659158,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar compactObject = function(obj) {\\n\\n    let ans;\\n\\n    if(Array.isArray(obj)){\\n\\n      ans = [];\\n      let index = 0;\\n\\n      for(let val of obj){\\n      \\n        if(val){\\n          \\n          if(typeof val == \"object\"){\\n            ans[index++] = compactObject(val);\\n          }\\n          else{\\n            ans[index++] = val;\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n    else{ \\n\\n      ans = {};\\n\\n      for(let key in obj){\\n      \\n        if(obj[key]){\\n          \\n          if(typeof obj[key] == \"object\"){\\n            ans[key] = compactObject(obj[key]);\\n          }\\n          else{\\n            ans[key] = obj[key];\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n\\n    return ans;\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar compactObject = function(obj) {\\n\\n    let ans;\\n\\n    if(Array.isArray(obj)){\\n\\n      ans = [];\\n      let index = 0;\\n\\n      for(let val of obj){\\n      \\n        if(val){\\n          \\n          if(typeof val == \"object\"){\\n            ans[index++] = compactObject(val);\\n          }\\n          else{\\n            ans[index++] = val;\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n    else{ \\n\\n      ans = {};\\n\\n      for(let key in obj){\\n      \\n        if(obj[key]){\\n          \\n          if(typeof obj[key] == \"object\"){\\n            ans[key] = compactObject(obj[key]);\\n          }\\n          else{\\n            ans[key] = obj[key];\\n          }\\n\\n        }\\n\\n      }\\n\\n    }\\n\\n    return ans;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3657195,
                "title": "javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const result = isArray ? [] : {};\\n    for(const key of Object.keys(obj)){\\n        if(typeof obj[key] === \\'object\\' && obj[key]){\\n            result[key] = compactObject(obj[key])\\n        }\\n        else if(obj[key]){\\n            result[key] = obj[key]\\n        }\\n    }\\n\\n    return isArray ? result.filter(Boolean) : result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const result = isArray ? [] : {};\\n    for(const key of Object.keys(obj)){\\n        if(typeof obj[key] === \\'object\\' && obj[key]){\\n            result[key] = compactObject(obj[key])\\n        }\\n        else if(obj[key]){\\n            result[key] = obj[key]\\n        }\\n    }\\n\\n    return isArray ? result.filter(Boolean) : result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3652180,
                "title": "easy-js-recursive-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let resultArray = [];\\n        for (let val of obj) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultArray.push(value);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        let resultObject = {};\\n        for (let [key, val] of Object.entries(obj)) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultObject[key] = value;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(obj) === true) return obj;\\n\\n    return undefined;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if (Array.isArray(obj)) {\\n        let resultArray = [];\\n        for (let val of obj) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultArray.push(value);\\n            }\\n        }\\n        return resultArray;\\n    }\\n\\n    if (typeof obj === \\'object\\' && obj !== null) {\\n        let resultObject = {};\\n        for (let [key, val] of Object.entries(obj)) {\\n            let value = compactObject(val);\\n            if (Boolean(value)) {\\n                resultObject[key] = value;\\n            }\\n        }\\n        return resultObject;\\n    }\\n\\n    if (Boolean(obj) === true) return obj;\\n\\n    return undefined;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3643957,
                "title": "short-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n        for(let i in obj){\\n            if(obj[i] instanceof Object){\\n                obj[i] = compactObject(obj[i])\\n            }\\n        }\\n        if(Array.isArray(obj)){\\n            return obj.filter(o => Boolean(o))\\n        }\\n        Object.keys(obj).forEach(e => {\\n            if(!Boolean(obj[e])){\\n                delete obj[e]\\n            }\\n        })\\n        return obj\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n        for(let i in obj){\\n            if(obj[i] instanceof Object){\\n                obj[i] = compactObject(obj[i])\\n            }\\n        }\\n        if(Array.isArray(obj)){\\n            return obj.filter(o => Boolean(o))\\n        }\\n        Object.keys(obj).forEach(e => {\\n            if(!Boolean(obj[e])){\\n                delete obj[e]\\n            }\\n        })\\n        return obj\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3619229,
                "title": "simple-recursive-easy-to-understand-approach-with-explanation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe question tells us we have a object or array given. So, we go by the following approach.\\n- First check for array (since its also an object). If the values are truthy (the if condition automatically checks for us) and not an object just insert it into a sub array (or results array) otherwise recurse on the value\\n- If an object, apply the same array approach if truthy and not object value add to sub object else recurse the sub object and then return it.\\n- If normal truthy value then return it.  \\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if(Array.isArray(obj)){\\n    let subArr = [];\\n    obj.forEach(o=>{\\n      if(o){\\n        if(typeof o===\\'object\\')subArr.push(compactObject(o));\\n        else subArr.push(o);\\n      }\\n    });\\n    return subArr;\\n  }else if(typeof obj === \\'object\\'){\\n    let subObj = {};\\n    Object.entries(obj).forEach(([key,val])=>{\\n      if(val){\\n        if(typeof val=== \\'object\\')subObj[key] = (compactObject(val)||{});\\n        else subObj[key]=val;\\n      };\\n    });\\n    return subObj;\\n  }else{\\n    if(obj)return obj;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  if(Array.isArray(obj)){\\n    let subArr = [];\\n    obj.forEach(o=>{\\n      if(o){\\n        if(typeof o===\\'object\\')subArr.push(compactObject(o));\\n        else subArr.push(o);\\n      }\\n    });\\n    return subArr;\\n  }else if(typeof obj === \\'object\\'){\\n    let subObj = {};\\n    Object.entries(obj).forEach(([key,val])=>{\\n      if(val){\\n        if(typeof val=== \\'object\\')subObj[key] = (compactObject(val)||{});\\n        else subObj[key]=val;\\n      };\\n    });\\n    return subObj;\\n  }else{\\n    if(obj)return obj;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610045,
                "title": "recursively-apply-array-filter-and-delete-javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const compact = obj => {\\n        if (Array.isArray(obj)){\\n            obj = obj.filter(o => !!o);\\n            for(let i = 0;i < obj.length; ++i) {\\n                obj[i] = compact(obj[i]);\\n            }\\n        }\\n        else if (obj !== null && typeof obj === \\'object\\') {\\n            for(const k in obj) {\\n                if (!obj[k]) {\\n                    delete obj[k];\\n                }\\n                else {\\n                    obj[k] = compact(obj[k]);\\n                }\\n            }\\n        }\\n        return obj;\\n    }\\n    return compact(obj);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const compact = obj => {\\n        if (Array.isArray(obj)){\\n            obj = obj.filter(o => !!o);\\n            for(let i = 0;i < obj.length; ++i) {\\n                obj[i] = compact(obj[i]);\\n            }\\n        }\\n        else if (obj !== null && typeof obj === \\'object\\') {\\n            for(const k in obj) {\\n                if (!obj[k]) {\\n                    delete obj[k];\\n                }\\n                else {\\n                    obj[k] = compact(obj[k]);\\n                }\\n            }\\n        }\\n        return obj;\\n    }\\n    return compact(obj);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603846,
                "title": "js-flatmap-solution",
                "content": "Instead of doing `map + filter` for the array, we traverse it only once via `flatMap`.\\n\\n`flatMap` allows to filter values with the return of an empty array in the callback. Also, it allows you to change the returned values.\\nFor example:\\n```\\nconst arr = [1, null, 2, null];\\nconst filtered = arr.flatMap(it => Boolean(it) ? it * 2 : []);\\n// filtered = [2, 4]\\n```\\n\\nSolution:\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction isObject(val: unknown) {\\n    return typeof val === \\'object\\' && val !== null;\\n}\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        return obj.flatMap(it => {\\n            if (isObject(it)) {\\n                return [compactObject(it)];\\n            }\\n            return it || [];\\n        })\\n    } else {\\n        const copy = {};\\n\\n        for (let k of Object.keys(obj)) {\\n            if (isObject(obj[k])) {\\n                copy[k] = compactObject(obj[k])\\n            } else {\\n                if (obj[k]) {\\n                    copy[k] = obj[k];\\n                }\\n            }\\n        }\\n\\n        return copy;\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst arr = [1, null, 2, null];\\nconst filtered = arr.flatMap(it => Boolean(it) ? it * 2 : []);\\n// filtered = [2, 4]\\n```\n```\\ntype Obj = Record<any, any>;\\n\\nfunction isObject(val: unknown) {\\n    return typeof val === \\'object\\' && val !== null;\\n}\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if (Array.isArray(obj)) {\\n        return obj.flatMap(it => {\\n            if (isObject(it)) {\\n                return [compactObject(it)];\\n            }\\n            return it || [];\\n        })\\n    } else {\\n        const copy = {};\\n\\n        for (let k of Object.keys(obj)) {\\n            if (isObject(obj[k])) {\\n                copy[k] = compactObject(obj[k])\\n            } else {\\n                if (obj[k]) {\\n                    copy[k] = obj[k];\\n                }\\n            }\\n        }\\n\\n        return copy;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3600649,
                "title": "easy-typescript-solution",
                "content": "\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) return obj.filter(Boolean).map(compactObject)\\n    if(typeof obj !== \\'object\\' || obj === null) return obj\\n\\n    let res = {}\\n    for(let key in obj){\\n        let value = compactObject(obj[key])\\n        if(value) res[key] = value\\n\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Recursion"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)) return obj.filter(Boolean).map(compactObject)\\n    if(typeof obj !== \\'object\\' || obj === null) return obj\\n\\n    let res = {}\\n    for(let key in obj){\\n        let value = compactObject(obj[key])\\n        if(value) res[key] = value\\n\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589983,
                "title": "typescript-1-liner-solution-commented-with-approch",
                "content": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n\\t/*\\n\\t\\tWe are first looking if it is an array, if yes, we are using map any giving `compactObject` as callback, \\n\\t\\twhich will do same thing again and then we are filtering nullify values,\\n\\t\\tif it is an object we then we are reducing it by creating a new object which is holding only non null \\n\\t\\tvalues and if it is not array nor object just return it\\n\\t*/\\n\\treturn Array.isArray(obj) ? obj.map(compactObject).filter((item) => item) : (typeof obj === \"object\" && obj) ? Object.entries(obj).reduce((acc, [key, val]) => val ? ({...acc, [key]: compactObject(val)}) : acc, {}) : obj;\\n\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n\\t/*\\n\\t\\tWe are first looking if it is an array, if yes, we are using map any giving `compactObject` as callback, \\n\\t\\twhich will do same thing again and then we are filtering nullify values,\\n\\t\\tif it is an object we then we are reducing it by creating a new object which is holding only non null \\n\\t\\tvalues and if it is not array nor object just return it\\n\\t*/\\n\\treturn Array.isArray(obj) ? obj.map(compactObject).filter((item) => item) : (typeof obj === \"object\" && obj) ? Object.entries(obj).reduce((acc, [key, val]) => val ? ({...acc, [key]: compactObject(val)}) : acc, {}) : obj;\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3582082,
                "title": "beats-100-memory-82-time",
                "content": "\\n# Approach\\nUsing recursion + simple if condition to distinguish array and object\\n\\n# Code\\n```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)){\\n        let result = [];\\n        obj.forEach((v,index)=>{\\n            if(Boolean(v)){\\n                if(Array.isArray(v)){\\n                    result.push(compactObject(v));                    \\n                }else if(typeof v ==\\'object\\'){\\n                    result.push(compactObject(v));\\n                }else {\\n                    result.push(v);\\n                }\\n            }            \\n        });\\n        return result;\\n    }\\n\\n    for(let key in obj){\\n        if(!Boolean(obj[key])){\\n            delete obj[key];\\n        }else{\\n            //Edge case 1: obj[key] is array or object\\n            if(Array.isArray(obj[key])){\\n                obj[key]=compactObject(obj[key]);\\n            }else if(typeof obj[key]==\\'object\\'){\\n                obj[key]=compactObject(obj[key]);\\n            }\\n        }\\n    }\\n    return obj;\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype Obj = Record<any, any>;\\n\\nfunction compactObject(obj: Obj): Obj {\\n    if(Array.isArray(obj)){\\n        let result = [];\\n        obj.forEach((v,index)=>{\\n            if(Boolean(v)){\\n                if(Array.isArray(v)){\\n                    result.push(compactObject(v));                    \\n                }else if(typeof v ==\\'object\\'){\\n                    result.push(compactObject(v));\\n                }else {\\n                    result.push(v);\\n                }\\n            }            \\n        });\\n        return result;\\n    }\\n\\n    for(let key in obj){\\n        if(!Boolean(obj[key])){\\n            delete obj[key];\\n        }else{\\n            //Edge case 1: obj[key] is array or object\\n            if(Array.isArray(obj[key])){\\n                obj[key]=compactObject(obj[key]);\\n            }else if(typeof obj[key]==\\'object\\'){\\n                obj[key]=compactObject(obj[key]);\\n            }\\n        }\\n    }\\n    return obj;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576498,
                "title": "javascript-runtime-79ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/58b8154e-8ecd-4af7-a7d6-edfa2efa8cc0_1685385820.780097.png)\\n\\n# Approach\\n```\\nfunction compactObject(obj) {\\n    // Handle array objets\\n    if (Array.isArray(obj)) return obj.filter(v => v).map(v => typeof v == \\'object\\' ? compactObject(v) : v);\\n\\n    // Handle map objects\\n    for (const key of Object.keys(obj)) {\\n        const val = obj[key];\\n\\n        if (!val) {\\n            delete obj[key];\\n        } else if (typeof val == \\'object\\') {\\n            obj[key] = compactObject(val);\\n        } \\n    }\\n\\n    return obj;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction compactObject(obj) {\\n    // Handle array objets\\n    if (Array.isArray(obj)) return obj.filter(v => v).map(v => typeof v == \\'object\\' ? compactObject(v) : v);\\n\\n    // Handle map objects\\n    for (const key of Object.keys(obj)) {\\n        const val = obj[key];\\n\\n        if (!val) {\\n            delete obj[key];\\n        } else if (typeof val == \\'object\\') {\\n            obj[key] = compactObject(val);\\n        } \\n    }\\n\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3576140,
                "title": "javascript-90-runtime",
                "content": "```\\nconst compactObject = (obj) => {\\n  let res;\\n  if (Array.isArray(obj)) {\\n    res = [];\\n    for (const x of obj) {\\n      if (typeof x == \"object\" && x) res.push(compactObject(x));\\n      else if (x) res.push(x);\\n    }\\n  } else if (typeof obj == \"object\") {\\n    res = {};\\n    for (const [key, val] of Object.entries(obj)) {\\n      if (typeof val == \"object\" && val) res[key] = compactObject(val);\\n      else if (val) res[key] = val;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst compactObject = (obj) => {\\n  let res;\\n  if (Array.isArray(obj)) {\\n    res = [];\\n    for (const x of obj) {\\n      if (typeof x == \"object\" && x) res.push(compactObject(x));\\n      else if (x) res.push(x);\\n    }\\n  } else if (typeof obj == \"object\") {\\n    res = {};\\n    for (const [key, val] of Object.entries(obj)) {\\n      if (typeof val == \"object\" && val) res[key] = compactObject(val);\\n      else if (val) res[key] = val;\\n    }\\n  }\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3575516,
                "title": "use-recursion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery time when we have nested complex object we need a recursion to traverse it, and that\\'s it!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. first we initialize a new variable `result` as an empty array (`[]`) if obj is an array, or as an empty object (`{}`) otherwise. This will store the reduced object.\\n\\n2. we iterate through each property (`key`) in the input object (`obj`).\\n\\n3. if the current property (obj[key]) is empty (falsy), the iteration continues (we just ignore this key).\\n\\n4. if the current value is an object (excluding arrays), recursively call the compactObject function on the property and assign the result to the corresponding property in the result object. If result is an array, push the result as a new element to the array.\\n\\n5. othwervise, if the current value is not an object, we assign the property value to the corresponding property in the result object. If result is an array, push the value as a new element to the array.\\n\\n6. finally, once all properties have been processed, the result object is returned.\\n\\n# Complexity\\n- Time complexity: n/a\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: n/a\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  const result = (Array.isArray(obj) ? [] : {});\\n  for (let key in obj) {\\n    if (!obj[key]) { continue; }\\n    if (typeof obj[key] === \\'object\\') {\\n      if (Array.isArray(result)) {\\n        result.push(compactObject(obj[key]));\\n      } else {\\n        result[key] = compactObject(obj[key]);\\n      }\\n    } else {\\n      if (Array.isArray(result)) {\\n        result.push(obj[key]);\\n      } else {\\n        result[key] = obj[key];\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n  const result = (Array.isArray(obj) ? [] : {});\\n  for (let key in obj) {\\n    if (!obj[key]) { continue; }\\n    if (typeof obj[key] === \\'object\\') {\\n      if (Array.isArray(result)) {\\n        result.push(compactObject(obj[key]));\\n      } else {\\n        result[key] = compactObject(obj[key]);\\n      }\\n    } else {\\n      if (Array.isArray(result)) {\\n        result.push(obj[key]);\\n      } else {\\n        result[key] = obj[key];\\n      }\\n    }\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573298,
                "title": "recur",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\') {\\n        if(obj) return obj\\n        return null\\n    }\\n    if(obj === null) return null\\n    if(Array.isArray(obj)) {\\n        const res = [];\\n        for(const ele of obj) {\\n            const val = compactObject(ele)\\n            if(val === null) continue\\n            res.push(val)\\n        }\\n        return res\\n    }\\n    let res = {}\\n    for(let key in obj) {\\n        const ele = compactObject(obj[key])\\n        if(ele !== null) res[key] = ele;\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    if(typeof obj !== \\'object\\') {\\n        if(obj) return obj\\n        return null\\n    }\\n    if(obj === null) return null\\n    if(Array.isArray(obj)) {\\n        const res = [];\\n        for(const ele of obj) {\\n            const val = compactObject(ele)\\n            if(val === null) continue\\n            res.push(val)\\n        }\\n        return res\\n    }\\n    let res = {}\\n    for(let key in obj) {\\n        const ele = compactObject(obj[key])\\n        if(ele !== null) res[key] = ele;\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569902,
                "title": "recursion",
                "content": "\\n\\n# Code\\n```\\nconst isObj = o => o?.constructor === Object;\\n\\nvar compactObject = function(obj) {\\n    if(Boolean(obj) === false) return null;\\n    else if(Array.isArray(obj)) {\\n        return obj.reduce((last, cur) => {\\n            const compacted = compactObject(cur);\\n            if(compacted !== null) {\\n                last.push(compacted)\\n            }\\n            return last;\\n        }, [])\\n    }\\n    else if(isObj(obj)) {\\n        return Object.keys(obj).reduce((last, key) => {\\n            const compacted = compactObject(obj[key]);\\n            if(compacted !== null) {\\n                last[key] = compacted;\\n            }\\n            return last;\\n        }, {})\\n    }\\n    return obj;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst isObj = o => o?.constructor === Object;\\n\\nvar compactObject = function(obj) {\\n    if(Boolean(obj) === false) return null;\\n    else if(Array.isArray(obj)) {\\n        return obj.reduce((last, cur) => {\\n            const compacted = compactObject(cur);\\n            if(compacted !== null) {\\n                last.push(compacted)\\n            }\\n            return last;\\n        }, [])\\n    }\\n    else if(isObj(obj)) {\\n        return Object.keys(obj).reduce((last, key) => {\\n            const compacted = compactObject(obj[key]);\\n            if(compacted !== null) {\\n                last[key] = compacted;\\n            }\\n            return last;\\n        }, {})\\n    }\\n    return obj;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3569276,
                "title": "without-extra-functions-except-isarray",
                "content": "# Code\\n```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const ret = isArray ? [] : {};\\n\\n    for (const key in obj) {\\n        if (obj[key]) {\\n            if (isArray) ret.push(typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key]);\\n            else ret[key] = typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key];\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Object} obj\\n * @return {Object}\\n */\\nvar compactObject = function(obj) {\\n    const isArray = Array.isArray(obj);\\n    const ret = isArray ? [] : {};\\n\\n    for (const key in obj) {\\n        if (obj[key]) {\\n            if (isArray) ret.push(typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key]);\\n            else ret[key] = typeof obj[key] === \"object\" ? compactObject(obj[key]) : obj[key];\\n        }\\n    }\\n\\n    return ret;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 2063477,
                "content": [
                    {
                        "username": "Harsh-br0",
                        "content": "idk why comment section seems like speechless...."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "anybody here?"
                    },
                    {
                        "username": "robin_rahman",
                        "content": "Throws a Runtime Error: \"RangeError: Maximum call stack size exceeded\" for Array.isArray(obj). But Run correctly, no idea what\\'s the problem in my case."
                    }
                ]
            },
            {
                "id": 2065435,
                "content": [
                    {
                        "username": "Harsh-br0",
                        "content": "idk why comment section seems like speechless...."
                    },
                    {
                        "username": "antonbrypto",
                        "content": "anybody here?"
                    },
                    {
                        "username": "robin_rahman",
                        "content": "Throws a Runtime Error: \"RangeError: Maximum call stack size exceeded\" for Array.isArray(obj). But Run correctly, no idea what\\'s the problem in my case."
                    }
                ]
            }
        ]
    },
    {
        "title": "Timeout Cancellation",
        "question_content": "<p>Given a function <code>fn</code>, an array of&nbsp;arguments&nbsp;<code>args</code>, and a timeout&nbsp;<code>t</code>&nbsp;in milliseconds, return a cancel function <code>cancelFn</code>.</p>\n\n<p>After a delay of&nbsp;<code>t</code>,&nbsp;<code>fn</code>&nbsp;should be called with <code>args</code> passed as parameters <strong>unless</strong> <code>cancelFn</code> was invoked before the delay of <code>t</code> milliseconds elapses, specifically at <code>cancelT</code>&nbsp;ms.&nbsp;In that case,&nbsp;<code>fn</code> should never be called.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x) =&gt; x * 5, args = [2], t = 20, cancelT = 50\n<strong>Output:</strong> [{&quot;time&quot;: 20, &quot;returned&quot;: 10}]\n<strong>Explanation:</strong> \nconst result = []\n\nconst fn = (x) =&gt; x * 5\n\nconst start = performance.now()&nbsp;\n\nconst log = (...argsArr) =&gt; {\n    const diff = Math.floor(performance.now() - start);\n    result.push({&quot;time&quot;: diff, &quot;returned&quot;: fn(...argsArr)})\n}\n &nbsp; &nbsp;&nbsp;\nconst cancel = cancellable(log, [2], 20);\n\nconst maxT = Math.max(t, 50)\n&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;\nsetTimeout(cancel, cancelT)\n\nsetTimeout(() =&gt; {\n &nbsp; &nbsp; console.log(result) // [{&quot;time&quot;:20,&quot;returned&quot;:10}]\n}, 65)\n\nThe cancellation was scheduled to occur after a delay of cancelT (50ms), which happened after the execution of fn(2) at 20ms.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x) =&gt; x**2, args = [2], t = 100, cancelT = 50 \n<strong>Output:</strong> []\n<strong>Explanation:</strong> The cancellation was scheduled to occur after a delay of cancelT (50ms), which happened before the execution of fn(2) at 100ms, resulting in fn(2) never being called.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> fn = (x1, x2) =&gt; x1 * x2, args = [2,4], t = 30, cancelT = 100\n<strong>Output:</strong> [{&quot;time&quot;: 30, &quot;returned&quot;: 8}]\n<strong>Explanation: </strong>The cancellation was scheduled to occur after a delay of cancelT (100ms), which happened after the execution of fn(2,4) at 30ms.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>fn</code> is a function</li>\n\t<li><code>args</code> is a valid JSON array</li>\n\t<li><code>1 &lt;= args.length &lt;= 10</code></li>\n\t<li><code><font face=\"monospace\">20 &lt;= t &lt;= 1000</font></code></li>\n\t<li><code><font face=\"monospace\">10 &lt;= cancelT &lt;= 1000</font></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3725241,
                "title": "full-explanation-unlike-any-others",
                "content": "# Intuition\\nThe following problem and the next one **\" Interval Cancellation \" **  represent an important concept in JavaScript . It\\'s gonna be a long but full through explanation so sit tight \\uD83D\\uDE06\\uD83D\\uDE06\\uD83D\\uDE06\\n# **Motive :**  Return a function after a specifc time only if you didn\\'t call other function , if we called the other function then the first function shouldn\\'t be called at all !!\\n\\n# Pre - Requistes : \\n- Familarity with callback functions\\n- Rest parameter\\n- clearTimeout and setTimeout methods\\n\\nIf you know those , Congrats \\uD83C\\uDF89 ! You can further continue reading , if not then please go back and understand those pretty well .\\n\\n# A QUESTION YOU MIGHT BE ASKING : WHY DO I NEED TO USE clearTimeout and setTimeout ?\\n\\nIn Javascript controlling the flow and exceution of tasks , is quite crucial. The following 2 questions (**Execute Cancellable function with delay**) and (**Interval Cnacellation**) , posses a really really important concept , sit tight and read well \\uD83D\\uDE0A !\\n\\nBy using such methods , we can easily control timing and execution of a code , we can either delay or cancel them .\\n\\n# OKAY I SEE THEY\\'RE IMPORTANT , BUT  WHERE MIGHT I USE THEM ?\\uD83E\\uDD14\\n\\nThey\\'re heavily used in scenarios such as :\\n- Animation\\n- Event Handling\\n- Scheduling\\n- Async Proggramming \\n\\n\\n# OTHER QUESTION YOU MIGHT BE ASKING : \\nHUM .... I THOUGHT I UNDERSTOOD THEM TURNS OUT I ONLY KNOW THE SYNTAX \\n\\nThat is alright , I will explain them fully don\\'t worry ! \\nLet\\'s start with the **setTimeout** Method :\\n\\n- The function takes two parameters: a callback function and a delay value in milliseconds. The callback function represents the code we want to execute after the delay.\\n- When we call setTimeout, it registers the callback function and starts a timer. After the specified delay, the JavaScript engine adds the callback function to the event queue.\\n-  In case you don\\'t know what an event Queue is , the event queue is a data structure that holds tasks to be processed by the JavaScript runtime. When the call stack is empty (all synchronous code has finished executing), the runtime picks the next task from the event queue and executes it.\\n- By using setTimeout, we introduce an asynchronous behavior in our code. This means that while the delay is counting down, the JavaScript engine can continue executing other code without waiting for the setTimeout callback to be invoked AND THIS IS REALLY IMPORTANT .\\n\\n# BUT WHY DID WE USE CLEARTIMEOUT ?\\n\\nWell , we need clearTimeout to cancel the scheduled execution before the delay expires.\\nWe already know that setTimeout returns a unique identifier called a timeout ID , right ????\\n\\nWell , clearTimeout is another built-in function that cancels a timeout previously set with setTimeout. By passing the timeout ID to clearTimeout, we  prevent the execution of the callback function and stop the timer .\\n\\n# Still not convinced ? Let\\'s ask ourselves what would happen if we didn\\'t use clearTimeout in our code ?!!\\n\\nUsing clearTimeout in conjunction with setTimeout provides us with the ability to control the execution of a scheduled function. When we set a timeout using setTimeout, the function inside it will run after the specified delay. However, by using clearTimeout, we can cancel the scheduled function before it runs which is what we want here .\\n\\n**In simpler terms, clearTimeout allows you to say, \"Hey, hold on! Don\\'t run that function yet!\" It gives you the ability to pause or cancel the scheduled execution, providing a smoother and more responsive user experience in situations where dynamic control is required.**\\n\\n# CONCLUSION :\\n Without clearTimeout, you wouldn\\'t have the option to stop or cancel the execution of a scheduled function. It would always run regardless of any subsequent logic or conditions. By using clearTimeout, you have the power to manage and adjust the timing of your code, ensuring it behaves exactly as you need it to.\\n\\n\\n\\n# Approach\\n- The code defines a function named \"cancellable\" that takes three parameters: \"fn\" (a function), \"args\" (an array of arguments), and \"t\" (a time delay in milliseconds).\\n- Inside the \"cancellable\" function, a nested function named \"cancelFn\" is defined. This function is responsible for canceling the execution of the scheduled function.\\n- The \"cancelFn\" function calls clearTimeout with the timer identifier to cancel the scheduled function execution.\\n- The setTimeout function is used to schedule the execution of a function, which is passed as the first parameter, after the specified time delay (t).\\n- The setTimeout function returns a timer identifier, which is stored in the \"timer\" variable.\\n- The scheduled function (fn) is executed using the spread operator (...args) to pass the arguments array to the function.\\n- Finally, the \"cancelFn\" function is returned from the \"cancellable\" function, allowing you to call it later to cancel the scheduled function if needed.\\n\\n# A beginner Level  Question you might be asking : why did you define cancelFn t the top ? \\nWell , The purpose of defining the \"cancelFn\" function at the top is to ensure that it is accessible within the scope of the \"cancellable\" function. This allows us to return the \"cancelFn\" function as part of the function\\'s result, making it available for later use outside of the \"cancellable\" function. It\\'s always a good practice to define functions at the top\\n\\n# FINAL CONCLUSION : \\n\\nThe concept of using clearTimeout and setTimeout provides a powerful mechanism for scheduling and canceling the execution of functions in JavaScript. By utilizing clearTimeout, you can prevent the scheduled function from running when it is no longer needed, allowing for more control and flexibility in managing asynchronous tasks. This concept is especially useful in scenarios where you want to delay the execution of code or schedule tasks to be performed in the future. Understanding and utilizing clearTimeout and setTimeout effectively can greatly enhance the efficiency and responsiveness of your JavaScript programs.\\n\\n**NOW THAT\\'S IT HOPE YOU ENJOYED MY EXPLANATION , CHECK OUT THE OTHER SOLUTION FOR THE NEXT PROBLEM (**Interval Cnacellation**) they\\'re both similar problems with slight difference tho \\uD83E\\uDD14\\uD83D\\uDE0A**\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    // cancelFn function//\\n    const cancelFn = function (){\\n      clearTimeout(timer);\\n  };\\n  const timer = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return cancelFn ;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = function(fn, args, t) {\\n    // cancelFn function//\\n    const cancelFn = function (){\\n      clearTimeout(timer);\\n  };\\n  const timer = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return cancelFn ;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3620608,
                "title": "full-thorough-explanation-simple-beginner-friendly",
                "content": "# Approach\\nThis problem can be a bit confusing, as simple as the solution code is, so I will convey the problem in a step-by-step concrete manner. The following example is how ```cancellable``` works:\\n\\nLet\\'s say we want to execute a function ```foo``` defined as follows:\\n```\\nfunction foo(message) {\\n    console.log(\"If you see this message, I wasn\\'t cancelled!!!\");\\n    console.log(\"I want to tell the world this:\");\\n    console.log(message);\\n}\\n```\\nHowever, we want ```foo``` to be cancellable within the next 1000 milliseconds. And so, we call ```foo``` with ```var myMsg = cancellable(foo, \"pineapple\", 1000);```\\n\\nOnce ```myMsg``` is defined, it will take 1000 milliseconds to execute ```foo```. However, if ```myMsg``` is ever called before 1000 milliseconds, ```foo``` will be cancelled. Aka, if we do ```myMsg()``` 1000 milliseconds after we defined ```myMsg```, then ```foo``` will not execute.\\n\\u2014\\nThe above is an example of ```cancellable``` in action. Now, to discuss how to implement it.\\n\\nFirst, let\\'s set a timeout. We can do this as one normally would:\\n```\\nvar timeout = setTimeout(() =>\\n    fn(...args)\\n, t)\\n```\\nNow the timeout is running. After this, let\\'s define a way to clear this timeout.\\n```\\nvar cancelFn = () => clearTimeout(timeout);\\n```\\nNote, unlike ```timeout```, we did not execute ```cancelFn```. This is due to the fact that ```timeout``` is calling a function (the right side is formatted as ```function(somestuff)```), whereas ```cancelFn``` is simply the definition of a function (the right side is formatted as ```() => function(somestuff)```). If we instead wrote ```var cancelFn = clearTimeout(timeout)```, we would always cancel right after we start the timeout, and always fail to execute the function.\\n\\nFinally, let\\'s have ```cancellable``` return ```cancelFn```. The reasoning behind this is as follows. We defined ```cancelFn```, but we need to be able to call it. By making ```cancellable``` return ```cancelFn```, the return line calls ```cancelFn```, which will cause ```cancelFn``` to execute (aka, it will cancel ```timeout```). And so, when we call cancellable, we execute the return line, thereby executing ```cancelFn```. Using the ```myMsg``` example above as demonstration, when we call ```myMsg()```, we return ```cancelFn```, which means we execute ```cancelFn```, thereby clearing ```timeout``` and cancelling ```foo```.\\n\\nAnd there you have it, a cancellable function!\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    // call setTimeout, which is set to call fn after t amount of time\\n    var timeout = setTimeout(() =>\\n        fn(...args)\\n    , t)\\n\\n    // define a clearTimeout\\n    var cancelFn = () => clearTimeout(timeout);\\n\\n    // When/if we call the function, it will return cancelFn,\\n    // and since the return line calls (and consequentially executes)\\n    // cancelFn, timeout will be cancelled, thereby cancelling fn\\n    return cancelFn;\\n};\\n```\\nUPVOTE if this was helpful \\uD83C\\uDF5E\\uD83C\\uDF5E\\uD83C\\uDF5E",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```cancellable```\n```foo```\n```\\nfunction foo(message) {\\n    console.log(\"If you see this message, I wasn\\'t cancelled!!!\");\\n    console.log(\"I want to tell the world this:\");\\n    console.log(message);\\n}\\n```\n```foo```\n```foo```\n```var myMsg = cancellable(foo, \"pineapple\", 1000);```\n```myMsg```\n```foo```\n```myMsg```\n```foo```\n```myMsg()```\n```myMsg```\n```foo```\n```cancellable```\n```\\nvar timeout = setTimeout(() =>\\n    fn(...args)\\n, t)\\n```\n```\\nvar cancelFn = () => clearTimeout(timeout);\\n```\n```timeout```\n```cancelFn```\n```timeout```\n```function(somestuff)```\n```cancelFn```\n```() => function(somestuff)```\n```var cancelFn = clearTimeout(timeout)```\n```cancellable```\n```cancelFn```\n```cancelFn```\n```cancellable```\n```cancelFn```\n```cancelFn```\n```cancelFn```\n```timeout```\n```cancelFn```\n```myMsg```\n```myMsg()```\n```cancelFn```\n```cancelFn```\n```timeout```\n```foo```\n```\\nvar cancellable = function(fn, args, t) {\\n    // call setTimeout, which is set to call fn after t amount of time\\n    var timeout = setTimeout(() =>\\n        fn(...args)\\n    , t)\\n\\n    // define a clearTimeout\\n    var cancelFn = () => clearTimeout(timeout);\\n\\n    // When/if we call the function, it will return cancelFn,\\n    // and since the return line calls (and consequentially executes)\\n    // cancelFn, timeout will be cancelled, thereby cancelling fn\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587129,
                "title": "simple-implementation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  var cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  var timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  var cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587201,
                "title": "js-settimeout-cleartimeout-2-lines",
                "content": "# Intuition\\nsetTimeout for fn execution for given time t, return function that executes clearTimeout when called\\n\\n# Code\\n```\\nconst cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(() => fn(...args), t)    \\n    return () => clearTimeout(timeoutHandle)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(() => fn(...args), t)    \\n    return () => clearTimeout(timeoutHandle)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590547,
                "title": "ts-boolean-flag-75ms-43-2mb",
                "content": "This problem requires little more than following the instructions, so we will:\\n* create a boolean flag `willFnCall` initially set to `true`;\\n* set a timeout in `t` milliseconds to call `fn` with `args`, but only if `willFnCall` is still `true`;\\n* `return` a function that sets the flag to `false` when called.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```ts\\nconst cancellable = (fn: Function, args: any[], t: number): Function => {\\n    let willFnCall = true;\\n    setTimeout(() => willFnCall && fn(...args), t);\\n    return () => willFnCall = false;\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```ts\\nconst cancellable = (fn: Function, args: any[], t: number): Function => {\\n    let willFnCall = true;\\n    setTimeout(() => willFnCall && fn(...args), t);\\n    return () => willFnCall = false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587568,
                "title": "easy-solution-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3639241,
                "title": "simple-solution-with-walk-through",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The cancellable function takes three parameters: `fn`, `args`, and `t`.\\n\\n2. `fn` is the function to be executed after a delay.\\n`args` is an array of arguments to be passed to the function `fn`.\\n`t` is the delay in milliseconds.\\nInside the `cancellable` function, a variable `cancel` is initialized to false. This variable will be used to determine if the execution of the delayed function should be canceled.\\n\\n3. The `setTimeout` function is called with an arrow function as the callback. This arrow function checks the value of `cancel` and executes the function fn with the provided arguments `...args` only if `cancel` is false. The timeout value is set to `t` milliseconds.\\n\\n4. The `setTimeout` function schedules the execution of the arrow function after the specified delay.\\n\\n5. Finally, the `cancellable` function returns another function. This returned function is used to cancel the execution of the delayed function.\\n    When the returned function is invoked, it sets `cancel` to true, effectively canceling the execution of `fn` if it hasn\\'t occurred yet.\\n\\n# Complexity\\n- Time complexity:\\nO(max(t,cancelT))\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4027030,
                "title": "easy-js-solution-no-explanation-required-clean-code",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(()=>{\\n        fn(...args);\\n    },t)\\n    return cancel=()=>{\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(()=>{\\n        fn(...args);\\n    },t)\\n    return cancel=()=>{\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974411,
                "title": "easy-approach-towards-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis requires clearTimeout funtion which cancels a timeout previously established by calling setTimeout().\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst to make a timer for function execution for time t and cancelFn function for cancelling that timeout event. \\nconst cancel = cancellable(log, args, t);\\nand cancel would get cancelfn function returned from cancellable. \\n         \\n  setTimeout(() => {     cancel()\\n  }, cancelT)\\n\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n\\nvar cancellable = function(fn, args, t) {\\n  const timer = setTimeout(()=> {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function(){\\n    clearTimeout(timer);\\n  }\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\n\\nvar cancellable = function(fn, args, t) {\\n  const timer = setTimeout(()=> {\\n    fn(...args);\\n  }, t);\\n\\n  const cancelFn = function(){\\n    clearTimeout(timer);\\n  }\\n  return cancelFn;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3907338,
                "title": "simple-solution-2-liner",
                "content": "\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3902413,
                "title": "javascript",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function() {\\n    fn.apply(null, args);\\n  }, t);\\n\\n  const cancelFn = function() {\\n    clearTimeout(timeoutId);\\n  };\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3677243,
                "title": "js-easy-use-of-settimeout-cleartimeout",
                "content": "```javascript\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3587429,
                "title": "1-liner",
                "content": "```js\\nconst cancellable =\\n    (f, a, t, c = setTimeout(f, t, ...a)) => () => clearTimeout(c)\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst cancellable =\\n    (f, a, t, c = setTimeout(f, t, ...a)) => () => clearTimeout(c)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101203,
                "title": "promise-closure-50ms-beats-96-51-42-46mb",
                "content": "\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4101194,
                "title": "promise-closure-50ms-beats-96-51-42-46mb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nlet cfn = true\\n\\n const promise = new Promise((resolve,reject)=>{\\n    setTimeout(()=>{\\n        if(cfn){\\n                fn(...args)\\n            resolve\\n        }else{\\n            reject\\n        }\\n    }, t);\\n  });\\n\\n\\nreturn function cancelFn(){\\n    cfn = false\\n}\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4089333,
                "title": "timeout-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    const cancelFn=()=>{\\n         clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerID=setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    const cancelFn=()=>{\\n         clearTimeout(timerID)\\n    }\\n    return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4085956,
                "title": "timeout-cancellation-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n      let isCancelled = true;\\n  setTimeout(() => {\\n      if(isCancelled)\\n          fn(...args);\\n  }, t);\\n\\n  return () => {\\n    isCancelled = false;\\n  };\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n      let isCancelled = true;\\n  setTimeout(() => {\\n      if(isCancelled)\\n          fn(...args);\\n  }, t);\\n\\n  return () => {\\n    isCancelled = false;\\n  };\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080810,
                "title": "cancel-response",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n \\n      let timeoutId;\\n      timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n\\n    const cancelFn = () => {\\n        clearTimeout(timeoutId);\\n    };\\n  \\n    return cancelFn;\\n};\\n\\n   const result = []\\n \\n   const fn = (x) => x * 5\\n   const args = [2], t = 20, cancelT = 50\\n \\n   const start = performance.now() \\n \\n   const log = (...argsArr) => {\\n       const diff = Math.floor(performance.now() - start);\\n       result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n   }\\n        \\n   const cancel = cancellable(log, args, t);\\n \\n   const maxT = Math.max(t, cancelT)\\n           \\n   setTimeout(() => {\\n      cancel()\\n   }, cancelT)\\n \\n   setTimeout(() => {\\n      console.log(result) // [{\"time\":20,\"returned\":10}]\\n  }, maxT + 15)\\n \\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n \\n      let timeoutId;\\n      timeoutId = setTimeout(() => {\\n            fn(...args);\\n        }, t);\\n\\n    const cancelFn = () => {\\n        clearTimeout(timeoutId);\\n    };\\n  \\n    return cancelFn;\\n};\\n\\n   const result = []\\n \\n   const fn = (x) => x * 5\\n   const args = [2], t = 20, cancelT = 50\\n \\n   const start = performance.now() \\n \\n   const log = (...argsArr) => {\\n       const diff = Math.floor(performance.now() - start);\\n       result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n   }\\n        \\n   const cancel = cancellable(log, args, t);\\n \\n   const maxT = Math.max(t, cancelT)\\n           \\n   setTimeout(() => {\\n      cancel()\\n   }, cancelT)\\n \\n   setTimeout(() => {\\n      console.log(result) // [{\"time\":20,\"returned\":10}]\\n  }, maxT + 15)\\n \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4078986,
                "title": "simple-ts-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\\n    let timer = setTimeout(fn, t, ...args)\\n    return () => clearTimeout(timer)\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nfunction cancellable(fn: Fn, args: JSONValue[], t: number): Function {\\n    let timer = setTimeout(fn, t, ...args)\\n    return () => clearTimeout(timer)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4075333,
                "title": "2715-timeout-cancellation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const calculationTimer = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(calculationTimer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const calculationTimer = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(calculationTimer);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4074729,
                "title": "very-beginner-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n    const timer = setTimeout(() => {\\n        if (!cancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    const cancel = () => {\\n        cancelled = true;\\n        clearTimeout(timer);\\n    };\\n\\n    return cancel;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n    const timer = setTimeout(() => {\\n        if (!cancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    const cancel = () => {\\n        cancelled = true;\\n        clearTimeout(timer);\\n    };\\n\\n    return cancel;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4048692,
                "title": "js-ts-best-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nconst cancellable = (fn: Fn, args: JSONValue[], t: number): Function => {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\ntype JSONValue = null | boolean | number | string | JSONValue[] | { [key: string]: JSONValue };\\ntype Fn = (...args: JSONValue[]) => void\\n\\nconst cancellable = (fn: Fn, args: JSONValue[], t: number): Function => {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4046010,
                "title": "simple-solution-in-typescript-using-id-that-is-cached",
                "content": "\\n# Approach\\nLet\\'s just use build-in async API provided by javascript\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id = setTimeout(() => {\\n        fn(...args);\\n    }, t)\\n\\n    return () => {\\n        clearTimeout(id);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4043111,
                "title": "javascript-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearTimeout(timer);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(()=>{\\n        fn(...args);\\n    }, t);\\n    return () => {\\n        clearTimeout(timer);\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4038667,
                "title": "easy-to-understand-solution",
                "content": "```\\nvar cancellable = function(fn, args, t) {\\n  let ignore = false;\\n\\n  setTimeout(() => {\\n    if (!ignore) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return function cancelT() {\\n    ignore = true;\\n  }; \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n  let ignore = false;\\n\\n  setTimeout(() => {\\n    if (!ignore) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return function cancelT() {\\n    ignore = true;\\n  }; \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4031022,
                "title": "d",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst cancelFn = ()=>{clearTimeout(pop)}\\nconst pop = setTimeout(()=>{\\nreturn fn(...args)\\n},t)\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\nconst cancelFn = ()=>{clearTimeout(pop)}\\nconst pop = setTimeout(()=>{\\nreturn fn(...args)\\n},t)\\nreturn cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030863,
                "title": "simple-solution-with-explanation",
                "content": "# Intuition\\nThe idea of this problem is not to make the call `fn(...args)` if `cancelFn` is called prior to the time passed as the parameter which is `t`. \\n\\n# Approach\\nEvrerytime clearTimeout is called, it cancels the preiviously established `setTiemout` which in this case is saved as id variable. So, if id is found the time `cancelFn` is called, just cancel the preiviously established `setTiemout`.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let id = setTimeout(() => fn(...args), t)\\n    \\n    return function cancelFn(){\\n        if(id) clearTimeout(id);\\n    }\\n    };\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let id = setTimeout(() => fn(...args), t)\\n    \\n    return function cancelFn(){\\n        if(id) clearTimeout(id);\\n    }\\n    };\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4018481,
                "title": "with-explanation-easy-understanding",
                "content": "# Explanation\\n1. It sets a timer to run fn after t milliseconds.\\n2. If you decide to cancel, call the provided cancellation function (cancelFn) before the timer expires.\\n3. If cancelFn is called, the execution of fn is stopped.\\n4. If not canceled, fn runs as scheduled after the delay.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        isCancelled = true;\\n    };\\n\\n    // Set a timeout to call the original function after t milliseconds\\n    const timeoutId = setTimeout(function() {\\n        if (!isCancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    // Return the cancellation function\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n\\n    // Define the cancellation function\\n    const cancelFn = function() {\\n        isCancelled = true;\\n    };\\n\\n    // Set a timeout to call the original function after t milliseconds\\n    const timeoutId = setTimeout(function() {\\n        if (!isCancelled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    // Return the cancellation function\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)})\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4007198,
                "title": "timeout-cancellation",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    var cleartime = setTimeout(() => fn(...args),t);\\n    var cancelFn = () =>  clearTimeout(cleartime);\\n    \\n    return cancelFn;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    var cleartime = setTimeout(() => fn(...args),t);\\n    var cancelFn = () =>  clearTimeout(cleartime);\\n    \\n    return cancelFn;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3974112,
                "title": "easy-to-follow-solution-step-by-step",
                "content": "# Intuition\\nThe exercice is telling we receieve a function that will run in t miliseconds, and will return another function capable of stopping the execution of the original function, this implies with need to use `setTimeout` to set the delay and using `clearTimeout` to have the possibility of stopping the function execution.\\n\\n# Approach\\n\\nI create a `timeoutId` to save the `setTimeout` and be able to clear it later.\\n\\nThen I created a new promise and using `setTimeout` we will resolve it in `t` miliseconds, in this step we will store the `setTimeout` in the `timeoutId`.\\n\\nThen I created a boolean to track if the function has already been canceled.\\n\\nThen we create the `cancelT` function we will return, inside it we check if the function has already been canceled, if not execute `clearTimeout` and change the `canceled` boolean to true, indicating the function got canceled.\\n\\nThen we call the promise with `then`, we check if `canceled` is false (the function has not been canceled yet), if is not, we print the original function\\'s result.\\n\\nFinally we return the `cancelT` function we defined early.\\n\\n# Complexity\\n## Time complexity:\\n\\n- Creating the tempPromise and scheduling the function call using setTimeout takes O(1) time.\\n\\n- Resolving the tempPromise and invoking the original function takes O(1) time.\\n\\n- The tempPromise.then block runs only once the promise is resolved, and it performs a constant amount of work (console logging) if the cancellation state is not active. Thus, it also takes O(1) time.\\n\\n- The cancelT function, when invoked, cancels the timeout using clearTimeout. This is also a constant-time operation, O(1).\\n\\nSince each step involves constant time operations, the overall time complexity of the cancellable function can be approximated as O(1).\\n\\n## Space complexity:\\nThe main space-consuming factor is the memory required to store the `tempPromise` promise and related structures, which is O(1) in this case.\\n\\nThe other variables like `timeoutId`, `cancelled`, and the arguments passed to the original function are also stored in memory, but they are independent of the input size and are constant in terms of space.\\n\\nHence, they contribute to O(1) space complexity, taking into account all of the above, I conclude that the total space complexity of `cancelable`\\nif O(1) -> constant.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId; // To store the setTimeout ID\\n\\n    // Wait t milliseconds before calling the function\\n    const tempPromise = new Promise((resolve, reject) => {\\n        timeoutId = setTimeout(() => {\\n            resolve(fn(...args));\\n        }, t);\\n    });\\n\\n    // Create a variable to track if the function was canceled\\n    let cancelled = false;\\n\\n    // Return cancel function\\n    const cancelT = () => {\\n        if (!cancelled) {\\n            clearTimeout(timeoutId); // Cancel the timeout\\n            cancelled = true;\\n            console.log(\\'Function call cancelled\\');\\n        }\\n    };\\n\\n    tempPromise.then((result) => {\\n        if (!cancelled) {\\n            console.log(\"result: \", result);\\n        }\\n    });\\n\\n    return cancelT;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId; // To store the setTimeout ID\\n\\n    // Wait t milliseconds before calling the function\\n    const tempPromise = new Promise((resolve, reject) => {\\n        timeoutId = setTimeout(() => {\\n            resolve(fn(...args));\\n        }, t);\\n    });\\n\\n    // Create a variable to track if the function was canceled\\n    let cancelled = false;\\n\\n    // Return cancel function\\n    const cancelT = () => {\\n        if (!cancelled) {\\n            clearTimeout(timeoutId); // Cancel the timeout\\n            cancelled = true;\\n            console.log(\\'Function call cancelled\\');\\n        }\\n    };\\n\\n    tempPromise.then((result) => {\\n        if (!cancelled) {\\n            console.log(\"result: \", result);\\n        }\\n    });\\n\\n    return cancelT;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3972953,
                "title": "js-clear-solution",
                "content": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{fn(...args)}, t)\\n    return function(cancelT) {\\n        setTimeout(()=>{clearTimeout(timeout)}, cancelT);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{fn(...args)}, t)\\n    return function(cancelT) {\\n        setTimeout(()=>{clearTimeout(timeout)}, cancelT);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3947737,
                "title": "implementation-of-cancellable-function-with-timer-and-cancellation",
                "content": "# Intuition\\nThe problem requires setting up a mechanism to execute a function after a certain delay *t*, unless a cancellation function is invoked before another delay **cancelT**. This involves managing timers, function execution, and cancellation states.\\n\\n# Approach\\n1. **Defining the Cancellable Function**: The main function, cancellable, will take the input parameters fn, args, and t. It will create a timer to execute the function fn after t milliseconds unless cancelled.\\n2. **Execution Timer**: The function will set up an executionTimer using setTimeout. This timer will execute the function fn with the provided args after a delay of t milliseconds. Inside the callback of the timer, we will check if the cancellation flag is not set (cancelled is false). If it\\'s not cancelled, we will execute the function and log the result.\\n3. **Cancellation Function**: The cancellable function will return a function called cancelFn. When cancelFn is invoked, it will set the cancelled flag to true to indicate cancellation. It will also clear the executionTimer using clearTimeout, preventing the function from being executed.\\n\\n# Complexity\\n- **Time Complexity**: The execution of the cancellable function involves setting up a setTimeout timer, which takes constant time. Executing the function fn also takes constant time. Therefore, the time complexity is constant, i.e., O(1).\\n- **Space Complexity**: The space required for this implementation is minimal. We have a few variables (cancelled, executionTimer, etc.), but they do not depend on the input size. Thus, the space complexity is also constant, i.e., O(1).\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n  const executionTimer = setTimeout(() => {\\n    if (!cancelled) {\\n      const result = fn(...args);\\n      console.log(`fn(${args.join(\\',\\')}) called at t=${t}ms`);\\n      console.log(`Returned: ${result}`);\\n    }\\n  }, t);\\n\\n  return function cancelFn() {\\n    cancelled = true;\\n    clearTimeout(executionTimer);\\n    console.log(`Cancellation called at t=${t}ms`);\\n  };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancelled = false;\\n\\n  const executionTimer = setTimeout(() => {\\n    if (!cancelled) {\\n      const result = fn(...args);\\n      console.log(`fn(${args.join(\\',\\')}) called at t=${t}ms`);\\n      console.log(`Returned: ${result}`);\\n    }\\n  }, t);\\n\\n  return function cancelFn() {\\n    cancelled = true;\\n    clearTimeout(executionTimer);\\n    console.log(`Cancellation called at t=${t}ms`);\\n  };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938301,
                "title": "typescript-shortest-solution",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const ref = setTimeout( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearTimeout, cancelT, ref );\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const ref = setTimeout( fn, t, ...args );\\n    return ( cancelT: number ) => setTimeout( clearTimeout, cancelT, ref );\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3935859,
                "title": "timeout-cancellation",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function(){\\n    fn(...args);\\n  },t)\\n\\n  const cancelFn = function(){\\n    clearTimeout(timeoutId)\\n  }\\n   \\n  return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeoutId = setTimeout(function(){\\n    fn(...args);\\n  },t)\\n\\n  const cancelFn = function(){\\n    clearTimeout(timeoutId)\\n  }\\n   \\n  return cancelFn\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3925413,
                "title": "javascript-simple-solution",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timeout);\\n};\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *\\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timeout);\\n};\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now()\\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *\\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *\\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3910645,
                "title": "beats-71-52-of-users-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout=setTimeout(()=>{ \\n  fn(...args);\\n  },t)\\n  return ()=>clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout=setTimeout(()=>{ \\n  fn(...args);\\n  },t)\\n  return ()=>clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909783,
                "title": "easy-use-of-settimeout-cleartimeout-js-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {    \\n    let timerId = setTimeout(fn, t, ...args);\\n    let cancelFn = () => clearTimeout(timerId);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3909396,
                "title": "javascript-solution-2-lines-super-easy-to-understand",
                "content": "```javascript\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeout);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeout);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891979,
                "title": "js-solution-runtime-65-ms-beats-71-45",
                "content": "# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    return () =>clearTimeout(timeout)\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    return () =>clearTimeout(timeout)\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3891346,
                "title": "simple-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the timeout id\\n  var timeoutId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the timeout if it exists\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n  };\\n  // set a timeout to execute fn after t milliseconds\\n  timeoutId = setTimeout(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    // create a variable to store the timeout id\\n  var timeoutId = null;\\n  // create a variable to store the cancellation flag\\n  var cancelled = false;\\n  // create a function to cancel the execution of fn\\n  var cancelFn = function() {\\n    // set the cancellation flag to true\\n    cancelled = true;\\n    // clear the timeout if it exists\\n    if (timeoutId) {\\n      clearTimeout(timeoutId);\\n    }\\n  };\\n  // set a timeout to execute fn after t milliseconds\\n  timeoutId = setTimeout(function() {\\n    // check if the cancellation flag is false\\n    if (!cancelled) {\\n      // call fn with args as parameters\\n      fn(...args);\\n    }\\n  }, t);\\n  // return the cancel function\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3882379,
                "title": "easy-to-understand-detailed-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind the solution is to use a flag variable to track whether the timer has been canceled. If the timer has been canceled, the flag variable will be set to false and the timer will be cleared. This will prevent the fn function from being called.\\n\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach is to first create a flag variable. The flag variable is used to track whether the timer has been canceled.\\n\\nThe cancelFn function is then used to cancel the timer. If the cancelFn function is called before the timer fires, the flag variable will be set to false and the timer will be cleared. This will prevent the fn function from being called.\\n\\nThe setTimeout() function is then used to create a timer object. The timer object is set to fire after t milliseconds. When the timer fires, the fn function is called with the args passed as parameters.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution is O(1). This is because the solution only needs to create a flag variable and a timer object.\\n\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the solution is O(1). This is because the solution only needs to store the flag variable and the timer object.\\n\\n\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var flag=true;\\n    var cancelFn = (cancelT)=>{\\n        if(flag)clearTimeout(flag);\\n    };\\n    flag = setTimeout(()=>{\\n        fn(...args);\\n    },t);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var flag=true;\\n    var cancelFn = (cancelT)=>{\\n        if(flag)clearTimeout(flag);\\n    };\\n    flag = setTimeout(()=>{\\n        fn(...args);\\n    },t);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3876283,
                "title": "accepted-javascript",
                "content": "```\\nvar cancellable = function(fn, args, t) {\\n    var cancel = false;\\n\\n    function call() {\\n        if (!cancel) {\\n            fn(...args);\\n        }\\n    }\\n\\n    setTimeout(call, t);\\n    \\n    return function() {\\n        cancel = true;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    var cancel = false;\\n\\n    function call() {\\n        if (!cancel) {\\n            fn(...args);\\n        }\\n    }\\n\\n    setTimeout(call, t);\\n    \\n    return function() {\\n        cancel = true;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872542,
                "title": "2-lines-of-code-beats-96-40-simple-solution-with-minimal-code",
                "content": "# Intuition\\nThese approach emphasizes achieving **performance with minimal code**.\\n\\n# Approach\\nTo understand the solution, it is important to grasp the entire execution process, not just the function itself.\\n\\nLet\\'s break down what happens when we call the cancellable() function:\\n\\n**1.** First, we **use setTimeout() to set a delay** for the execution of fn() and store the timeout ID in the timeoutId variable.\\n\\n`  let timeoutId = setTimeout(() => fn(...args), t);`\\n\\n**2.** Next, we **return a function** that clears the same timeout.\\n\\n`return () => clearTimeout(timeoutId);`\\n\\n**3.** Now, let\\'s focus on how we call the cancellable function:\\n\\n` const cancel = cancellable(log, args, t);`\\n\\nWe call the cancellable function, which initializes the setTimeout for fn. However, ****the returned function, which wraps the clearTimeout, is not executed immediately****. Instead, we save it in the variable cancel. This allows the fn() to keep executing after a specific period t.\\n\\n**4.** As time progresses, fn() will continue to execute after a specific time period defined by t. **Until the cancelT time delay is not reached, the fn() execution will continue based on its own delay t**. But once the cancelT time has reached, the cancel function will stop the execution by clearing the setTimeout.\\n\\n```\\n setTimeout(() => {\\n    cancel()\\n }, cancelT)\\n```\\n\\n**5.** The cancel function is able to **access the timeoutId due to closure**. When a function is defined inside another function, it forms a closure, which allows the inner function (cancel function in this case) to access variables and parameters of the outer function (cancellable function) even after the outer function has finished executing.\\n\\nPlease **Upvote** if you find helpful.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = (fn, args, t) => {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n setTimeout(() => {\\n    cancel()\\n }, cancelT)\\n```\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = (fn, args, t) => {\\n    let timeoutId = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3869453,
                "title": "clear-explanation-with-example",
                "content": "# Code\\n```\\nconst cancellable = function(fn, args, T) {\\n    // This function will only execute after a delay of \\'T\\' ms.\\n    const delayedExecution = setTimeout(() => fn(...args), T);\\n\\n    // Returns a function that cancels the previous delayed fn.\\n    // You can invoke this function with another delayed execution\\n    // so that by the time clearTimeout is executed, \\'fn\\' has  \\n    // potentially finished.\\n    const cancelDelayedExecution = () => clearTimeout(delayedExecution);\\n\\n    return cancelDelayedExecution;\\n};\\n```\\n\\n# Example\\nYou want to provide a API which using openAI\\'s API key, which can be expensive if user keep calling it. You somehow decide to use this strange method to prevent user burn your money.\\n\\n### function provider\\n\\n```\\n// Example usage:\\nconst apiKey = \"your_openai_api_key\";\\nfunction expensiveAPICall(key) {\\n    console.log(`Calling expensive API with key: ${key}`);\\n    // Simulating an API call\\n};\\n\\n// Create a cancellable function for the expensive API call \\n// with a 20-second delay\\nexport const exeAfter20secs = cancellable(\\n    expensiveAPICall, \\n    [apiKey], \\n    20000);\\n```\\n\\n### function user\\n\\n```\\n// User decide to cancel the API call within 10 seconds \\n// and nothing happened!\\nsetTimeout(() => {\\n    expensiveCallwithMinimum20sDelay(); \\n}, 10000);\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = function(fn, args, T) {\\n    // This function will only execute after a delay of \\'T\\' ms.\\n    const delayedExecution = setTimeout(() => fn(...args), T);\\n\\n    // Returns a function that cancels the previous delayed fn.\\n    // You can invoke this function with another delayed execution\\n    // so that by the time clearTimeout is executed, \\'fn\\' has  \\n    // potentially finished.\\n    const cancelDelayedExecution = () => clearTimeout(delayedExecution);\\n\\n    return cancelDelayedExecution;\\n};\\n```\n```\\n// Example usage:\\nconst apiKey = \"your_openai_api_key\";\\nfunction expensiveAPICall(key) {\\n    console.log(`Calling expensive API with key: ${key}`);\\n    // Simulating an API call\\n};\\n\\n// Create a cancellable function for the expensive API call \\n// with a 20-second delay\\nexport const exeAfter20secs = cancellable(\\n    expensiveAPICall, \\n    [apiKey], \\n    20000);\\n```\n```\\n// User decide to cancel the API call within 10 seconds \\n// and nothing happened!\\nsetTimeout(() => {\\n    expensiveCallwithMinimum20sDelay(); \\n}, 10000);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3845180,
                "title": "js-closure",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const id = setTimeout(() => fn(...args), t);\\n    return function cancelFn() {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const id = setTimeout(() => fn(...args), t);\\n    return function cancelFn() {\\n        clearTimeout(id);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3835501,
                "title": "execute-cancellable-function-with-delay-javascript-easy-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const cancelFn = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(cancelFn);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Design"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const cancelFn = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(cancelFn);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3831129,
                "title": "simple-solution-cleartimeout",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout = setTimeout(fn, t, ...args);\\n\\n  return () => clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeout = setTimeout(fn, t, ...args);\\n\\n  return () => clearTimeout(timeout);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3830837,
                "title": "cleeartimeout-simple-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timer)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => {\\n        fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timer)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3818342,
                "title": "execute-cancellable-function-with-delay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  const timeoutId = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let canceled = false;\\n\\n  const cancelFn = function () {\\n    canceled = true;\\n  };\\n\\n  const timeoutId = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3816080,
                "title": "javascript-set-timeout-clear-timeout-easy-solution",
                "content": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const setId = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(setId)\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const setId = setTimeout(() => fn(...args), t);\\n\\n    return () => clearTimeout(setId)\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3815897,
                "title": "fun-code",
                "content": "\\n# Code\\n```\\nconst cancellable = (fn, args, time) => {\\n  let timeOut\\n  timeOut = setTimeout(() => {\\n    fn(...args)\\n  }, time)\\n  return () => {\\n    clearTimeout(timeOut)\\n    return []\\n  }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, time) => {\\n  let timeOut\\n  timeOut = setTimeout(() => {\\n    fn(...args)\\n  }, time)\\n  return () => {\\n    clearTimeout(timeOut)\\n    return []\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813771,
                "title": "2715-execute-cancellable-function-with-delay",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  let r = setTimeout(() => fn(...args), t)\\n  return function () { clearTimeout(r) }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  let r = setTimeout(() => fn(...args), t)\\n  return function () { clearTimeout(r) }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3813288,
                "title": "easy-cancellable-solution-using-timeoutid",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId;\\n    let isCanceled = false;\\n\\n    const cancelFn = () => {\\n        isCanceled = true;\\n        clearTimeout(timeoutId);\\n    };\\n\\n    timeoutId = setTimeout(() => {\\n        if (!isCanceled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeoutId;\\n    let isCanceled = false;\\n\\n    const cancelFn = () => {\\n        isCanceled = true;\\n        clearTimeout(timeoutId);\\n    };\\n\\n    timeoutId = setTimeout(() => {\\n        if (!isCanceled) {\\n            fn(...args);\\n        }\\n    }, t);\\n\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3810918,
                "title": "javascript-o-1-solution",
                "content": "# Intuition\\nreturn a clearTimeout of a setTimeout\\n\\n# Approach\\n1. Create a setTimeout for the passed arguments.\\n2. Take a reference variable for the timeout.\\n3. Create & return a clearTimeout for the setTimeout.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  const ref = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(ref);\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nconst cancellable = (fn, args, t) => {\\n  const ref = setTimeout(()=>fn(...args), t);\\n  return () => clearTimeout(ref);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784592,
                "title": "2715-execute-cancellable-function-with-delay",
                "content": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    setTimeout(() => { if(!lock) fn(...args)}, t);\\n    return () => {\\n        lock = true;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let lock = false;\\n    setTimeout(() => { if(!lock) fn(...args)}, t);\\n    return () => {\\n        lock = true;\\n    };\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3767477,
                "title": "very-tricky-indeed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo be honest, I had to look at other solutions inorder to write this.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem essentially boils down to this implementation.. However \\nit\\'s kind of hard to reach to this thought process ..\\n\\nWrap the fn inside setTimeout that it get\\'s executed after t sec..\\n\\nif cancelFn is executed before fn (cancelTime is less than t), the case when you don\\'t want to execute fn ..do a clear the timer of the execution of fn.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const  timer = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const  timer = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3757797,
                "title": "ts-very-simple-approach-settimeout-cleartimeout",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3757796,
                "title": "ts-very-simple-approach-settimeout-cleartimeout",
                "content": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const timeoutId = setTimeout(()=>{\\n        fn(...args)\\n    },t);\\n\\n    const cancelFn:Function = ()=>{\\n        clearTimeout(timeoutId);\\n    }\\n    return cancelFn;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3753898,
                "title": "soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n        fn(...args)\\n    },t)\\n    const cancelFn = () => clearTimeout(timeout);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n        fn(...args)\\n    },t)\\n    const cancelFn = () => clearTimeout(timeout);\\n    return cancelFn;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746025,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3746024,
                "title": "easy-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let cancel = false;\\n    setTimeout(() =>!cancel && fn(...args),t)\\n    return () => cancel = true\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3745054,
                "title": "solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    const timeOut = setTimeout(() => fn(...args), t)\\n    const delay = () => clearTimeout(timeOut)\\n    return delay;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n\\n    const timeOut = setTimeout(() => fn(...args), t)\\n    const delay = () => clearTimeout(timeOut)\\n    return delay;\\n};\\n\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const start = performance.now() \\n *\\n *  const log = (...argsArr) => {\\n *      const diff = Math.floor(performance.now() - start);\\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(log, args, t);\\n *\\n *  const maxT = Math.max(t, cancelT)\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *  }, cancelT)\\n *\\n *  setTimeout(() => {\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, maxT + 15)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741299,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3741298,
                "title": "short-and-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(() => fn(...args), t)\\n\\n    return () => clearTimeout(timerId)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3733291,
                "title": "simple-approach",
                "content": "**Bold**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let a=setTimeout(() => {\\n      fn(...args)\\n  }, t)\\n    return function(){\\n        clearTimeout(a);\\n    } \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let a=setTimeout(() => {\\n      fn(...args)\\n  }, t)\\n    return function(){\\n        clearTimeout(a);\\n    } \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3732231,
                "title": "easiest-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    let id1 = setTimeout(fn,t,...args)\\n    return cancelFn = (cancelTime) => {\\n        setTimeout(()=>clearTimeout(id1),cancelTime)\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    let id1 = setTimeout(fn,t,...args)\\n    return cancelFn = (cancelTime) => {\\n        setTimeout(()=>clearTimeout(id1),cancelTime)\\n    }\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3721734,
                "title": "easiest-way-to-solve-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    var cancelFn = ()=> clearTimeout(timeout);\\n    return cancelFn\\n        \\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function (fn, args, t) {\\n    var timeout = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n\\n    var cancelFn = ()=> clearTimeout(timeout);\\n    return cancelFn\\n        \\n\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3695460,
                "title": "two-lines-easy-to-understand-ts-js-solution",
                "content": "\\n# Code\\n``` Javascript []\\nfunction cancellable(fn, args, t){\\n    const id = setTimeout(() => fn(...args),t)\\n    return () => clearTimeout(id)\\n};\\n```\\n\\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id: ReturnType<typeof setTimeout> = setTimeout(()=>fn(...args),t)\\n    return ()=>clearTimeout(id)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction cancellable(fn, args, t){\\n    const id = setTimeout(() => fn(...args),t)\\n    return () => clearTimeout(id)\\n};\\n```\n``` Typescript []\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    const id: ReturnType<typeof setTimeout> = setTimeout(()=>fn(...args),t)\\n    return ()=>clearTimeout(id)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3694682,
                "title": "simple-settimeout-and-cleartimeout-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timeout)\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeout = setTimeout(() => {\\n      fn(...args)\\n    }, t)\\n\\n    return () => clearTimeout(timeout)\\n\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3683367,
                "title": "easy-solution-cancellable-function-with-delay",
                "content": "# Approach\\nTo solve this problem, we can use a combination of **setTimeout** and a **flag variable** to keep track of whether the cancellation function has been called or not.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let canceled = false;\\n\\n  const timer = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  const cancelFn = () => {\\n    canceled = true;\\n    clearTimeout(timer);\\n  };\\n\\n  return cancelFn;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let canceled = false;\\n\\n  const timer = setTimeout(() => {\\n    if (!canceled) {\\n      fn(...args);\\n    }\\n  }, t);\\n\\n  const cancelFn = () => {\\n    canceled = true;\\n    clearTimeout(timer);\\n  };\\n\\n  return cancelFn;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3674049,
                "title": "easiest-to-understand-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    return ()=>clearTimeout(timeoutHandle)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timeoutHandle = setTimeout(()=>{\\n        fn(...args)\\n    },t)\\n    return ()=>clearTimeout(timeoutHandle)\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670282,
                "title": "simple-solution-with-explanation",
                "content": "# Intuition\\nThe `timeout` function returns an `ID` so that we can clear it whenever needed.\\nWe just use this timeout ID to delete the timeout action whenever cancelFn is called.\\n\\n# Approach\\n1. create a setTimeout with the function and arguments given.\\n2. save the timeout ID returned the setTimeout function\\n3. return the requested function `cancelFn`. This function clears the timeout.\\nYou can see an example of timeout and clearTimeout on the official documentation [here](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout).\\n\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(() => fn(...args), t);\\n    return cancelFn = () => clearTimeout(timeoutID);\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "# Intuition\\nThe `timeout` function returns an `ID` so that we can clear it whenever needed.\\nWe just use this timeout ID to delete the timeout action whenever cancelFn is called.\\n\\n# Approach\\n1. create a setTimeout with the function and arguments given.\\n2. save the timeout ID returned the setTimeout function\\n3. return the requested function `cancelFn`. This function clears the timeout.\\nYou can see an example of timeout and clearTimeout on the official documentation [here](https://developer.mozilla.org/en-US/docs/Web/API/clearTimeout).\\n\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(() => fn(...args), t);\\n    return cancelFn = () => clearTimeout(timeoutID);\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3666649,
                "title": "the-best-and-shortest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timerId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timerId = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timerId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3660850,
                "title": "very-simple-solution",
                "content": "Inspired by [setTimeout() MDN Reference](https://developer.mozilla.org/en-US/docs/Web/API/setTimeout).\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  const timeoutID = setTimeout(() => {\\n    fn(...args);\\n  }, t);\\n\\n  return () => {\\n    clearTimeout(timeoutID);\\n  };\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n  const timeoutID = setTimeout(() => {\\n    fn(...args);\\n  }, t);\\n\\n  return () => {\\n    clearTimeout(timeoutID);\\n  };\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3654573,
                "title": "javascript-soution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeout = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return ()=>{\\n      clearTimeout(timeout);\\n  }  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  const timeout = setTimeout(()=>{\\n      fn(...args)\\n  }, t);\\n  return ()=>{\\n      clearTimeout(timeout);\\n  }  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3633283,
                "title": "why-this-give-error",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let exe=setTimeout(fn(...args)\\n    ,t);\\n\\n    let cancel=()=>{\\n        clearTimeout(exe);\\n    }\\n\\n    return cancel;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let exe=setTimeout(fn(...args)\\n    ,t);\\n\\n    let cancel=()=>{\\n        clearTimeout(exe);\\n    }\\n\\n    return cancel;\\n    \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3625551,
                "title": "javascript-solution-with-boolean-variable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe just need 2 things to solve this question- \\n(1) setTimeout() for giving t ms delay before calling the function fn.\\n(2) a boolean variable which decides whether calling function fn is allowed for not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use a boolean variable \\'isCancelled\\' and initialize it with false, ie, the funtion fn is not cancelled initially.\\nThen we use setTimeout() which calls the function fn after t ms delay only if the \\'isCancelled\\' variable is set to false.\\nFrom our cancellable function we are just returning a function which flips our \\'isCancelled\\' boolean variable to true , ie, function fn is never called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n    setTimeout(() => {\\n        if(!isCancelled)\\n            fn(...args);\\n    }, t);\\n    return () => isCancelled = true;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let isCancelled = false;\\n    setTimeout(() => {\\n        if(!isCancelled)\\n            fn(...args);\\n    }, t);\\n    return () => isCancelled = true;\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3616242,
                "title": "javascript-solution",
                "content": "\\n\\n# Code\\n```\\n\\nvar cancellable = function(fn, args, t) {\\n    \\n    let tmot = setTimeout(()=>{ fn(...args); }, t);\\n    return ()=>{ clearTimeout(tmot); }\\n\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar cancellable = function(fn, args, t) {\\n    \\n    let tmot = setTimeout(()=>{ fn(...args); }, t);\\n    return ()=>{ clearTimeout(tmot); }\\n\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3611988,
                "title": "javascript-settimeout-cleartimeout-2lines",
                "content": "# Code\\n```\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timeoutID);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar cancellable = function(fn, args, t) {\\n    const timeoutID = setTimeout(fn, t, ...args);\\n    return () => clearTimeout(timeoutID);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3603876,
                "title": "simple-js-solution",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var t = setTimeout(()=>{fn(...args)},t);\\n    return () => {\\n        clearTimeout(t);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    var t = setTimeout(()=>{fn(...args)},t);\\n    return () => {\\n        clearTimeout(t);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3596956,
                "title": "javascript-2-lines",
                "content": "```\\nconst cancellable = (fn, args, t) => {\\n  const timer = setTimeout(() => fn(...args), t);\\n  return () => clearTimeout(timer);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst cancellable = (fn, args, t) => {\\n  const timer = setTimeout(() => fn(...args), t);\\n  return () => clearTimeout(timer);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3595669,
                "title": "very-easy-solution-with-cleartimeout",
                "content": "\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   const id = setTimeout(() => {\\n     return fn(...args)\\n   },t)\\n    return function(){\\n      clearTimeout(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n   const id = setTimeout(() => {\\n     return fn(...args)\\n   },t)\\n    return function(){\\n      clearTimeout(id)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3594328,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        return fn(...args);\\n    },t);\\n\\n    return () => {\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timeout = setTimeout(()=>{\\n        return fn(...args);\\n    },t);\\n\\n    return () => {\\n        clearTimeout(timeout);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3593116,
                "title": "javascript-beats-100-2-line-code",
                "content": "# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const exec = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(exec)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const exec = setTimeout(() => fn(...args), t);\\n    return () => clearTimeout(exec)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3592885,
                "title": "2-lines-of-code",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou are supposed to execute `fn` after delay of `t`, and alongwith return a function `cancel`.\\nNow if `cancel` function is called, then stop the timeout of fn.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\nNote: Just put a `setTimeout` before returning the function cancel. and the timeout will resolve into execution of `fn`. and put `clearTimeout` in cancel function.\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    timeoutId =  setTimeout(fn, t, ...args);\\n\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    timeoutId =  setTimeout(fn, t, ...args);\\n\\n    return () => clearTimeout(timeoutId);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591725,
                "title": "simple-js-solution-using-closures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => fn(...args), t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    const timer = setTimeout(() => fn(...args), t);\\n\\n    return () => {\\n        clearTimeout(timer);\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3591098,
                "title": "simple-javascript-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timerId;\\n    timerId = setTimeout(() => fn(...args), t);\\n    return function(){\\n        clearTimeout(timerId)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n    let timerId;\\n    timerId = setTimeout(() => fn(...args), t);\\n    return function(){\\n        clearTimeout(timerId)\\n    }\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3590142,
                "title": "simple-javascript-solution-using-cleartimeout-and-settimeout",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {Function} fn\\n * @param {Array} args\\n * @param {number} t\\n * @return {Function}\\n */\\nvar cancellable = function(fn, args, t) {\\n  let timeoutId;\\n\\n  const cancelFn = () =>  clearTimeout(timeoutId);\\n\\n  timeoutId = setTimeout(() => fn(...args), t);\\n\\n  return cancelFn;  \\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589196,
                "title": "72ms-45mb-short-typescript-click",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    let tf = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearTimeout(tf);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction cancellable(fn: Function, args: any[], t: number): Function {\\n    let tf = setTimeout(() => {\\n        fn(...args);\\n    }, t);\\n    return () => clearTimeout(tf);\\n};\\n\\n/**\\n *  const result = []\\n *\\n *  const fn = (x) => x * 5\\n *  const args = [2], t = 20, cancelT = 50\\n *\\n *  const log = (...argsArr) => {\\n *      result.push(fn(...argsArr))\\n *  }\\n *       \\n *  const cancel = cancellable(fn, args, t);\\n *           \\n *  setTimeout(() => {\\n *     cancel()\\n *     console.log(result) // [{\"time\":20,\"returned\":10}]\\n *  }, cancelT)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3589074,
                "title": "closure",
                "content": "```\\nvar cancellable = function(fn, args, t) \\n{\\n    let timeout = setTimeout(()=>fn(...args), t);\\n    return ()=>clearTimeout(timeout);\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar cancellable = function(fn, args, t) \\n{\\n    let timeout = setTimeout(()=>fn(...args), t);\\n    return ()=>clearTimeout(timeout);\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1913955,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913840,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1921885,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1975295,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1961560,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1969825,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 2062026,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1986039,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1940498,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1990067,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913955,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1913840,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1921885,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1975295,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1961560,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1969825,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 2062026,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1986039,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1940498,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            },
            {
                "id": 1990067,
                "content": [
                    {
                        "username": "todor91",
                        "content": "Confusing description."
                    },
                    {
                        "username": "a90100",
                        "content": "agree!"
                    },
                    {
                        "username": "kumawatvinit",
                        "content": "Those who are confused by calling and execution of function fn:\\n\\nYou are supposed to execute `fn after delay of t`, and alongwith `return` a function `cancel`.\\nNow if  `cancel` function is called, then stop the timeout of `fn`.\\n\\nSo if `cancel` has been called after execution of `fn`, then nothing will happen, but if it is called before execution of `fn`, we will clear the timeout of `fn`, so that it won\\'t execute ever.\\n\\n\\n\\nNote: Just put a  `setTimeout` before returning the function `cancel`. and the timeout will `resolve` into `execution of fn`. and put `clearTimeout` in `cancel` function."
                    },
                    {
                        "username": "elborracho420",
                        "content": "This is extremely confusing because the example cases indicate a variable cancelTime or cancelT is being passed to the function but it is not. For example:\\n\\nInput: fn = (x) => x**2, args = [2], t = 100, cancelTime = 50\\nOutput: []\\nExplanation: fn(2) was never called because cancelTime (50ms) is before the delay time (100ms).\\n\\nThere is no cancelTime input being passed to the function, just fn, args, and t.\\n\\nThat, or I am completely misinterpreting the problem text."
                    },
                    {
                        "username": "cloudeeoh",
                        "content": "Yes, this is confusing. CancelTime is not being passed; it's being used as part of the setTimeout function that is setup *after* the function is called. \n\nLet's see if this helps clarify things:  \n\n1.  The line below calls the cancellable function (the one we are trying to write). All we have to do is make sure that we delay the execution of the function being passed by *t* milliseconds. Notice that we are storing the returned value of our cancellable function in a variable named *cancel*.\n\n```\nconst cancel = cancellable(fn, args, t)\n\n```\n\n2. Then you see a setTimeout block which waits *cancelTime* milliseconds before calling *cancel()*. Since cancel holds the return value of cancellable, it means that after *cancelTime* milliseconds, we will execute whatever it was returned by cancellable in the first place. This is where *THEY* are using the cancelTime. Your function doesn't need to worry about it. All you need to make sure is that when the *return value* of your function is executed, it will cancel the execution of the original fn.\n\n```\n setTimeout(() => {\n    cancel()\n    console.log(result) // [{\"time\":20,\"returned\":10}]\n }, cancelT)\n```\nIn short, write a function that will execute whatever fn is passed as an argument after *t* millisecond and return another function that, when executed, will cancel the execution of the original fn.\n\n"
                    },
                    {
                        "username": "Dexmente",
                        "content": "This is so confusing.\\nIt isn\\'t that complex, but I gave the exact same description to 4 fellow developers.\\nNone of them quite understood how it should work.\\n\\nThe description and the examples should really be improved"
                    },
                    {
                        "username": "universalwavefunction",
                        "content": "whoever writes these problems writes them in the most confusing way possible... chatGPT could write better problems"
                    },
                    {
                        "username": "RavirajKumarTiwari",
                        "content": " ```\\nvar cancellable = function(fn, args, t) {\\n  // This line declares a variable named cancellable and assigns it a function value.\\n  // The function takes three parameters: fn, args, and t.\\n  // fn is another function that we want to call later.\\n  // args is an array of arguments that we want to pass to fn when we call it.\\n  // t is a number of milliseconds that we want to wait before calling fn.\\n\\n  let timer = setTimeout(() => {\\n    // This line creates a variable named timer and assigns it the result of calling setTimeout.\\n    // setTimeout is a built-in function that can execute another function after a delay.\\n    // The first argument of setTimeout is a function that we want to execute later.\\n    // The second argument of setTimeout is the delay in milliseconds.\\n    // In this case, we are using an arrow function as the first argument, which is a shorthand way of writing a function.\\n    // The arrow function has no parameters and no curly braces, which means it will execute one statement and return its value.\\n    fn(...args); // This is the statement that the arrow function will execute. It calls fn with the args as parameters.\\n    // The ... operator is called the spread operator, which can expand an array into individual elements.\\n    // For example, if args is [2, 3], then fn(...args) is equivalent to fn(2, 3).\\n  }, t);\\n  // The result of calling setTimeout is a numeric value that represents the timer ID. We can use this ID to cancel the timer later.\\n\\n  return function() {\\n    // This line returns another function from the cancellable function. This function will act as the cancel function.\\n    // This function has no parameters and no name. It is an anonymous function.\\n\\n    clearTimeout(timer); // This line calls clearTimeout, which is another built-in function that can cancel a timer created by setTimeout.\\n    // The argument of clearTimeout is the timer ID that we want to cancel. In this case, we use the timer variable that we created earlier.\\n  };\\n};\\n```"
                    },
                    {
                        "username": "Nogaroid",
                        "content": "I don\\'t know where to report this, but there is a mistake in the test output for case 3. It says the expected output is [{\"time\":29,\"returned\":8}] but in reality the correct output is [{\"time\":30,\"returned\":8}] which effectively passes the test and is the same as the output in the problem description."
                    },
                    {
                        "username": "fedorvladysh",
                        "content": "\\u0410 \\u043C\\u043D\\u0435 \\u043F\\u043E\\u043D\\u0440\\u0430\\u0432\\u0438\\u043B\\u0430\\u0441\\u044C \\u0437\\u0430\\u0434\\u0430\\u0447\\u043A\\u0430 : )\\n\\u041E\\u043D\\u0430 \\u0445\\u043E\\u0442\\u044C \\u0438 \\u043F\\u0440\\u043E\\u0441\\u0442\\u043E \\u0440\\u0435\\u0448\\u0430\\u0435\\u0442\\u0441\\u044F, \\u0437\\u0430\\u043C\\u044B\\u0441\\u043B\\u043E\\u0432\\u0430\\u0442\\u043E\\u0435 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0435 \\u0437\\u0430\\u0441\\u0442\\u0430\\u0432\\u043B\\u044F\\u0435\\u0442 \\u0445\\u043E\\u0440\\u043E\\u0448\\u043E \\u0437\\u0430\\u0434\\u0443\\u043C\\u0430\\u0442\\u044C\\u0441\\u044F \\u043D\\u0430\\u0434 \\u0442\\u0435\\u043C, \\u0447\\u0442\\u043E \\u0438\\u043C\\u0435\\u043D\\u043D\\u043E \\u043D\\u0430\\u0434\\u043E \\u0441\\u0434\\u0435\\u043B\\u0430\\u0442\\u044C, \\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0440\\u0430\\u0437 \\u043F\\u0435\\u0440\\u0435\\u0447\\u0438\\u0442\\u0430\\u0442\\u044C, \\u043F\\u0440\\u043E\\u0441\\u043C\\u043E\\u0442\\u0440\\u0435\\u0442\\u044C \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440\\u044B. \\u041F\\u043E\\u043D\\u0438\\u043C\\u0430\\u043D\\u0438\\u0435 \\u0443\\u0441\\u043B\\u043E\\u0432\\u0438\\u044F - \\u0442\\u043E\\u0436\\u0435 \\u0447\\u0430\\u0441\\u0442\\u044C \\u0440\\u0435\\u0448\\u0435\\u043D\\u0438\\u044F. "
                    },
                    {
                        "username": "rayrogar",
                        "content": "Confusing description, until I get an error with something that say \"... cancel()\" I dont undestand that I have to return the ID of my function. I really like this path, it is like a camp, but this desciption dont help. If we pay better attemption to the example of how our function will be call .... "
                    },
                    {
                        "username": "imbkz",
                        "content": "Confusing question"
                    }
                ]
            }
        ]
    }
]