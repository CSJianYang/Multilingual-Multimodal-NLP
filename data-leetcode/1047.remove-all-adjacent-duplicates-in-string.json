[
    {
        "title": "Remove All Adjacent Duplicates In String",
        "question_content": "You are given a string s consisting of lowercase English letters. A duplicate removal consists of choosing two adjacent and equal letters and removing them.\nWe repeatedly make duplicate removals on s until we no longer can.\nReturn the final string after all such duplicate removals have been made. It can be proven that the answer is unique.\n&nbsp;\nExample 1:\nInput: s = \"abbaca\"\nOutput: \"ca\"\nExplanation: \nFor example, in \"abbaca\" we could remove \"bb\" since the letters are adjacent and equal, and this is the only possible move.  The result of this move is that the string is \"aaca\", of which only \"aa\" is possible, so the final string is \"ca\".\nExample 2:\nInput: s = \"azxxzy\"\nOutput: \"ay\"\n&nbsp;\nConstraints:\n\t1 <= s.length <= 105\n\ts consists of lowercase English letters.",
        "solutions": [
            {
                "id": 294893,
                "title": "java-c-python-two-pointers-and-stack-solution",
                "content": "## Solution 1: Two Pointers\\n`i` refers to the index to set next character in the output string.\\n`j` refers to the index of current iteration in the input string.\\n\\nIterate characters of `S` one by one by increasing `j`.\\n\\nIf `S[j]` is same as the current last character `S[i - 1]`,\\nwe remove duplicates by doing `i -= 2`.\\n\\nIf `S[j]` is different as the current last character `S[i - 1]`,\\nwe set `S[i] = S[j]` and increment `i++`.\\n<br>\\n\\n**Java**\\n```java\\n    public String removeDuplicates(String s) {\\n        int i = 0, n = s.length();\\n        char[] res = s.toCharArray();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            res[i] = res[j];\\n            if (i > 0 && res[i - 1] == res[i]) // count = 2\\n                i -= 2;\\n        }\\n        return new String(res, 0, i);\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    string removeDuplicates(string s) {\\n        int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i > 0 && s[i - 1] == s[i]) // count = 2\\n                i -= 2;\\n        }\\n        return s.substr(0, i);\\n    }\\n```\\n<br>\\n\\n## Why This solution\\nYou can easily update this solution to remove more duplicates.\\nNow it\\'s a specil case where we only remove replicates `k = 2`.\\n<br>\\n\\n## Solution 2: Stack\\n\\nKeep a `res` as a characters stack.\\nIterate characters of `S` one by one.\\n\\nIf the next character is same as the last character in `res`,\\npop the last character from `res`.\\nIn this way, we remove a pair of adjacent duplicates characters.\\n\\nIf the next character is different,\\nwe append it to the end of `res`.\\n<br>\\n\\n**C++**\\n```cpp\\n    string removeDuplicates(string S) {\\n        string res = \"\";\\n        for (char& c : S)\\n            if (res.size() && c == res.back())\\n                res.pop_back();\\n            else\\n                res.push_back(c);\\n        return res;\\n    }\\n```\\n**Java**\\n```java\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) {\\n                sb.deleteCharAt(size - 1);\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\\n**Python**\\n```py\\n    def removeDuplicates(self, S):\\n        res = []\\n        for c in S:\\n            if res and res[-1] == c:\\n                res.pop()\\n            else:\\n                res.append(c)\\n        return \"\".join(res)\\n```\\n\\n**Python 1-line**\\n```py\\n    def removeDuplicates(self, S):\\n        return reduce(lambda s, c: s[:-1] if s[-1:] == c else s + c, S)\\n```\\n## **Complexity**\\nThese two solution actually work in the similar way.\\nTime `O(N)` for one pass\\nSpace `O(N)` for output\\n<br>",
                "solutionTags": [],
                "code": "```java\\n    public String removeDuplicates(String s) {\\n        int i = 0, n = s.length();\\n        char[] res = s.toCharArray();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            res[i] = res[j];\\n            if (i > 0 && res[i - 1] == res[i]) // count = 2\\n                i -= 2;\\n        }\\n        return new String(res, 0, i);\\n    }\\n```\n```cpp\\n    string removeDuplicates(string s) {\\n        int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i > 0 && s[i - 1] == s[i]) // count = 2\\n                i -= 2;\\n        }\\n        return s.substr(0, i);\\n    }\\n```\n```cpp\\n    string removeDuplicates(string S) {\\n        string res = \"\";\\n        for (char& c : S)\\n            if (res.size() && c == res.back())\\n                res.pop_back();\\n            else\\n                res.push_back(c);\\n        return res;\\n    }\\n```\n```java\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) {\\n                sb.deleteCharAt(size - 1);\\n            } else {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```py\\n    def removeDuplicates(self, S):\\n        res = []\\n        for c in S:\\n            if res and res[-1] == c:\\n                res.pop()\\n            else:\\n                res.append(c)\\n        return \"\".join(res)\\n```\n```py\\n    def removeDuplicates(self, S):\\n        return reduce(lambda s, c: s[:-1] if s[-1:] == c else s + c, S)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 294964,
                "title": "java-python-3-three-easy-iterative-codes-w-brief-explanation-analysis-and-follow-up",
                "content": "**Method 1: ArrayDeque**\\n\\nIf current char is same as previous char in the ArrayDeque, pop out the previous char; \\nOtherwise, add current char into the ArrayDeque.\\n\\n\\n```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        for (char c : S.toCharArray()) {\\n            if (!dq.isEmpty() && dq.peekLast() == c) { \\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : dq) { sb.append(c); }\\n        return sb.toString();\\n    }\\n```\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        dq = collections.deque()\\n        for c in S:\\n            if dq and dq[-1] == c:\\n                dq.pop()\\n            else:\\n                dq.append(c)\\n        return \\'\\'.join(dq)\\n```\\nOr just use list:\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for c in S:\\n            if stack and stack[-1] == c:\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\\n\\n**Method 2: StringBuilder.**\\n\\nGet rid of the ArrayDeque in method 1, use only StringBuilder.\\n\\nIf current char is same as the end of the StringBuilder, delete the char at end; otherwise, append it at the end.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) { \\n                sb.deleteCharAt(size - 1); \\n            }else { \\n                sb.append(c); \\n            }\\n        }\\n        return sb.toString();\\n    }\\n``` \\n\\n**Method 3: two pointers**\\n\\nIf current char is same as the end of non-adjacent-duplicate chars, decrease the counter `end` by 1;\\notherwise, copy the current char to its end.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        char[] a = S.toCharArray();\\n        int end = -1;\\n        for (char c : a) {\\n            if (end >= 0 && a[end] == c) { \\n                --end; \\n            }else { \\n                a[++end] = c; \\n            }\\n        }\\n        return String.valueOf(a, 0, end + 1);\\n    }\\n```\\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        end, a = -1, list(S)\\n        for c in a:\\n            if end >= 0 and a[end] == c:\\n                end -= 1\\n            else:\\n                end += 1\\n                a[end] = c\\n        return \\'\\'.join(a[: end + 1])\\n```\\n**Analysis for all methods:**\\n\\nTime & space: O(n), where n = S.length().\\n\\n----\\n\\n**Follow-up:**\\n\\nSee follow up [1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/393149/JavaPython-3-O(n)-codes-using-Stack-w-brief-explanation-and-analysis.)\\n\\nQ: What if we are required to **remove all k-in-a-row duplicates in a string (for more-than-k-in-a-row, remove only first k duplicates)**? - credit to **@betterztt**.\\n\\nA: Use 2 stacks, one for characters, and the other for the count of adjacent characters.\\n\\n```java\\n    public String removeDuplicates(String S, int k) {\\n        Deque<Character> charStk = new ArrayDeque<>();\\n        Deque<Integer> cntStk = new ArrayDeque<>();\\n        for (int i = 0; i < S.length(); ++i) {\\n            char c = S.charAt(i);\\n            if (charStk.isEmpty() || charStk.peek() != c) { // no char in stack yet, or top char is different from the current.\\n                charStk.push(c);\\n                cntStk.push(1);\\n            }else if (cntStk.peek() + 1 < k) { // top char is same as the current, but less than k after appending the current.\\n                cntStk.push(cntStk.pop() + 1);\\n            }else { // found k-in-a-row duplicates, remove them.\\n                charStk.pop();\\n                cntStk.pop();\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : charStk) {\\n            int cnt = cntStk.pop();\\n            while (cnt-- > 0) {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString(); // Do NOT forget reverse().\\n    }\\n```\\n```python\\n    def removeDuplicates(self, S: str, k: int) -> str:\\n         stk = []\\n        for char in S:\\n            if not stk or stk[-1][0] != char:\\n                stk.append([char, 1])\\n            elif stk[-1][1] + 1 < k:\\n                stk[-1][1] += 1\\n            else:\\n                stk.pop()\\n        return \\'\\'.join(char * cnt for char, cnt in stk)\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String",
                    "Iterator"
                ],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> dq = new ArrayDeque<>();\\n        for (char c : S.toCharArray()) {\\n            if (!dq.isEmpty() && dq.peekLast() == c) { \\n                dq.pollLast();\\n            }else {\\n                dq.offer(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : dq) { sb.append(c); }\\n        return sb.toString();\\n    }\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        dq = collections.deque()\\n        for c in S:\\n            if dq and dq[-1] == c:\\n                dq.pop()\\n            else:\\n                dq.append(c)\\n        return \\'\\'.join(dq)\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for c in S:\\n            if stack and stack[-1] == c:\\n                stack.pop()\\n            else:\\n                stack.append(c)\\n        return \\'\\'.join(stack)\\n```\n```\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : S.toCharArray()) {\\n            int size = sb.length();\\n            if (size > 0 && sb.charAt(size - 1) == c) { \\n                sb.deleteCharAt(size - 1); \\n            }else { \\n                sb.append(c); \\n            }\\n        }\\n        return sb.toString();\\n    }\\n```\n```\\n    public String removeDuplicates(String S) {\\n        char[] a = S.toCharArray();\\n        int end = -1;\\n        for (char c : a) {\\n            if (end >= 0 && a[end] == c) { \\n                --end; \\n            }else { \\n                a[++end] = c; \\n            }\\n        }\\n        return String.valueOf(a, 0, end + 1);\\n    }\\n```\n```\\n    def removeDuplicates(self, S: str) -> str:\\n        end, a = -1, list(S)\\n        for c in a:\\n            if end >= 0 and a[end] == c:\\n                end -= 1\\n            else:\\n                end += 1\\n                a[end] = c\\n        return \\'\\'.join(a[: end + 1])\\n```\n```java\\n    public String removeDuplicates(String S, int k) {\\n        Deque<Character> charStk = new ArrayDeque<>();\\n        Deque<Integer> cntStk = new ArrayDeque<>();\\n        for (int i = 0; i < S.length(); ++i) {\\n            char c = S.charAt(i);\\n            if (charStk.isEmpty() || charStk.peek() != c) { // no char in stack yet, or top char is different from the current.\\n                charStk.push(c);\\n                cntStk.push(1);\\n            }else if (cntStk.peek() + 1 < k) { // top char is same as the current, but less than k after appending the current.\\n                cntStk.push(cntStk.pop() + 1);\\n            }else { // found k-in-a-row duplicates, remove them.\\n                charStk.pop();\\n                cntStk.pop();\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : charStk) {\\n            int cnt = cntStk.pop();\\n            while (cnt-- > 0) {\\n                sb.append(c);\\n            }\\n        }\\n        return sb.reverse().toString(); // Do NOT forget reverse().\\n    }\\n```\n```python\\n    def removeDuplicates(self, S: str, k: int) -> str:\\n         stk = []\\n        for char in S:\\n            if not stk or stk[-1][0] != char:\\n                stk.append([char, 1])\\n            elif stk[-1][1] + 1 < k:\\n                stk[-1][1] += 1\\n            else:\\n                stk.pop()\\n        return \\'\\'.join(char * cnt for char, cnt in stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2430136,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tans.push_back(s[0]);\\n\\n\\t\\t\\tfor(int i=1 ; i<s.length() ; i++){\\n\\n\\t\\t\\t\\tif(!ans.empty() && s[i] == ans.back()){\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tans.push_back(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\n\\t\\t\\tstring ans;\\n\\t\\t\\tans.push_back(s[0]);\\n\\n\\t\\t\\tfor(int i=1 ; i<s.length() ; i++){\\n\\n\\t\\t\\t\\tif(!ans.empty() && s[i] == ans.back()){\\n\\t\\t\\t\\t\\tans.pop_back();\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1302208,
                "title": "c-java-python-stack-based-solution-really-clean-concise",
                "content": "**Idea**\\n- Use stack `st` to store non duplicate characters so far.\\n- Iterating each character `c` in string `s`, if the the top of stack is equal to `c` then `st.pop()` else `st.append(c)`.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/7bHcEq4r/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`, where `N` is length of string `S`.\\n- Space: `O(N-D)`, where `D` is a total length for all duplicates.\\n\\n**Next step, try yourself to solve this following up questions:**\\n* [1209. Remove All Adjacent Duplicates K Letters in String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n\\nIf you like this post, please **give it a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "solutionTags": [],
                "code": "**Idea**\\n- Use stack `st` to store non duplicate characters so far.\\n- Iterating each character `c` in string `s`, if the the top of stack is equal to `c` then `st.pop()` else `st.append(c)`.\\n\\n**Implementation**\\n<iframe src=\"https://leetcode.com/playground/7bHcEq4r/shared\" frameBorder=\"0\" width=\"100%\" height=\"320\"></iframe>\\n\\n**Complexity:**\\n- Time: `O(N)`, where `N` is length of string `S`.\\n- Space: `O(N-D)`, where `D` is a total length for all duplicates.\\n\\n**Next step, try yourself to solve this following up questions:**\\n* [1209. Remove All Adjacent Duplicates K Letters in String](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n\\nIf you like this post, please **give it a vote**. Any questions or discussions in this post are welcome! Thanks.",
                "codeTag": "Unknown"
            },
            {
                "id": 295163,
                "title": "c-5-lines-use-string-as-a-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string a;\\n        for (auto& c : S) \\n            if (a.size() && a.back() == c) a.pop_back();\\n            else a.push_back(c);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string a;\\n        for (auto& c : S) \\n            if (a.size() && a.back() == c) a.pop_back();\\n            else a.push_back(c);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798052,
                "title": "python3-stack-approach-o-n-candy-crush",
                "content": "Think about this as Candy Crush for a single row where you can only crush two candies at a time :) The idea is to have a stack to store the visited chars. If the current char in the string is the same as the last char in the stack, pop the last char from the stack and skip the current char in the string; otherwise, append the current char to the stack.\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n    \\t### initialize an empty stack\\n        stack = []\\n\\n        for char in s:\\n        \\t\\n        \\t### This is the case where two adjacent letters are equal\\n        \\t### don\\'t store it and pop the last one from stack,\\n        \\t### Don\\'t forget to check if the stack is empty!\\n            if stack and char==stack[-1]:\\n                stack.pop()\\n\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```\\n\\n**Time complexity** is **O(n)** since we just went over ```s```.\\n\\nRuning the code with an example ```s = \"abbaca\"```\\n```\\n\\t\\t\\t\\tBEFORE\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAFTER\\n\\ti=0\\t\\t\\tstack=[]\\t\\ts[i]=a \\t\\tempty stack, append\\t\\t\\tstack=[a]\\n\\ti=1\\t\\t\\tstack=[a]\\t\\ts[i]=b \\t\\tstack[-1]!=s[i], append\\t\\tstack=[a,b]\\n\\ti=2\\t\\t\\tstack=[a,b]\\t\\ts[i]=b \\t\\tstack[-1]==s[i], pop\\t\\tstack=[a]\\n\\ti=3\\t\\t\\tstack=[a]\\t\\ts[i]=a \\t\\tstack[-1]==s[i], pop\\t\\tstack=[]\\n\\ti=4\\t\\t\\tstack=[]\\t\\ts[i]=c \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c]\\n\\ti=5\\t\\t\\tstack=[c]\\t\\ts[i]=a \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c,a] (result)\\n```\\n\\nOne line from genius [lee215](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/discuss/294893/JavaC%2B%2BPython-Two-Pointers-and-Stack-Solution):\\n\\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        return reduce(lambda stack, char: stack[:-1] if stack[-1:] == char else stack + char, s)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n    \\t### initialize an empty stack\\n        stack = []\\n\\n        for char in s:\\n        \\t\\n        \\t### This is the case where two adjacent letters are equal\\n        \\t### don\\'t store it and pop the last one from stack,\\n        \\t### Don\\'t forget to check if the stack is empty!\\n            if stack and char==stack[-1]:\\n                stack.pop()\\n\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```\n```s```\n```s = \"abbaca\"```\n```\\n\\t\\t\\t\\tBEFORE\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tAFTER\\n\\ti=0\\t\\t\\tstack=[]\\t\\ts[i]=a \\t\\tempty stack, append\\t\\t\\tstack=[a]\\n\\ti=1\\t\\t\\tstack=[a]\\t\\ts[i]=b \\t\\tstack[-1]!=s[i], append\\t\\tstack=[a,b]\\n\\ti=2\\t\\t\\tstack=[a,b]\\t\\ts[i]=b \\t\\tstack[-1]==s[i], pop\\t\\tstack=[a]\\n\\ti=3\\t\\t\\tstack=[a]\\t\\ts[i]=a \\t\\tstack[-1]==s[i], pop\\t\\tstack=[]\\n\\ti=4\\t\\t\\tstack=[]\\t\\ts[i]=c \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c]\\n\\ti=5\\t\\t\\tstack=[c]\\t\\ts[i]=a \\t\\tstack[-1]!=s[i], append\\t\\tstack=[c,a] (result)\\n```\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        return reduce(lambda stack, char: stack[:-1] if stack[-1:] == char else stack + char, s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798136,
                "title": "leetcode-the-hard-way-explained-line-by-line-c-python-java-go-kotlin-rust",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nVery similar to [1544. Make The String Great](https://leetcode.com/problems/make-the-string-great/).\\n\\n<iframe src=\"https://leetcode.com/playground/3DAthf6c/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Go",
                    "Kotlin",
                    "Rust",
                    "String",
                    "Stack"
                ],
                "code": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\n---\\n\\nVery similar to [1544. Make The String Great](https://leetcode.com/problems/make-the-string-great/).\\n\\n<iframe src=\"https://leetcode.com/playground/3DAthf6c/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 389304,
                "title": "javascript-easy-to-understand-3-solutions",
                "content": "## Solution 1\\n\\nSince we need to check and remove the previous char by the current char, so it let us think about the stack:\\n1. traverse the string `s`\\n2. for every char, we compare it with the top value in stack\\n\\t- if they are same, pop the top value\\n\\t- otherwise, push the current char into stack\\n3. finally, return the stack as a string\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);\\n  }\\n  return stack.join(\\'\\');\\n};\\n```\\n\\n## Solution 2\\n\\nFor this solution, we use 2 pointers. One for traversal and one for store result:\\n1. the traversal pointer just traverse the string `s`\\n2. the store pointer try to save char into the arr itself just as the `stack` in solution 1\\n3. we compare every new char with the store pointer value and maintain the value of store pointer\\n\\nIn fact, this is just a variant of solution 1.\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const arr = s.split(\\'\\');\\n  let ans = 0;\\n  for (let i = 0; i < arr.length; ++i) {\\n    ans === 0 || arr[i] !== arr[ans - 1] ? (arr[ans++] = arr[i]) : --ans;\\n  }\\n  return arr.slice(0, ans).join(\\'\\');\\n};\\n```\\n\\n## Solution 3\\n\\nFor this solution, we try to deal with all the adjacent duplicates right now, and loop again until there are no more adjacent duplicates.\\nWe also use the RegExp to make the code easy.\\n\\nHere\\'s a sample code from me:\\n\\n```js\\nconst removeDuplicates = s => {\\n  const s2 = s.replace(/(.)\\\\1/g, \\'\\');\\n  return s2.length === s.length ? s : removeDuplicates(s2);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst removeDuplicates = s => {\\n  const stack = [];\\n  for (const char of s) {\\n    stack[stack.length - 1] === char ? stack.pop() : stack.push(char);\\n  }\\n  return stack.join(\\'\\');\\n};\\n```\n```js\\nconst removeDuplicates = s => {\\n  const arr = s.split(\\'\\');\\n  let ans = 0;\\n  for (let i = 0; i < arr.length; ++i) {\\n    ans === 0 || arr[i] !== arr[ans - 1] ? (arr[ans++] = arr[i]) : --ans;\\n  }\\n  return arr.slice(0, ans).join(\\'\\');\\n};\\n```\n```js\\nconst removeDuplicates = s => {\\n  const s2 = s.replace(/(.)\\\\1/g, \\'\\');\\n  return s2.length === s.length ? s : removeDuplicates(s2);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302217,
                "title": "remove-all-adjacent-duplicates-in-string-simple-solutions-w-explanation",
                "content": "***Solution 1:(Recursion-TLE)***\\n```\\nBrute force way is to simply remove the characters from string whenever you find any adjacent duplicates,\\nand then again restart from start.\\n\\n```\\n\\n```\\nclass Solution {\\npublic:\\n    string ans;\\n    void go(string str,int idx=0)\\n    {\\n        if(idx>=str.length())\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(str[idx]==str[idx+1])\\n        {\\n            if(idx==0)\\n                go(str.substr(idx+2),0);\\n            else\\n                go(str.substr(0,idx)+str.substr(idx+2),0);\\n        }\\n        else\\n        go(str,idx+1);\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        ans=\"\";\\n        go(s);\\n        return ans;\\n    }\\n};\\n```\\n\\n***Solution 2:(Using Stack- Accepted)***\\n```\\n# Optimised Approach:\\n\\n1) We will be using stack for it.\\n\\n2) We will traverse the characters in the string one by one and compare with stack top,\\nif at any time stack.top()==currentCharacter then we pop the element from stack.\\n\\n3) And at last we will form the answer string using the stack elements.\\n\\nLet us simulate the process with the help of an eg:\\nstring : abbaca\\nstack: empty\\n\\nfirst iteration: \\'a\\'\\nstack is empty so we will push \\'a\\' to the stack,\\nstack: |a|\\n\\nsecond iteration: \\'b\\'\\nstack.top() is not equal to \\'b\\',\\nso we will push \\'b\\' to the stack.\\nstack: |b|a|\\n\\nthird iteration: \\'b\\'\\nstack.top() is equal to \\'b\\',\\nso we will pop the element from stack.\\nstack: |a|\\n\\nfourth iteration: \\'a\\'\\nstack.top() is equal to \\'a\\',\\nso we will pop element from the stack.\\nstack: empty\\n\\nFifth iteration: \\'c\\'\\nstack is empty\\nso we will push the element into the stack.\\nstack: |c|\\n\\nSixth iteration: \\'a\\'\\nstack.top() is not equal to \\'a\\',\\nso we will push \\'a\\' to the stack.\\nstack: |a|c|\\n\\nNow, we will pop all the elements from the stack and store them into the answer string,\\nans = \"ac\"\\nas the elements are in reverse order and hence we need to reverse the ans,\\nreverse(ans)\\nans=\"ca\" (FINAL RESULT)\\n```\\n\\n**Time Complexity: O(N)**\\n**Space Complexity: O(N)**\\n**N: length of string**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        stack<char> s;\\n        for(auto i:str)\\n        {\\n            if(s.empty())\\n                s.push(i);\\n            else\\n            {\\n                if(s.top()==i)\\n                {\\n                    s.pop();\\n                }\\n                else\\n                    s.push(i);\\n            }\\n        }\\n        string ans;\\n        while(!s.empty())\\n            ans+=s.top(),s.pop();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n***Solution 3:(Using String as Stack - Accepted)***\\n```\\nIt is just the simple modification of above code,\\ninstead of using stack we can directly use the resultant string for performing pop and push operations.\\n```\\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        string ans;\\n        for(auto i:str)\\n        {\\n            if(!ans.empty() and ans.back()==i)\\n                ans.pop_back();\\n            else\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***If you found the post useful, then please do consider it for Upvotes\\uD83D\\uDE00\\uD83D\\uDE00***\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nBrute force way is to simply remove the characters from string whenever you find any adjacent duplicates,\\nand then again restart from start.\\n\\n```\n```\\nclass Solution {\\npublic:\\n    string ans;\\n    void go(string str,int idx=0)\\n    {\\n        if(idx>=str.length())\\n        {\\n            ans=str;\\n            return;\\n        }\\n        if(str[idx]==str[idx+1])\\n        {\\n            if(idx==0)\\n                go(str.substr(idx+2),0);\\n            else\\n                go(str.substr(0,idx)+str.substr(idx+2),0);\\n        }\\n        else\\n        go(str,idx+1);\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        ans=\"\";\\n        go(s);\\n        return ans;\\n    }\\n};\\n```\n```\\n# Optimised Approach:\\n\\n1) We will be using stack for it.\\n\\n2) We will traverse the characters in the string one by one and compare with stack top,\\nif at any time stack.top()==currentCharacter then we pop the element from stack.\\n\\n3) And at last we will form the answer string using the stack elements.\\n\\nLet us simulate the process with the help of an eg:\\nstring : abbaca\\nstack: empty\\n\\nfirst iteration: \\'a\\'\\nstack is empty so we will push \\'a\\' to the stack,\\nstack: |a|\\n\\nsecond iteration: \\'b\\'\\nstack.top() is not equal to \\'b\\',\\nso we will push \\'b\\' to the stack.\\nstack: |b|a|\\n\\nthird iteration: \\'b\\'\\nstack.top() is equal to \\'b\\',\\nso we will pop the element from stack.\\nstack: |a|\\n\\nfourth iteration: \\'a\\'\\nstack.top() is equal to \\'a\\',\\nso we will pop element from the stack.\\nstack: empty\\n\\nFifth iteration: \\'c\\'\\nstack is empty\\nso we will push the element into the stack.\\nstack: |c|\\n\\nSixth iteration: \\'a\\'\\nstack.top() is not equal to \\'a\\',\\nso we will push \\'a\\' to the stack.\\nstack: |a|c|\\n\\nNow, we will pop all the elements from the stack and store them into the answer string,\\nans = \"ac\"\\nas the elements are in reverse order and hence we need to reverse the ans,\\nreverse(ans)\\nans=\"ca\" (FINAL RESULT)\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        stack<char> s;\\n        for(auto i:str)\\n        {\\n            if(s.empty())\\n                s.push(i);\\n            else\\n            {\\n                if(s.top()==i)\\n                {\\n                    s.pop();\\n                }\\n                else\\n                    s.push(i);\\n            }\\n        }\\n        string ans;\\n        while(!s.empty())\\n            ans+=s.top(),s.pop();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nIt is just the simple modification of above code,\\ninstead of using stack we can directly use the resultant string for performing pop and push operations.\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    string removeDuplicates(string str) \\n    {\\n        string ans;\\n        for(auto i:str)\\n        {\\n            if(!ans.empty() and ans.back()==i)\\n                ans.pop_back();\\n            else\\n                ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161308,
                "title": "no-stack-solution-only-string-stringbuilder-c-java",
                "content": "**C++**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string ans = \"\";\\n        for (char ch: S) {\\n            if ( ans.size() != 0 and ans.back() == ch )\\n                ans.pop_back();\\n            else\\n                ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Java**\\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch: S.toCharArray()) {\\n            if ( sb.length() != 0 && sb.charAt(sb.length() - 1) == ch ) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        string ans = \"\";\\n        for (char ch: S) {\\n            if ( ans.size() != 0 and ans.back() == ch )\\n                ans.pop_back();\\n            else\\n                ans.push_back(ch);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char ch: S.toCharArray()) {\\n            if ( sb.length() != 0 && sb.charAt(sb.length() - 1) == ch ) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295517,
                "title": "python-100-stack",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for char in S:\\n            if stack and stack[-1] == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        for char in S:\\n            if stack and stack[-1] == char:\\n                stack.pop()\\n            else:\\n                stack.append(char)\\n        \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3655668,
                "title": "simple-c-approach-using-basic-strings-no-stack-with-detailed-explanation",
                "content": "\\n# Approach\\n- Create a empty string temp\\n- make a pointer i=0\\n- iterate till (i<length of string )\\n- if either the string is empty or the char is not equal to the last char at temp\\npush the current character.\\n- else\\n    pop the last character of the temp string.\\n    i++\\nreturn temp.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string temp = \"\";\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            if (temp.empty() || s[i] != temp.back()) {\\n                temp.push_back(s[i]);\\n            } else {\\n                temp.pop_back();\\n            }\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```\\n# Please upvote if you liked my approach",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string temp = \"\";\\n        int i = 0;\\n        \\n        while (i < s.length()) {\\n            if (temp.empty() || s[i] != temp.back()) {\\n                temp.push_back(s[i]);\\n            } else {\\n                temp.pop_back();\\n            }\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302789,
                "title": "c-5-line-in-place-solution-o-n-time-o-1-space",
                "content": "We use the given string as a stack.\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string& s) {\\n        int i = 0;\\n        for(int j = 1; j < s.size(); ++j)\\n            if (i < 0 || s[i] != s[j]) s[++i] = s[j];\\n            else --i;\\n        return s.substr(0, i + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string& s) {\\n        int i = 0;\\n        for(int j = 1; j < s.size(); ++j)\\n            if (i < 0 || s[i] != s[j]) s[++i] = s[j];\\n            else --i;\\n        return s.substr(0, i + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294930,
                "title": "c-recursive",
                "content": "```\\nstring removeDuplicates(string S) {\\n  for (auto i = 1; i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n\\t  return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1));\\n  return S;\\n}\\n```\\nA small optimization to continue from the \"cutting\" point:\\n```cpp\\nstring removeDuplicates(string S, int i = 1) {\\n  for (i = max(1, i); i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n        return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1), i - 1);\\n  return S;\\n}\\n```\\n**Complexity Analysis**\\nRuntime & Memory: O(n ^ 2). We are copying the string up to n times. With a two-pointer solution, we can achieve O(n) | O(1) complexity. This solution is slow but perhaps simpler to implement.",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicates(string S) {\\n  for (auto i = 1; i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n\\t  return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1));\\n  return S;\\n}\\n```\n```cpp\\nstring removeDuplicates(string S, int i = 1) {\\n  for (i = max(1, i); i < S.size(); ++i)\\n    if (S[i - 1] == S[i]) \\n        return removeDuplicates(S.substr(0, i - 1) + S.substr(i + 1), i - 1);\\n  return S;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798868,
                "title": "java-easy-solution-using-stack-faster-than-60",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length() ;i++){\\n            if(!st.isEmpty()){\\n                if(st.peek() == s.charAt(i)){\\n                    st.pop();\\n                }else{\\n                    st.push(s.charAt(i));\\n                }\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder ns = new StringBuilder(\"\");\\n        while(!st.isEmpty()){\\n            ns.append(st.pop());\\n        }\\n        return ns.reverse().toString();\\n    }\\n}\\n```\\n\\n**upvote please",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length() ;i++){\\n            if(!st.isEmpty()){\\n                if(st.peek() == s.charAt(i)){\\n                    st.pop();\\n                }else{\\n                    st.push(s.charAt(i));\\n                }\\n            }else{\\n                st.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder ns = new StringBuilder(\"\");\\n        while(!st.isEmpty()){\\n            ns.append(st.pop());\\n        }\\n        return ns.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1490674,
                "title": "java-tc-o-n-sc-o-n-clean-concise-solution-using-stringbuilder-as-stack",
                "content": "```\\n/**\\n * Using StringBuilder as Stack.\\n *\\n * Time Complexity: O(N + N) = O(N) -> N for Iterating over the string. N for\\n * sb.toString()\\n *\\n * Space Complexity: O(N) -> Space used by the StringBuilder\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) {\\n            // Ask Interviewer about this base case. You can also return null here.\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < len; i++) {\\n            char curChar = s.charAt(i);\\n            int sbLen = sb.length();\\n\\n            if (sbLen > 0 && sb.charAt(sbLen - 1) == curChar) {\\n                // If last character in StringBuilder is same as the current character, then\\n                // remove the last character from StringBuilder\\n                sb.setLength(sbLen - 1);\\n            } else {\\n                sb.append(curChar);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```\\n\\nSolution to Part II: [1209. Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/1490956/Java-or-TC:-O(N)-or-SC:-O(N)-or-Clean-and-Concise-solution-using-StringBuilder-and-Stack)",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\n/**\\n * Using StringBuilder as Stack.\\n *\\n * Time Complexity: O(N + N) = O(N) -> N for Iterating over the string. N for\\n * sb.toString()\\n *\\n * Space Complexity: O(N) -> Space used by the StringBuilder\\n *\\n * N = Length of input string.\\n */\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) {\\n            // Ask Interviewer about this base case. You can also return null here.\\n            throw new IllegalArgumentException(\"Input string is null\");\\n        }\\n\\n        int len = s.length();\\n        if (len <= 1) {\\n            return s;\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < len; i++) {\\n            char curChar = s.charAt(i);\\n            int sbLen = sb.length();\\n\\n            if (sbLen > 0 && sb.charAt(sbLen - 1) == curChar) {\\n                // If last character in StringBuilder is same as the current character, then\\n                // remove the last character from StringBuilder\\n                sb.setLength(sbLen - 1);\\n            } else {\\n                sb.append(curChar);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294908,
                "title": "simple-solution-using-stack-c",
                "content": "Iterate through the input string.(curr is the current character)\\n\\nIf the stack is empty push curr into the stack.\\nelse if the stack top is same as curr, pop the stack once.\\nelse push curr into the stack.\\n\\nFinally the elements in the stack is the answer in reverse order.\\n\\nTry understanding with input :cabba\\n\\ncurr=c: stack=[c\\ncurr=a: stack=[ca\\ncurr=b: stack=[cab\\ncurr=b: stack=[ca\\ncurr=a: stack=[c\\n\\nans:c\\n\\n```\\nstring removeDuplicates(string a) {\\n\\tstack<char> st;\\n\\tstring ans=\"\";\\n\\tfor(auto curr:a) {\\n\\t\\tif(st.empty()) st.push(curr);\\n\\t\\telse if(st.top() == curr) st.pop();\\n\\t\\telse st.push(curr);\\n\\t}\\n\\n\\twhile(!st.empty()) {\\n\\t\\tans += st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(ans.begin(), ans.end());\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nstring removeDuplicates(string a) {\\n\\tstack<char> st;\\n\\tstring ans=\"\";\\n\\tfor(auto curr:a) {\\n\\t\\tif(st.empty()) st.push(curr);\\n\\t\\telse if(st.top() == curr) st.pop();\\n\\t\\telse st.push(curr);\\n\\t}\\n\\n\\twhile(!st.empty()) {\\n\\t\\tans += st.top();\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(ans.begin(), ans.end());\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798026,
                "title": "c-easy-detailed-explanation",
                "content": "**\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705**\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            if(ans.size() && ans.back() == s[i])\\n                ans.pop_back();\\n            else\\n                ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**TC : 0(n)**           **SC : O(n)**\\n\\n**Explanation :**\\n\\n\\t\\t\\t\\t\\t\\ts = \"abbaca\"\\n\\t\\t\\t\\t\\t\\t\\n1. \\t\\t\\t\\t\\t\\tans = a              s[i+1] = b\\n1. \\t\\t\\t\\t\\t\\tans = ab             s[i+1] = b\\n1. \\t\\t\\t\\t\\t\\tans = a              s[i+1] = a\\n1. \\t\\t\\t\\t\\t\\tans = c              s[i+1] = a\\n1. \\t\\t\\t\\t\\t\\tans = ca      \\n\\t\\t\\t\\t\\t\\t \\n \\t\\t\\t\\t\\t\\tFinally ans = \"ca\"        \\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        string ans;\\n        \\n        for(int i = 0 ; i < s.size() ; i++)\\n        {\\n            if(ans.size() && ans.back() == s[i])\\n                ans.pop_back();\\n            else\\n                ans.push_back(s[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263474,
                "title": "c-2-solutions-easy-to-understand",
                "content": "* **Solution using stack.**\\n(Scroll down for more optimized solution.)\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        stack<char>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == st.top())\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        while(st.size() != 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n* **More optimized solution (faster than 96.15%)**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        string ans;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i] == ans.back())\\n            {\\n                ans.pop_back();\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        stack<char>st;\\n        string ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.size() == 0)\\n            {\\n                st.push(s[i]);\\n            }\\n            else if(s[i] == st.top())\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        while(st.size() != 0)\\n        {\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) \\n    {\\n        string ans;\\n        ans.push_back(s[0]);\\n        for(int i=1;i<s.size();i++)\\n        {\\n            if(s[i] == ans.back())\\n            {\\n                ans.pop_back();\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 545434,
                "title": "java-easy-solution-fast-and-memory-efficient",
                "content": "```\\nchar[] ch = new char[S.length()];\\n        int i = 0;\\n        \\n        for(int j = 0; j < S.length(); j++){\\n            if(i > 0 && ch[i - 1] == S.charAt(j)){\\n                i--;\\n            }\\n            else{\\n                ch[i] = S.charAt(j);\\n                i++;\\n            }\\n        }\\n        return new String(ch, 0, i);",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nchar[] ch = new char[S.length()];\\n        int i = 0;\\n        \\n        for(int j = 0; j < S.length(); j++){\\n            if(i > 0 && ch[i - 1] == S.charAt(j)){\\n                i--;\\n            }\\n            else{\\n                ch[i] = S.charAt(j);\\n                i++;\\n            }\\n        }\\n        return new String(ch, 0, i);",
                "codeTag": "Unknown"
            },
            {
                "id": 428241,
                "title": "easy-java-stack-solution-w-comments",
                "content": "```java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        //create stack\\n        Stack<Character> stack = new Stack();\\n        \\n        //iterate thru string\\n        for (char c : S.toCharArray()) {\\n            //check if top of stack is equal to this character\\n            if (!stack.isEmpty() && stack.peek() == c) {\\n                //remove\\n                stack.pop();\\n            } else {\\n               //add to stack\\n                stack.push(c);\\n            }\\n        }\\n        \\n        //string builder for result\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //empty stack out (everything left is not an adjacent duplicate)\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        //result\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        //create stack\\n        Stack<Character> stack = new Stack();\\n        \\n        //iterate thru string\\n        for (char c : S.toCharArray()) {\\n            //check if top of stack is equal to this character\\n            if (!stack.isEmpty() && stack.peek() == c) {\\n                //remove\\n                stack.pop();\\n            } else {\\n               //add to stack\\n                stack.push(c);\\n            }\\n        }\\n        \\n        //string builder for result\\n        StringBuilder sb = new StringBuilder();\\n        \\n        //empty stack out (everything left is not an adjacent duplicate)\\n        while (!stack.isEmpty()) sb.append(stack.pop());\\n        \\n        //result\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295116,
                "title": "java-solution-using-stack",
                "content": "* If the top of the stack has the same character as the current character of String at position i, keep popping from the stack.\\n* Otherwise, push the element onto the stack.\\n* If the stack is not empty, pop all elements and store them in a StringBuilder, reverse it and return the result.\\n```\\npublic String removeDuplicates(String S) {\\n        if(S == null || S.length() == 0)\\n            return new String();\\n        Stack<Character> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            if(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                while(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                    stack.pop();\\n            else\\n                stack.push(S.charAt(i));\\n        }\\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String removeDuplicates(String S) {\\n        if(S == null || S.length() == 0)\\n            return new String();\\n        Stack<Character> stack = new Stack();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < S.length(); i++) {\\n            if(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                while(!stack.isEmpty() && stack.peek() == S.charAt(i))\\n                    stack.pop();\\n            else\\n                stack.push(S.charAt(i));\\n        }\\n        while(!stack.isEmpty())\\n            sb.append(stack.pop());\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799041,
                "title": "python-c-java-rust-make-the-stack-great-again-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs a stack to keep track of equal adjacent letters. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n\\n**Comment.** To remove adjacent duplicates, we iteratively compare each letter with the last letter on the stack. This problem is almost identical to the November 8th\\'s daily challenge [**1544. Make The String Great**](https://leetcode.com/problems/make-the-string-great/) (check my [**solution**](https://leetcode.com/problems/make-the-string-great/discuss/2790965/PythonC%2B%2BJavaRust-Make-The-String-Great-Again-(explained))).\\n\\n**Python.**\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ss = []\\n        for c in s:\\n            if ss and ss[-1] == c : ss.pop()\\n            else                  : ss.append(c)\\n        return \"\".join(ss)\\n```\\n\\nThis solution in other languages.\\n\\n<iframe src=\"https://leetcode.com/playground/dekDhVK9/shared\" frameBorder=\"0\" width=\"800\" height=\"320\"></iframe>",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ss = []\\n        for c in s:\\n            if ss and ss[-1] == c : ss.pop()\\n            else                  : ss.append(c)\\n        return \"\".join(ss)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291694,
                "title": "easy-python-solution-89-05",
                "content": "Runtime: 64 ms, faster than 89.05% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 14.9 MB, less than 21.60% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack=[s[0]]\\n        for i in range(1,len(s)):\\n            if(stack and stack[-1]==s[i]):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 64 ms, faster than 89.05% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 14.9 MB, less than 21.60% of Python3 online submissions for Remove All Adjacent Duplicates In String.\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack=[s[0]]\\n        for i in range(1,len(s)):\\n            if(stack and stack[-1]==s[i]):\\n                stack.pop()\\n            else:\\n                stack.append(s[i])\\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1672744,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack = []\\n        for ch in s:\\n            if stack and ch == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        stack = []\\n        for ch in s:\\n            if stack and ch == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 294942,
                "title": "javascript-stack-solution-60ms",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    let res = [];\\n    for(let i=0; i<S.length; i++){\\n        if(S[i] !== res[res.length-1]) {\\n            res.push(S[i]);\\n        } else {\\n            res.pop();\\n        }\\n    }\\n    return res.join(\"\");\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    let res = [];\\n    for(let i=0; i<S.length; i++){\\n        if(S[i] !== res[res.length-1]) {\\n            res.push(S[i]);\\n        } else {\\n            res.pop();\\n        }\\n    }\\n    return res.join(\"\");\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798202,
                "title": "accepted-detail-explained-stack-approach-tc-o-n",
                "content": "# Approach\\n1. Take a stack \\n2. Take a loop iterate from first to last char from given string\\n    * Check if stack is empty then push current char into stack\\n    * else check if stack top char is equal to current char then pop that form stack else push current char into stack\\n3. At the end return the reverse order of the remaining characters inside the stack.\\n\\n# Complexity\\n- Time complexity: o(N) **Reason:** We are iterating each char from string\\n\\n- Space complexity: o(N) **Reason:** Using stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(st.top()==s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }else{\\n                if(st.top()==s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302281,
                "title": "java-remove-all-adjacent-duplicates-in-string-java-simple-solution-using-stack",
                "content": "\\nclass Solution {\\n\\n\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        stack.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            char c = s.charAt(i);\\n\\t\\t\\t// if stack is empty or the top element of the stack is not current we have then push into the stack\\n            if(stack.isEmpty() || stack.peek() != c){\\n                stack.push(c);\\n            }// otherwise pop from the stack\\n\\t\\t\\telse{\\n                stack.pop();\\n            }\\n        }\\n\\t\\t// pop all the element which is left in the stack and store into the string and return;\\n        String ans=\"\";\\n        while (!stack.isEmpty()){\\n            ans=stack.pop()+ans;\\n        }\\n        return ans;\\n        \\n    }\\n}\\n\\n<<<<<<<<<<<<   Please upvote.. if it is useful :)  >>>>>>>>>>>>>\\n<<<<<<<<<<<<   Happy coding :)   >>>>>>>>>>>>>>>>>>>>>>>",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "class Solution {\\n\\n\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        stack.push(s.charAt(0));\\n        for(int i=1;i<s.length();i++){\\n            char c = s.charAt(i);\\n\\t\\t\\t// if stack is empty or the top element of the stack is not current we have then push into the stack\\n            if(stack.isEmpty() || stack.peek() != c){\\n                stack.push(c);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1302187,
                "title": "python-stack-solution-explained",
                "content": "It is given in the statement of the problem that no matter in which order we remove adjacent duplicates in our string, result will always be the same. It is not obvious for my why (that is why problem marked as easy, because we can use it), so we we choose the most convinient way for us. Let us go from left to right and try to add element by element. If we see that we have repetition when we add new element, it means that we have adjacent duplicate and we pop element. In the opposite case we add element to stack. In the end we just return what we have in our stack.\\n\\n#### Complexity\\nTime and space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        stack = []\\n        for symb in s:\\n            if stack and stack[-1] == symb:\\n                stack.pop()\\n            else:\\n                stack.append(symb)\\n        return \"\".join(stack)\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```python\\nclass Solution:\\n    def removeDuplicates(self, s):\\n        stack = []\\n        for symb in s:\\n            if stack and stack[-1] == symb:\\n                stack.pop()\\n            else:\\n                stack.append(symb)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 375290,
                "title": "c-solution-without-stack",
                "content": "Runtime: 20 ms, faster than 86.17% of C++ online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Remove All Adjacent Duplicates In String.\\n\\n```\\nstring removeDuplicates(string S) {\\n        \\n        string res;\\n        \\n        for(char ch : S)\\n        {\\n            if(!res.empty() && res[res.size() - 1] == ch) res.pop_back();\\n            else res += ch;\\n        }\\n        \\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 20 ms, faster than 86.17% of C++ online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 12.3 MB, less than 100.00% of C++ online submissions for Remove All Adjacent Duplicates In String.\\n\\n```\\nstring removeDuplicates(string S) {\\n        \\n        string res;\\n        \\n        for(char ch : S)\\n        {\\n            if(!res.empty() && res[res.size() - 1] == ch) res.pop_back();\\n            else res += ch;\\n        }\\n        \\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2799023,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(!st.empty() && st.top() == s[i]) st.pop();\\n            else st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        int n = s.size();\\n        for(int i=0; i<n; i++){\\n            if(!st.empty() && st.top() == s[i]) st.pop();\\n            else st.push(s[i]);\\n        }\\n        string ans = \"\";\\n        while(!st.empty()){\\n            ans += st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798255,
                "title": "fastest-solution-possibles-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstack\\n# Complexity\\n- Time complexity:n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563402,
                "title": "python-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef removeDuplicates(self, s: str) -> str:\\n\\ti = 0\\n\\n\\twhile i < len(s) - 1:\\n\\t\\tif i >= 0 and s[i] == s[i + 1]:\\n\\t\\t\\ts = s[:i] + s[i + 2:]\\n\\t\\t\\ti -= 1\\n\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\treturn s\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\ti = 0\\n\\n\\twhile i < len(s) - 1:\\n\\t\\tif i >= 0 and s[i] == s[i + 1]:\\n\\t\\t\\ts = s[:i] + s[i + 2:]\\n\\t\\t\\ti -= 1\\n\\n\\t\\telse:\\n\\t\\t\\ti += 1\\n\\n\\treturn s\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984619,
                "title": "c-solution-o-n-time-o-1-space-complexity-100-faster",
                "content": "###   T = O(n) & S = O(n)    \\n ```\\n\\n\\n  stack<char> st;\\n\\tfor(int i = 0; i < S.size(); i++) {\\n\\t\\tif(st.empty() || S[i] != st.top()) {\\n\\t\\t\\tst.push(S[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\tstring Ans = \"\";\\n\\twhile(!st.empty()) {\\n\\t\\tAns.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(Ans.begin(), Ans.end());\\n\\treturn Ans;\\n```\\n\\n        \\n        \\n###  T = O(n) & S = O(1)\\n\\n\\t\\t\\n```\\nint stptr = -1;\\n for(int i = 0; i < S.size(); i++) {\\n\\tif(stptr == -1 || S[i] != S[stptr]) {\\n\\t\\tstptr++;\\n\\t\\tS[stptr] = S[i];\\n\\t}\\n\\telse {\\n\\t\\tstptr--;\\n\\t}\\n}\\nS.erase(stptr+1,S.size());\\n        return S;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\n  stack<char> st;\\n\\tfor(int i = 0; i < S.size(); i++) {\\n\\t\\tif(st.empty() || S[i] != st.top()) {\\n\\t\\t\\tst.push(S[i]);\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tst.pop();\\n\\t\\t}\\n\\t}\\n\\tstring Ans = \"\";\\n\\twhile(!st.empty()) {\\n\\t\\tAns.push_back(st.top());\\n\\t\\tst.pop();\\n\\t}\\n\\n\\treverse(Ans.begin(), Ans.end());\\n\\treturn Ans;\\n```\n```\\nint stptr = -1;\\n for(int i = 0; i < S.size(); i++) {\\n\\tif(stptr == -1 || S[i] != S[stptr]) {\\n\\t\\tstptr++;\\n\\t\\tS[stptr] = S[i];\\n\\t}\\n\\telse {\\n\\t\\tstptr--;\\n\\t}\\n}\\nS.erase(stptr+1,S.size());\\n        return S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783707,
                "title": "python-super-simple-solution-w-explanation",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        new_list = []\\n        \\n        for letter in S:\\n            new_list.append(letter)\\n            # if letter inserted is same as previous letter in list - remove both\\n            if len(new_list) > 1 and new_list[-1] == new_list[-2]: \\n                new_list.pop()\\n                new_list.pop()\\n                \\n        return \"\".join(new_list)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        new_list = []\\n        \\n        for letter in S:\\n            new_list.append(letter)\\n            # if letter inserted is same as previous letter in list - remove both\\n            if len(new_list) > 1 and new_list[-1] == new_list[-2]: \\n                new_list.pop()\\n                new_list.pop()\\n                \\n        return \"\".join(new_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799147,
                "title": "short-and-clear-solution-using-stack",
                "content": "```csharp\\npublic class Solution\\n{\\n    public string RemoveDuplicates(string s)\\n    {\\n        Stack<char> st = new();\\n\\n        foreach (char c in s)\\n        {\\n            if (st.TryPeek(out char d) && d == c)\\n            {\\n                st.Pop();\\n                continue;\\n            }\\n\\n            st.Push(c);\\n        }\\n\\n        return string.Concat(st.Reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Stack"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string RemoveDuplicates(string s)\\n    {\\n        Stack<char> st = new();\\n\\n        foreach (char c in s)\\n        {\\n            if (st.TryPeek(out char d) && d == c)\\n            {\\n                st.Pop();\\n                continue;\\n            }\\n\\n            st.Push(c);\\n        }\\n\\n        return string.Concat(st.Reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798875,
                "title": "easy-java-solution-using-stack-loop-separate-solution-easy-to-understand",
                "content": "# Using Loop\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n# Using Stack\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      Stack<Character> st=new Stack<>();\\n      for(int i=0;i<s.length();i++){\\n          char c=s.charAt(i);\\n          if(st.isEmpty()){\\n              st.push(c);\\n          }\\n          else if(st.peek()==c){\\n              st.pop();\\n          }\\n          else{\\n              st.push(c);\\n          }\\n      }\\n      String ans=new String(\"\");\\n        while(!st.isEmpty()){\\n            ans=st.pop()+ans;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb=new StringBuilder(s);\\n        int len=sb.length();\\n        for(int i=0;i<sb.length()-1;i++){\\n            char c1=sb.charAt(i);\\n            char c2=sb.charAt(i+1);\\n            if(c1==c2){\\n                sb.delete(i,i+2);\\n                i=i==0?i-1:i-2;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      Stack<Character> st=new Stack<>();\\n      for(int i=0;i<s.length();i++){\\n          char c=s.charAt(i);\\n          if(st.isEmpty()){\\n              st.push(c);\\n          }\\n          else if(st.peek()==c){\\n              st.pop();\\n          }\\n          else{\\n              st.push(c);\\n          }\\n      }\\n      String ans=new String(\"\");\\n        while(!st.isEmpty()){\\n            ans=st.pop()+ans;\\n        }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 788514,
                "title": "with-diagrams-java-implictly-stack-solution-beats-99-7-time-and-97-6-space",
                "content": "For this dedup problem, first let us think about if we don\\'t use computer, just do it by hand. We will scan from left to right to see whether we need to de-duplicates. It required us to look back to previous step and check whether the character we added is the same as current character.\\n\\nThus it is easier to think out to use Stack to handle this case. Thus there will be two ways:\\n* Explicitly maintian a stack: `ArrayDeque<Character>` or `LinkedList<Character>`\\n* Implicitly simulate a stack: Two pointers or StringBuilder\\n\\nHere I will use Two Pointers to simulate a stack to be more efficient:\\n* Slow: represent the last elemetn to be returned, initialize as 0\\n* Fast: traverse the whole char array\\n```Java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        if (S == null || S.length() <= 1) {\\n            return S;\\n        }\\n        char[] chars = S.toCharArray(); // maintain as stack\\n        int slow = 0; // slow is the last element to be returned\\n        // [0, slow] will be the result after removing (inclusive)\\n        \\n        for (int fast = 1; fast < S.length(); fast++) {\\n            if (slow >= 0 && chars[slow] == chars[fast]) { // case 1: stack top has same data\\n                slow--; // stack.pop()\\n            } else { // case 2: stack top is different\\n                chars[++slow] = chars[fast]; // stack.push()\\n            }\\n        }\\n        return new String(chars, 0, slow + 1);\\n    }\\n}\\n```\\nLet\\'s use one example to see what is going on here:\\n```\\ninitially fast = 1, slow = 0\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t  f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\ta b b a c a\\n\\t  s \\u2192\\n\\t    f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t      f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n  s \\u2192\\n\\t        f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc b b a c a\\n    s \\u2192\\n\\t          f \\u2192 \\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc a b a c a\\n      s \\u2192\\n\\t            f \\u2192 \\n---------------------------------------------------\\nDone! \\'ca\\' will be returned.\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```Java\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        if (S == null || S.length() <= 1) {\\n            return S;\\n        }\\n        char[] chars = S.toCharArray(); // maintain as stack\\n        int slow = 0; // slow is the last element to be returned\\n        // [0, slow] will be the result after removing (inclusive)\\n        \\n        for (int fast = 1; fast < S.length(); fast++) {\\n            if (slow >= 0 && chars[slow] == chars[fast]) { // case 1: stack top has same data\\n                slow--; // stack.pop()\\n            } else { // case 2: stack top is different\\n                chars[++slow] = chars[fast]; // stack.push()\\n            }\\n        }\\n        return new String(chars, 0, slow + 1);\\n    }\\n}\\n```\n```\\ninitially fast = 1, slow = 0\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t  f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\ta b b a c a\\n\\t  s \\u2192\\n\\t    f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n\\ts \\u2192\\n\\t      f \\u2192\\n---------------------------------------------------\\nchars[fast] == chars[slow], f++, s-- (same as stack.pop())\\n\\ta b b a c a\\n  s \\u2192\\n\\t        f \\u2192\\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc b b a c a\\n    s \\u2192\\n\\t          f \\u2192 \\n---------------------------------------------------\\nchars[fast] != chars[slow], s++, copy chars[fast] to slow, f++ (same as stack.push())\\n\\tc a b a c a\\n      s \\u2192\\n\\t            f \\u2192 \\n---------------------------------------------------\\nDone! \\'ca\\' will be returned.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798404,
                "title": "c-single-pass-solution-7-lines-code-easy-explained",
                "content": "```\\nstring removeDuplicates(string s) {\\n    string ans = \"\";\\n    for (auto &i: s) {\\n        //if current element of original string matches to last appended element of ans\\n        if (i == ans.back()){\\n            //remove that element from ans\\n            ans.pop_back();\\n        }\\n        else{\\n            //append that element to ans\\n            ans += i;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n    string ans = \"\";\\n    for (auto &i: s) {\\n        //if current element of original string matches to last appended element of ans\\n        if (i == ans.back()){\\n            //remove that element from ans\\n            ans.pop_back();\\n        }\\n        else{\\n            //append that element to ans\\n            ans += i;\\n        }\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798033,
                "title": "python-3-5-lines-stack-w-example-t-m-99-58",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n                                                        #   Ex: azxxzy\\n        stack = []\\n                                                        #   ch    stack      stack.pop()\\n        for ch in s:                                    #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            if stack and stack[-1]==ch: stack.pop()     #    a     [a]          \\n            else: stack.append(ch)                      #    z     [a,z]\\n                                                        #    x     [a,z,x]\\n        return \\'\\'.join(stack)                           #    x     [a,z]          x\\n                                                        #    z     [a]            z\\n                                                        #    y     [a,z]         --> \\'\\'.join([a,z]) = az\\n```\\n[https://leetcode.com/submissions/detail/637459942/](http://)\\n\\nI could be wrong, but I think it\\'s *O*(*n*) / *O*(*n*).",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n                                                        #   Ex: azxxzy\\n        stack = []\\n                                                        #   ch    stack      stack.pop()\\n        for ch in s:                                    #  \\u2013\\u2013\\u2013\\u2013   \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013  \\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\u2013\\n            if stack and stack[-1]==ch: stack.pop()     #    a     [a]          \\n            else: stack.append(ch)                      #    z     [a,z]\\n                                                        #    x     [a,z,x]\\n        return \\'\\'.join(stack)                           #    x     [a,z]          x\\n                                                        #    z     [a]            z\\n                                                        #    y     [a,z]         --> \\'\\'.join([a,z]) = az\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2495279,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Stack***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        \\n        int n = str.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(res.size() > 0 && str[i] == res.back())\\n            {\\n                res.pop_back();\\n            }\\n            else \\n            {\\n                res.push_back(str[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        \\n        int n = str.size();\\n        \\n        string res = \"\";\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(res.size() > 0 && str[i] == res.back())\\n            {\\n                res.pop_back();\\n            }\\n            else \\n            {\\n                res.push_back(str[i]);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2013350,
                "title": "c-solution-o-n-dry-run-included",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size(),i=0;\\n        for(int j=0;j<n;++i,++j){\\n            s[i]=s[j];\\n            if(i>0 and s[i-1]==s[i])\\n                i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n// a b b a c a , i=0,j=0\\n// a b b a c a , i=1,j=1\\n// a b b a c a , i=2,j=2 -> i-=2,j=2\\n// a a b a c a , i=0,j=3\\n// c a b a c a , i=0, j=4\\n// c a b a c a, i=1,j=4\\n// i=2,j=5 -> ans = ca\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size(),i=0;\\n        for(int j=0;j<n;++i,++j){\\n            s[i]=s[j];\\n            if(i>0 and s[i-1]==s[i])\\n                i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n// a b b a c a , i=0,j=0\\n// a b b a c a , i=1,j=1\\n// a b b a c a , i=2,j=2 -> i-=2,j=2\\n// a a b a c a , i=0,j=3\\n// c a b a c a , i=0, j=4\\n// c a b a c a, i=1,j=4\\n// i=2,j=5 -> ans = ca\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682474,
                "title": "using-stack-o-n",
                "content": "logic i used : I looped over the string and push the element in to the stack but if the top of the stack matches the next element to be pushped i poped the top.\\n\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n    stack<char> stack;\\n        string str=\"\";\\n    \\n        for(int i=0;i<s.length();i++){\\n        \\n            if(!stack.empty() && s[i]==stack.top())\\n            {\\n                stack.pop();\\n            }\\n            else\\n            stack.push(s[i]);\\n        }\\n        while(!stack.empty()){\\n            str+=stack.top();\\n            stack.pop();\\n        }\\n        reverse(str.begin(),str.end());\\n return str; }\\n};\\n",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n    stack<char> stack;\\n        string str=\"\";\\n    \\n        for(int i=0;i<s.length();i++){\\n        \\n            if(!stack.empty() && s[i]==stack.top())\\n            {\\n                stack.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 560221,
                "title": "python-96-79-run-time-100-memory",
                "content": "![image](https://assets.leetcode.com/users/jackli2046/image_1585817374.png)\\n```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        if not S:\\n            return S\\n        res = [S[0]]\\n        for curr in S[1:]:            \\n            if res and curr == res[-1]:\\n                res.pop()\\n            else:\\n                res.append(curr)\\n        res = \\'\\'.join(res)                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        if not S:\\n            return S\\n        res = [S[0]]\\n        for curr in S[1:]:            \\n            if res and curr == res[-1]:\\n                res.pop()\\n            else:\\n                res.append(curr)\\n        res = \\'\\'.join(res)                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295287,
                "title": "straightforward-java-solution",
                "content": "```\\nRuntime: 192 ms, faster than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 44 MB, less than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\n```\\n```\\n\\t\\tpublic String removeDuplicates(String S) {\\n            StringBuilder sb = new StringBuilder(S);\\n            for (int i = 0; i < S.length() - 1; i++) {\\n                if (S.charAt(i) == S.charAt(i + 1)) {\\n                    return removeDuplicates(S.substring(0, i) + S.substring(i + 2));\\n                }\\n            }\\n            return sb.toString();\\n        }\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nRuntime: 192 ms, faster than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 44 MB, less than 100.00% of Java online submissions for Remove All Adjacent Duplicates In String.\\n```\n```\\n\\t\\tpublic String removeDuplicates(String S) {\\n            StringBuilder sb = new StringBuilder(S);\\n            for (int i = 0; i < S.length() - 1; i++) {\\n                if (S.charAt(i) == S.charAt(i + 1)) {\\n                    return removeDuplicates(S.substring(0, i) + S.substring(i + 2));\\n                }\\n            }\\n            return sb.toString();\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798407,
                "title": "python-super-fast-solution",
                "content": "\\tdef removeDuplicates(self, s: str) -> str:\\n\\t\\tres=[]\\n        for x in s:\\n            if len(res)>0 and res[-1]==x:\\n                res.pop()\\n            else:\\n                res.append(x)\\n        return \\'\\'.join(res)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tdef removeDuplicates(self, s: str) -> str:\\n\\t\\tres=[]\\n        for x in s:\\n            if len(res)>0 and res[-1]==x:\\n                res.pop()\\n            else:\\n                res.append(x)\\n        return \\'\\'.join(res)\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2798135,
                "title": "most-easy-c-solution-without-stack-beginner-friendly",
                "content": "**Please Upvote if you like the Solution**\\n\\nclass Solution {\\npublic:\\n\\n    string removeDuplicates(string s) {\\n        string ans = \"\";                // String to store the Final result\\n        for(int i=0;i<s.length();i++) {\\n            if(ans.empty()) {           // if \\'ans\\' is empty then just add the current char of string \\'s\\'\\n                ans+=s[i];\\n            } else {                    // else compare the current char of string \\'s\\' with last char of \\'ans\\'\\n                                        // if they are equal then take out  last element from \\'ans\\' else put that current element in the ans\\n                if(s[i] == ans[ans.length()-1]) {\\n                    ans.pop_back();\\n                } else {\\n                    ans+=s[i];\\n                }\\n            }\\n        }\\n        return ans;                     // return the result\\n    }\\n\\t\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string removeDuplicates(string s) {\\n        string ans = \"\";                // String to store the Final result\\n        for(int i=0;i<s.length();i++) {\\n            if(ans.empty()) {           // if \\'ans\\' is empty then just add the current char of string \\'s\\'\\n                ans+=s[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2798121,
                "title": "easy-understanding-daily-leetcode-november-10",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       int i=1;\\n        string k;\\n        k.push_back(s[0]);\\n        while(i<s.length())\\n        {\\n            if(!k.empty()&&s.length())\\n            {\\n                if(k.back()==s[i])\\n                {\\n                    k.pop_back();\\n                }\\n                else\\n                {\\n                    k.push_back(s[i]);\\n                }\\n            }\\n            else\\n                k.push_back(s[i]);\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed.\\n//Happy Coding!!\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       int i=1;\\n        string k;\\n        k.push_back(s[0]);\\n        while(i<s.length())\\n        {\\n            if(!k.empty()&&s.length())\\n            {\\n                if(k.back()==s[i])\\n                {\\n                    k.pop_back();\\n                }\\n                else\\n                {\\n                    k.push_back(s[i]);\\n                }\\n            }\\n            else\\n                k.push_back(s[i]);\\n            i++;\\n        }\\n        return k;\\n    }\\n};\\n//Suggestions and feedbacks are welcomed.\\n//Happy Coding!!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2398983,
                "title": "c-stack-from-brute-force-to-optimized-well-documented",
                "content": "Brute Force time-complexity : O(N(N+M))\\nTypically O(N^2)\\n\\n```    \\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n        int i = 0;\\n        int j = 1;\\n        while(j < s.length()){\\n            if(s[i] == s[j]){\\n                s.erase(s.begin()+i);  // this function takes O(N+M) time\\n                s.erase(s.begin()+i); // N is size of the array & M is the remaining elements to be shifted\\n                i = 0;\\n                j = 1;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n\\t}\\n}\\n```\\n\\nOptimized time-complexity : O(N)\\n```\\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n\\t    string ans =\"\";\\n        stack<char> st;\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){ // initially if the stack is empty (to avoid segmentation fault)\\n                st.push(s[i]);\\n                continue; \\n            }else{\\n                if(st.top() == s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// popping out remaining elements and storing them to the string\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\t\\t\\n\\t\\t// reversing the string because stack reversed the string while popping.\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```\\n\\nIf you read it till here don\\'t forget to like :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack"
                ],
                "code": "```    \\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n        int i = 0;\\n        int j = 1;\\n        while(j < s.length()){\\n            if(s[i] == s[j]){\\n                s.erase(s.begin()+i);  // this function takes O(N+M) time\\n                s.erase(s.begin()+i); // N is size of the array & M is the remaining elements to be shifted\\n                i = 0;\\n                j = 1;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n\\t}\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\tstring removeDuplicates(string s) {\\n\\t    string ans =\"\";\\n        stack<char> st;\\n        for(int i = 0; i < s.length(); i++){\\n            if(st.empty()){ // initially if the stack is empty (to avoid segmentation fault)\\n                st.push(s[i]);\\n                continue; \\n            }else{\\n                if(st.top() == s[i]){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n\\t\\t\\n\\t\\t// popping out remaining elements and storing them to the string\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n\\t\\t\\n\\t\\t// reversing the string because stack reversed the string while popping.\\n        reverse(ans.begin(), ans.end());\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1737378,
                "title": "very-simple-java-solution-using-stack",
                "content": "** PLEASE UPVOTE IF U FIND IT USEFULL**\\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stk = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!stk.isEmpty() && stk.peek()==s.charAt(i))\\n                stk.pop();\\n            else\\n                stk.push(s.charAt(i));\\n        }\\n        \\n        for(Character c : stk)\\n            sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```\\n\\n** PLEASE UPVOTE IF U FIND IT USEFULL**",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        Stack<Character> stk = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            if(!stk.isEmpty() && stk.peek()==s.charAt(i))\\n                stk.pop();\\n            else\\n                stk.push(s.charAt(i));\\n        }\\n        \\n        for(Character c : stk)\\n            sb.append(c);\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1048019,
                "title": "java-no-stack-solution-o-n-single-pass",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n       StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n       for(char ch : S.toCharArray()){\\n           if(sb.length() == 0){\\n               sb.append(ch);\\n              \\n           }\\n           else{\\n               if(sb.charAt(index-1) == ch){\\n                   sb.deleteCharAt(index-1);\\n               }\\n               else{\\n                   sb.append(ch);\\n               }\\n           }\\n            index = sb.length();\\n           }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String S) {\\n       StringBuilder sb = new StringBuilder();\\n        int index = 0;\\n       for(char ch : S.toCharArray()){\\n           if(sb.length() == 0){\\n               sb.append(ch);\\n              \\n           }",
                "codeTag": "Java"
            },
            {
                "id": 581643,
                "title": "swift",
                "content": "```\\n    func removeDuplicates(_ S: String) -> String {\\n        var stack = [Character]()\\n        for char in S {\\n            if let last = stack.last, last == char {\\n                stack.removeLast()\\n            } else {\\n                stack.append(char)\\n            }\\n        }\\n        return String(stack)\\n    }",
                "solutionTags": [],
                "code": "```\\n    func removeDuplicates(_ S: String) -> String {\\n        var stack = [Character]()\\n        for char in S {\\n            if let last = stack.last, last == char {\\n                stack.removeLast()\\n            } else {\\n                stack.append(char)\\n            }\\n        }\\n        return String(stack)\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 496072,
                "title": "c-regex-vs-stack-solution-100-time-100-space",
                "content": "I know it sucks, just wanted to play with regexes in C++ for the sake of getting familiar with them in this language as well :)\\n\\n```cpp\\nclass Solution {\\npublic:\\n    regex r = regex(\"(.)\\\\\\\\1\");\\n    \\n    string removeDuplicates(string s) {\\n        string oldS, newS = s;\\n        while (oldS != newS) {\\n            oldS = newS;\\n            newS = regex_replace(oldS, r, \"\");\\n        }\\n        return newS;\\n    }\\n};\\n```\\n\\n1.5 years later, a nicer one using the result string directly as a stack:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // support variables\\n        string res = \"\";\\n        // parsing s \\n        for (char c: s) {\\n            // case 1: c is not a duplicate\\n            if (!res.size() || res.back() != c) res.push_back(c);\\n            // case 2: c is a duplicate\\n            else res.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    regex r = regex(\"(.)\\\\\\\\1\");\\n    \\n    string removeDuplicates(string s) {\\n        string oldS, newS = s;\\n        while (oldS != newS) {\\n            oldS = newS;\\n            newS = regex_replace(oldS, r, \"\");\\n        }\\n        return newS;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // support variables\\n        string res = \"\";\\n        // parsing s \\n        for (char c: s) {\\n            // case 1: c is not a duplicate\\n            if (!res.size() || res.back() != c) res.push_back(c);\\n            // case 2: c is a duplicate\\n            else res.pop_back();\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3878712,
                "title": "easy-two-pointer-solution",
                "content": "\\n# Approach\\nInitialize two pointers, i and j, both pointing to the first and second characters of the string s, respectively.\\n\\nUse a while loop to iterate through the string while j is within the valid index range (0 to s.length() - 1).\\n\\nCheck if the characters at indices i and j are the same. If they are, it means we have found a duplicate pair.\\n\\nWhen a duplicate pair is found, use the erase function to remove both characters from the string s. Since the erase function modifies the string in place, the characters at indices i and j will be removed.\\n\\nAdjust the pointers i and j to continue searching for adjacent duplicates:\\n\\nMove i one step back (i = max(0, i - 1)) to check if there are any duplicates before the previously deleted pair.\\nMove j one step back (j = max(1, j - 1)) to continue the search from the updated position of i.\\nIf the characters at indices i and j are different, move both pointers i and j one step forward to check the next pair of characters.\\n\\nRepeat steps 3 to 6 until all characters in the string have been checked.\\n\\nReturn the updated string after all adjacent duplicates have been removed.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s)\\n    {\\n        int i = 0;\\n        int j = 1;\\n        while (j < s.length())\\n        {\\n            if (s[i] == s[j])\\n            {\\n                s.erase(i, 2);\\n                i = max(0, i - 1);\\n                j = max(1, j - 1);\\n            } \\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s)\\n    {\\n        int i = 0;\\n        int j = 1;\\n        while (j < s.length())\\n        {\\n            if (s[i] == s[j])\\n            {\\n                s.erase(i, 2);\\n                i = max(0, i - 1);\\n                j = max(1, j - 1);\\n            } \\n            else\\n            {\\n                i++;\\n                j++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800038,
                "title": "easy-explained-solution-c-with-without-stack-stl",
                "content": "## Approach without stack STL [explained in code]\\n\\nThis is a better approach than using stack STL, as the string t used here acts as a stack too.\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create another string t\\n        string t;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in string t we add the current character to t\\n            // but if the last character added to string t is same as the current character from string t\\n            // we have to remove it\\n            if (!t.empty() && t.back()==x) t.pop_back();\\n            else t.push_back(x);\\n        }\\n\\n        // and finally we return the string t\\n        return t;\\n    }\\n};\\n```\\n\\n## Approach using stack STL [explained in code]\\n\\nThis process involves using stack STL and the unnecessary extra steps to put all the characters in stack and then back in string again uses more time.\\n\\nI\\'m putting this up here for the sole sake of your understanding.\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create stack st\\n        stack<char> st;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in stack st we add the current character to st\\n            // but if the last character added to stack st is same as the current character from stack st\\n            // we have to remove it\\n            if (!st.empty() && st.top()==x) st.pop();\\n            else st.push(x);\\n        }\\n\\n        // now we\\'re going to write s from scratch so clean it up\\n        s = \"\";\\n\\n        // while stack isn\\'t empty let\\'s create string s\\n        while (!st.empty()) s=st.top()+s, st.pop();\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create another string t\\n        string t;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in string t we add the current character to t\\n            // but if the last character added to string t is same as the current character from string t\\n            // we have to remove it\\n            if (!t.empty() && t.back()==x) t.pop_back();\\n            else t.push_back(x);\\n        }\\n\\n        // and finally we return the string t\\n        return t;\\n    }\\n};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        // create stack st\\n        stack<char> st;\\n\\n        // let\\'s iterate through the string s\\n        for (char x:s) {\\n            // if the there is nothing in stack st we add the current character to st\\n            // but if the last character added to stack st is same as the current character from stack st\\n            // we have to remove it\\n            if (!st.empty() && st.top()==x) st.pop();\\n            else st.push(x);\\n        }\\n\\n        // now we\\'re going to write s from scratch so clean it up\\n        s = \"\";\\n\\n        // while stack isn\\'t empty let\\'s create string s\\n        while (!st.empty()) s=st.top()+s, st.pop();\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800035,
                "title": "stack-java-easy-solution-easy-to-understand",
                "content": "\\n\\n# Approach\\nWe compare our string character with the stack topmost element if both are same we remove the element from stack and move forward or else we just push that element too into the stack.\\n\\n# Complexity\\n- Time complexity: O(N)\\n- N-> length of string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n-  N-> length of String\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0));\\n        for(int i = 1; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek() == s.charAt(i)){\\n                st.pop(); continue;\\n            }\\n            st.push(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return String.valueOf(sb.reverse());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        st.push(s.charAt(0));\\n        for(int i = 1; i<s.length(); i++){\\n            if(!st.isEmpty() && st.peek() == s.charAt(i)){\\n                st.pop(); continue;\\n            }\\n            st.push(s.charAt(i));\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return String.valueOf(sb.reverse());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741398,
                "title": "java-11-ms-faster-than-92-89",
                "content": "If you like it pls upvote\\n```\\n\\n    public String removeDuplicates(String s) {\\n        StringBuilder stb = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (stb.length() == 0) {\\n                stb.append(s.charAt(i));\\n            } else if (s.charAt(i) == stb.charAt(count)) {\\n                stb.deleteCharAt(count);\\n                if (count!=0) count--;\\n            } else {\\n                stb.append(s.charAt(i));\\n                count++;\\n            }\\n        }\\n        return stb.toString();\\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n    public String removeDuplicates(String s) {\\n        StringBuilder stb = new StringBuilder();\\n        int count = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            if (stb.length() == 0) {\\n                stb.append(s.charAt(i));\\n            } else if (s.charAt(i) == stb.charAt(count)) {\\n                stb.deleteCharAt(count);\\n                if (count!=0) count--;\\n            } else {\\n                stb.append(s.charAt(i));\\n                count++;\\n            }\\n        }\\n        return stb.toString();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1653948,
                "title": "java-explained-with-pictures-two-pointers-solution",
                "content": "```\\n public String removeDuplicates(String s) {\\n        //declare i outside of for loop so we can use it as upper bound for our final result\\n        int i = 0;\\n\\t\\t//conver string to array of characters\\n        char[] res = s.toCharArray();\\n       \\n        for (int j = 0; j < s.length(); ++j, ++i) {\\n\\t\\t    //this line will update array only in case if duplictae is found \\n\\t\\t\\t//otherwise i = to j so nothing will change \\n            res[i] = res[j];\\n\\t\\t\\t//check if previous value euals to current \\n            if (i > 0 && res[i - 1] == res[i]) \\n\\t\\t\\t   //reset i to the position before duplicate \\n                i -= 2;\\n        }\\n       \\n        // string from 0 - to i because rest of the array contains garbage\\n       //we moved all non-duplicate values to the begining of arr\\n        return new String(res, 0, i);\\n    }\\n```\\n\\t\\n\\t\\n![image](https://assets.leetcode.com/users/images/bfc233c8-3654-4cbe-bdb5-7a1dfc854d4a_1640752465.0941455.png)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n public String removeDuplicates(String s) {\\n        //declare i outside of for loop so we can use it as upper bound for our final result\\n        int i = 0;\\n\\t\\t//conver string to array of characters\\n        char[] res = s.toCharArray();\\n       \\n        for (int j = 0; j < s.length(); ++j, ++i) {\\n\\t\\t    //this line will update array only in case if duplictae is found \\n\\t\\t\\t//otherwise i = to j so nothing will change \\n            res[i] = res[j];\\n\\t\\t\\t//check if previous value euals to current \\n            if (i > 0 && res[i - 1] == res[i]) \\n\\t\\t\\t   //reset i to the position before duplicate \\n                i -= 2;\\n        }\\n       \\n        // string from 0 - to i because rest of the array contains garbage\\n       //we moved all non-duplicate values to the begining of arr\\n        return new String(res, 0, i);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562458,
                "title": "best-c-solution-5line-code-faster-than-99-users-time-o-n",
                "content": "Solution is very easy dont need and explanation. If still comment down below.\\n\\nHope you like my solution. If yes Upvote so that others can also get help.\\n\\nThanks for your time.\\n\\n    string removeDuplicates(string s) {\\n        vector<char> out;\\n        int i;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(!out.empty() && out.back()==s[i] )\\n                out.pop_back();\\n            else\\n                out.push_back(s[i]);\\n        }\\n        string ans(out.begin(),out.end());\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Solution is very easy dont need and explanation. If still comment down below.\\n\\nHope you like my solution. If yes Upvote so that others can also get help.\\n\\nThanks for your time.\\n\\n    string removeDuplicates(string s) {\\n        vector<char> out;\\n        int i;\\n        for(i=0;i<s.length();i++)\\n        {\\n            if(!out.empty() && out.back()==s[i] )\\n                out.pop_back();\\n            else\\n                out.push_back(s[i]);\\n        }\\n        string ans(out.begin(),out.end());\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1459061,
                "title": "python-using-stack-easy-to-understand",
                "content": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\tstk = []\\n\\tfor i in s:\\n\\t\\tif(len(stk) == 0):\\n\\t\\t\\tstk.append(i)\\n\\t\\telif(stk[-1] == i):\\n\\t\\t\\tstk.pop()\\n\\t\\telse:\\n\\t\\t\\tstk.append(i)\\n\\n\\treturn \"\".join(stk)\\n```\\n\\nUpvote if liked",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef removeDuplicates(self, s: str) -> str:\\n\\tstk = []\\n\\tfor i in s:\\n\\t\\tif(len(stk) == 0):\\n\\t\\t\\tstk.append(i)\\n\\t\\telif(stk[-1] == i):\\n\\t\\t\\tstk.pop()\\n\\t\\telse:\\n\\t\\t\\tstk.append(i)\\n\\n\\treturn \"\".join(stk)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 977142,
                "title": "java-simple-using-stack-char-array",
                "content": "```\\npublic String removeDuplicates(String S) \\n{\\n\\tStack<Character> stackWithoutDupl = new Stack();\\n\\n\\tfor(char letter : S.toCharArray())\\n\\t{\\n\\t\\tif(stackWithoutDupl.isEmpty() || stackWithoutDupl.peek() != letter)\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.push(letter);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tchar[] result = new char[stackWithoutDupl.size()];\\n\\tfor(int i = result.length -1; i >= 0; i--)\\n\\t{\\n\\t\\tresult[i] = stackWithoutDupl.pop();\\n\\t}\\n\\n\\treturn new String(result);\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String removeDuplicates(String S) \\n{\\n\\tStack<Character> stackWithoutDupl = new Stack();\\n\\n\\tfor(char letter : S.toCharArray())\\n\\t{\\n\\t\\tif(stackWithoutDupl.isEmpty() || stackWithoutDupl.peek() != letter)\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.push(letter);\\n\\t\\t}\\n\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tstackWithoutDupl.pop();\\n\\t\\t}\\n\\t}\\n\\n\\tchar[] result = new char[stackWithoutDupl.size()];\\n\\tfor(int i = result.length -1; i >= 0; i--)\\n\\t{\\n\\t\\tresult[i] = stackWithoutDupl.pop();\\n\\t}\\n\\n\\treturn new String(result);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 905247,
                "title": "two-pointer-solution-clean-code",
                "content": "We can use two-pointer method to solve this problem. We can set a pointer p to point the next index of current substring:\\n**1. If there are no 2 same adjacent characters, then we move p forward along with i;\\n2. else, we move back for 1 step since we need to remove those 2 same adjacent characters!**\\n\\n```\\n    public String removeDuplicates(String S) {\\n        char[] ch = S.toCharArray();\\n        int len = S.length(), p = 0; // p as a pointer, to point the next index of current substring.\\n        for (int i=0; i<len; i++) {\\n            if (p == 0 || ch[i] != ch[p-1]) {\\n                ch[p++] = ch[i];\\n            } else {\\n                p--;\\n            }\\n        }\\n        return String.valueOf(ch).substring(0, p);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        char[] ch = S.toCharArray();\\n        int len = S.length(), p = 0; // p as a pointer, to point the next index of current substring.\\n        for (int i=0; i<len; i++) {\\n            if (p == 0 || ch[i] != ch[p-1]) {\\n                ch[p++] = ch[i];\\n            } else {\\n                p--;\\n            }\\n        }\\n        return String.valueOf(ch).substring(0, p);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 378367,
                "title": "java-double-ended-queue-no-stack-explained-7ms",
                "content": "For this task we can use stack and analyse last seen char with current. But this approach has one tradeoff - added chars are in reverse order so we need to reverse it at the end. To avoid this we can use double ended queue - add chars at the end, but read it from the head for the final string.\\nThis leads to solution below.\\nO(n) time and space - read ever char 2 times when checking for duplicates and then form result string. Also we need O(n) space for the deque.\\n\\n```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deq = new LinkedList();\\n        //iterate over the chars in string\\n        for (char ch : S.toCharArray()) {\\n            //check if the last char we checked is equal to the current one\\n            //if so - don\\'t add current and remove that previosuly added\\n            //else add char to the stack\\n            if (!deq.isEmpty() && deq.peekLast() == ch) {\\n                deq.pollLast();\\n            } else {\\n                deq.addLast(ch);\\n            }\\n        }\\n        //form the result string by polling from the stack in reversed order\\n        char[] strArr = new char[deq.size()];\\n        for (int i = 0; i < strArr.length; i++) {\\n            strArr[i] = deq.pollFirst();\\n        }  \\n        return new String(strArr);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deq = new LinkedList();\\n        //iterate over the chars in string\\n        for (char ch : S.toCharArray()) {\\n            //check if the last char we checked is equal to the current one\\n            //if so - don\\'t add current and remove that previosuly added\\n            //else add char to the stack\\n            if (!deq.isEmpty() && deq.peekLast() == ch) {\\n                deq.pollLast();\\n            } else {\\n                deq.addLast(ch);\\n            }\\n        }\\n        //form the result string by polling from the stack in reversed order\\n        char[] strArr = new char[deq.size()];\\n        for (int i = 0; i < strArr.length; i++) {\\n            strArr[i] = deq.pollFirst();\\n        }  \\n        return new String(strArr);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 336940,
                "title": "python-3-using-regex",
                "content": "It\\'s not the most efficient, but it\\'s pretty simple.\\n\\n```\\nimport re\\n\\nclass Solution:\\n  def removeDuplicates(self, S: str) -> str:\\n    last = None\\n    while last != S:\\n      last, S = S, re.sub(r\\'(.)\\\\1\\', \\'\\', S)\\n    return S\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\n\\nclass Solution:\\n  def removeDuplicates(self, S: str) -> str:\\n    last = None\\n    while last != S:\\n      last, S = S, re.sub(r\\'(.)\\\\1\\', \\'\\', S)\\n    return S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584200,
                "title": "easy-approach-using-stack-beginners-friendly",
                "content": "**T.C =O(N)\\nS.C =O(N) Because of stack**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==st.top()){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/e93c3100-4795-4d44-a542-fc2fb2572896_1685588124.7269132.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char>st;\\n        string ans=\"\";\\n        \\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()){\\n                st.push(s[i]);\\n            }\\n            else if(s[i]==st.top()){\\n                st.pop();\\n            }\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        while(!st.empty()){\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n         reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553532,
                "title": "easy-approach-c",
                "content": "# Don\\'t Feel Demotivating during watching the solution You are the _STAR_ and you can do it very well and you are able to crack every Problem in the future (INSHALLAH)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       string Result=\"\";\\n       Result=s[0];\\n       for( int i=1;i<s.size();i++){\\n         if(s[i]==Result.back()){\\n          Result.pop_back();\\n         }\\n         else {\\n           Result.push_back(s[i]);\\n         }\\n       }\\n       return Result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n       string Result=\"\";\\n       Result=s[0];\\n       for( int i=1;i<s.size();i++){\\n         if(s[i]==Result.back()){\\n          Result.pop_back();\\n         }\\n         else {\\n           Result.push_back(s[i]);\\n         }\\n       }\\n       return Result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307093,
                "title": "easy-c-solution-beat-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n            if(ans.length()>0&&ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n           i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n            if(ans.length()>0&&ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n           i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801475,
                "title": "c-faster-than-90-stack-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs its clearly mentioned the adjacent were to delete and if we delete any middle sequence it might be possible for the case to give another sequesnce consisting of first element so, stack was the best possible data structure I could think about.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst -- pushing the first element inti the stack,\\nsecondly-- checking if the upcomming elemnt is equal to the top of the stack if true pop() the top and move forwrd.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\nP.S : there is no need of the while loop you can ommit it and just pop() the top element. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n        \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n        \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799597,
                "title": "easy-to-understand-c-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Use Of Stack\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<int> p;\\n        p.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!p.empty()){\\n                if(s[i]==p.top()){\\n                    p.pop();\\n                }\\n                else{\\n                    p.push(s[i]);\\n                }\\n            }\\n            else{\\n                p.push(s[i]);\\n            }\\n        }\\n        string r;\\n        while(!p.empty()){\\n            r+=p.top();\\n            p.pop();\\n        }\\n        reverse(r.begin(), r.end());\\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<int> p;\\n        p.push(s[0]);\\n        for(int i=1;i<s.size();i++){\\n            if(!p.empty()){\\n                if(s[i]==p.top()){\\n                    p.pop();\\n                }\\n                else{\\n                    p.push(s[i]);\\n                }\\n            }\\n            else{\\n                p.push(s[i]);\\n            }\\n        }\\n        string r;\\n        while(!p.empty()){\\n            r+=p.top();\\n            p.pop();\\n        }\\n        reverse(r.begin(), r.end());\\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798675,
                "title": "c-three-simple-solutions-with-and-without-stack",
                "content": "# Code 1 : with stack\\n# Complexity\\n- Time complexity: O(N) Traverse each char from string\\n- Space complexity: O(N) Using stack \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n\\n        for(char i: s){\\n            if(st.empty() or i != st.top()) st.push(i);\\n\\n            else\\n                st.pop();\\n        }\\n\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code 2 : without stack\\n# Complexity\\n- Time complexity: O(N) Traverse each char from string\\n- Space complexity: O(1) \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==0 or ans.back() != s[i]) \\n                ans+= s[i];\\n\\n            else if(ans.back()==s[i]) \\n                ans.pop_back();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n# Code 3 : without stack\\n\\n# Complexity\\n- Time complexity: O(N*N) Traverse each char from string\\n             extra O(N) because of erase function.\\n- Space complexity: O(1) \\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int n= s.size();\\n\\n        while(i<n){\\n            if(s[i]==s[i+1]){\\n                s.erase(s.begin()+i); \\n                s.erase(s.begin()+i);\\n\\n                if(i>0) i--;\\n\\n                n= s.size();\\n            }\\n\\n            else i++;\\n        }      \\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n\\n        for(char i: s){\\n            if(st.empty() or i != st.top()) st.push(i);\\n\\n            else\\n                st.pop();\\n        }\\n\\n        while(!st.empty()){\\n            ans+= st.top();\\n            st.pop();\\n        }\\n\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        \\n        for(int i=0; i<s.length(); i++){\\n            if(s[i]==0 or ans.back() != s[i]) \\n                ans+= s[i];\\n\\n            else if(ans.back()==s[i]) \\n                ans.pop_back();\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int n= s.size();\\n\\n        while(i<n){\\n            if(s[i]==s[i+1]){\\n                s.erase(s.begin()+i); \\n                s.erase(s.begin()+i);\\n\\n                if(i>0) i--;\\n\\n                n= s.size();\\n            }\\n\\n            else i++;\\n        }      \\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798396,
                "title": "easy-solution-using-stack",
                "content": "this problem is similar to\\nhttps://leetcode.com/problems/make-the-string-great/solutions/2790887/daily-leetcoding-challenge-november-8-o-n-t-c/\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n//if stack is empty push the element into stack\\n            if(st.empty())\\n                st.push(s[i]);\\n            else \\n//else check top element of stack is same of currunt element or not\\n//if yes pop top elemnt and ignore this element (dont push into stack)\\n                if(st.top()==s[i])\\n                    st.pop();\\n                else\\n//otherwise push into the stack\\n                   st.push(s[i]);\\n        }\\n         while(!st.empty()){\\n             ans+=st.top();\\n             st.pop();\\n         }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.length();\\n        stack<char>st;\\n        string ans=\"\";\\n        for(int i=0;i<n;i++){\\n//if stack is empty push the element into stack\\n            if(st.empty())\\n                st.push(s[i]);\\n            else \\n//else check top element of stack is same of currunt element or not\\n//if yes pop top elemnt and ignore this element (dont push into stack)\\n                if(st.top()==s[i])\\n                    st.pop();\\n                else\\n//otherwise push into the stack\\n                   st.push(s[i]);\\n        }\\n         while(!st.empty()){\\n             ans+=st.top();\\n             st.pop();\\n         }\\n         reverse(ans.begin(),ans.end());\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798201,
                "title": "simple-c-solution-using-stack",
                "content": "```\\nstring removeDuplicates(string s)\\n    {\\n        stack<char>vishwas;\\n       for(int i=0;i<(s.size());i++)\\n       {\\n          int flag=1;\\n           while(!vishwas.empty() && vishwas.top()==s[i])\\n           {\\n              vishwas.pop();\\n               flag=0;\\n           }\\n           if(flag==1)\\n           {\\n               vishwas.push(s[i]);\\n           }\\n   \\n     \\n       }\\n                s=\"\";\\n          while(!vishwas.empty())\\n          {\\n              s+=vishwas.top();\\n              vishwas.pop();\\n          }\\n           reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nstring removeDuplicates(string s)\\n    {\\n        stack<char>vishwas;\\n       for(int i=0;i<(s.size());i++)\\n       {\\n          int flag=1;\\n           while(!vishwas.empty() && vishwas.top()==s[i])\\n           {\\n              vishwas.pop();\\n               flag=0;\\n           }\\n           if(flag==1)\\n           {\\n               vishwas.push(s[i]);\\n           }\\n   \\n     \\n       }\\n                s=\"\";\\n          while(!vishwas.empty())\\n          {\\n              s+=vishwas.top();\\n              vishwas.pop();\\n          }\\n           reverse(s.begin(),s.end());\\n        \\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798115,
                "title": "daily-leetcode-solution-easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(st.empty())\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798005,
                "title": "daily-leetcoding-challenge-november-day-10",
                "content": "This problem is the Daily LeetCoding Challenge for November, Day 10.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Replace\n\n  \n**Approach 2:** Stack\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2594691,
                "title": "easy-and-simple-java-code-using-stack-and-stringbuilder-easy-to-understand",
                "content": "```\\npublic String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\npublic String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2556870,
                "title": "js-with-explanation-easy-to-understand-fast",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/09/1047-remove-all-adjacent-duplicates-in.html\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n   const stack = [];\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tconst cv = s[i];\\n\\t\\tconst top = stack[stack.length - 1];\\n\\n\\t\\t// if last element is same as current pop off from stack\\n\\t\\tif (cv === top) stack.pop();\\n\\t\\telse stack.push(cv); // if not equal, add to stack\\n\\t}\\n\\n\\treturn stack.join(\\'\\');\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Stack"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n   const stack = [];\\n\\tfor (let i = 0; i < s.length; i++) {\\n\\t\\tconst cv = s[i];\\n\\t\\tconst top = stack[stack.length - 1];\\n\\n\\t\\t// if last element is same as current pop off from stack\\n\\t\\tif (cv === top) stack.pop();\\n\\t\\telse stack.push(cv); // if not equal, add to stack\\n\\t}\\n\\n\\treturn stack.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329168,
                "title": "python-solution",
                "content": "* Runtime: 64 ms, faster than 92.95% of Python online submissions for Remove All Adjacent Duplicates In String.\\n* Memory Usage: 14.3 MB, less than 92.19% of Python online submissions for Remove All Adjacent Duplicates In String\\n\\n class Solution(object):\\n    \\n\\tdef removeDuplicates(self, s):\\n        \\n        stack =[]\\n\\n        for char in s:\\n            if stack and char == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(char)           \\n\\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python"
                ],
                "code": "* Runtime: 64 ms, faster than 92.95% of Python online submissions for Remove All Adjacent Duplicates In String.\\n* Memory Usage: 14.3 MB, less than 92.19% of Python online submissions for Remove All Adjacent Duplicates In String\\n\\n class Solution(object):\\n    \\n\\tdef removeDuplicates(self, s):\\n        \\n        stack =[]\\n\\n        for char in s:\\n            if stack and char == stack[-1]:\\n                stack.pop()\\n            else:\\n                stack.append(char)           \\n\\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 2303295,
                "title": "c-faster-than-100-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        ans = ans + s[0];\\n        for (int i=1; i<s.length(); i++) {\\n            if (s[i]==ans.back()) {\\n                ans.pop_back();\\n            }\\n            else {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        ans = ans + s[0];\\n        for (int i=1; i<s.length(); i++) {\\n            if (s[i]==ans.back()) {\\n                ans.pop_back();\\n            }\\n            else {\\n                ans += s[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177959,
                "title": "java-simple-logic-and-less-code",
                "content": "# Please Upvote IF You Find This Helpful\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (!st.empty() && st.peek() == s.charAt(i)) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        while (!st.empty()) ans.append(st.pop());\\n        return ans.reverse().toString();\\n    }\\n}\\n```\\n# Please Upvote IF You Find This Helpful",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (!st.empty() && st.peek() == s.charAt(i)) st.pop();\\n            else st.push(s.charAt(i));\\n        }\\n        StringBuilder ans = new StringBuilder();\\n        while (!st.empty()) ans.append(st.pop());\\n        return ans.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1825701,
                "title": "c-easy-solution-without-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n     for(int i=0;i<s.length();i++)\\n     {\\n         \\n         if(s[i]==s[i+1])\\n         {\\n             s.erase(i,2);\\n             if(i==0)\\n             i=-1;\\n             else\\n             i=i-2;\\n         }\\n         \\n     }\\n        return s;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n     for(int i=0;i<s.length();i++)\\n     {\\n         \\n         if(s[i]==s[i+1])\\n         {\\n             s.erase(i,2);\\n             if(i==0)\\n             i=-1;\\n             else\\n             i=i-2;\\n         }\\n         \\n     }\\n        return s;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1727513,
                "title": "simple-c-solution-one-pass-where-we-use-string-as-a-stack",
                "content": "Using string as a stack prevents the need for reversing which happens if we use a stack.\\nSince the output string is not counted in space complexity, the space complexity for the below code is O(1)\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(ans.length()==0 || ans.back()!=s[i])\\n            {\\n               ans.push_back(s[i]);\\n               continue;\\n            }\\n            while(ans.length() >0 && ans.back() == s[i])\\n            {\\n                ans.pop_back();\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(ans.length()==0 || ans.back()!=s[i])\\n            {\\n               ans.push_back(s[i]);\\n               continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1585958,
                "title": "python-solution-memory-usage-beats-97",
                "content": "In this code we compare the current value with the previous value .\\nFor better understanding remove the \"#\" commented part .\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        first=1\\n        last=len(s)\\n        while(first<last):\\n            if(s[first]==s[first-1]):\\n                s=s.replace(s[first-1:first+1],\"\")\\n                if(first>1):\\n                    first=first-1\\n            else:\\n                first+=1\\n            last=len(s)\\n\\t\\t\\t#print(s,first,last)\\n        return(s)\\n```\\nIf u understood the code then plz...UPVOTE",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        first=1\\n        last=len(s)\\n        while(first<last):\\n            if(s[first]==s[first-1]):\\n                s=s.replace(s[first-1:first+1],\"\")\\n                if(first>1):\\n                    first=first-1\\n            else:\\n                first+=1\\n            last=len(s)\\n\\t\\t\\t#print(s,first,last)\\n        return(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1497407,
                "title": "deque-solution-tc-o-n",
                "content": "```\\nstring removeDuplicates(string s) {\\n        deque<char> q;\\n        string res;\\n        for(int i=0;i<s.length();i++) {\\n            if(!q.empty() && q.back()==s[i])  //when q.back is same as the current char\\n                q.pop_back();\\n            else\\n                q.push_back(s[i]);  //when q is empty or when char at q back !=s[i]\\n        }\\n\\t\\t//Concatenate chars in q from front to back\\n        while(!q.empty()){\\n            res+=q.front();\\n            q.pop_front();\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Queue"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n        deque<char> q;\\n        string res;\\n        for(int i=0;i<s.length();i++) {\\n            if(!q.empty() && q.back()==s[i])  //when q.back is same as the current char\\n                q.pop_back();\\n            else\\n                q.push_back(s[i]);  //when q is empty or when char at q back !=s[i]\\n        }\\n\\t\\t//Concatenate chars in q from front to back\\n        while(!q.empty()){\\n            res+=q.front();\\n            q.pop_front();\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1307206,
                "title": "javascript-stack-oriented-elegant-solution",
                "content": "\\tconst stack = [];\\n\\tfor(let letter of s) {\\n        let stackLastEl = stack[stack.length - 1]; //b\\n        if (letter === stackLastEl) {\\n            stack.pop();\\n            continue;\\n        }\\n\\n        stack.push(letter);\\n    }\\n\\n    return stack.join(\\'\\');",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "\\tconst stack = [];\\n\\tfor(let letter of s) {\\n        let stackLastEl = stack[stack.length - 1]; //b\\n        if (letter === stackLastEl) {\\n            stack.pop();\\n            continue;\\n        }\\n\\n        stack.push(letter);\\n    }\\n\\n    return stack.join(\\'\\');",
                "codeTag": "Unknown"
            },
            {
                "id": 1303191,
                "title": "remove-all-adjacent-duplicates-in-string-python-comments",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        arr = [i for i in s]            # Make an array of chars from the string \\'s\\'\\n        found = True                    # Initialize a var \\'found\\' to \\'True\\'\\n        \\n        while found:                    # Traverse until \\'found\\' is \\'True\\'\\n            \\n            found = False               # Change the value of \\'found\\' to \\'False\\'\\n            i = 0                       # A var to traverse the array \\'arr\\'\\n            \\n            while i < len(arr)-1:       # Traverse till the 2nd last element of \\'arr\\'\\n                \\n                if arr[i] == arr[i+1]:  # If any duplicate adjacent chars are found\\n                    del arr[i]          # Delete the ith char\\n                    del arr[i]          # Delete the i+1 th char\\n                    found = True        # Change the value of \\'found\\' to \\'True\\'\\n                    continue            # Skip the rest of the loop\\n                    \\n                i += 1                  # Else, Increase \\'i\\' to move to the next index\\n        \\n        s = \"\"                          # Take an empty string to create the resultant string\\n        for i in arr:                   # For each remaining char in the array, \\'arr\\'\\n            s += i                      # Append it to the resultant string, \\'s\\'\\n            \\n        return s                        # Finally, return the resultant string, \\'s\\'\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        arr = [i for i in s]            # Make an array of chars from the string \\'s\\'\\n        found = True                    # Initialize a var \\'found\\' to \\'True\\'\\n        \\n        while found:                    # Traverse until \\'found\\' is \\'True\\'\\n            \\n            found = False               # Change the value of \\'found\\' to \\'False\\'\\n            i = 0                       # A var to traverse the array \\'arr\\'\\n            \\n            while i < len(arr)-1:       # Traverse till the 2nd last element of \\'arr\\'\\n                \\n                if arr[i] == arr[i+1]:  # If any duplicate adjacent chars are found\\n                    del arr[i]          # Delete the ith char\\n                    del arr[i]          # Delete the i+1 th char\\n                    found = True        # Change the value of \\'found\\' to \\'True\\'\\n                    continue            # Skip the rest of the loop\\n                    \\n                i += 1                  # Else, Increase \\'i\\' to move to the next index\\n        \\n        s = \"\"                          # Take an empty string to create the resultant string\\n        for i in arr:                   # For each remaining char in the array, \\'arr\\'\\n            s += i                      # Append it to the resultant string, \\'s\\'\\n            \\n        return s                        # Finally, return the resultant string, \\'s\\'\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303019,
                "title": "rust-solution-0ms",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(s: String) -> String {\\n        s.chars()\\n            .fold(Vec::new(), |mut stack, c| {\\n                if stack.last() == Some(&c) {\\n                    stack.pop();\\n                } else {\\n                    stack.push(c);\\n                }\\n                stack\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_duplicates(s: String) -> String {\\n        s.chars()\\n            .fold(Vec::new(), |mut stack, c| {\\n                if stack.last() == Some(&c) {\\n                    stack.pop();\\n                } else {\\n                    stack.push(c);\\n                }\\n                stack\\n            })\\n            .iter()\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302424,
                "title": "remove-all-adjacent-duplicates-in-string-python-simple-solution",
                "content": "```\\n\\nclass Solution(object):\\n    def removeDuplicates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        for i in range(len(s)):\\n            if ans==\"\" or ans[-1] != s[i]:\\n                ans+=s[i]\\n            elif ans[-1] == s[i]:\\n                ans=ans[:-1]        \\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution(object):\\n    def removeDuplicates(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: str\\n        \"\"\"\\n        ans=\"\"\\n        for i in range(len(s)):\\n            if ans==\"\" or ans[-1] != s[i]:\\n                ans+=s[i]\\n            elif ans[-1] == s[i]:\\n                ans=ans[:-1]        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1302331,
                "title": "c-without-stack-with-stack-2-approach-o-n",
                "content": "**Withou Using Stack**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(ans.size())\\n            {\\n                if(ans[ans.size()-1]==s[i])\\n                {\\n                    ans.pop_back();\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Stack Based Approach**\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!st.empty())\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n\\n*If find HelpFul then Upvote* **:)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(ans.size())\\n            {\\n                if(ans[ans.size()-1]==s[i])\\n                {\\n                    ans.pop_back();\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(!st.empty())\\n            {\\n                if(st.top()==s[i])\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    st.push(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                st.push(s[i]);\\n            }\\n        }\\n        string ans=\"\";\\n        while(!st.empty())\\n        {\\n            ans.push_back(st.top());\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1046953,
                "title": "python-using-stacks",
                "content": "```\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S: return s\\n        stack = []\\n        for ch in S:\\n            if stack and stack[-1]==ch: \\n                stack.pop()\\n                continue\\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        if not S: return s\\n        stack = []\\n        for ch in S:\\n            if stack and stack[-1]==ch: \\n                stack.pop()\\n                continue\\n            stack.append(ch)\\n        return \"\".join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 899822,
                "title": "python-3-with-explanation",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        _stack=[]                                     #initilized a new stack\\n        for s in S:                                   #looping over the characters in S\\n            if len(_stack)==0:                        #checking if the stack is empty \\n                _stack.append(s)                      #if its empty it will append the character in string S\\n            else:\\n                char=_stack[len(_stack)-1]            #top element of stack is copied to char\\n                if s==char:                           #checking if the top char is same as the current char\\n                    _stack.pop()                      # both are same the char is poped form the stack\\n                else:\\n                    _stack.append(s)                  #else will append the char to the top of the stack\\n        return \"\".join(_stack)                        #this will return the list as a string\\n            \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        _stack=[]                                     #initilized a new stack\\n        for s in S:                                   #looping over the characters in S\\n            if len(_stack)==0:                        #checking if the stack is empty \\n                _stack.append(s)                      #if its empty it will append the character in string S\\n            else:\\n                char=_stack[len(_stack)-1]            #top element of stack is copied to char\\n                if s==char:                           #checking if the top char is same as the current char\\n                    _stack.pop()                      # both are same the char is poped form the stack\\n                else:\\n                    _stack.append(s)                  #else will append the char to the top of the stack\\n        return \"\".join(_stack)                        #this will return the list as a string\\n            \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 882142,
                "title": "ruby-stack",
                "content": "```\\ndef remove_duplicates(s)\\n  stack = []\\n  s.each_char do |c|\\n    if stack[-1] == c\\n      stack.pop\\n    else\\n      stack << c\\n    end\\n  end\\n  stack.join\\nend",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef remove_duplicates(s)\\n  stack = []\\n  s.each_char do |c|\\n    if stack[-1] == c\\n      stack.pop\\n    else\\n      stack << c\\n    end\\n  end\\n  stack.join\\nend",
                "codeTag": "Python3"
            },
            {
                "id": 813459,
                "title": "java-one-pass-stringbuilder",
                "content": "\\tclass Solution {\\n\\t\\tpublic String removeDuplicates(String S) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\t\\t\\tif(sb.length() == 0 || sb.charAt(sb.length()-1) != S.charAt(i)){\\n\\t\\t\\t\\t\\tsb.append(S.charAt(i));\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tsb.deleteCharAt(sb.length()-1);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn sb.toString();\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic String removeDuplicates(String S) {\\n\\t\\t\\tStringBuilder sb = new StringBuilder();\\n\\n\\t\\t\\tfor (int i = 0; i < S.length(); i++) {\\n\\t\\t\\t\\tif(sb.length() == 0 || sb.charAt(sb.length()-1) != S.charAt(i)){\\n\\t\\t\\t\\t\\tsb.append(S.charAt(i));\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 757187,
                "title": "javascript-simple-recursive-solution-93-faster",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    if (S.match(/(.)\\\\1/g)) {\\n        return removeDuplicates(S.replace(/(.)\\\\1/g, \\'\\'));\\n    }\\n\\n    return S;\\n};\\n```\\n\\nStats:\\nRuntime: 80 ms, faster than 93.20% of JavaScript online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 39.4 MB, less than 100.00% of JavaScript online submissions for Remove All Adjacent Duplicates In String.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    if (S.match(/(.)\\\\1/g)) {\\n        return removeDuplicates(S.replace(/(.)\\\\1/g, \\'\\'));\\n    }\\n\\n    return S;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708930,
                "title": "c-very-simple-solution-fast-and-low-memory-usage",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string &S) {\\n        string s;\\n        for (char &c : S)\\n            (!s.empty() && s.back() == c)? s.pop_back() : s.push_back(c);\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string &S) {\\n        string s;\\n        for (char &c : S)\\n            (!s.empty() && s.back() == c)? s.pop_back() : s.push_back(c);\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 607379,
                "title": "swift-144ms-84-21-21mb-100",
                "content": "```\\nfunc removeDuplicates(_ S: String) -> String {\\n        var result: String = \"\"\\n        \\n        for char in S {\\n            if result.isEmpty {\\n                result += String(char)\\n            }\\n            else if let peek = result.last {\\n                if char == peek {\\n                    result.removeLast()\\n                }\\n                else {\\n                    result += String(char)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc removeDuplicates(_ S: String) -> String {\\n        var result: String = \"\"\\n        \\n        for char in S {\\n            if result.isEmpty {\\n                result += String(char)\\n            }\\n            else if let peek = result.last {\\n                if char == peek {\\n                    result.removeLast()\\n                }\\n                else {\\n                    result += String(char)\\n                }\\n            }\\n        }\\n        \\n        return result\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459740,
                "title": "python-o-n-solution-based-on-stack-run-time-90",
                "content": "Python O( n ) solution based on stack, run time 90%+\\n\\n```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        \\n        char_stack = []\\n        \\n        for char  in S:\\n            \\n            if char_stack and char_stack[-1] == char:\\n                # top of stack is the same as next character\\n                # eliminate duplicates \\n                char_stack.pop()  \\n                \\n            else:\\n                # no adjacent repetition characters\\n                # push next character into stack\\n                char_stack.append( char )\\n            \\n            \\n        return \\'\\'.join(char_stack)\\n```",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        \\n        char_stack = []\\n        \\n        for char  in S:\\n            \\n            if char_stack and char_stack[-1] == char:\\n                # top of stack is the same as next character\\n                # eliminate duplicates \\n                char_stack.pop()  \\n                \\n            else:\\n                # no adjacent repetition characters\\n                # push next character into stack\\n                char_stack.append( char )\\n            \\n            \\n        return \\'\\'.join(char_stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 302723,
                "title": "c-c-solution-with-stack",
                "content": "```\\nchar * removeDuplicates(char * S){\\n    int len = strlen(S);\\n    \\n    if(len <= 0){\\n        return S;\\n    }\\n    \\n    char* chars = (char *)malloc(len+1);\\n    int top = -1;\\n    \\n    for ( int i = 0; i < len ; i++ ){\\n        if(top < 0 || chars[top] != S[i] ){\\n            chars[++top] = S[i];\\n        }else{\\n            top--;\\n        }\\n    }\\n    chars[++top] = \\'\\\\0\\';\\n    return chars;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * removeDuplicates(char * S){\\n    int len = strlen(S);\\n    \\n    if(len <= 0){\\n        return S;\\n    }\\n    \\n    char* chars = (char *)malloc(len+1);\\n    int top = -1;\\n    \\n    for ( int i = 0; i < len ; i++ ){\\n        if(top < 0 || chars[top] != S[i] ){\\n            chars[++top] = S[i];\\n        }else{\\n            top--;\\n        }\\n    }\\n    chars[++top] = \\'\\\\0\\';\\n    return chars;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 295088,
                "title": "c-1-line-4-lines-o-n-time",
                "content": "Build the result string in a stack way. 1 line version:\\n```\\nstring removeDuplicates(string S) {\\n    return accumulate(S.begin(), S.end(), string(), [](auto &s, char c)->auto& {return s.size() && s.back() == c ? s.pop_back() : s.push_back(c), s;});\\n}\\n```\\n4 line version:\\n```\\nstring removeDuplicates(string S) {\\n    string s;\\n    for (char c : S)\\n        s.size() && s.back() == c ? s.pop_back() : s.push_back(c);\\n    return s;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring removeDuplicates(string S) {\\n    return accumulate(S.begin(), S.end(), string(), [](auto &s, char c)->auto& {return s.size() && s.back() == c ? s.pop_back() : s.push_back(c), s;});\\n}\\n```\n```\\nstring removeDuplicates(string S) {\\n    string s;\\n    for (char c : S)\\n        s.size() && s.back() == c ? s.pop_back() : s.push_back(c);\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3610530,
                "title": "easy-c-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   \\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        \\n        for(auto ch:s){\\n            if(!st.empty()&&st.top()==ch)\\n            st.pop();\\n             else\\n            st.push(ch);\\n            }\\n       while(!st.empty()){\\n           ans+=st.top();\\n           st.pop();\\n       }\\n       reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        stack<char> st;\\n        \\n        for(auto ch:s){\\n            if(!st.empty()&&st.top()==ch)\\n            st.pop();\\n             else\\n            st.push(ch);\\n            }\\n       while(!st.empty()){\\n           ans+=st.top();\\n           st.pop();\\n       }\\n       reverse(ans.begin(),ans.end());\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3307088,
                "title": "easy-c-solution-beat-90",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n           if(ans.length()>0){\\n            if(ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n            }\\n             else\\n            ans.push_back(s[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans=\"\";\\n        int i=0;\\n       while(i<s.length()){\\n           if(ans.length()>0){\\n            if(ans[ans.length()-1]==s[i])\\n            ans.pop_back();\\n            else\\n            ans.push_back(s[i]);\\n            }\\n             else\\n            ans.push_back(s[i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3102598,
                "title": "97-faster-no-stack-just-one-loop-java",
                "content": "I hope you understand it. It is just stack\\'s implementation. \\n\\n**Don\\'t forget to upvote**\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int length = s.length();\\n        int length_sb;\\n        for(int i=0;i<length;i++){\\n            length_sb = sb.length();\\n            if(length_sb!=0 && sb.charAt(length_sb-1)==s.charAt(i)){\\n                sb.deleteCharAt(length_sb-1);\\n                continue;\\n            }\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder(\"\");\\n        int length = s.length();\\n        int length_sb;\\n        for(int i=0;i<length;i++){\\n            length_sb = sb.length();\\n            if(length_sb!=0 && sb.charAt(length_sb-1)==s.charAt(i)){\\n                sb.deleteCharAt(length_sb-1);\\n                continue;\\n            }\\n            sb.append(s.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3039587,
                "title": "using-string-only-0ms-code-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(ans == \"\"){\\n                ans.push_back(s[i]);\\n            }\\n            else if(ans.back()==s[i]){\\n                ans.pop_back();\\n            }\\n            else{\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans = \"\";\\n        for(int i = 0; i < s.length(); i++){\\n            if(ans == \"\"){\\n                ans.push_back(s[i]);\\n            }\\n            else if(ans.back()==s[i]){\\n                ans.pop_back();\\n            }\\n            else{\\n                ans.push_back(s[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948454,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        while(s.size()>1&&i!=s.size()-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                s.erase(i,2);\\n                if(i==0)\\n                {\\n                    i=-1;\\n                }\\n                else\\n                {\\n                    i=i-2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        while(s.size()>1&&i!=s.size()-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                s.erase(i,2);\\n                if(i==0)\\n                {\\n                    i=-1;\\n                }\\n                else\\n                {\\n                    i=i-2;\\n                }\\n            }\\n            i++;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832310,
                "title": "easy-to-understand-c",
                "content": "**class Solution {\\npublic:**\\n\\n    string removeDuplicates(string s) {\\n        //using stack n=len of string\\n        int n=s.size();\\n        stack<char> st;\\n        //iterate over all elements\\n        for(int i=0;i<n;i++){\\n            //if stack size is greater than 0\\n            if(st.size()>0){\\n                //if current character is equal to topmost element\\n                //drop the topmost element\\n                //else push the current element in the stack\\n                char c=st.top();\\n                if(c==s[i]){\\n                    st.pop();\\n                }\\n                else{\\n                    st.push(s[i]);\\n                }\\n            }\\n            //if stack size is 0\\n            else{\\n                st.push(s[i]);\\n            }\\n        }\\n        //retrieve the char from stack\\n        string rt=\"\";\\n        while(st.size()>0){\\n            char t=st.top();\\n            rt+=t;\\n            st.pop();\\n        }\\n        //reverse the string for final ans\\n        string ans=\"\";\\n        for(int i=rt.size()-1;i>=0;i--){\\n            ans+=rt[i];\\n        }\\n        return ans;\\n    }\\n**};**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:**\\n\\n    string removeDuplicates(string s) {\\n        //using stack n=len of string\\n        int n=s.size();\\n        stack<char> st;\\n        //iterate over all elements\\n        for(int i=0;i<n;i++){\\n            //if stack size is greater than 0\\n            if(st.size()>0){\\n                //if current character is equal to topmost element\\n                //drop the topmost element\\n                //else push the current element in the stack\\n                char c=st.top();\\n                if(c==s[i]){\\n                    st.pop();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2801903,
                "title": "yi",
                "content": "```\\ndef fun(s):\\n    for i in range(len(s)-1):\\n        if(s[i]==s[i+1]):\\n            s.pop(i)\\n            s.pop(i)\\n            return(fun(s))\\n    return s\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "solutionTags": [],
                "code": "```\\ndef fun(s):\\n    for i in range(len(s)-1):\\n        if(s[i]==s[i+1]):\\n            s.pop(i)\\n            s.pop(i)\\n            return(fun(s))\\n    return s\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans=[]\\n        for a in s:\\n            if(len(ans)>0 and ans[-1]==a):\\n                ans.pop()\\n            else:\\n                ans.append(a)\\n        return(\"\".join(ans))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800773,
                "title": "go-short-solution-o-n-memory-o-n",
                "content": "The main idea is to go from the end of the array and each time compare with the previous value\\n\\n```\\nfunc removeDuplicates(s string) string {\\n\\tb := []byte(s)\\n\\tfor i := len(b) - 1; i > 0; i-- {\\n\\t\\tif i != len(b) && b[i] == b[i-1] {\\n\\t\\t\\tb = append(b[:i-1], b[i+1:]...)\\n\\t\\t}\\n\\t}\\n\\treturn string(b)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeDuplicates(s string) string {\\n\\tb := []byte(s)\\n\\tfor i := len(b) - 1; i > 0; i-- {\\n\\t\\tif i != len(b) && b[i] == b[i-1] {\\n\\t\\t\\tb = append(b[:i-1], b[i+1:]...)\\n\\t\\t}\\n\\t}\\n\\treturn string(b)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2800524,
                "title": "java-detailed-solution-stack-two-pointers-approaches",
                "content": "Using Stack:\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && c == stack.peek()) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```\\n\\nTwo pointers:\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int slow = 0, fast = 1;\\n        while (fast < sb.length()) {\\n            if (sb.charAt(slow) == sb.charAt(fast)) {\\n                sb.deleteCharAt(slow);\\n                sb.deleteCharAt(slow);\\n                if (slow != 0) slow--;\\n                if (fast != 1) fast--;\\n            } else {\\n                slow++;\\n                fast++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n\\n        for (char c : s.toCharArray()) {\\n            if (!stack.isEmpty() && c == stack.peek()) {\\n                stack.pop();\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n\\n        StringBuilder ans = new StringBuilder();\\n        for (char c : stack) ans.append(c);\\n        return ans.toString();\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s.length() <= 1) return s;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        int slow = 0, fast = 1;\\n        while (fast < sb.length()) {\\n            if (sb.charAt(slow) == sb.charAt(fast)) {\\n                sb.deleteCharAt(slow);\\n                sb.deleteCharAt(slow);\\n                if (slow != 0) slow--;\\n                if (fast != 1) fast--;\\n            } else {\\n                slow++;\\n                fast++;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800329,
                "title": "java-easy-peasy-solution",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char x : s.toCharArray()) {\\n            if (sb.length() > 0 && sb.charAt(sb.length() - 1) == x) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char x : s.toCharArray()) {\\n            if (sb.length() > 0 && sb.charAt(sb.length() - 1) == x) {\\n                sb.deleteCharAt(sb.length() - 1);\\n            } else {\\n                sb.append(x);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799199,
                "title": "easy-solution-using-stack",
                "content": "```\\nclass Solution {\\n   public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }\\n                else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n}\\n```\\n",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n   public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n       \\n        for(int i=0; i<s.length(); i++){\\n            if(!stack.empty()){\\n                if(stack.peek().equals(s.charAt(i))){\\n                    stack.pop();\\n                }\\n                else{\\n                    stack.push(s.charAt(i));\\n                }\\n            }\\n            else{\\n                stack.push(s.charAt(i));\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!stack.empty()){\\n            sb.append(stack.pop());\\n        }\\n        return sb.reverse().toString();\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799152,
                "title": "c-stack-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(st.empty()){\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(!st.empty() && st.top()==s[i]){\\n\\t\\t\\t\\t\\t\\twhile(!st.empty() && st.top()==s[i]){\\n\\t\\t\\t\\t\\t\\t\\tst.pop();\\n\\t\\t\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ti--;\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tstring ans=\"\";\\n\\t\\t\\twhile(!st.empty()){\\n\\t\\t\\t\\tans+=st.top(); st.pop();\\n\\t\\t\\t}\\n\\t\\t\\treverse(ans.begin(), ans.end());\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring removeDuplicates(string s) {\\n\\t\\t\\tstack<char>st;\\n\\t\\t\\tfor(int i=0; i<s.size(); i++){\\n\\t\\t\\t\\tif(st.empty()){\\n\\t\\t\\t\\t\\tst.push(s[i]);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2798880,
                "title": "easy-java-solution-using-stack",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            if(st.isEmpty()){\\n            st.push(curr);\\n                }\\n            \\n            else if(st.peek() == curr){\\n                st.pop();\\n            }else{\\n                st.push(curr);\\n            }\\n           \\n        }\\n        String n = \"\";\\n        while(!st.isEmpty()){\\n            n =st.pop()+ n  ;\\n        }\\n        return n;\\n    }\\n    \\n}",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String s) {\\n\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i=0;i<s.length();i++){\\n            char curr = s.charAt(i);\\n            if(st.isEmpty()){\\n            st.push(curr);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2798677,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(auto c: s) {\\n            if(ans.empty()) ans.push_back(c);\\n            else {\\n                if(ans.back() == c) ans.pop_back();\\n                else ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans;\\n        for(auto c: s) {\\n            if(ans.empty()) ans.push_back(c);\\n            else {\\n                if(ans.back() == c) ans.pop_back();\\n                else ans.push_back(c);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798574,
                "title": "javascript-beats-100-solutions-in-memory",
                "content": "# Intuition\\nIt is simple. Whenever 2 adjacent characters are matching, create a window, start expanding in opposite directions. See if characters are matching or not. If not stop there, let your main counter increment\\n\\nThis solution beats 100% solutions in memory.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n    const str = [...s];\\n\\n    for(let i = 1; i < str.length; i++) {\\n        if (!str[i]) {\\n            continue;\\n        }\\n\\n        if (str[i] === str[i - 1]) {\\n            str[i] = str[i - 1] = null;\\n            let left = i - 2;\\n            let right = i + 1;\\n\\n            while (!str[left] && left >= 0) {\\n                left--;\\n            }\\n\\n            while (!str[right] && right < str.length) {\\n                right++;\\n            }\\n\\n            while(str[left] === str[right] && str[left] != null && left >= 0 && right < str.length) {\\n                str[left] = str[right] = null;\\n                left--;\\n                right++;\\n            }\\n        }\\n    }\\n\\n    return str.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {string}\\n */\\nvar removeDuplicates = function(s) {\\n    const str = [...s];\\n\\n    for(let i = 1; i < str.length; i++) {\\n        if (!str[i]) {\\n            continue;\\n        }\\n\\n        if (str[i] === str[i - 1]) {\\n            str[i] = str[i - 1] = null;\\n            let left = i - 2;\\n            let right = i + 1;\\n\\n            while (!str[left] && left >= 0) {\\n                left--;\\n            }\\n\\n            while (!str[right] && right < str.length) {\\n                right++;\\n            }\\n\\n            while(str[left] === str[right] && str[left] != null && left >= 0 && right < str.length) {\\n                str[left] = str[right] = null;\\n                left--;\\n                right++;\\n            }\\n        }\\n    }\\n\\n    return str.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2798421,
                "title": "line-by-line-explanation-easy-to-understand-stack-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n> Using stack to get the immediate previous character in the string\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Start a loop for each character in the string \\n2. Check if the stack is empty, or if the peeked element from the stack is not equals to the present character in the string, then add the element in the stack\\n3. In the else condition pop the last element in the stack becase in this case, the last element and the present character is equal to each other.\\n4. Initialize a char array of `stack.size()` length\\n5. Pop the elements if the stack while it isnt empty and insert the characters in the array in the `reverse` order.\\n6. Convert the char array to String and return it.\\n\\n# Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(stack.isEmpty() || stack.peek() != ch) stack.add(ch);\\n            else stack.pop();\\n        }\\n        char[] arr = new char[stack.size()];\\n        for(int i=stack.size(); i>0; i--) arr[i-1] = stack.pop();\\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(stack.isEmpty() || stack.peek() != ch) stack.add(ch);\\n            else stack.pop();\\n        }\\n        char[] arr = new char[stack.size()];\\n        for(int i=stack.size(); i>0; i--) arr[i-1] = stack.pop();\\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798308,
                "title": "stack-remove-all-adjacent-duplicates-in-string",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(char c:s.toCharArray())\\n        {\\n            if(!stack.isEmpty()&&stack.peek()==c)\\n            {\\n                stack.pop();\\n            }else{\\n                stack.push(c);\\n            }\\n        }\\n        String res=\"\";\\n        while(!stack.isEmpty()){\\n            res=stack.pop()+res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        \\n        for(char c:s.toCharArray())\\n        {\\n            if(!stack.isEmpty()&&stack.peek()==c)\\n            {\\n                stack.pop();\\n            }else{\\n                stack.push(c);\\n            }\\n        }\\n        String res=\"\";\\n        while(!stack.isEmpty()){\\n            res=stack.pop()+res;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798236,
                "title": "c-most-easy-solution-using-string",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        int i=1;\\n        string ans; // stores the answer string\\n        \\n        ans.push_back(s[0]); // pushes the first char of the given string\\n        while(i<s.length())\\n        {\\n            if(ans.empty() == 0)\\n            {\\n                if(ans.back()==s[i]) // checking the char present in the ans == presenti in s\\n                {\\n                    ans.pop_back(); // removing the char\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]); // pushing the char\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if the ans is empty\\n            }\\n            i++; // incremenet \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        \\n        int i=1;\\n        string ans; // stores the answer string\\n        \\n        ans.push_back(s[0]); // pushes the first char of the given string\\n        while(i<s.length())\\n        {\\n            if(ans.empty() == 0)\\n            {\\n                if(ans.back()==s[i]) // checking the char present in the ans == presenti in s\\n                {\\n                    ans.pop_back(); // removing the char\\n                }\\n                else\\n                {\\n                    ans.push_back(s[i]); // pushing the char\\n                }\\n            }\\n            else\\n            {\\n                ans.push_back(s[i]); // if the ans is empty\\n            }\\n            i++; // incremenet \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2798020,
                "title": "easy-c-solution-0ms-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        for (int j = 0 ; j < s.size() ; j++,i++)\\n        {\\n            s[i] = s[j];\\n            if (i > 0 && s[i-1] == s[i])\\n            i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        for (int j = 0 ; j < s.size() ; j++,i++)\\n        {\\n            s[i] = s[j];\\n            if (i > 0 && s[i-1] == s[i])\\n            i-=2;\\n        }\\n        return s.substr(0,i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2752419,
                "title": "java-efficient-solution-faster-than-96-21",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) return null;\\n\\n        char[] stack = new char[s.length()];\\n        int i = 0;\\n\\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            if (i > 0 && stack[i - 1] == c) {\\n                i--;\\n            } else {\\n                stack[i++] = c;\\n            }\\n        }\\n        return new String(stack, 0, i);       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if (s == null) return null;\\n\\n        char[] stack = new char[s.length()];\\n        int i = 0;\\n\\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            if (i > 0 && stack[i - 1] == c) {\\n                i--;\\n            } else {\\n                stack[i++] = c;\\n            }\\n        }\\n        return new String(stack, 0, i);       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2725400,
                "title": "python3-o-n-runtime-104-ms-beats-82-48-memory-14-7-mb-beats-86-13",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans = []\\n        i = 0\\n        for i in s:\\n            if len(ans) > 0:\\n                if i == ans[-1]:\\n                    ans.pop()\\n                else:\\n                    ans.append(i)\\n            else:\\n                ans.append(i)\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        ans = []\\n        i = 0\\n        for i in s:\\n            if len(ans) > 0:\\n                if i == ans[-1]:\\n                    ans.pop()\\n                else:\\n                    ans.append(i)\\n            else:\\n                ans.append(i)\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703030,
                "title": "two-solutions-o-1-extra-space-clean-code",
                "content": "**Solution 1: Using Stack**\\n```\\nvar removeDuplicates = function(str){\\n    var stack = [];\\n    for(var s of str){\\n        stack.push(s);\\n        while(stack.length > 1 && stack[stack.length-1] === stack[stack.length-2]){\\n            stack.pop();\\n            stack.pop();\\n        }\\n    }\\n    return stack.join(\\'\\');\\n}\\n```\\n**Solution 2: O(1) Space || Inplace string manipulation**\\n```\\nvar removeDuplicates = function(s) {\\n    for(var i=1; i<s.length; i++){\\n        if(s[i] === s[i-1]){\\n            s = s.slice(0, i-1) + s.slice(i+1);\\n            i-=2;\\n        }\\n    }\\n    return s;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(str){\\n    var stack = [];\\n    for(var s of str){\\n        stack.push(s);\\n        while(stack.length > 1 && stack[stack.length-1] === stack[stack.length-2]){\\n            stack.pop();\\n            stack.pop();\\n        }\\n    }\\n    return stack.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2651043,
                "title": "easy-python-solution-using-if-else-with-explanation",
                "content": "Iterating an if-else loop throughout the string\\n```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        # Initiate a blank list\\n\\t\\tstr_list = []\\n        for i in s:\\n            # Remove the element from that list only if its Non Empty and its last appended element = current element\\n\\t\\t\\tif str_list and str_list[-1] == i:\\n                str_list.pop()\\n            else:\\n\\t\\t\\t    # Else, keep appending the characters\\n                str_list.append(i)\\n        return \\'\\'.join(str_list)\\n```\\n\\n***Please upvote if you like it***",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        # Initiate a blank list\\n\\t\\tstr_list = []\\n        for i in s:\\n            # Remove the element from that list only if its Non Empty and its last appended element = current element\\n\\t\\t\\tif str_list and str_list[-1] == i:\\n                str_list.pop()\\n            else:\\n\\t\\t\\t    # Else, keep appending the characters\\n                str_list.append(i)\\n        return \\'\\'.join(str_list)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641587,
                "title": "js-very-easy-solution-with-stack",
                "content": "```\\nvar removeDuplicates = function(s) {\\n    let output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === output[output.length - 1]) {\\n            output.pop();\\n        } else {\\n            output.push(s[i]);\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(s) {\\n    let output = [];\\n    \\n    for (let i = 0; i < s.length; i++) {\\n        if (s[i] === output[output.length - 1]) {\\n            output.pop();\\n        } else {\\n            output.push(s[i]);\\n        }\\n    }\\n    \\n    return output.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1882377,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans{};\\n        \\n        for(char &c : s){\\n            if(ans.empty())\\n                ans.push_back(c);\\n            else{\\n                if(ans.back() == c)\\n                    ans.pop_back();\\n                else\\n                    ans.push_back(c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string ans{};\\n        \\n        for(char &c : s){\\n            if(ans.empty())\\n                ans.push_back(c);\\n            else{\\n                if(ans.back() == c)\\n                    ans.pop_back();\\n                else\\n                    ans.push_back(c);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1672467,
                "title": "c-easy-solution-stack-based",
                "content": "**Please upvote to motivate me in quest of documenting all leetcode solutions. :)**\\n```\\nThe problem is simply a use case of \"STACK\" data structure.\\nThe logic of problem is simply push the character in stack if it is empty or stack top is not same. If stack top is same\\nas the current character then pop the character from stack top. ( Easy Peasy ) :)\\n```\\n```\\nclass Solution {\\npublic:\\n    string remove_duplicate(string str, int l)\\n   {\\n          stack<char>s;\\n          for(int i=0; i<l; i++)\\n          {\\n              if(s.empty())\\n                  s.push(str[i]);\\n              else\\n             {\\n                   if(s.top()==str[i])\\n                                  s.pop();\\n                   else\\n                      s.push(str[i]);\\n             }\\n          }\\n   \\n        string sout;\\n   while(!s.empty())\\n   {\\n         sout+=s.top();\\n          s.pop();\\n   } \\n   \\n        reverse(sout.begin(),sout.end());\\n   \\n    return sout;\\n}\\n    string removeDuplicates(string str) {\\n        \\n        int l=str.length();\\n        string s=remove_duplicate(str,l);\\n    return s;\\n}\\n      \\n};\\n```\\n**Stack is best DS ;)**",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nThe problem is simply a use case of \"STACK\" data structure.\\nThe logic of problem is simply push the character in stack if it is empty or stack top is not same. If stack top is same\\nas the current character then pop the character from stack top. ( Easy Peasy ) :)\\n```\n```\\nclass Solution {\\npublic:\\n    string remove_duplicate(string str, int l)\\n   {\\n          stack<char>s;\\n          for(int i=0; i<l; i++)\\n          {\\n              if(s.empty())\\n                  s.push(str[i]);\\n              else\\n             {\\n                   if(s.top()==str[i])\\n                                  s.pop();\\n                   else\\n                      s.push(str[i]);\\n             }\\n          }\\n   \\n        string sout;\\n   while(!s.empty())\\n   {\\n         sout+=s.top();\\n          s.pop();\\n   } \\n   \\n        reverse(sout.begin(),sout.end());\\n   \\n    return sout;\\n}\\n    string removeDuplicates(string str) {\\n        \\n        int l=str.length();\\n        string s=remove_duplicate(str,l);\\n    return s;\\n}\\n      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572648,
                "title": "using-stringbuilder-as-a-stack",
                "content": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i = 1; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(sb.length() > 0 && sb.charAt(sb.length()-1) == ch) {\\n                sb.setLength(sb.length()-1);\\n            } else {\\n                sb.append(ch);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String removeDuplicates(String s) {\\n        if(s == null || s.length() == 0) return s;\\n        StringBuilder sb = new StringBuilder();\\n        sb.append(s.charAt(0));\\n        for(int i = 1; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n            \\n            if(sb.length() > 0 && sb.charAt(sb.length()-1) == ch) {\\n                sb.setLength(sb.length()-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1569642,
                "title": "c-noob-solution-easy-to-understand-using-stack",
                "content": "If This helps you then please upvote \\uD83D\\uDE4F\\n\\n\\n```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stc;\\n        string ans=\"\";\\n        for(auto x:s){\\n             if(stc.empty() || stc.top()!=x){\\n                 stc.push(x);\\n             }\\n            else if(stc.top()==x){\\n                stc.pop();\\n            }\\n        }\\n        while(!stc.empty()){\\n            ans+=stc.top();\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        stack<char> stc;\\n        string ans=\"\";\\n        for(auto x:s){\\n             if(stc.empty() || stc.top()!=x){\\n                 stc.push(x);\\n             }\\n            else if(stc.top()==x){\\n                stc.pop();\\n            }\\n        }\\n        while(!stc.empty()){\\n            ans+=stc.top();\\n            stc.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1487242,
                "title": "c-easy-solution-using-stack",
                "content": "```\\nstring removeDuplicates(string s) {\\n        if(s.size()==1) return s;\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                if(s[i]==st.top()){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring removeDuplicates(string s) {\\n        if(s.size()==1) return s;\\n        string ans=\"\";\\n        stack<char> st;\\n        for(int i=0;i<s.size();i++){\\n            if(st.empty()) st.push(s[i]);\\n            else{\\n                if(s[i]==st.top()){\\n                    st.pop();\\n                }else{\\n                    st.push(s[i]);\\n                }\\n            }\\n        }\\n        while(!st.empty()){\\n            ans+=st.top();\\n            st.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1459991,
                "title": "java-sol-48ms",
                "content": "Used the same approach as done in the extension for this question. Only difference being that we don\\'t need to worry about k(frequency of character) in this question.\\n\\nreference:\\n[Remove All Adjacent Duplicates in String II](https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/discuss/1439667/Java-sol-or-52ms)  \\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (Character c : s.toCharArray()){\\n            if (!st.isEmpty() && st.peek() == c){\\n                st.pop();\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty())\\n            sb.append(st.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for (Character c : s.toCharArray()){\\n            if (!st.isEmpty() && st.peek() == c){\\n                st.pop();\\n            } else {\\n                st.push(c);\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while(!st.isEmpty())\\n            sb.append(st.pop());\\n        return sb.reverse().toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457324,
                "title": "both-approach-s-in-detail-with-explanation-java-code",
                "content": "**Approach 1: Replace**\\n\\nThe idea is very simple:\\n\\nGenerate hashset of all 26 possible duplicates from aa to zz.\\n\\nIterate over that 26 duplicates and replace them all in string by empty char.\\n    \\n\\nAlgorithm\\n\\nGenerate hashset of all 26 possible duplicates from aa to zz.\\n\\nInitiate \\'one step before\\' string length by prevLength = -1.\\n\\nWhile previous length is still different from the current one prevLength != S.length()\\n\\nSet \\'one step before\\' length to be equal to the string length prevLength = S.length().\\n\\nIterate over all 26 duplicates and replace them in string by empty char.\\n\\nReturn S.\\n    \\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    // generate 26 possible duplicates\\n    HashSet<String> duplicates = new HashSet();\\n    StringBuilder sb = new StringBuilder();\\n    for(char i = \\'a\\'; i <= \\'z\\'; ++i) {\\n      sb.setLength(0);\\n      sb.append(i); sb.append(i);\\n      duplicates.add(sb.toString());\\n    }\\n\\n    int prevLength = -1;\\n    while (prevLength != S.length()) {\\n      prevLength = S.length();\\n      for (String d : duplicates) S = S.replace(d, \"\");\\n    }\\n\\n    return S;\\n  }\\n}\\n```\\nComplexity Analysis\\n\\n*Time complexity : O(N^2)\\nSpace complexity : O(N).*\\n    \\n\\n    \\n    \\n**Approach 2: Stack**\\n\\nWe could trade an extra space for speed. The idea is to use an output stack to keep track of only non duplicate characters. Here is how it works:\\n\\nCurrent string character is equal to the last element in stack? Pop that last element out of stack.\\n\\nCurrent string character is not equal to the last element in stack? Add the current character into stack.\\n\\nWhich data structure to use as the stack here?\\n    \\n    \\nSomething that is fast to convert to string for output, for example list in Python and StringBuilder in Java\\n\\nAlgorithm\\n\\nInitiate an empty output stack.\\n\\nIterate over all characters in the string.\\n\\nCurrent element is equal to the last element in stack? Pop that last element out of stack.\\n\\nCurrent element is not equal to the last element in stack? Add the current element into stack.\\n\\nConvert stack into string and return it.\\n    \\nImplementation\\n\\n\\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    StringBuilder sb = new StringBuilder();\\n    int sbLength = 0;\\n    for(char character : S.toCharArray()) {\\n      if (sbLength != 0 && character == sb.charAt(sbLength - 1))\\n        sb.deleteCharAt(sbLength-- - 1);\\n      else {\\n        sb.append(character);\\n        sbLength++;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```\\n\\nComplexity Analysis\\n\\n*Time complexity : O(N), where N is a string length.\\nSpace complexity : O(N\\u2212D) where D is a total length for all duplicates.*\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    // generate 26 possible duplicates\\n    HashSet<String> duplicates = new HashSet();\\n    StringBuilder sb = new StringBuilder();\\n    for(char i = \\'a\\'; i <= \\'z\\'; ++i) {\\n      sb.setLength(0);\\n      sb.append(i); sb.append(i);\\n      duplicates.add(sb.toString());\\n    }\\n\\n    int prevLength = -1;\\n    while (prevLength != S.length()) {\\n      prevLength = S.length();\\n      for (String d : duplicates) S = S.replace(d, \"\");\\n    }\\n\\n    return S;\\n  }\\n}\\n```\n```\\nclass Solution {\\n  public String removeDuplicates(String S) {\\n    StringBuilder sb = new StringBuilder();\\n    int sbLength = 0;\\n    for(char character : S.toCharArray()) {\\n      if (sbLength != 0 && character == sb.charAt(sbLength - 1))\\n        sb.deleteCharAt(sbLength-- - 1);\\n      else {\\n        sb.append(character);\\n        sbLength++;\\n      }\\n    }\\n    return sb.toString();\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1324665,
                "title": "python-o-n-solution-using-stack",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:        \\n        stack = deque()\\n        \\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack[-1] == c:\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n                    \\n        return \"\".join(stack)\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:        \\n        stack = deque()\\n        \\n        for c in s:\\n            if not stack:\\n                stack.append(c)\\n            else:\\n                if stack[-1] == c:\\n                    stack.pop()\\n                else:\\n                    stack.append(c)\\n                    \\n        return \"\".join(stack)\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1303758,
                "title": "remove-all-adjacent-duplicates-in-string-beginners-c-easy-to-understand",
                "content": "Upvote if You Like it ! Please leave a comment for any query or suggestion.\\n```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n = s.length();\\n        int i=0;\\n        while(i<=n-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                i--;\\n                s.erase(s.begin()+i+2);\\n                s.erase(s.begin()+i+1);\\n                n=n-2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n            if(i<1) i=0;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int n = s.length();\\n        int i=0;\\n        while(i<=n-1)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                i--;\\n                s.erase(s.begin()+i+2);\\n                s.erase(s.begin()+i+1);\\n                n=n-2;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n            if(i<1) i=0;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1208823,
                "title": "faster-than-84-of-python-solutions",
                "content": "```class Solution(object):\\n    def removeDuplicates(self, s):\\n        \\n        c = [0]\\n    \\n        for i in s:   \\n            \\n            \\n            if i != c[-1]:\\n                \\n                c.append(i)\\n            else:\\n                c.pop()\\n        c.pop(0)   \\n        return (\"\".join(c))\\n    \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```class Solution(object):\\n    def removeDuplicates(self, s):\\n        \\n        c = [0]\\n    \\n        for i in s:   \\n            \\n            \\n            if i != c[-1]:\\n                \\n                c.append(i)\\n            else:\\n                c.pop()\\n        c.pop(0)   \\n        return (\"\".join(c))\\n    \\n",
                "codeTag": "Java"
            },
            {
                "id": 1192588,
                "title": "js-o-n-solutions-using-two-pointers-and-stack-approaches-92ms",
                "content": "**Solution using Two Pointers approach**\\n```\\nvar removeDuplicates = function(S) {\\n\\t// to store the resultant string\\n    const result = [];\\n    \\n\\t// i is used to maintain the pointer at result string\\n\\t// j is used to iterate over the string S\\n    for(let i = 0, j = 0; j < S.length; ++i, ++j) {\\n        result[i] = S[j];\\n\\n\\t\\t// if the value adjacent to recently added value is same\\n        if(i > 0 && result[i] === result[i - 1]) {\\n\\n\\t\\t\\t// set both the values as empty - removing duplicate\\n\\t\\t\\t// can also pop twice - result.pop()\\n            result[i] = result[i - 1] = \\'\\';\\n\\t\\t\\t\\n\\t\\t\\t// set the value for i as the index from where to add the new value\\n\\t\\t\\t// go back 2 places since duplicates are removed\\n            i -= 2;\\n        }\\n    }\\n\\t// since result is an array, use join to convert it into a string\\n    return result.join(\\'\\');\\n}\\n```\\n\\nTime and Space Complexity: O(n)\\nn = length of the String S\\n\\n**Solution using Stack**\\n```\\nvar removeDuplicates = function(S) {\\n    const stack = [];\\n    \\n    for(let i = 0; i < S.length; ++i) {\\n\\t\\t// if stack is not empty and the stack.top() is same as the value at index i\\n        if(stack.length > 0 && stack[stack.length - 1] === S[i]) {\\n\\t\\t\\t// pop the value as it is a duplicate\\n            stack.pop();\\n        } else {\\n\\t\\t\\t// else push the value into the stack\\n            stack.push(S[i]);\\n        }\\n    }\\n\\t\\n\\t// since stack is an array, use join to convert it into a string\\n    return stack.join(\\'\\');\\n}\\n```\\n\\nTime and Space Complexity: O(n)\\nn = length of the String S",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Stack"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n\\t// to store the resultant string\\n    const result = [];\\n    \\n\\t// i is used to maintain the pointer at result string\\n\\t// j is used to iterate over the string S\\n    for(let i = 0, j = 0; j < S.length; ++i, ++j) {\\n        result[i] = S[j];\\n\\n\\t\\t// if the value adjacent to recently added value is same\\n        if(i > 0 && result[i] === result[i - 1]) {\\n\\n\\t\\t\\t// set both the values as empty - removing duplicate\\n\\t\\t\\t// can also pop twice - result.pop()\\n            result[i] = result[i - 1] = \\'\\';\\n\\t\\t\\t\\n\\t\\t\\t// set the value for i as the index from where to add the new value\\n\\t\\t\\t// go back 2 places since duplicates are removed\\n            i -= 2;\\n        }\\n    }\\n\\t// since result is an array, use join to convert it into a string\\n    return result.join(\\'\\');\\n}\\n```\n```\\nvar removeDuplicates = function(S) {\\n    const stack = [];\\n    \\n    for(let i = 0; i < S.length; ++i) {\\n\\t\\t// if stack is not empty and the stack.top() is same as the value at index i\\n        if(stack.length > 0 && stack[stack.length - 1] === S[i]) {\\n\\t\\t\\t// pop the value as it is a duplicate\\n            stack.pop();\\n        } else {\\n\\t\\t\\t// else push the value into the stack\\n            stack.push(S[i]);\\n        }\\n    }\\n\\t\\n\\t// since stack is an array, use join to convert it into a string\\n    return stack.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1162232,
                "title": "java-simple-and-easy-to-understand-greedy-solution-using-stack-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n\\n```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deque = new LinkedList();\\n        \\n        for(char c : S.toCharArray()){\\n            //if last character same as current, \\n            //then just pop last one\\n            if(!deque.isEmpty() && deque.peek() == c){\\n                deque.pop();\\n            }else{\\n                deque.push(c);\\n            }\\n        }\\n        \\n        //get all the left character\\n        StringBuilder sb = new StringBuilder();\\n        while(!deque.isEmpty()){\\n            sb.append(deque.pop());\\n        }\\n        //reverse the string\\n        sb.reverse();\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public String removeDuplicates(String S) {\\n        Deque<Character> deque = new LinkedList();\\n        \\n        for(char c : S.toCharArray()){\\n            //if last character same as current, \\n            //then just pop last one\\n            if(!deque.isEmpty() && deque.peek() == c){\\n                deque.pop();\\n            }else{\\n                deque.push(c);\\n            }\\n        }\\n        \\n        //get all the left character\\n        StringBuilder sb = new StringBuilder();\\n        while(!deque.isEmpty()){\\n            sb.append(deque.pop());\\n        }\\n        //reverse the string\\n        sb.reverse();\\n        \\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161162,
                "title": "easy-python-3-line-solution-no-stack-required",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        for character in s:\\n            s = s.replace (character * 2, \"\") if character * 2 in s else s\\n        return s\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, s: str) -> str:\\n        for character in s:\\n            s = s.replace (character * 2, \"\") if character * 2 in s else s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158365,
                "title": "python-stack-solution-95-37-faster",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        \\n        for s in S:\\n            if stack and stack[-1] == s:\\n                stack.pop()\\n            else:\\n                stack.append(s)\\n                \\n        return \"\".join(stack)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        stack = []\\n        \\n        for s in S:\\n            if stack and stack[-1] == s:\\n                stack.pop()\\n            else:\\n                stack.append(s)\\n                \\n        return \"\".join(stack)",
                "codeTag": "Java"
            },
            {
                "id": 1041434,
                "title": "python3-simple-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        st = []\\n        for i in S:\\n            if st == [] or st[-1] != i:\\n                st.append(i)\\n            else:\\n                st.pop()\\n        return \\'\\'.join(st)\\n```\\nIf you like the solution, please vote for this.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        st = []\\n        for i in S:\\n            if st == [] or st[-1] != i:\\n                st.append(i)\\n            else:\\n                st.pop()\\n        return \\'\\'.join(st)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1011120,
                "title": "python-simple-iterative-solution",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        i = 0\\n        S = list(S)\\n        while i < len(S) - 1:\\n            if S[i] == S[i + 1]:\\n                del S[i]\\n                del S[i]\\n                if i: i -= 1\\n            else: i+= 1\\n        return \"\".join(S)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, S: str) -> str:\\n        i = 0\\n        S = list(S)\\n        while i < len(S) - 1:\\n            if S[i] == S[i + 1]:\\n                del S[i]\\n                del S[i]\\n                if i: i -= 1\\n            else: i+= 1\\n        return \"\".join(S)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998346,
                "title": "python-no-stack-using-slow-and-fast-pointer-tc-o-n-sc-o-1",
                "content": "```\\nclass Solution:\\n    def removeDuplicates(self, a: str) -> str:\\n        slow=0\\n        a=list(a)\\n        for fast in range(len(a)):\\n            if slow==0 or a[slow-1]!=a[fast]:\\n                a[slow]=a[fast]\\n                slow+=1\\n            else:\\n                slow-=1\\n        return \\'\\'.join(a[:slow])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeDuplicates(self, a: str) -> str:\\n        slow=0\\n        a=list(a)\\n        for fast in range(len(a)):\\n            if slow==0 or a[slow-1]!=a[fast]:\\n                a[slow]=a[fast]\\n                slow+=1\\n            else:\\n                slow-=1\\n        return \\'\\'.join(a[:slow])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925024,
                "title": "java-solution-using-stack",
                "content": "``` \\npublic String removeDuplicates(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n\\n            //add character to the stack and append it to StringBuilder\\n            if (stack.isEmpty()) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top of stack is not equal to the current character, add it to stack and StringBuilder\\n            } else if (stack.peek() != c) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top and current character are equal, remove them from stringBuilder and stack\\n            } else {\\n                stack.pop();\\n                //remove last character in sb by reducing its length by 1\\n                sb.setLength(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "``` \\npublic String removeDuplicates(String s) {\\n        if (s.length() == 1) {\\n            return s;\\n        }\\n\\n        Stack<Character> stack = new Stack<>();\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : s.toCharArray()) {\\n\\n            //add character to the stack and append it to StringBuilder\\n            if (stack.isEmpty()) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top of stack is not equal to the current character, add it to stack and StringBuilder\\n            } else if (stack.peek() != c) {\\n                stack.push(c);\\n                sb.append(c);\\n            //If the top and current character are equal, remove them from stringBuilder and stack\\n            } else {\\n                stack.pop();\\n                //remove last character in sb by reducing its length by 1\\n                sb.setLength(sb.length() - 1);\\n            }\\n        }\\n        return sb.toString();\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 619457,
                "title": "javascript",
                "content": "```\\nvar removeDuplicates = function(S) {\\n    while(S.match(/([a-z])\\\\1/)) {\\n        S = S.replace(/([a-z])\\\\1/, \\'\\');\\n    }\\n    return S;\\n};",
                "solutionTags": [],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    while(S.match(/([a-z])\\\\1/)) {\\n        S = S.replace(/([a-z])\\\\1/, \\'\\');\\n    }\\n    return S;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 552914,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        stack<char> st;\\n        st.push(S[0]);\\n        for(int i=1;i<S.size();i++)\\n        {\\n            if(!st.empty()&&st.top()==S[i])\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(S[i]);\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp+=st.top();\\n            st.pop();\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        stack<char> st;\\n        st.push(S[0]);\\n        for(int i=1;i<S.size();i++)\\n        {\\n            if(!st.empty()&&st.top()==S[i])\\n            {\\n                st.pop();\\n            }\\n            else\\n            {\\n                st.push(S[i]);\\n            }\\n        }\\n        string temp=\"\";\\n        while(!st.empty())\\n        {\\n            temp+=st.top();\\n            st.pop();\\n        }\\n        reverse(temp.begin(),temp.end());\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418388,
                "title": "o-n-o-1-space-with-two-pointers-php",
                "content": "```\\n    function removeDuplicates($s) {\\n        $len = strlen($s);\\n        if ($len <= 1) return $s;\\n        $l = 0;\\n        $r = 1;\\n        while ($r < $len) {\\n            if ($l >= 0 && $s[$l] == $s[$r]) {\\n                $l--;\\n                $r++;\\n            } else {\\n                $l++;\\n                $s[$l] = $s[$r];\\n                $r++;\\n            }\\n        }\\n        return substr($s, 0, $l + 1);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    function removeDuplicates($s) {\\n        $len = strlen($s);\\n        if ($len <= 1) return $s;\\n        $l = 0;\\n        $r = 1;\\n        while ($r < $len) {\\n            if ($l >= 0 && $s[$l] == $s[$r]) {\\n                $l--;\\n                $r++;\\n            } else {\\n                $l++;\\n                $s[$l] = $s[$r];\\n                $r++;\\n            }\\n        }\\n        return substr($s, 0, $l + 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389255,
                "title": "c-simple-easy-to-read-99-25-100",
                "content": "We create an output array the new string will be written to, we have a variable that tracks our position in the output. We loop through the chars in the input string, if the char equal that last value in the output array, then we skip the char and decrement the position variable to \\'delete\\' the last char.\\n\\n```\\npublic class Solution {\\n    public string RemoveDuplicates(string S) {\\n        \\n        char[] output = new char[S.Length];\\n        int position = -1;\\n        \\n        for (int i = 0; i < S.Length; i++){\\n            if (position >= 0 && S[i] == output[position]){\\n                position--;\\n            }\\n            else{\\n                output[++position] = S[i];\\n            }\\n        }\\n        \\n        return new string(output.Take(position + 1).ToArray());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string S) {\\n        \\n        char[] output = new char[S.Length];\\n        int position = -1;\\n        \\n        for (int i = 0; i < S.Length; i++){\\n            if (position >= 0 && S[i] == output[position]){\\n                position--;\\n            }\\n            else{\\n                output[++position] = S[i];\\n            }\\n        }\\n        \\n        return new string(output.Take(position + 1).ToArray());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352182,
                "title": "go-golang-0ms-clean-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Remove All Adjacent Duplicates In String.\\nMemory Usage: 6 MB, less than 100.00% of Go online submissions for Remove All Adjacent Duplicates In String\\n\\n```go\\nfunc removeDuplicates(S string) string {\\n\\n\\tstack := []byte{}\\n\\n\\tfor i := 0; i < len(S); i++ {\\n\\t\\tif len(stack) != 0 && stack[len(stack)-1] == S[i] {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else {\\n\\t\\t\\tstack = append(stack, S[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc removeDuplicates(S string) string {\\n\\n\\tstack := []byte{}\\n\\n\\tfor i := 0; i < len(S); i++ {\\n\\t\\tif len(stack) != 0 && stack[len(stack)-1] == S[i] {\\n\\t\\t\\tstack = stack[:len(stack)-1]\\n\\t\\t} else {\\n\\t\\t\\tstack = append(stack, S[i])\\n\\t\\t}\\n\\t}\\n\\n\\treturn string(stack)\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338065,
                "title": "php-solution-20-ms",
                "content": "Runtime: 20 ms, faster than 93.10% of PHP online submissions\\nMemory Usage: 14.8 MB, less than 100.00% of PHP online submissions\\n\\nNo arrays; no splitting; no joining.\\n\\n```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $S\\n     * @return String\\n     */\\n    function removeDuplicates($S)\\n    {\\n        $end = -1;\\n        for ($i = 0; $i < strlen($S); $i++)\\n            if (0 <= $end && $S[$end] === $S[$i]) $end--;\\n            else $S[++$end] = $S[$i];\\n        return substr($S, 0, $end + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\n\\n    /**\\n     * @param String $S\\n     * @return String\\n     */\\n    function removeDuplicates($S)\\n    {\\n        $end = -1;\\n        for ($i = 0; $i < strlen($S); $i++)\\n            if (0 <= $end && $S[$end] === $S[$i]) $end--;\\n            else $S[++$end] = $S[$i];\\n        return substr($S, 0, $end + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 333614,
                "title": "python-stack",
                "content": "```\\ndef removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        for s in S:\\n            if not stack or s != stack[-1]:\\n                stack.append(s)\\n            else:\\n                stack.pop()\\n                \\n        return \\'\\'.join(stack)\\n```",
                "solutionTags": [],
                "code": "```\\ndef removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        stack = []\\n        \\n        for s in S:\\n            if not stack or s != stack[-1]:\\n                stack.append(s)\\n            else:\\n                stack.pop()\\n                \\n        return \\'\\'.join(stack)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 306186,
                "title": "python-easy-solution-using-stack",
                "content": "```\\n# Main idea is to use a stack and keep popping the top element if it is same as the current element in the string\\n# Return my_stack as string \\n\\n# This may not be efficient but one of the approaches to solve using stack. Upvote it if you like the solution and do comment if you have a better solution.\\n\\nclass Solution(object):\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and my_stack[-1]==S[i]:\\n                my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return \\'\\'.join(my_stack)\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\n# Main idea is to use a stack and keep popping the top element if it is same as the current element in the string\\n# Return my_stack as string \\n\\n# This may not be efficient but one of the approaches to solve using stack. Upvote it if you like the solution and do comment if you have a better solution.\\n\\nclass Solution(object):\\n    def removeDuplicates(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: str\\n        \"\"\"\\n        my_stack = []\\n        for i in range(len(S)):\\n            if my_stack and my_stack[-1]==S[i]:\\n                my_stack.pop()\\n            else:\\n                my_stack.append(S[i])\\n        return \\'\\'.join(my_stack)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 303366,
                "title": "c-beats-97-without-extra-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        std::string res = \"0\";\\n        for (int i = 0; i < S.size(); i++) {\\n            if (res.back() == S[i]) {\\n\\t\\t\\t\\tres.pop_back();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres.push_back(S[i]);\\n\\t\\t\\t}\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string removeDuplicates(string S) {\\n        std::string res = \"0\";\\n        for (int i = 0; i < S.size(); i++) {\\n            if (res.back() == S[i]) {\\n\\t\\t\\t\\tres.pop_back();\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tres.push_back(S[i]);\\n\\t\\t\\t}\\n        }\\n        return res.substr(1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 298585,
                "title": "javascript-using-regex-and-replace-52ms-36-5mb",
                "content": "I haven\\'t seen any solutions with regex and replace so I figured I would share mine. It took 52ms and used 36.5MB of memory.\\n\\n```\\nvar removeDuplicates = function(S) {\\n    const regex = /(.)\\\\1/gm;\\n    let startLength;\\n    \\n    do {\\n        startLength = S.length;\\n        S = S.replace(regex, \\'\\');\\n    } while (S.length != startLength);\\n    \\n    return S;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeDuplicates = function(S) {\\n    const regex = /(.)\\\\1/gm;\\n    let startLength;\\n    \\n    do {\\n        startLength = S.length;\\n        S = S.replace(regex, \\'\\');\\n    } while (S.length != startLength);\\n    \\n    return S;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1565616,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1568144,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678613,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1630350,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678858,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1919739,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1575390,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678476,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1675023,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794577,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1565616,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1568144,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678613,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1630350,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678858,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1919739,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1575390,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1678476,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1675023,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794577,
                "content": [
                    {
                        "username": "gunsnroz",
                        "content": "In LC 1047, we\\'re asked to remove exact two consecutive letters.\\nThe follow-up questions are:\\n1. remove exact K consectuve letters\\n     see LC 1209 (https://leetcode.com/problems/remove-all-adjacent-duplicates-in-string-ii/)\\n2. remove K or more consecutive letters (left-to-right removal order)\\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush\\n\\t- code : stack solution\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/342375 \\n3. remove K or more consecutive letters and find the shortest string after the removal \\nhttps://leetcode.com/discuss/interview-question/380650/bloomberg-phone-screen-candy-crush (See the Follow-up)\\nhttps://leetcode.com/discuss/interview-question/309064/google-phone-interview-remove-repeating-numbers\\n\\t- code : Recursion+Memoization\\n\\t\\t- https://leetcode.com/discuss/interview-question/380650/Bloomberg-or-Phone-Screen-or-Candy-Crush-1D/343992\\n\\nHope it helps.\\n\\n"
                    },
                    {
                        "username": "spookie886",
                        "content": "THANK YOU for posing the followup question and the interview experience link"
                    },
                    {
                        "username": "Lily_Tennant",
                        "content": "I do not understand.\\nAccording to my interpretation, the goal of this question is to remove duplicate string until there\\'s no any duplicate string can be found.\\n\\nAs the example test case shows, \\ninput \"abbaca\" should output \"ca\", because:\\n**\"abbaca\"** --remove duplicate \"bb\"--> **\"aaca\"** --remove duplicate \"aa\"--> **\"ca\"**\\n\\nSo I implement my code so that it remove duplicate string repetedly, but it fails at test case **\"abbbabaaa\"**. The system says that the expected result should be **\"ababa\"**.\\nCompared to the example test case \"abbaca\"->\"ca\", I think the processing of test case \"abbbabaaa\" is supposed to be:\\n**\"abbbabaaa\"**-(remove duplicate \"bbb\")->**\"aabaaa\"**-(remove duplicate \"aa\")->**\"baaa\"**-(remove duplicate \"aaa\")->**\"b\"**\\nWhy would the expected result be \"ababa\"? If the meaning of this question is to remove duplicate string for only one time and remain one character for each, the example test case shouldn\\'t be **\"abbaca\"-**>**\"ca\"**. These two test cases are contradictory.\\n\\nTest case \"aaaaaaaa\" and test case \"aaaaaaaaa\" are weird as well.\\nThe system displays that the expected result of  **\"aaaaaaaa\"** is **\"\"** while the expected result of **\"aaaaaaaaa\"** is **\"a\"**.\\nWhy would it be like that?\\nDoes it want us to remain one character for monotonous input string based on whether its length is odd or even? I didn\\'t see that information in the description.\\n\\nI think It\\'s so weird. I cannot figure why. I don\\'t know why your guys\\' code can pass all these paradoxical test cases.\\nIt\\'s really disappointing to find out this question is so full of loopholes after spending some time writing a solution for it.\\n"
                    },
                    {
                        "username": "Aman_Tripathi1dec",
                        "content": "since the question has mentioned duplicates that\\'s why you are supposed to remove two elements at a time. "
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "Duplicate by default means twice in occurrence"
                    },
                    {
                        "username": "jithi121",
                        "content": "[@ghugeshreyas](/ghugeshreyas)  Just 2 bro"
                    },
                    {
                        "username": "ghugeshreyas",
                        "content": "Hi [@Lily_Tennant](/Lily_Tennant), I believe the main aim is to remove 2 duplicate ADJACENT characters, until there are none left.\n\nFor instance: TC - \"aaaaaaaa\" has 8 a's, hence your code should discard 4 pairs of a i.e 8 a's in this case.\n\nBut for TC - \"aaaaaaaaa\" you still remove 4 pairs of a's i.e 8 a's and hence your output demands a at the end.\n\nLastly, for TC - \"abbbabaaa\"\nStep 1 - remove 2 adjacent b's, making it \"ababaaa\"\nStep 2 - remove 2 adjacent a's, making it \"ababa\"\n\nTherefore the final answer being ababa. I hope this helps!"
                    },
                    {
                        "username": "kevv96",
                        "content": "use stack -\\u203F\\u25E6"
                    },
                    {
                        "username": "ShubhamRathod",
                        "content": "can you explain why deque is producing result which consumes less time than stack??"
                    },
                    {
                        "username": "sayadav96",
                        "content": "Mine works for all the small cases but , it show TLE for extremely big case, i don\\'t know how to optimize\\n----------------------------------\\nclass Solution {\\npublic:\\n\\n    int hasDupAt(string s)\\n    {\\n        int index = -1;\\n        for(int i=0; i<s.length(); i++)\\n        {\\n            if(s[i]==s[i+1])\\n            {\\n                index = i;\\n                break;\\n            }\\n        }\\n        return index;\\n    }\\n    string removeDuplicates(string s) \\n    {\\n        while (hasDupAt(s) >= 0)\\n        {\\n            s.erase(hasDupAt(s), 2);\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "ShashidharAngadi",
                        "content": "You can use strings only ....with different conditions such as index i==0 , i==s.length()-1 and for any middle indexed cases.... you will get the desired result\\uD83E\\uDD1E\\uD83D\\uDE0A\\uD83D\\uDC4D"
                    },
                    {
                        "username": "chrisake",
                        "content": "you could continue the search from the point you left it after finding a duplicate and not start over from the beggining"
                    },
                    {
                        "username": "Saumya2004",
                        "content": "yea same problem"
                    },
                    {
                        "username": "RegexSage",
                        "content": "use stack push pop concept"
                    },
                    {
                        "username": "riyan372828",
                        "content": "[Watch](https://www.youtube.com/watch?v=9S0yc2UeEAQ)\\nhttps://www.youtube.com/watch?v=9S0yc2UeEAQ\\n\\n\\n\\nAlso you can SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the daily leetcode challange solution.\\n\\n\\n\\n\\n\\n\\n\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n**If you find my solution helpful please upvote it.**"
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution.\\n"
                    },
                    {
                        "username": "YogeshAgarwal123",
                        "content": "Can anyone please suggest me selective  questions of stack for solving so that I can Improving my thinking ability as well as save time in doing unnecessary questions"
                    },
                    {
                        "username": "Chouhan_Gourav",
                        "content": "Look for stack playlist creater by aditya verma.\\n(here)[https://www.youtube.com/watch?v=P1bAPZg5uaE&list=PL_z_8CaSLPWdeOezg68SKkeLN4-T_jNHd&ab_channel=AdityaVerma]"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "we can solve it by creating another string and storing the character which does not have any duplicate character"
                    },
                    {
                        "username": "mahesh_1729",
                        "content": "Nice question for beginners \\u2705"
                    },
                    {
                        "username": "sharkzz",
                        "content": "TLE slaps very hard"
                    }
                ]
            },
            {
                "id": 1794544,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1569543,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1973014,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1776047,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1574539,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1572692,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2061191,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2040648,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2031753,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1977159,
                "content": [
                    {
                        "username": "sharkzz",
                        "content": "can anyone tell me why i am getting tle in this though it\\'s O(n) solution\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string str) {\\n        stack<char>s;\\n        //s.push(str[0]);\\n        for(int i=0;i<str.size();i++)\\n        {\\n            if( !s.empty() && s.top()==str[i])\\n            { \\n                s.pop();   \\n            }\\n            else\\n            {\\n            s.push(str[i]);\\n            }\\n        }\\n        string ans=\"\";\\n            \\n            while(!s.empty())\\n            {\\n                ans=s.top()+ans;\\n                s.pop();\\n            }\\n      \\n\\n       \\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "harsh03302",
                        "content": "you should start your iteration from 1 as you have already push the first element"
                    },
                    {
                        "username": "Aanchall",
                        "content": "Instead using ans+=s.top(); then reverse the string "
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "im also getting TLE........\\nsame logic "
                    },
                    {
                        "username": "Nexro",
                        "content": "When the test case is \"aaaaaa\", it returns \"a\", but why not return \"\" ?\\n\\n![image](https://assets.leetcode.com/users/nexro/image_1561439982.png)\\n"
                    },
                    {
                        "username": "Knightwing1941",
                        "content": "There are an odd number of a\\'s. Which mean is that there will be one a left after you remove all the pair\\'s of a\\'s."
                    },
                    {
                        "username": "the_invincible_coder",
                        "content": "total 9 a\\'s are present and you aren\\'t removing 2 a\\'s at a Time"
                    },
                    {
                        "username": "chrisake",
                        "content": "you remove 2 adjacent equal characters at a time so in the input \\'aaaaaaaaa\\' where there are 9 \\'a\\'s you remove 4 groups of \\'a\\'s so 8 \\'a\\'s and the 9th a remains at the end."
                    },
                    {
                        "username": "suryadevsingh",
                        "content": "because when you remove 8 \\'a\\' then 9th \\'a\\' will remain unique only."
                    },
                    {
                        "username": "Pandit2408",
                        "content": "as the number of  \\'a\\' is odd answer is a\\n"
                    },
                    {
                        "username": "bcbowen",
                        "content": "I missed in the description where it says a duplicate removal consists of finding \"two\" duplicate characters and removing them. My initial implementation removed all duplicate characters, so cabbad -> cd but also cabbbad -> cd. It seems from reading the comments that the answer would be cabad, we remove 2 dupe b's, then leave the remaining one.  "
                    },
                    {
                        "username": "Coder-Haris",
                        "content": "I also made a similar mistake and wasted so much time on that"
                    },
                    {
                        "username": "ashutoshrai126",
                        "content": "can anyonw tell me why this code only works upto 104 test case ?? what\\'s the issue let me know with this easy approach \\n\\n\\n   string removeDuplicates(string s) {\\n<!--  i wanted to know why this commented code works only upto 104 test case [note : only commented code] -->\\n        // long long int i =0;\\n        // while(i < s.length()){\\n        //     long long int j = i+1;\\n         \\n        //     if(s[i] == s[j]){\\n        //        s.erase(i,2);\\n        //         i = 0 ; \\n        //     }\\n        //     else{\\n        //         i++;\\n        //     }\\n           \\n        // }\\n        // return s;\\n}"
                    },
                    {
                        "username": "amank8525",
                        "content": "At test case 104, your code throws time limit exceeded because the test case is too long and your code scans the whole string when it finds and removes a duplicate array because you set  i=0 after erase function. Try to store i in a temp variable do i=temp-1 after the erase function. Also remember the edge case that if temp=0 then \" i \" can\\'t be zero.                     \\n            temp=i;\\n            if(s[i]==s[j]){\\n                s.erase(i,2);\\n                if(i==0){\\n                    i=0;\\n                    j=i+1;\\n                }\\n                else{\\n                    i=temp-1;\\n                    j=i+1;\\n                }"
                    },
                    {
                        "username": "mastercoder",
                        "content": "`reduce(aaab)` should be `b` not the expected code run `ab`"
                    },
                    {
                        "username": "nagarwal3569",
                        "content": "only remove 2 adjacent characters at a time"
                    },
                    {
                        "username": "ClayLj",
                        "content": "Is there no C language solution of this problem?"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "It\\'s an easy question! you just need to create an empty string and need to compare it\\'s last character with the original one"
                    },
                    {
                        "username": "TusharSharma2003",
                        "content": "what is wrong in this code\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) { \\n       \\n      while(true){\\n        int i = 0;int flag = 0;\\n       while(i<s.size()-1){\\n           if(s[i] == s[i+1]){ flag = 1;\\n               s.erase(i,2);\\n           }else{ i++;}\\n       }   if(flag == 0 || s.size() == 0){\\n           break;\\n       }\\n        }\\n  return s;  }\\n};    "
                    },
                    {
                        "username": "udhavnegi960",
                        "content": "You have not changed the value of i in if condition."
                    },
                    {
                        "username": "lokeshsharmacp2023",
                        "content": "Please can someone tell why limit exceeds on very long input string....... `your inline code...your inline code...` `your inline code...your inline code...`\\n\\n\\n\\nclass Solution {\\npublic:\\n    stack<char> st;\\n    string smallAns;\\n    string removeDuplicates(string s) {\\n        if(s.length()==1){\\n            st.push(s[0]);\\n            return s;\\n        }\\n        smallAns=removeDuplicates(s.substr(1));\\n        if(st.empty() || s[0]!=st.top()){\\n            smallAns=s[0]+smallAns;\\n            st.push(s[0]);\\n        }\\n        else if(s[0]==st.top()){\\n            smallAns=smallAns.substr(1);\\n            st.pop();\\n        }\\n        return smallAns;\\n    }\\n};"
                    },
                    {
                        "username": "userkaaname",
                        "content": "//this gives tle on last second test case, i know other approaches to solve but can anyone tell me what was the problem here?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        while(!s.empty())\\n        {\\n            int flag=0;\\n            for(int i=0;i<s.length()-1;i++)\\n            {\\n                if(s[i]==s[i+1])\\n                {\\n                    flag=1;\\n                    s.erase(i,2);\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1951716,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1932231,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1930296,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1919713,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1876828,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1849645,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1838820,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1824934,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1783619,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1760378,
                "content": [
                    {
                        "username": "ram_muchhal205",
                        "content": "I am getting TLE for this code for a particular testcase no.105 having huge input .  Can anyone plz tell me why ??How can I optimise my code.\\nP.S. - I don\\'t wanna use stack :)\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0;\\n        int j=i+1;\\n        int n=s.size();\\n\\n        while(i<s.size() && j<s.size()){\\n            bool removal = false;\\n            \\n            if(s[i]==s[j]){\\n                    s.erase(i,2);\\n                    removal = true;\\n                }\\n            if(removal){\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n            j=i+1;\\n        }\\n        return s;\\n    }\\n};\\n"
                    },
                    {
                        "username": "userkaaname",
                        "content": "got solved?"
                    },
                    {
                        "username": "summerSorted",
                        "content": "I don\\'t know why its showing runtime error when its clearly working on my local system can anyone shed some light\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st;\\n        st.push_back(s[0]);\\n        for(int i = 1;i<s.size();i++){\\n            if(st[st.size()-1]==s[i]){\\n                st.erase(st.size()-1,1);\\n            }\\n            else{\\n                st.push_back(s[i]);\\n            }\\n        }\\n        return st;\\n    }\\n};"
                    },
                    {
                        "username": "avi_gangurde7227",
                        "content": "same bro"
                    },
                    {
                        "username": "Aditya_Jangid",
                        "content": "For beginners here is the solution \n\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        for(int i = 0;i<s.length();i++){\n            if(s[i] == s[i+1]){\n                s.erase(i,2);\n//for normal cases like aabcd,bcdaa\n                if(i>0){\n                    i = i-2;\n                }\n//for special cases like aaaaa, bbbbbb, etc\n                else{\n                    i = i - 1;\n                }\n            }\n        }\n        return s;\n    }\n};"
                    },
                    {
                        "username": "Marre-86",
                        "content": "[PHP] I tried to solve it in 4 different ways (recursion, iteration, converting to array, iterating over pure string) - and no luck. TLE on 104/106 testcases passed :("
                    },
                    {
                        "username": "GaganSharma",
                        "content": "The best and easy way to doing this question is using stack.\\npush the string element in stack it stack is empty or st.top() is not equal to the next element.\\nwhen make a new string from remaining the stack string.\\nthe final step, just reverse the string and return final string.\\nIn this way it is easy to understand the question.\\nUPVOTE if you like this solution."
                    },
                    {
                        "username": "ruchitakb7",
                        "content": "case 93 !!!!!!!!!!!"
                    },
                    {
                        "username": "BatMe",
                        "content": "Explain why it failed on testcase 104 showed tle\n \n\n int i = 0, j =i+1;\n        while(j<=s.length()){\n            if(s[i]==s[j]){\n        \n                s.erase(s.begin()+i,s.begin()+j+1);\n         \n                if(s.length()!=1){\n                i=0;\n                j=i+1;\n                }\n                else{\n                    break;\n                }\n            }\n            else{     \n                i++;\n                j++;\n            }\n        }\n        return s"
                    },
                    {
                        "username": "akshatjain7806",
                        "content": "the approch is easy there are 3 case in this program if we use new string method \\nin first step we find if string is empty  store first element means s[i]  in second step check the last element of new string if its not qual to  s[i]\\nso we store in new string ans if its qual we also store s[i] but after store we popback the last element of string 2 times \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string k;\\n        int i = 0;\\n        for(int i = 0;i<s.length();i++){\\n            if(k.empty()){ \\n                k.push_back(s[i]);\\n            }\\n            else if(k.back()!=s[i]){\\n                 k.push_back(s[i]);\\n            }\\n            else if(k.back()==s[i]){\\n                 k.push_back(s[i]);\\n                 k.pop_back();\\n                k.pop_back();\\n            }\\n        }\\n        return k;\\n    }\\n};"
                    },
                    {
                        "username": "adiraj04",
                        "content": " class Solution {\npublic:\n    string removeDuplicates(string s) \n    {\n        long long int j=0;\n        while(j<= s.length() && s.length()>=0)\n        {\n            for(long long int i=0; i<s.length(); i++)\n            {\n                if(s[i] == s[i+1])\n              {\n                s.erase(s.begin()+i, s.begin()+i+2);\n              }\n            }\n            j++;\n        }\n        return s;\n    }\n};\nWhen I submit this, it gives TLE for a testcase but when I use that testcase as an input it runs successfully. Like How?\n\nThis is the input \ns = \"gelqldwkvxejndcmnkevcwlhiknxanphpdblahpgjeuygkbuobulfpvpbnmwovlsjyltibyqmsvphjimiuqvsncndsghdwcyojfgojwfifyacjpmdydpuwrfooedrpgajamopxqgtkwtkwijxugfbyievinfpdyqyueldjwsapmockronowrikuceaqnlgtmifehfhuyjfygfqwhefcswbinxjwjmclelxtiwcdfqowxlgcotlaavxlvoknunfumbkkpuliyblqxgqtgvxgljadcuhvvhmxkbuaomesfgvgvmanfvfilxpbmmtofotvsdmtblleapomywdcmjbudqntfxncjgcsyfpwnokprmjkkyrmgoytulxudvbxvbfeyqimjcirxsrwlvbgjipxxkaxjhetewptavrvhewdbvuahkbvflhlsabxmftbovafmikiaetylahfegdekmuwwdqutggcsupfaqruvxqsbfsddeaiyiypoktfxqmfyoeaiudjhpqidryschtvrfxgcgrirwajevlgjfslgtgrypjfeajbjdoaebpeprpwsohvgihjbykckwypmlqysrgturmcxqcbckohjqlkswgwqpqnriipmmokosulqbnduyygrsdyglxlregxivcjvsmomrtrxuetttdmsnbmuqciqibffacgnvlqmwscshxuvvvtwbjppktqututxqdvycdcupukbaayoqfioexovnnffyatoqrmapjbwnpdntikffdaouqlxaurtllyesgevyyhmtmcxcxewekiqmyjkvgibgywnxdvmlevscnmmmuoffklklbfuwxuadqpmjgbnryrnulbtdxagmjsxhqxetqvapimcaovfpnetndwtrirvbhqklkiiqepbjejecjlxrcjhbmlgklqsunblfimofmjnlodhqiqkclulsxtnurbmfgonypqmstcktvywjtkjqtcexllhuamgfwxthtbmwyadxutepbsrtkhgsuswisdbkhdibaplcgogatfeejcjlgffsquclfryieoegocnnhugqgrravykwncdnibniehgvqoxdyyajminevrpugqdbecjltqdarunlypaqokiwkveipfwegdbybcuperilwrobnqdhxwfdnkdbtvcntxfnluioaxyposkwjqrwponmhomnsgrnmxkjnvreqbcwxkdhbsnjhqhdtqrqfjrhylggxgwtxchwnrklhwdjjvunwuwfnlssijmkubmbcbgsquifmefxddkhhkcnblmndiklallxkssiootryvbunkossebobnsmredjtqoxanmejafippyehxcqhstilrftvcwtcmpgxwvubbtxobuudvljfkelphxlfuwefcpwxnmdidlxvachfakdrgbfijvhmkbkumpaedfaxmslrllqfawdqcmihjrjpbhchytdjvmypxjbkxqxnmkusohdjqowrhlgardjlswlggpkmqystjurajwtirsrsbgqndeiwgdoltytreguodvymekggvbtqjuufohukiaipwixtujlsgsgmehhorqeqvgdqvwxrobudkmfojdmqxanitxutgwvdlmwndslxueuybxtuwjjjrrvnynqbqtxtfxiejlgpnolwfpngqelfmplpbqweskujfgevkvdmrowruewfbwilfilslpeltwhamfpydtnivjhrhqdvwuptnbebrlhgodoajridcgeakwnatoxkiirugjxephpdogcsocfrgaobqekfjnmoqcmqerclgfspscfsoycshmrotlokwbexmueifpvuuuqdyacedlfomhfhjmgyuxrtxpiumikcemluismjvlgirofvmthrbaiagadludguiktnwplcavghvhxeadlqaidmwoaexuvfdjmsgjrmwgkrqhjeqwqnbwmdlitmaaakertjdveeopjsreivocqsvdrfcsbrtuswblfgkkhqcvhdbwroruvumdqfjwcxqgfxpnrrudrewohiinsayfacestnkonirflciepiqjjnjxliqpvdqxmtbeyqnyxhyiajhgvtnhdsxcuobwlcepljwopemwswqlmrqfufafyskmkdbdddxqgiacbbhjkimpejkgnlrhyucmddmnrbmsdushyilfiodsmryvpkfrcsufoupebfsqawmknkkiqqrihndbmvrqergmrxhiojcqirhwqqwnoiaahvmyonbbwnqekysahkvdhsmdeyddespxwynyvokycvdpqswpengdeymoexjnepinjinxtogddseibtxvbhdrrdmhyjhuunpdokwnrgyhmitmfgctpeqbttbcftedhdfesyrdewtncfcopmlsjmfmmrrhfmdkydaykkgkkcmnkvjgufkaybvdoatokfiexubuihtbwvcuabirayalfoymhucaxhhuqcsdlbxoxwaibqctcwknhbmribbvltgshulrtlpaqqdwxllpfjiufddlicvjweegqtgcwmrcdfawyxukpltqrhrgxyyomyyngwtjvggrkpkynlfksioldcuqhygsqolsmatxvdymghguxswsovbalondhobxsyrvnfkbmlrqpmuwowaoeubwcyoyvfpsxggxvvpahexndistpyfslelisvemyohfxmwjlhscdmycmnslxfpbqjovvubvuevmtyarfyetskxnjuyhaxniclresmkoelvohmjirmwmjsfqssblteplkujqcpxainhahvceonhypcqiftexatllxvsmadurdtehkramdpwcqeosyxewwivxephbrgwtsxtfpvrxtsitlpjcjhxhpjjvbgrqbmdpoyiotroafvfgfhygthyjytymrkpmuqxputgvfdumpkifqrsvgftvpocyabqikgyutavcgjruuthydwjqnexfnbdehpkrriicpldfrbxlvrhqlkyeicawwbnugwlodckgbjjrwvawhdxniisppmqnkojcbxkjabqenrdbmunohnmurubhyfqoxbwuytjsyphaaltucupygqpkhpowwxsqthdivocicfdvvragptvdislhtclhxkwxilrsdvgahfqgtjycrykgeberqfrbexyhjvxmgjwppfmxtntyahlldcwxruhdkfyogynjuqxigutkghryfvvkxaxcjhgiokrmujvnloykffilruscmsdmxguxrhqobsbatkbuahlfriwkrhmmolpjwqnqirmovfrlsetynuqvfsoecnypoggtylnygvnhjivhhkbsrsmfirhutiklkfbsgxbgwceuexnaxxmrwqgppjqqnkwrgelhqxsmedlcuyhgivlxcvldhvaequinhgnmohkooqacbvvhrbtwyqaprimjbrbkbqqpwphtbkyscwlhmwmntdglwqktayhfouoaeiearnfmgahwwybgpltswlhgrcmrophnpbqvnqcdawikkxkmdmwkxnrlmnqdffwfgdpmxttsttlbgtynivaiklgyxxswmecyrnpibgdharfawvivksqkgyybqnvaugekpxjoghgbrqaomfuqjlcbetgtnbxfguwiggeowxanxkycgfmbfaoeeruisjpqgkyemtufbpuafrrsrhhykggalfxevqxtblbvmiaruesotlkgibbrgnmdlghpowgjlxprmwjpksehktbsfjsxvbmlutyllqwyqjnofeejypedkbkheivgenoqbkugimapsibmqbiedhumhlwjhayooyffncbtsiigcvyygpdueywoptykiqydetohjocobiwjkkapoxvnvbhwsoxctnknadhlsedxjhrvprqtnpaghxquwxyllvtpbnihgblhycifumtemnpfiybmicyhvkhgjugrxcdsxxankxkmfwlbmwgybyweoqmeiimgussqsibixtudspfrqatofpohpmfyahjebrpggvgsrsrvqvglamjxpfkwtbhdskqftjsmskiqdkdnacskwkqkggufyjsvggpjuxlkgcoabluhrvihauadasoajfrakywjfxhlomkwuwywwxvfvnfkvjhaludckeuiuiajkhfixufcrabtlyjvroxirvqpuovnpdkjvypnpbpbwptxyansqvyyhgigvaoudriccknkrnjxnqbqdxswfgxofwfrkwfjfsmxfcjjjqnihehnevqcxiqbvqfexrockgaknordeldrxgxrodtxrhaslggcqsupmbtqvjpylgdhvxeqpfipctlodkgbvjkrvpxuuwaoepvgpcdllotmvpevpdjfepiqlkufqgdeppsactyfgwilpraxcmeryjuhypfvaerxahnbwhekmlwyruvddvnlenwiviijpwgaeveqmacijttblppmxohriimurvpheaucckvxleyndvextbiqgjynpsokqinovisacumbbxnenpakfbfdguxcduqckumxijevyktwbpqciufnfwbnvucumnhiwxdnmlqyadxdqyaysfphvvubgtmjfalnnrutviulqocyvmktcurnqgwuthwqxyinplxecgeeknijftsxojesbjmjahgptxoilcpgclwigfxsgoxdmvmkcrcnpibwnqspbxhxcpnqoyyiempyoalegipuodqfibbgirgllttlukwckxfkixxycuyimpqbnojbqfcvssbergpdxbtvvanvusfvgedwsaidpxtnyikkfsfgtdjufcyhbqxdhevxemrrnspwtutvdoayemxxwthbqgqrswduitkjyhtwnqgfybsdvvwvpelwhhqhorrvvmodujixqphhfifqblyxcltpfddpnnnhskwikujhtpmcbvmiupaekjeffgnyinbtjuusxkpflveonceywshfjyaytvclptbvumxcbwnjledduwkwbnsxxkoqnuqgxpiedclcbqtfxfvyuyfhchdhbwdkrmyfnovhvrorfgfavpaslhmurucqwbespplqpscclfhgjbayvhrwknwbbajyxsatweguqgdlncnawyfwvvdoiogfhjfaiyroeeonqtbnpxqwltxlestbupbhcqmftxplnxkfaypdntlapnkqqnueqrciojodgloywwiryjrtkjlvvbohwlnggwavtrjxdpurbdfghaclbtqjmxuvfolhbtnktijoumnflearoohbfiresghjmjdygotiqmrypdebajaibetkmqsxgfrsbschqhfcoamqddojrgukxnjmbopicnrxbwyvjhuinngbyphpyfumtdgqkbckxbsfoihbvcaiiuskwpmjwcolttqvfveutyworqniosvtiefoginenshgnupbrijsyqbvowhbibqoetcdubxtmkktvhclclfgmkjpxunluoiwepcpdpwxgajpnndenskohxftuveviojiauqvbepcdtqqhragsfvfqhudxyraaqmahtuouwkkjswiatwkbhcarwmpxxydeawntsnghcjvudsvdcrkactopvrinjhmwivxmcdrcrpxbswvtaduuatajowilmaspdkpnjwgmkuiaehqnlmglcsomqrmgrtmkyfqpkecvwprbioebrxinudswkflqgowvoftjtjmajfbyyqjvsvfeqfbntrlorpmtpvgpabibhpovvagcxtgwgclleepdpjwiljkwjfbikqquheraoippyuyqpnjinjfxnmcikscolcbguhbxkrpbdnuednpafmbqvdwvfijbhossferkayvbfmktuelbmjirrbvlbidwvekumbtygniawfgrtgpafwhgxaqvswkqjwfbdmkrwmnlsududynaspbyhnjjqrwqlrncxjcyvqexccxsyetqmwlivbewdpxmbuiqvpdaqneeldmpsfrskvrgujsspkxmpxrinypkuhsjcowjdaavbbnodsttsiipytnujvkubbmatjgaicjkrdfjqkeseclndrcsuipkufiqdusetgpkgmdfckjdprevexutwstkfsreqvfryshwadvcmbewcqetkhhrydmkcawhoralyglsivppcltseoyloyimubrbbwxcrwyqftbewixotbkowwjigoewnbhuvffwtfbudagklpwipdhgwlsahcxfsjvhvcnylbwpseyrkrxcmcqgkewnyrrtmchrtdheradutannixymvwnnbdvlsbefdhumbilqdftnklgoraomxgaeohtyqesrfcrnxsevrdefemlhihfjhwavcnffxmrooedpuetlwlpkfyoxnbftlorhykkqtcqbcatxsgdmxfjywtusvuwkenexhcohcrkrpifcggxnhpgghjteadhvybbavibgvsvvidqlrmsynklxkaxdnicqnyptwvkdnsmwohisupcdnmnhhvlkcggvbkrenuhguqhanplwcmhbquoselmobqpjokkkyxntfseiwnrbulkvjdqtfqpmdbquihhyffkwnvqpjtgmmgninygdpqqlojsucymeqfpgwjhoibcpegqragaaiaqrmklmlyqmvwumpmhticogoqvqjqqpnexfcocwxwrokbwbnnvfuyjpehmrtlnrcdpkaispofvcwljppxjtodlaxuqpmymyhdfovbmrqtyyaaylnjlntatinkrnonopaaclqhelkibqmkqywsloinqslujuetxknxdhnmskrwvaulfxxjaikcmmoarlgygonbdxfjuwodnayouaspqxuabqhaftsytdcubyntntdykcplqmyyijfaetppubvwdtdyjemvihslqlynjlkkymtmnmowybplmyfgvyjljrymwieckgwjmjmieiluuvoyxocbgnnldnwpcsjufbjgqlnwosoamwincmwtvmgaabvhnccnpntyjgwxlgavcvluhnjlluixgspwjvaqmgthmrxmardheqljfmtsvupptphwyjeqqqmnqfnvjrgrawmjuosimtgcuhfrkyskkrgiyndiuwawyjrxjukhwdrmgydktpyhgyhnrdugxveopppmfwkpleympwxeyiysiygswncvsydinguupemomukawvjidfttskparlosnycvmvhlytcabbluovjoevdgidsnhelmyidgfvtswbccdgbvetirmhcoduujyrtowfvvpcpgcddmtkguwyisyicypuqvambvyaoyobmhrxphsykahaagubebliexkdtahqjmkvudyytlpygjtxsfneapwafrbhvpdakasiibkvadwpdbvfbvrquihbougpxjjclfckflbrbngufertaaggrhqnyyndlqnkdhmbjujodxslafcnujjpuiaxhqoxspugjvmgloseriivfvsnxvjqwnscxkncsalokjphepnsrjtnnhgcbumptmpprwvcsevpgbsxbmfmtiwlmjfflmhouerljvumwrlrdbiviitajatoxkwictawrjbqemheopvgcmeblxshfqumqmcsliooelerwnrlqxsjybkntparkuerlgdwudnyjhorukxsrllgvhknivcqxbtemibvfrptdreuxtrbldwkuhgshfxxhvggdxftrrlkpbkllioamcfunebwypxusrjpschxpiceeqrpylotvtbqukapdhdqasrilsuakhhdcxmhasrxgcedjunkhkxtyxmvakcwcnplpvalimficoxlasrbqnhfnibjljcflgydqvxoqewialfqsdbhfkrxvhgmctnsjyvpideexdtkgibkoghpohblqlgnecgslqbisgxanhshlykpqijfegxcaeqocopxgwoipfavcoktowhjfoarmiabfdvnuxumqqvsrbfxjmrcdgpkiqvhrernrwwjcdmgbkmdbrjjekldfikugaffqhvqkrmvllgorwvqucsgnkhjcjaauheiqrnglbteshkkwdkrhfjvvalbcafqqwoxejimvrmsngrhiurlytksqdirykkqtudcoidoggmfwlfakkcthcvrtiwvkfswochastffpkbxmayvaqafywqyjkrgassyojtqkobphycddnkfbxhsuiisktbqnlikekfoylmhsnbnorihijtihffbioofufpsmbxmspnsqysccoseyvatlucmxhtclkiuaksedijnwfyxoehjfmhaximlsjkxmerdcdosaekfygnppavknkvmrxggmkmmsxmpcqgckgxahrravfoywmebqhlheqaeljdgrlwoqipsljcxsaicmhstlqqyfbkqacdsotbbmhvrxywdbrsstomgcxmnuxudiecobjdaoicumuemqbipvbkwimlubofpuxljuyklimqfnrkevnjyrhdhahgskegrkymncnrbeirhclvavdwfvmtgdjnawreweuliuwtleggqixnosdjfodewbolfapwqsmprixjrwkvbctmtiatokdjyanugxpdjlfpjrxekpcwjftqljenpqkuijjilahjusurlpxddbdfhacvgqxufakfhgqtnevnuursebqpppxesdkqoiyncasvriujmfbebvulhowwrrkpgvhowptwrhjuvipsmycxjhdfsypdoecrwamjhgmnwmtsvcyflsdovrgbnlmsxgsupcxkdwkadvwxcipimtowaxokowqbocitjeyudoookjnecgyoosonatjonkthbfhgbtmsxrhkubdeqouttcmxweysooqpfhuwigluxxvmkruahhtvgxmtimlddmkvyfgrsxuslfpododdmqqrptnetwvusotwpxkcqjblvoethebncrbxsumyhfbqhxglujlgrgorgbpnnlretcixnbmhinpvdpifowrmkpqgovlplrivdcvpxfhpohdelxkgwjfcvfinbhhotelxqmhgekeycowtwaxscgudwvuafffhrhfeyfygpesjxmnlvwptyxhwwojibjnwxjaqwdqrurtidmnkttobtjtbachxluulixyrdahuamdrvtxhhtistakedujwfgoakmwrilmfeekcxepreimeqdlfvokugnxqwqrlnipwwyliahhbkyjvvyfqyukgavglbmuicbroulotsojykogjfxlwjaxkqohkxjqtifcvnssfejgcxexoyaecpowvxhnkgukruhugdyglawdctfuufmnvamrsbsxvbcwiaspkfhsexjwhmcyeogjfbjxsptvcjmaunpymnecjupntdmrhywkoadufqmlpkshusulxkjytcnoocygmpbfjdxwohhluvwtqihcwqqfwdshqjauicvadkqqwisxvvyulgfunvlbnnmqyxxccbjdiwmrcestsnegxfbmsiedkieipoojrohfbpffxwshuntieabepaxrotehwueekyuxdxuxykvymrmyoilakylwyypwvjfoxvyfspxewxnatxogymucchlkdwbyltagpyfwncdmfrqvtwblckdsvkpvdlbiiqrrbrtqdvonhcowblvhpdcpvsybkxrtcerxlhlflassimbxvlowdqgntlvwugqcvrrwfyghxcdicslnonxvxekkncrtwqemgqaqbvchyimuljmchcmlvyecfluxcujaefnucggnnjqiyjsusewcvltcunnkmhrsgrbcbbpvssdioagnhgutqljrabirycpxjmcxbbkacdyivrdbmcshpwccxsdrfdkujmijchiwguneobiwnhajnlambcrpefaccekgairenuddketcadyjmweewnqnleuxttbkawdbalmkstvnpjouoglysjiwcncskoxpqktwpufrftkynqeydjblueevmwkrrtbflsiufgvclutfvhtoncqnhospijalsqcmttnuyetcokfaeujxxcxsxqelnvogrkbdxycfgeeyrmeflmiwbbcvioajudxcdrhhyfrhydbxmhjxtsnpfeknvhrpkntksvnypvxosynwoueprtnpnwybcfqnhbknjbpfgnknvgvfrfaqvdfgfapemyotgnideuevfiggltyvmwherqjnkoqqbgcbmkkwmrtgrbkmxdbhnwiehimxxrfjrpyhxxindfnoucsursvknkdcxpnqwpwmbhsrrbhroaahyhaeirnjnrwsgdkoqttbtmclklogkrrswyklhdbgostxeskmtupnvcgiktnljoaicqdpfqgfbjwsaifrtkqsbrklwivtnqrruqpxlibggaoljcgaxavhoypxnomabqgctbfulwwjmgmjuseqrtmqaoactvmqmeiriugnkyffsgonyrlhathwaivqwnrndfskpjjajgnmsajepcvydxuvdvlrkghragsfolsqbxlocoddwuxogttbcmiiesebofxcaxiladvbvduqdvmequrrlmvbsexcfervbvmtebtniipusrajaaoygesesamgkxmeepjulvsrbqywgvvdosmnmphnvlkargukieahttyqocqfrucwektjpictfecvovfmtcncbsvgpfniljfjbbjljfwekufpsxhkuejgakcvmtcluafomuqgaqvhrqjqegqglsipekfvyilgfthxxsaecioalkhgqpqlbjjbbuaeeggbwoicosfcscwddsxxbwnsifbdhyjbgiegblhqnaxcqqneksxaosdgbbonpyjrlnsxwegktlgkdylykavykyujwcoxbmesrdthcpvkbxwwyrmklaqppkgboncncfhgebsmmbewbocfeumecwrpnnjxlenyjekpgwoujeefoxmjqjisiamwjcuauwfycdymbwauucugjdtjryjyeyvnsgbkrfgtgoqsskgcdnsgssssgikfluhvspxfhifkdttmjfwlaagtfclbxldaxjtxrkjxocmmavrgkpethgmimmdvchjaahljsxbfqjewujpsplomqbxccvvgnemiuixelajfkqdheefajlxuojooatlkgjwmxwesslnexgoxwsyadpvblngayllgqvrvyohueencevkwputwdygtxjpeacjytvapafvlxpwjorkixtkbvynnwrdnuujwtrtakrpqmetxrnlcmnaswdypbcnaxkdlldutyculdcxagaloibtoakjhavvtaiywbwtdokywpvwnfnbpexqqumimhtrhnsgclflsoojetqxyhhnglkabpywqfhttahbdlhawgotqvrxcjutiriduxktumakcjbbrcfjbmcrqoejbkmskpjaplbcmxohhuvrqehhrgrmpfxngkgaweqcafumuyunhbmbpmysvocuejktssetrejxsokpqjpcdbswpxvthihbpmweidjrnjadhuuodemxuocfnavquplmkrhthvydwyamhyyxclqknflpnmasnfrrtneuegdsjenodfaobmvyxhtyayppntmgndngilsjtavehjqeqlbfoltqnapnysouhlxyagytviicxuekdcayekhjysqnmoljghuslbtogpgopqgiwkikrrbxepwmginjupwcxspdcsxcqbvjqhkmoyletkkeppcpvjovpkdcpfvicbvmcrwkshjlngfubqqufipapmicgbgyaibrchwgwpiyqqrmbuoiotbfatxmaccbhabsbykpypgdxalaycirpnymjkkpykjbstdoihrcqgwloigtauxojgjxvbditbvqeatyufuoumuafnaoeylifitckweoxjgwoofnnhhwnjdhstxfimapxshvewnldlpmdanmxugkvlembfyfecanvdtwkvnpueirkjgelltuhuwulfhuehuhdmyxmxflrqhxuavxxwnlruugrwkavrpljuxreqjeltsufnpulwewxkbipmtavinsctsyykoukesyxkuvqtroxkwxgajyebnbubokxqlpysnrkcskrmfgwlxaqlhrriqlqexxonodivfgwvrolxrbbxrbbjysrqkrtirqgwedtbwgplmpgkwymcxowgmukpmehftbmjeplqqxhibnsiqyfkuyhyrctqxjyncqdlxvrstxeqybkpmirhaoteigwlytsrtsjbjwexqtxuiykbvsluwveamforjufnpruipqwhicwbatfwnkfjqluvbokuwjvfbcqhnqwcojggungycodnoiuputsdcnvdeahfjkfdeoeelkmochfwyawqfbkolbhpwktlpwukjkygdoxdjqgvdpyeuxrffkknjjtlpsuhcqjbcrbmmxxjavtqmwllvdnfdymgexylubvgmdyoiqhimekqrdmimkujexhltjrsjmrnvvmmfjbyklorjsnhutyyvldwfspvicrsbgpvbhxkbsixjqovgjbfplytvukdyxdxriyvhjuhygvsoufwvaqbiqdqrmllevixenmlhjbbvfsoeehommmcppabtnixddblwysldqhdstywbhchccwwabsveniugcvaowwsngtyrkeonceqlyurokygxasuidqeqrmdysihoytqdnoiqsbluiwwcovrkyixyxadywfgwfomlhlwagbnwlevqkpxttqgrdjhbawadyrxclrpbpqshievuglqgaubypvatejsjenhnrtucdijfmjtohxmjbypuvlumpgddsvgbrqktbeflfglugccdptwsxsdaxctejvfwphvyrivqmnnnpyvfudvlqjurotpcmgbixsufgigeedccfcbhqrsxcpdvngjrsskqlicfysmkhwtkxnbavvjbxwmqlsdxrcnmjtbysbqkhfnpuyoxvyhjrqootwbakpmccxjfqrjdrxpdgdhvxyfybpalvsjqjrahshsxtxgyxvsubecavvldsgwliewqwfsgsfhlutkyyhpevarycrvolpnivlcxwedntsduckwofruqjysggadululitltiahltfvanqotmbgbpxcptpjkhiynilnelqcwuimcmyblxxsamihgrfmlxbswialtuoxspgpioyctmhmxxvjfdnuinppgebsqarvttepwibtajxnicclsxwbxdugyvmisxh\"\n"
                    },
                    {
                        "username": "panwarDeepanshu",
                        "content": "those who are getting runtime error like AddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==4029==ERROR: AddressSanitizer: SEGV on unknown address 0x7f5ca33d6787 (pc 0x7f5ca328ffdd bp 0x7ffca0431550 sp 0x7ffca0430e70 T0)\\n==4029==The signal is caused by a WRITE memory access.\\n    #0 0x7f5ca328ffdc  (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc)\\n    #1 0x7f5ca329f12b  (/lib/x86_64-linux-gnu/libc.so.6+0x7c12b)\\n    #2 0x4a724c  (/home/student/Documents/extra+0x4a724c)\\n    #3 0x4a734e  (/home/student/Documents/extra+0x4a734e)\\n    #4 0x512a5e  (/home/student/Documents/extra+0x512a5e)\\n    #5 0x7f5ca3244b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\\n    #6 0x419e19  (/home/student/Documents/extra+0x419e19)\\n\\nAddressSanitizer can not provide additional info.\\nSUMMARY: AddressSanitizer: SEGV (/lib/x86_64-linux-gnu/libc.so.6+0x6cfdc) \\n==4029==ABORTING\\n\\ntry to use first initial condition i.e when stack is empty , do not directly compare stack.top() with s[i] \\n\\nif(s.empty()){\\ns.push(s[i]);\\n}\\nelse{\\nif(s[i]==s.top()){\\nstack.pop();\\nelse{\\nstack.push(s[i]);\\n}"
                    },
                    {
                        "username": "arshr",
                        "content": "//Whats wrong with this recursive approach in C++\\n\\n```\\nclass Solution {\\n   void rem(string &s, int ind){\\n   if(ind==0)return;\\n\\n   int val= *s.rbegin();\\n\\n   s.pop_back();\\n   rem(s,ind-1);\\n\\n   if((*s.rbegin())==val )s.pop_back();\\n   else\\n   s.push_back(val); \\n\\n\\n    }\\npublic:\\n    string removeDuplicates(string s) {\\n        int n=s.size();\\n        rem(s,n-1);\\n        return s;\\n    }\\n};\\n```"
                    }
                ]
            },
            {
                "id": 1752815,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1741416,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1740932,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1736518,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1722121,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1717508,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1713040,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1702041,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1682524,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1679754,
                "content": [
                    {
                        "username": "itsSankalp",
                        "content": "runtime 21 ms\\nfaster than 87% online c++ submissions\\n\\nstring removeDuplicates(string s) {\\nstring temp = \"\";\\nfor(int i = 0 ; i < s.length(); i++){\\nif(temp is empty){\\npush s[i] to temp\\n}\\nif(s.back() == s[i])\\ntemp.pop_back();\\nelse\\ntemp.push_back(s[i]);\\n}\\nreturn temp;\\n}"
                    },
                    {
                        "username": "Isshh",
                        "content": "My code works for 104/106 cases, can anyone provide any suggestions to make it work?\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n      while(hasdup(s)){\\n      if(hasdup(s))\\n        s=dup(s);\\n        }return s;\\n    }    \\n    String dup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)\\n                s=s.substring(0,i)+s.substring(i+2);\\n         }return s;\\n    } \\n    boolean hasdup(String s)\\n    {\\n        for(int i=0;i<s.length()-1;i++)\\n        {   char c1= s.charAt(i);\\n            char c2= s.charAt(i+1);\\n            if(c1==c2)           \\n                return true;            \\n        } return false;\\n    }\\n} "
                    },
                    {
                        "username": "hkhurana",
                        "content": "Can anybody please tell me the problem with this code?\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int count;\\n        while(count!=0){\\n            count = 0;\\n            for(int i = 0 ; i < s.length()-1 ;){\\n                if(s[i] != s[i+1]){\\n                    i++;\\n                }\\n\\n                else{\\n                s.erase(i , i+1);\\n                count++;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "gaurav0538",
                        "content": "s.erase(i,2). Use this"
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "Solution(C++) : \\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i=0, j=1;\\n        int n = s.length()-1;\\n        while(i<n){\\n            if(s[i] == s[j]){\\n                s.erase(i,2);\\n                n = n-2;\\n                if(i!=0 && j!=1){\\n                    i--; \\n                    j--;\\n                }\\n            }\\n            else{\\n                i++;\\n                j++;\\n            } \\n        }\\n        return s;\\n    }\\n};"
                    },
                    {
                        "username": "apurvanaruka1",
                        "content": "Why this give runtime error ?\\nMy code work on vs code properly but when I run code then it generate error \\n `your inline code...your inline code...`\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n         string stk;\\n        int i = 0;\\n        while( i < s.length()){\\n            if(stk[stk.length()-1] == s[i]){\\n                stk.erase(stk.length()-1);\\n            }else{\\n                stk.push_back(s[i]);\\n            }\\n            i++;\\n        }\\n        return stk;\\n\\n    }\\n};\\n\\n############################################################\\nLine 1061: Char 9: runtime error: addition of unsigned offset to 0x7fffc7dc6b00 overflowed to 0x7fffc7dc6aff (basic_string.h)\\nSUMMARY: UndefinedBehaviorSanitizer: undefined-behavior /usr/bin/../lib/gcc/x86_64-linux-gnu/9/../../../../include/c++/9/bits/basic_string.h:1070:9"
                    },
                    {
                        "username": "TERNION2205",
                        "content": "string::length returns an `unsigned int` value; if the length returned is 0, and you subtract 1, you get -1, which can\\'t be stored in `unsigned int`. Thus it results in a huge value.\\nSearch about how signed and unsigned integers are stored, and the concept of two\\'s complement, to know more."
                    },
                    {
                        "username": "adityawaskar03",
                        "content": "what is stk? You have not assign anything in stk so how come you use it in if condition."
                    },
                    {
                        "username": "santanu99",
                        "content": "wrong answer\n```\nclass Solution {\npublic:\n    string removeDuplicates(string s) {\n        int n = s.size();\n        string tmp = \"\";\n        int sz=INT_MAX;\n        for(int i=0;i<n;i++){\n            for(int j=n-1;j>i;j--){\n                // cout<<i<<j<<\": \"<<s.substr(i,j+1)<<\"\\n\";\n\n                if(isPalindrome(s.substr(i,j+1-i))){\n                    if(sz>n-(j+1-i)){   \n                        sz =  n-(j+1-i);\n                        tmp = s.substr(0,i)+s.substr(j+1,sz);\n                    }\n                }\n                if(isPalindrome(s.substr(0,i))&& isPalindrome(s.substr(0,i))){\n                    if(sz>(j+1-i)){\n                        tmp = s.substr(i,j+1-i);\n                        sz =  (j+1-i);\n                    }\n                }\n            }\n        }\n        \n        return tmp;\n    }\n    bool isPalindrome(string s){\n        for(int i=0;i<s.size()/2;i++){\n            if(s[i]!=s[s.size()-1-i])\n                return false;\n        }\n        return (s.size()%2) ? false : true;\n    }\n};\n```"
                    },
                    {
                        "username": "abhishekpurohit20",
                        "content": "Using Stack and StringBuilder - Java\\n\\nclass Solution {\\n    public String removeDuplicates(String s) {\\n        Stack<Character>st=new Stack<>();\\n        StringBuilder sb =new StringBuilder();\\n        int n=s.length();\\n        st.push(s.charAt(n-1));\\n        for(int i=n-2;i>=0;i--){\\n            if(!st.isEmpty()){\\n        if(st.peek()==s.charAt(i)){\\n            st.pop();\\n        }\\n        else{\\n            st.push(s.charAt(i));\\n        }\\n            }\\n        else if(st.isEmpty()){\\n            st.push(s.charAt(i));\\n        }\\n        }\\n        while(!st.isEmpty()){\\n            sb.append(st.pop());\\n        }\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "khilesh_17",
                        "content": "My Code works for all the small cases but , it show TLE for extremely big case . please someone help me to optimise my code\\n\\nclass Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        int i = 0;\\n        while(i<s.length() && s.length() > 0){\\n            if(s[i] == s[i+1]){\\n                s.erase(i, 2);\\n                i=0;\\n            }\\n            else{\\n                i++;\\n            }\\n        }\\n    \\n        return s;\\n    }\\n};\\n\\n\\n"
                    },
                    {
                        "username": "MadoSexsyBoy",
                        "content": "go\\n"
                    },
                    {
                        "username": "BenniBaum",
                        "content": "My submission always fails but my output and the expected output always match up... Does somebody got the same issue?\n"
                    }
                ]
            },
            {
                "id": 1679219,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679128,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679090,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679027,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1679026,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678974,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678932,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678913,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678908,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678898,
                "content": [
                    {
                        "username": "iamshreyash28",
                        "content": " `stack<char> stk;\\n        string ans;\\n        for(auto&i: s){\\n            if(stk.empty())\\n            {\\n                stk.push(i);\\n            }\\n            else{\\n                if(i==stk.top())\\n                {\\n                    while(!stk.empty() && stk.top()==i)\\n                    {\\n                        stk.pop();\\n                    }\\n                }\\n                else{\\n                    stk.push(i);\\n                    }\\n            }\\n        }\\n        while(!stk.empty())\\n        {\\n            ans.push_back(stk.top());\\n            stk.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }`\\n\\nMight someone suggest any way so I can avoid using reverse function."
                    },
                    {
                        "username": "rakesh_pal12",
                        "content": "Hi Everyone \\ncan anyone explain me the difference between ans+= 1 and  ans = ans+1 ? I faced the memory limit exceed with one of the above implementations in the current question?"
                    },
                    {
                        "username": "shuohe",
                        "content": "```\\npublic class Solution {\\n    public string RemoveDuplicates(string s) {\\n        StringBuilder sb=new StringBuilder();\\n        foreach(char c in s){\\n            if (sb.Length==0)\\n                sb.Append(c);\\n            else{\\n                if(c==sb[sb.Length-1])\\n                    sb.Remove(sb.Length-1,1);\\n                else\\n                    sb.Append(c);\\n            }\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```"
                    },
                    {
                        "username": "rohitdoyal",
                        "content": "hint : think about stack :) "
                    },
                    {
                        "username": "jcpearlson",
                        "content": "code error on case 46, checked debugger and the for loop de increments by 1 for some reason at the end? anyone understand what might be happening?\n\n `\n\nclass Solution {\n    public String removeDuplicates(String s) {\n        char prev = '-'; \n        \n        for(int i = 0; i < s.length(); i++){\n            char c = s.charAt(i);\n            if (c == prev){\n                //remove the two equal chars\n                s = s.substring(0,i-1) + s.substring(i+1,s.length());\n                //if this happens we need to call recusion\n                s = removeDuplicates(s);\n            }\n            prev = c;\n        }\n\n        return s;\n    }\n}\n\n`\n\n"
                    },
                    {
                        "username": "Itachi_uchiya",
                        "content": "     class Solution {\\n         public String removeDuplicates(String S) {\\n        char[] Stack = new char[S.length()];\\n        int i=0;\\n\\n        for(int j=0; j<S.length(); j++){\\n            char current_char = S.charAt(j);\\n            if(i>0 && Stack[i-1] == current_char){\\n                i--;\\n            } else {\\n                Stack[i] = current_char;\\n                i+=1;\\n            }\\n         }\\n         return new String(Stack, 0 , i);\\n    }\\n}\\n\\n// Time Complexity O(n)\\n// Space Complexity log (n)"
                    },
                    {
                        "username": "Indhu3003",
                        "content": "can i use stacks to remove duplicates"
                    },
                    {
                        "username": "rschevenin",
                        "content": "This is nearly the same problem as #1544 Make The String Great"
                    },
                    {
                        "username": "vdz1192",
                        "content": "Go from average to above average by adding... `if len(s) == 1: return s`"
                    },
                    {
                        "username": "Rdbhalekar_2907",
                        "content": "class Solution {\\npublic:\\n    string removeDuplicates(string s) {\\n        string st = \"\";\\n        st.push_back(s[0]);\\n       for(int i =1 ;i< s.length();i++){\\n            if(st.back() == s[i])\\n                st.pop_back();\\n            else\\n                st.push_back(s[i]);\\n        }\\n        return st;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1678849,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678786,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678741,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678708,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678610,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678580,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678546,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678540,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678500,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            },
            {
                "id": 1678472,
                "content": [
                    {
                        "username": "aryan_gusain",
                        "content": "\n //ss stack contains the charachters to be printed\n      string ax=\"\";\n        while(!ss.empty())\n        {\n            char ch=ss.top();\n            ss.pop();\n            ax=ch+ax;\n        }\n         return ax;\n    }\n};\nI have a few doubts:\nruntime error is occuring at the line ax=ch+ax.Why?\nWhen I do ax=ax+ch runtime error vanishes.Why?\nOn using ax=ax+ch it shows TLE which is corrected by using ax+=ch.How?"
                    },
                    {
                        "username": "saahilhameed",
                        "content": "`class Solution:`\n    `def removeDuplicates(self, s: str) -> str:`    \n        `for i in range(len(s)- 1):`\n            `print(s, i, len(s))`\n            `if s[i] == s[i+1]:`\n                `s = s[:i] + s[i+2:]`\n                `Solution.removeDuplicates(self, s)`\n                 `break`\n        `return s `\nWhy does my code not work"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "I managed to do it in an recursive way but I keep failing the 104/106 testcase because I exceed the time limit, any tips on how can I improve my code?\n\n`char res[100000];  //awnser \n\nchar * removeDuplicates(char * s){\n    //int that verifies if any char from the string can be deleted\n    int ver = 0;\n\n   //do while loop that reiterates to eliminate the duplicates\n    do {\n    int lenght = strlen(s);\n    int j = 0;\n    ver = 0;\n\n    //for loop that if there are duplicates adds one to ver and deletes the duplicate\n    for (int i = 0; i < lenght ; i++){\n        if (s[i] == s[i + 1]){\n            i++;\n            j--;\n            ver++;\n        }\n        else {\n            res[j] = s[i];\n        }\n        j++;\n    }\n    //copying the res string into the s to redo the loop if necessary\n    strcpy(s,res);\n    //clar the res string\n    memset(res, '\\0', sizeof res);\n    } while (ver > 0);\n    return s;\n}`"
                    },
                    {
                        "username": "itsadityap",
                        "content": "Same as 1544.Make string great again!!"
                    },
                    {
                        "username": "Raghav-Agrawal",
                        "content": "<h2> Simple Approach using Stack </h2>\n\nThe question basically ask you to remove the adjacent (Consecutive 2) characters that are same. So if you have 'abbba' So the answer will be aba because 2 b will be removed and one b does not have any adjacent b to pair.\n\nSo to approach it we can simply use a stack with following algorithmic steps.\n1. Create a empty stack.\n2. Iterate through original string from beginning.\n3. Check if stack is empty then simply append in stack.\n4. Else if check the top char of stack matches the current char then pop it else append in stack.\n5. simply remove each character from stack and reverse (In python not needed as you use list) and return an answer joining to string.\n\n<h3> CODE </h3>\n\n <pre>\ndef removeDuplicates(self, s: str) -> str:\n    stack = []\n    for ch in s:\n        if len(stack) == 0:\n            stack.append(ch)\n        elif stack[-1] == ch:\n            stack.pop()\n        else:\n            stack.append(ch)\n    ans = \"\".join(stack)\n    return ans\n</pre>"
                    },
                    {
                        "username": "pratikthakur2019",
                        "content": "106/106 test case passed but still the verdict is memory limit exceeded. Can anyone mention the reason how can this be fixed?"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Make The String Great Again!!!"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "any idea of how to solve this recursively? I tried but two test cases are failing\\nhere is my code:\\n                         public String check(String s){\\n                String t=s;\\n        for(int i=0;i<s.length()-1;i++){\\n            if(s.charAt(i)==s.charAt(i+1)){\\n                return check(s.substring(0,i)+s.substring(i+2));\\n           }\\n        }\\n\\n       return t;\\n     } "
                    },
                    {
                        "username": "shakir_iiitd",
                        "content": "Very easy approach using stack  \n\n````stack<char> st;\n        st.push(s[0]);\n        for(int i=1;i<s.length();i++){\n            if(!st.empty() && st.top()==s[i]){\n                st.pop();\n            }\n            else{\n                st.push(s[i]);\n            }\n        }\n\n        string nstr=\"\";\n        while(!st.empty()){\n            nstr+=st.top();\n            st.pop();\n        }\n        reverse(nstr.begin(),nstr.end());\n\n\n        return nstr;```"
                    },
                    {
                        "username": "TheAshenOne",
                        "content": "Unnecessarily complex, you can just append each time and then run a while loop to remove two adjacent duplicates.\n\n``` python\nfor character in s:\n    stack.append(character)\n    \n    while len(stack) > 1 and stack[-1] == stack[-2]:\n        stack.pop()\n        stack.pop()\n```"
                    },
                    {
                        "username": "pratham0402",
                        "content": "   string removeDuplicates(string s) {\n        string s1=\"\";\n        for(int i=0; i<s.size(); i++){\n            if(s1.empty()){\n                s1.push_back(s[i]);\n            }\n            else if(s[i]==s1[s1.size()-1]){\n                s1.pop_back();\n            }\n            else{\n                s1.push_back(s[i]);\n            }\n        }\n        return s1;\n    }"
                    }
                ]
            }
        ]
    }
]